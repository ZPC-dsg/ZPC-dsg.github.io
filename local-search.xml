<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>交换链</title>
    <link href="/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/"/>
    <url>/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>窗口表面</title>
    <link href="/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/"/>
    <url>/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述">概述</h2><p>因为Vulkan本身是平台无关的，所以它并不会直接和不同的窗口系统打交道，而是要通过所谓的WSI(WindowSystemIntegration)拓展来达到和窗口系统交互的目的。这一节我们将讨论该拓展提供的表面对象<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html"><code>VkSurfaceKHR</code></a>，该对象用于提供展示渲染结果所需的窗口表面。该对象将由我们使用的窗口系统GLFW负责创建。</p><p>值得一提的是，WSI拓展其实是一个Instance层面的拓展而非设备层面。之所以将这个Instance层面的拓展延后到本节来讲而不是在<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">创建Instance</a>章节讲是因为表面和接下来要讲的有关展示图像的内容部分关系紧密，所以将这些内容放在一起会更加自然。</p><p>另外，表面对象一定要在选择物理设备之前创建，因为表面其实会影响物理设备的选择。不过并非所有的应用程序都需要这样一个表面对象，因为有的程序只需要离屏渲染即可。对于这种应用程序，可以为它们创建一个不可见的窗口。</p><p>创建窗口表面分为三步：</p><ul><li>创建并保存<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html"><code>VkSurfaceKHR</code></a>对象</li><li>查询支持将图像显示到该表面的物理设备</li><li>构建该设备展示显示图像所需的显示队列</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Window_surface">Windowsurface</a>章节。</p><hr><h2 id="创建表面">创建表面</h2><p>在应用程序类内添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html"><code>VkSurfaceKHR</code></a>成员<i><font color="Orange">surface</font></i>用于保存表面对象。</p><p>创建一个表面对象很简单，首先我们需要启用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_surface.html"><code>VK_KHR_surface</code></a>拓展。幸运的是这个拓展已经包含在<a href="https://www.glfw.org/docs/3.3/group__vulkan.html#ga99ad342d82f4a3421e2864978cb6d1d6"><code>glfwGetRequiredInstanceExtensions</code></a>所返回的拓展中了，我们无需额外添加。接下来只需调用<a href="https://www.glfw.org/docs/3.3/group__vulkan.html#ga1a24536bec3f80b08ead18e28e6ae965"><code>glfwCreateWindowSurface</code></a>函数，GLFW就会帮我们处理好一切平台相关的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createSurface</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwCreateWindowSurface</span>(instance, window, <span class="hljs-literal">nullptr</span>, &amp;surface) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create window surface!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过虽然glfw负责创建该表面对象，销毁它仍然使用的是Vulkan的API：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkDestroySurfaceKHR</span>(instance, surface, <span class="hljs-literal">nullptr</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="查询支持设备">查询支持设备</h2><p>Vulkan本身是支持WSI的，但这并不意味着所有的显卡都可以支持这个拓展。为了保证选取的物理设备支持该拓展，我们需要拓展<i><font color="Green">isDeviceSuitable</font></i>函数以保证选择的物理设备支持将图像显示到创建的表面上。由于显示图像其实是一个和队列有关的特性，因此我们其实需要的是选择一个具有支持显示对象到指定表面功能的队列家族的物理设备。</p><p>因此，我们首先拓展一下<i><font color="Orange">QueueFamilyIndices</font></i>结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">QueueFamilyIndices</span> &#123;<br>    std::optional&lt;<span class="hljs-type">uint32_t</span>&gt; graphicsFamily;<br>    std::optional&lt;<span class="hljs-type">uint32_t</span>&gt; presentFamily;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isComplete</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> graphicsFamily.<span class="hljs-built_in">has_value</span>() &amp;&amp; presentFamily.<span class="hljs-built_in">has_value</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意，支持显示图像的队列家族和支持图像功能的的队列家族未必相同，虽然它们大概率一致，但保险起见我们还是使用两个队列家族分别存储。</p><p>接下来我们需要修改<i><font color="Green">findQueueFamilies</font></i>函数来寻找<i><font color="Orange">presentFamily</font></i>。为了寻找这样一个队列家族，我们使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceSupportKHR.html"><code>vkGetPhysicalDeviceSurfaceSupportKHR</code></a>函数。现在<i><font color="Green">findQueueFamilies</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QueueFamilyIndices <span class="hljs-title">findQueueFamilies</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices;<br><br>    <span class="hljs-type">uint32_t</span> queueFamilyCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkQueueFamilyProperties&gt; <span class="hljs-title">queueFamilies</span><span class="hljs-params">(queueFamilyCount)</span></span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, queueFamilies.<span class="hljs-built_in">data</span>());<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; queueFamily : queueFamilies) &#123;<br>        <span class="hljs-keyword">if</span> (queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) &#123;<br>            indices.graphicsFamily = i;<br>        &#125;<br><br>        VkBool32 presentSupport = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">vkGetPhysicalDeviceSurfaceSupportKHR</span>(device, i, surface, &amp;presentSupport);<br><br>        <span class="hljs-keyword">if</span> (presentSupport) &#123;<br>            indices.presentFamily = i;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (indices.<span class="hljs-built_in">isComplete</span>()) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        i++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> indices;<br>    &#125;<br></code></pre></td></tr></table></figure><p><i><font color="Green">isDeviceSuitable</font></i>函数的代码并不需要改动，因为它通过调用<i><font color="Orange">QueueFamilyIndices</font></i>结构体的成员函数<i><font color="Green">isComplete</font></i>来检查物理设备是否满足要求，而<font color="Green">isComplete</font>已经更新了并包含了目前一切需要检查的信息。</p><hr><h2 id="构建展示队列">构建展示队列</h2><p>接下来如同图形队列一样，设备对应的显示队列也应该保存在类内一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkQueue.html"><code>VkQueue</code></a>类型的成员<i><font color="Orange">presentQueue</font></i>中。</p><p>现在我们的逻辑设备已经有两个需要的队列了（如果它们不是同一个的话），因此在逻辑设备的创建信息<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateInfo.html"><code>VkDeviceCreateInfo</code></a>中我们需要两个对应的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html"><code>VkDeviceQueueCreateInfo</code></a>。因此我们需要更新<i><font color="Green">createLogicalDevice</font></i>函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createLogicalDevice</span><span class="hljs-params">()</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(physicalDevice);<br><br>    std::vector&lt;VkDeviceQueueCreateInfo&gt; queueCreateInfos;<br>    std::set&lt;<span class="hljs-type">uint32_t</span>&gt; uniqueQueueFamilies = &#123;indices.graphicsFamily.<span class="hljs-built_in">value</span>(), indices.presentFamily.<span class="hljs-built_in">value</span>()&#125;;<br><br>    <span class="hljs-type">float</span> queuePriority = <span class="hljs-number">1.0f</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> queueFamily : uniqueQueueFamilies) &#123;<br>        VkDeviceQueueCreateInfo queueCreateInfo&#123;&#125;;<br>        queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;<br>        queueCreateInfo.queueFamilyIndex = queueFamily;<br>        queueCreateInfo.queueCount = <span class="hljs-number">1</span>;<br>        queueCreateInfo.pQueuePriorities = &amp;queuePriority;<br>        queueCreateInfos.<span class="hljs-built_in">push_back</span>(queueCreateInfo);<br>    &#125;<br><br>    VkPhysicalDeviceFeatures deviceFeatures&#123;&#125;;<br><br>    VkDeviceCreateInfo createInfo&#123;&#125;;<br>    createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;<br><br>    createInfo.queueCreateInfoCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(queueCreateInfos.<span class="hljs-built_in">size</span>());<br>    createInfo.pQueueCreateInfos = queueCreateInfos.<span class="hljs-built_in">data</span>();<br><br>    createInfo.pEnabledFeatures = &amp;deviceFeatures;<br><br>    createInfo.enabledExtensionCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>        createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateDevice</span>(physicalDevice, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;device) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create logical device!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">vkGetDeviceQueue</span>(device, indices.graphicsFamily.<span class="hljs-built_in">value</span>(), <span class="hljs-number">0</span>, &amp;graphicsQueue);<br>    <span class="hljs-built_in">vkGetDeviceQueue</span>(device, indices.presentFamily.<span class="hljs-built_in">value</span>(), <span class="hljs-number">0</span>, &amp;presentQueue);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个函数的最后，如同对图形队列所做的那样，我们调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue.html"><code>vkGetDeviceQueue</code></a>来获得该逻辑设备对应的显示队列并保存到<i><font color="Orange">presentQueue</font></i>成员中。</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/">上一篇：逻辑设备和队列</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/">下一篇：交换链</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>逻辑设备和队列</title>
    <link href="/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>如果说Instance是Vulkan库的接口和抽象，那么逻辑设备就是物理设备的接口和抽象。可以认为逻辑设备是对物理设备功能的一个“定制化”视图，允许开发者选择所需的功能集。构建与物理设备关联的逻辑设备可以分为三步：</p><ul><li>从选定物理设备的队列家族中分配所需数目的队列供逻辑设备使用</li><li>指定逻辑设备所需要的物理设备特性和功能拓展等</li><li>创建逻辑设备</li></ul><p>接下来我们将创建一个<i><font color="Green">voidcreateLogicalDevice()</font></i>函数用于构建逻辑设备，并添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDevice.html"><code>VkDevice</code></a>成员<i><font color="Orange">device</font></i>来存储创建的逻辑设备。</p><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Logical_device_and_queues">Logicaldevice and queues</a>章节</p><hr><h2 id="指定队列">指定队列</h2><p>指定逻辑设备需要使用的队列很简单，我们只需要创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html"><code>VkDeviceQueueCreateInfo</code></a>并填写相应信息即可。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDeviceQueueCreateInfo</span> &#123;</span><br>    VkStructureType             sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                 pNext;<br>    VkDeviceQueueCreateFlags    flags;<br>    <span class="hljs-type">uint32_t</span>                    queueFamilyIndex;<span class="hljs-comment">//队列家族索引，上一章在QueueFamilyIndices结构体中已经存储好了</span><br>    <span class="hljs-type">uint32_t</span>                    queueCount;      <span class="hljs-comment">//需要从该队列家族分配的队列数</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span>*                pQueuePriorities;<span class="hljs-comment">//队列优先级</span><br>&#125; VkDeviceQueueCreateInfo;<br></code></pre></td></tr></table></figure><p>其中<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlags.html"><code>VkDeviceQueueCreateFlags</code></a>是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlagBits.html"><code>VkDeviceQueueCreateFlagBits</code></a>的位组合，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlagBits.html"><code>VkDeviceQueueCreateFlagBits</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDeviceQueueCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//受保护的队列，用于处理敏感数据或需要额外安全性的操作</span><br>&#125; VkDeviceQueueCreateFlagBits;<br></code></pre></td></tr></table></figure><p>另外，队列优先级是一个0.0到1.0之间的数，规定了队列中的命令被执行的顺序，优先级大的优先执行和访问资源。注意，即使只有一个队列也应该指定优先级。</p><p>在这里我们只需要一个队列就可以了，事实上，大多数的时候我们也不需要分配多个队列，因为Vulkan允许在多线程上创建命令然后在主线程上一次性提交所有命令到一个队列。填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html"><code>VkDeviceQueueCreateInfo</code></a>过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(physicalDevice);<br><br>VkDeviceQueueCreateInfo queueCreateInfo&#123;&#125;;<br>queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;<br>queueCreateInfo.queueFamilyIndex = indices.graphicsFamily.<span class="hljs-built_in">value</span>();<br>queueCreateInfo.queueCount = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">float</span> queuePriority = <span class="hljs-number">1.0f</span>;<br>queueCreateInfo.pQueuePriorities = &amp;queuePriority;<br></code></pre></td></tr></table></figure><hr><h2 id="指定物理设备特性">指定物理设备特性</h2><p>物理设备特性通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures.html"><code>vkGetPhysicalDeviceFeatures</code></a>得到。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkGetPhysicalDeviceFeatures</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkPhysicalDevice                            physicalDevice,</span><br><span class="hljs-params">    VkPhysicalDeviceFeatures*                   pFeatures)</span>;<br></code></pre></td></tr></table></figure><p>我们暂时还不需要指定任何特性，所以只需在<i><font color="Green">createLogicalDevice</font></i>函数中把<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html"><code>VkPhysicalDeviceFeatures</code></a>结构体留空即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPhysicalDeviceFeatures deviceFeatures&#123;&#125;;<br></code></pre></td></tr></table></figure><p>一如我们之前一直做的那样，创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDevice.html"><code>VkDevice</code></a>同样需要我们填写相应的信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateInfo.html"><code>VkDeviceCreateInfo</code></a>。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDeviceCreateInfo</span> &#123;</span><br>    VkStructureType                    sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                        pNext;<br>    VkDeviceCreateFlags                flags;<br>    <span class="hljs-type">uint32_t</span>                           queueCreateInfoCount;<br>    <span class="hljs-type">const</span> VkDeviceQueueCreateInfo*     pQueueCreateInfos;<br>    <span class="hljs-comment">// enabledLayerCount is deprecated and should not be used</span><br>    <span class="hljs-type">uint32_t</span>                           enabledLayerCount;<br>    <span class="hljs-comment">// ppEnabledLayerNames is deprecated and should not be used</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*                 ppEnabledLayerNames;<br>    <span class="hljs-type">uint32_t</span>                           enabledExtensionCount;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*                 ppEnabledExtensionNames;<br>    <span class="hljs-type">const</span> VkPhysicalDeviceFeatures*    pEnabledFeatures;<br>&#125; VkDeviceCreateInfo;<br></code></pre></td></tr></table></figure><p>可以看到为了填充该结构体，我们还需要指定逻辑设备需要的拓展以及层。在<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">验证层</a>章节已经提到，如今Vulkan已经不再使用devicespecific layers了，instance specificlayer适用于一切的Vulkan调用。然而，为了与旧代码兼容，显示地指定设备层仍然是一个好的选择。另外，当前我们对于设备所需要的拓展尚且没有什么要求，因此填充信息代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkDeviceCreateInfo createInfo&#123;&#125;;<br>createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;<br><br>createInfo.pQueueCreateInfos = &amp;queueCreateInfo;<br>createInfo.queueCreateInfoCount = <span class="hljs-number">1</span>;<br><br>createInfo.pEnabledFeatures = &amp;deviceFeatures;<br><br>createInfo.enabledExtensionCount = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>    createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>    createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="创建逻辑设备">创建逻辑设备</h2><p>一切就绪，我们可以构建逻辑设备对象了，构建过程一如我们之前构建对象时一直做的那样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateDevice</span>(physicalDevice, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;device) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create logical device!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑设备就此构建完成，但我们还有一些工作需要做。由于之后我们可能需要在代码中使用逻辑设备对应的队列对象，但目前在应用程序类中并没有保存这个对象，所以我们需要添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkQueue.html"><code>VkQueue</code></a>类型的成员<i><font color="Orange">graphicsQueue</font></i>来保存这个对象。可以使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue.html"><code>vkGetDeviceQueue</code></a>函数得到赋予该逻辑设备的队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkGetDeviceQueue</span>(device, indices.graphicsFamily.<span class="hljs-built_in">value</span>(), <span class="hljs-number">0</span>, &amp;graphicsQueue);<br><span class="hljs-comment">//0代表获取的队列在队列家族中的索引。由于我们只需要一个队列，所以该值为0。</span><br></code></pre></td></tr></table></figure><p>大功告成！设备层面的建立以及完成了，接下来的章节我们将处理和图像处理及展示有关的初始化流程。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97%E5%AE%B6%E6%97%8F/">上一篇：物理设备和队列家族</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/">下一篇：窗口表面</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>物理设备和队列家族</title>
    <link href="/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97%E5%AE%B6%E6%97%8F/"/>
    <url>/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97%E5%AE%B6%E6%97%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在创建好了Instance之后，我们需要选择一个合适的物理设备（显卡）来执行实际的操作。实际上我们可以选择多张显卡同时工作，不过简单起见本文只选择一张显卡进行操作。选择合适的显卡主要分为两步：</p><ul><li>决定应用程序需要显卡具有的功能和属性。</li><li>从所有显卡中选择合适的那个作为物理设备。</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Physical_devices_and_queue_families">Physicaldevices and queue families</a>章节。</p><hr><h2 id="显卡要求">显卡要求</h2><p>显卡在Vulkan中的对应句柄对象为<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html"><code>VkPhysicalDevice</code></a>，我们可以创建一个<i><font color="Green">boolisDeviceSuitable(VkPhysicalDevicedevice)</font></i>函数来决定一张显卡是否满足我们的需求。目前我们只需要显卡支持图形队列家族（Graphicsqueuefamilies），也就是能够接受图形有关命令的队列家族，于是对于一个给定的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html"><code>VkPhysicalDevice</code></a>，我们可以创建一个<i><font color="Green">QueueFamilyIndicesfindQueueFamilies(VkPhysicalDevicedevice)</font></i>函数来检查它是否支持该队列家族。其中，我们定义结构体<i><font color="Orange">QueueFamilyIndices</font></i>如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">QueueFamilyIndices</span> &#123;<br>    std::optional&lt;<span class="hljs-type">uint32_t</span>&gt; graphicsFamily;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isComplete</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> graphicsFamily.<span class="hljs-built_in">has_value</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>为c++17定义的一个模板类，它有一个成员函数<i><font color="Green">constexprbool has_value() const noexcept</font></i>，该函数在赋予了<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>包裹的对象值后返回true，否则返回false。如此设计是因为有时在考虑应用程序需要的队列家族的时候，有些队列家族是可选的，也就是说显卡有该家族的话更好，没有的话也不应该直接终止程序，而是选择别的替代品，因此我们可以通过<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>包裹对象是否存储了一个找到的值来做出决策。另外，该结构体目前只包含一个成员，随着应用程序的深入和复杂化，也会有更多的队列家族需求，也就会有更多的成员添加到这个结构体中来。</p><p>接下来看一下<i><font color="Green">findQueueFamilies</font></i>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QueueFamilyIndices <span class="hljs-title">findQueueFamilies</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices;<br><br>    <span class="hljs-type">uint32_t</span> queueFamilyCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkQueueFamilyProperties&gt; <span class="hljs-title">queueFamilies</span><span class="hljs-params">(queueFamilyCount)</span></span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, queueFamilies.<span class="hljs-built_in">data</span>());<br>    <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; queueFamily : queueFamilies) &#123;<br>        <span class="hljs-keyword">if</span> (queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) &#123;<br>            indices.graphicsFamily = i;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (indices.<span class="hljs-built_in">isComplete</span>()) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        i++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> indices;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数的代码是直观易懂的，这里不做过多解释了。</p><p>于是，接下来我们就可以在<i><font color="Green">isDeviceSuitable</font></i>函数中使用这个函数来判断一个物理设备是否符合要求（当前来讲就是是否具有图形队列家族）。当然，随着应用程序的复杂化，<i><font color="Green">isDeviceSuitable</font></i>函数还会逐渐地拓展：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(device);<br><br>    <span class="hljs-keyword">return</span> indices.graphicsFamily.<span class="hljs-built_in">has_value</span>();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="选择显卡">选择显卡</h2><p>在决定好对于设备的要求之后，是时候开始挑选符合要求的显卡了！首先我们当然要枚举出Instance所具有的所有物理设备，并且在类内创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html"><code>VkPhysicalDevice</code></a>成员<i><font color="Orange">physicalDevice</font></i>来存储满足需求的显卡对象（将这个成员初始化为<i><font color="Orange">VK_NULL_HANDLE</font></i>。我们创建一个<i><font color="Green">voidpickPhysicalDevice()</font></i>成员函数来挑选需要的显卡：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pickPhysicalDevice</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">uint32_t</span> deviceCount = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">vkEnumeratePhysicalDevices</span>(instance, &amp;deviceCount, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span> (deviceCount == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to find GPUs with Vulkan support!&quot;</span>);<br>&#125;<br>    <span class="hljs-function">std::vector&lt;VkPhysicalDevice&gt; <span class="hljs-title">devices</span><span class="hljs-params">(deviceCount)</span></span>;<br><span class="hljs-built_in">vkEnumeratePhysicalDevices</span>(instance, &amp;deviceCount, devices.<span class="hljs-built_in">data</span>());<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来对于每一个显卡，检查它是否满足需求，简单起见，我们这里采取的策略是一旦找到了一张满足要求的显卡，就直接使用它。当然你可以自定义更加复杂的选取策略以寻找最合适的那张显卡。测试显卡是否满足要求只需使用上文创建的<i><font color="Green">isDeviceSuitable</font></i>函数即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//接pickPhysicalDevice函数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; device : devices) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isDeviceSuitable</span>(device)) &#123;<br>        physicalDevice = device;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (physicalDevice == VK_NULL_HANDLE) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to find a suitable GPU!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，由于Instance被销毁时，对应的物理设备会被自动销毁，所以我们不需要在<i><font color="Green">cleanup</font></i>函数中显示销毁它。</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">上一篇：验证层</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/">下一篇：逻辑设备和队列</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>验证层</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>VulkanAPI本身几乎不自带任何错误检测功能，不过这并不意味着我们不能添加相应的错误检测功能。Vulkan的验证层（validationlayer）就是为此而生。验证层是可选的组件，它们会挂钩到 Vulkan函数调用中，以执行额外的操作，包括：</p><ul><li>检查参数类型以避免错误调用</li><li>跟踪对象的创建和销毁以防止内存泄漏</li><li>检查线程安全性</li><li>把调用信息以及其参数输出到标准输出</li><li>跟踪调用以便性能优化和复现</li></ul><p>Vulkan中有两种验证层：instance layer和devicelayer。最初的想法是instance layer用于检查全局的Vulkan调用，而devicelayer用于检查特定GPU相关的调用。不过现在devicelayer已经逐渐被废弃了，也就是说现在可以将instancelayer用于检查任何Vulkan调用。当然，如果是为了和旧代码兼容，仍然可以使用devicelayer。</p><p>验证层的使用主要分为以下三步：</p><ul><li>启用验证层</li><li>设置回调函数</li><li>创建debug messenger以使用回调函数控制输出验证层产生的信息</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Validation_layers#page_Message-callback">Validationlayers</a>章节</p><hr><h2 id="启用验证层">启用验证层</h2><p>我们需要启用的是Vulkan中几乎包含了所有有用验证功能的层，它的名称为<i><font color="Orange">VK_LAYER_KHRONOS_validation</font></i>。在启用之前，如同拓展一样，我们也需要检查层的可用性，检查的方式和拓展如出一辙。首先我们需要列举出硬件支持的所有层：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkValidationLayerSupport</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> layerCount;<br>    <span class="hljs-built_in">vkEnumerateInstanceLayerProperties</span>(&amp;layerCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkLayerProperties&gt; <span class="hljs-title">availableLayers</span><span class="hljs-params">(layerCount)</span></span>;<br>    <span class="hljs-built_in">vkEnumerateInstanceLayerProperties</span>(&amp;layerCount, availableLayers.<span class="hljs-built_in">data</span>());<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们需要的是<i><font color="Orange">VK_LAYER_KHRONOS_validation</font></i>，它由名称对应的字符串给出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; validationLayers = &#123;<br>    <span class="hljs-string">&quot;VK_LAYER_KHRONOS_validation&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>于是我们需要检查这个层是否可用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//接上述checkValidationLayerSupport函数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span>* layerName : validationLayers) &#123;<br>    <span class="hljs-type">bool</span> layerFound = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; layerProperties : availableLayers) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(layerName, layerProperties.layerName) == <span class="hljs-number">0</span>) &#123;<br>            layerFound = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!layerFound) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>检查完毕后，我们还需要决定什么时候启用这个验证层。由于验证层输出的调试信息应该只能被开发应用程序的程序员看见，因此调试模式下我们理应启用该验证层，而发布模式下我们当然应该关闭该验证层功能。这可以通过宏来做到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> NDEBUG</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> enableValidationLayers = <span class="hljs-literal">false</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> enableValidationLayers = <span class="hljs-literal">true</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>另外，<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">上一篇</a>中我们没有填上<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>结构体中的层信息，现在就可以填上我们选取的验证层信息了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>    createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>    createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//发布模式不需要启用验证层，因此结构体中层信息也不需要填写</span><br>    createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="设置回调函数">设置回调函数</h2><p>默认情况下验证层会将调试信息输出到标准输出。但是更多时候我们希望自己控制输出信息的种类以及详细程度等。因此我们需要设置一个回调函数来指定信息输出的方式。</p><p>为了设置回调函数，我们需要一个新的拓展：<i><font color="Orange">VK_EXT_debug_utils</font></i>，因此我们可以创建一个<i><font color="Green">getRequiredExtensions</font></i>函数来统一处理所有需要的拓展：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; <span class="hljs-title">getRequiredExtensions</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> glfwExtensionCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>** glfwExtensions;<br>    glfwExtensions = <span class="hljs-built_in">glfwGetRequiredInstanceExtensions</span>(&amp;glfwExtensionCount);<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; <span class="hljs-title">extensions</span><span class="hljs-params">(glfwExtensions, glfwExtensions + glfwExtensionCount)</span></span>;<br><br>    <span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>        extensions.<span class="hljs-built_in">push_back</span>(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);<br>        <span class="hljs-comment">//VK_EXT_DEBUG_UTILS_EXTENSION_NAME是字符串&quot;VK_EXT_debug_utils&quot;等价的宏，使用宏可以避免拼写错误问题</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> extensions;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到的拓展用于Instance的创建：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> extensions = <span class="hljs-built_in">getRequiredExtensions</span>();<br>createInfo.enabledExtensionCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(extensions.<span class="hljs-built_in">size</span>());<br>createInfo.ppEnabledExtensionNames = extensions.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>在启用了回调函数所需要的拓展之后，就可以创建回调函数本身了。Vulkan通过函数指针<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/PFN_vkDebugUtilsMessengerCallbackEXT.html"><code>PFN_vkDebugUtilsMessengerCallbackEXT</code></a>指明了一个回调函数所应该具有的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">VkBool32</span> <span class="hljs-params">(VKAPI_PTR *PFN_vkDebugUtilsMessengerCallbackEXT)</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDebugUtilsMessageSeverityFlagBitsEXT           messageSeverity,</span><br><span class="hljs-params">    VkDebugUtilsMessageTypeFlagsEXT                  messageTypes,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkDebugUtilsMessengerCallbackDataEXT*      pCallbackData,</span><br><span class="hljs-params">    <span class="hljs-type">void</span>*                                            pUserData)</span>;<br></code></pre></td></tr></table></figure><p>第一个参数通过[<code>VkDebugUtilsMessageSeverityFlagBitsEXT</code><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessageSeverityFlagBitsEXT.html">id4</a>的位掩码指定输出信息的严重性，该枚举定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDebugUtilsMessageSeverityFlagBitsEXT</span> &#123;</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//所有诊断信息</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = <span class="hljs-number">0x00000010</span>, <span class="hljs-comment">//信息性消息，如资源细节</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = <span class="hljs-number">0x00000100</span>,<span class="hljs-comment">//警告信息</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = <span class="hljs-number">0x00001000</span>,  <span class="hljs-comment">//错误信息</span><br>&#125; VkDebugUtilsMessageSeverityFlagBitsEXT;<br></code></pre></td></tr></table></figure><p>第二个参数通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessageTypeFlagBitsEXT.html"><code>VkDebugUtilsMessageTypeFlagsBitsEXT</code></a>的位掩码指定输出信息的种类，该枚举定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDebugUtilsMessageTypeFlagBitsEXT</span> &#123;</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = <span class="hljs-number">0x00000001</span>,    <span class="hljs-comment">//与使用规范或性能无关的一般事件消息</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = <span class="hljs-number">0x00000002</span>, <span class="hljs-comment">//未遵循Vulkan使用规则</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//性能浪费</span><br>  <span class="hljs-comment">// Provided by VK_EXT_device_address_binding_report</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//地址绑定信息</span><br>&#125; VkDebugUtilsMessageTypeFlagBitsEXT;<br></code></pre></td></tr></table></figure><p>第三个参数指向一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCallbackDataEXT.html"><code>VkDebugUtilsMessengerCallbackDataEXT</code></a>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDebugUtilsMessengerCallbackDataEXT</span> &#123;</span><br>    VkStructureType                              sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                  pNext;<br>    VkDebugUtilsMessengerCallbackDataFlagsEXT    flags; <span class="hljs-comment">//目前只有0</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                                  pMessageIdName;  <span class="hljs-comment">//消息相关名称标识符</span><br>    <span class="hljs-type">int32_t</span>                                      messageIdNumber; <span class="hljs-comment">//该名称对应ID</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                                  pMessage;  <span class="hljs-comment">//具体调试信息</span><br>    <span class="hljs-type">uint32_t</span>                                     queueLabelCount; <span class="hljs-comment">//队列标签数</span><br>    <span class="hljs-type">const</span> VkDebugUtilsLabelEXT*                  pQueueLabels;    <span class="hljs-comment">//队列标签</span><br>    <span class="hljs-type">uint32_t</span>                                     cmdBufLabelCount;<span class="hljs-comment">//命令缓冲标签数</span><br>    <span class="hljs-type">const</span> VkDebugUtilsLabelEXT*                  pCmdBufLabels;  <span class="hljs-comment">//命令缓冲标签</span><br>    <span class="hljs-type">uint32_t</span>                                     objectCount;  <span class="hljs-comment">//消息相关对象数</span><br>    <span class="hljs-type">const</span> VkDebugUtilsObjectNameInfoEXT*         pObjects;  <span class="hljs-comment">//消息相关对象</span><br>&#125; VkDebugUtilsMessengerCallbackDataEXT;<br></code></pre></td></tr></table></figure><p>该参数包含了回调函数输出信息的具体方式和细节。</p><p>最后一个参数指定用户自己提供的额外信息，一般为nullptr。</p><p>回调函数返回一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBool32.html"><code>VkBool32</code></a>类型的值，如果它返回<i><font color="Red">VK_TRUE</font></i>，则意味着产生验证层信息的函数应该被终止，这一般只用于验证调试层是否生效，因此我们一般返回<i><font color="Red">VK_FALSE</font></i>。</p><p>于是，我们可以创建一个自己的回调函数（注意要把它设置为静态函数）。<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Validation_layers#page_Message-callback">验证层</a>章节给出的一个简单的例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> VKAPI_ATTR VkBool32 VKAPI_CALL <span class="hljs-title">debugCallback</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,</span></span><br><span class="hljs-params"><span class="hljs-function">    VkDebugUtilsMessageTypeFlagsEXT messageType,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">void</span>* pUserData)</span> </span>&#123;<br><br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;validation layer: &quot;</span> &lt;&lt; pCallbackData-&gt;pMessage &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> VK_FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VKAPI_CALL.html"><code>VKAPI_CALL</code></a>和<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VKAPI_ATTR.html"><code>VKAPI_ATTR</code></a>宏用于指定和编译器有关的调用方式，前者指定MSVC-style的编译器调用方式，后者指定GCC/Clang-style的编译器调用方式。</p><hr><h2 id="创建debug-messenger">创建Debug Messenger</h2><p>设置好回调函数的形式后，现在我们需要告知Vulkan我们设置了一个回调函数。这可以通过创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerEXT.html"><code>VkDebugUtilsMessengerEXT</code></a>句柄对象来实现。</p><p>创建该对象同样需要填写相应的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>信息，我们可以创建一个<i><font color="Green">voidsetupDebugMessenger()</font></i>函数来处理该对象的构建。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VkDebugUtilsMessengerCreateInfoEXT</span> &#123;<br>    VkStructureType                         sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                             pNext;<br>    VkDebugUtilsMessengerCreateFlagsEXT     flags;    <span class="hljs-comment">//目前只有0</span><br>    VkDebugUtilsMessageSeverityFlagsEXT     messageSeverity;<br>    VkDebugUtilsMessageTypeFlagsEXT         messageType;<br>    PFN_vkDebugUtilsMessengerCallbackEXT    pfnUserCallback;<br>    <span class="hljs-type">void</span>*                                   pUserData;<br>&#125; VkDebugUtilsMessengerCreateInfoEXT;<br></code></pre></td></tr></table></figure><p>容易注意到后四个参数中倒数第二个参数就是我们需要指定的回调函数，其它三个参数是我们需要传递给该回调函数的实参。</p><p>于是<i><font color="Green">voidsetupDebugMessenger()</font></i>函数可以如下编写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setupDebugMessenger</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!enableValidationLayers) <span class="hljs-keyword">return</span>;<br><br>    VkDebugUtilsMessengerCreateInfoEXT createInfo&#123;&#125;;<br>    <br>    createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;<br>    createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |   VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;<br>    createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;<br>    createInfo.pfnUserCallback = debugCallback;<br>    createInfo.pUserData = <span class="hljs-literal">nullptr</span>;<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来只需要创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerEXT.html"><code>VkDebugUtilsMessengerEXT</code></a>对象即可。但是到这里还有一个小问题，那就是创建对象的函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>是一个拓展函数，它不是自动加载的，而是需要我们手动使用[<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetInstanceProcAddr.html"><code>vkGetInstanceProcAddr</code></a>去寻找它的地址后才能使用。因此我们可以创建一个（全局的）工具函数VkResultCreateDebugUtilsMessengerEXT(VkInstance instance, constVkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, constVkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT*pDebugMessenger)函数来加载<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetInstanceProcAddr.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>进行加载。于是我们可以创建一个（全局的）<i><font color="Green">VkResultCreateDebugUtilsMessengerEXT(VkInstance instance, constVkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, constVkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT*pDebugMessenger)</font></i>函数加载<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>并在加载成功后使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>创建DebugMessenger对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkResult <span class="hljs-title">CreateDebugUtilsMessengerEXT</span><span class="hljs-params">(VkInstance instance, <span class="hljs-type">const</span> VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, <span class="hljs-type">const</span> VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pDebugMessenger)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> func = (PFN_vkCreateDebugUtilsMessengerEXT) <span class="hljs-built_in">vkGetInstanceProcAddr</span>(instance, <span class="hljs-string">&quot;vkCreateDebugUtilsMessengerEXT&quot;</span>);<br>    <span class="hljs-keyword">if</span> (func != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(instance, pCreateInfo, pAllocator, pDebugMessenger);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> VK_ERROR_EXTENSION_NOT_PRESENT;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，只需要在<i><font color="Green">setupDebugMessenger</font></i>函数末尾使用该函数来创建句柄对象即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//接setupDebugMessenger函数</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">CreateDebugUtilsMessengerEXT</span>(instance, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;debugMessenger) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to set up debug messenger!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>另外注意，销毁<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerEXT.html"><code>VkDebugUtilsMessengerEXT</code></a>对象的函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyDebugUtilsMessengerEXT.html"><code>vkDestroyDebugUtilsMessengerEXT</code></a>也是一个拓展函数，同样需要我们手动加载，我们也写一个工具函数来完成加载该函数和销毁的工作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyDebugUtilsMessengerEXT</span><span class="hljs-params">(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, <span class="hljs-type">const</span> VkAllocationCallbacks* pAllocator)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> func = (PFN_vkDestroyDebugUtilsMessengerEXT) <span class="hljs-built_in">vkGetInstanceProcAddr</span>(instance, <span class="hljs-string">&quot;vkDestroyDebugUtilsMessengerEXT&quot;</span>);<br>    <span class="hljs-keyword">if</span> (func != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-built_in">func</span>(instance, debugMessenger, pAllocator);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后只需在应用程序类的<i><font color="Green">cleanup()</font></i>函数中调用该加载函数即可。</p><hr><h2 id="instance创建和销毁函数内部的调试">Instance创建和销毁函数内部的调试</h2><p>大功告成了吗？其实还没有。注意到<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>函数需要创建的Instance作为参数，这也就意味着Instance的创建函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html"><code>vkCreateInstance</code></a>和销毁函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyInstance.html"><code>vkDestroyInstance</code></a>是在DebugMessenger的作用范围之外的，它们的调试信息无法被显示出来。</p><p>解决办法是将<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>信息传递给<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>结构体的pNext成员指针。具体而言，我们可以创建一个<i><font color="Green">voidpopulateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT&amp;createInfo)</font></i>函数来抽象出填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>的代码以便在<i><font color="Green">createInstance</font></i>函数和<i><font color="Green">setupDebugMessenger</font></i>函数中复用，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++|">void populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT&amp; createInfo) &#123;<br>    createInfo = &#123;&#125;;<br>    <br>    createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;<br>    createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;<br>    createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;<br>    createInfo.pfnUserCallback = debugCallback;<br>&#125;<br></code></pre></td></tr></table></figure><p><i><font color="Green">setupDebugMessenger</font></i>函数现在改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setupDebugMessenger</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!enableValidationLayers) <span class="hljs-keyword">return</span>;<br><br>    VkDebugUtilsMessengerCreateInfoEXT createInfo;<br>    <span class="hljs-built_in">populateDebugMessengerCreateInfo</span>(createInfo);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CreateDebugUtilsMessengerEXT</span>(instance, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;debugMessenger) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to set up debug messenger!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><i><font color="Green">createInstance</font></i>函数添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br><br>    VkInstanceCreateInfo createInfo&#123;&#125;;<br>    createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;<br>    createInfo.pApplicationInfo = &amp;appInfo;<br><br>    ...<br><br>    VkDebugUtilsMessengerCreateInfoEXT debugCreateInfo&#123;&#125;;<br>    <span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>        createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br><br>        <span class="hljs-built_in">populateDebugMessengerCreateInfo</span>(debugCreateInfo);<br>        createInfo.pNext = (VkDebugUtilsMessengerCreateInfoEXT*) &amp;debugCreateInfo;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br><br>        createInfo.pNext = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateInstance</span>(&amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;instance) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create instance!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以实现在Instance的构造和销毁函数中也能输出调试信息。现在终于是大功告成了！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">上一篇：创建Instance</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/">下一篇：物理设备和队列家族</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>创建Instance</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>是沟通应用程序和vulkan库的桥梁，它将你的应用程序的信息提供给图形驱动。创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>主要分为三步：</p><ul><li>检查instance所需的拓展是否可用</li><li>填写包含了创建instance所需信息的结构体</li><li>将该结构体传递给<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html"><code>vkCreateInstance</code></a>函数创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>实例</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Instance">Instance</a>章节。</p><hr><h2 id="检查拓展">检查拓展</h2><p>使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html"><code>vkEnumerateInstanceExtensionProperties</code></a>函数分两步检查拓展：</p><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html"><code>vkEnumerateInstanceExtensionProperties</code></a>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkEnumerateInstanceExtensionProperties</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                                 pLayerName,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>*                                   pPropertyCount,</span><br><span class="hljs-params">    VkExtensionProperties*                      pProperties)</span>;<br></code></pre></td></tr></table></figure><p>需要解释的是该函数第一个参数，该参数指定层名，如果为nullptr则则查询全局可用的扩展属性，否则查询指定层提供的额外拓展属性。</p><p>具体使用上，一般分两步进行，也就是先查询拓展个数再查询具体拓展，许多vulkan查询操作都分为这两步进行（假设这里不需要具体层名）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> extensionCount = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="hljs-literal">nullptr</span>, &amp;extensionCount, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-function">std::vector&lt;VkExtensionProperties&gt; <span class="hljs-title">extensions</span><span class="hljs-params">(extensionCount)</span></span>;<br><span class="hljs-built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="hljs-literal">nullptr</span>, &amp;extensionCount, extensions.<span class="hljs-built_in">data</span>());<span class="hljs-comment">// T* std::vector&lt;T,Allocator&gt;::data()返回指向vector底部数组元素的指针</span><br></code></pre></td></tr></table></figure><hr><h2 id="填写创建信息">填写创建信息</h2><p>为了创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>实例，需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>。Vulkan中很多创建实例的函数都需要一个createInfo结构体作为参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkInstanceCreateInfo</span> &#123;</span><br>    VkStructureType             sType;                  <span class="hljs-comment">//类型</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                 pNext;     <span class="hljs-comment">//拓展结构体，此教程均为nullptr</span><br>    VkInstanceCreateFlags       flags;  <br>    <span class="hljs-type">const</span> VkApplicationInfo*    pApplicationInfo;<br>    <span class="hljs-type">uint32_t</span>                    enabledLayerCount;    <span class="hljs-comment">//层数</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*          ppEnabledLayerNames;  <span class="hljs-comment">//层名</span><br>    <span class="hljs-type">uint32_t</span>                    enabledExtensionCount;  <span class="hljs-comment">//拓展数</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*          ppEnabledExtensionNames;<span class="hljs-comment">//拓展名</span><br>&#125; VkInstanceCreateInfo;<br></code></pre></td></tr></table></figure><p>第三个参数代表一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateFlagBits.html"><code>VkInstanceCreateFlagBits</code></a>的位掩码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkInstanceCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_KHR_portability_enumeration</span><br>    VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR = <span class="hljs-number">0x00000001</span>,<br>&#125; VkInstanceCreateFlagBits;<br></code></pre></td></tr></table></figure><p>其中只有一个标志位<i><font color="Red">VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR</font></i>，当设置这个标志时，表示应用程序希望能够在不同的设备和平台上更好地支持Vulkan的可移植性扩展。这对于那些希望在多种硬件和操作系统上运行的应用程序尤其重要。</p><p>第四个参数是一个指向<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkApplicationInfo.html"><code>VkApplicationInfo</code></a>结构体的指针，该结构体代表一个可选的应用程序信息，提供该信息可能有助于驱动优化应用程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkApplicationInfo</span> &#123;</span><br>    VkStructureType    sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*        pNext;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*        pApplicationName;<br>    <span class="hljs-type">uint32_t</span>           applicationVersion;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*        pEngineName;<br>    <span class="hljs-type">uint32_t</span>           engineVersion;<br>    <span class="hljs-type">uint32_t</span>           apiVersion;<br>&#125; VkApplicationInfo;<br></code></pre></td></tr></table></figure><p>该结构体每个参数都很好理解，<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Instance">Instance</a>章节中的使用范例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkApplicationInfo appInfo&#123;&#125;;<br>VkApplicationInfo appInfo&#123;&#125;;<br>appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;<br>appInfo.pApplicationName = <span class="hljs-string">&quot;Hello Triangle&quot;</span>;<br>appInfo.applicationVersion = <span class="hljs-built_in">VK_MAKE_VERSION</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>appInfo.pEngineName = <span class="hljs-string">&quot;No Engine&quot;</span>;<br>appInfo.engineVersion = <span class="hljs-built_in">VK_MAKE_VERSION</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>appInfo.apiVersion = VK_API_VERSION_1_0;<br></code></pre></td></tr></table></figure><p>解释完所有参数之后，正式开始填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkInstanceCreateInfo createInfo&#123;&#125;;<br>createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;<br>createInfo.pApplicationInfo = &amp;appInfo;<br><br><span class="hljs-type">uint32_t</span> glfwExtensionCount = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>** glfwExtensions;<br><br><span class="hljs-comment">//获取glfw窗口系统所需的拓展，可以在获取前先使用步骤1检查以下拓展是否可用</span><br>glfwExtensions = <span class="hljs-built_in">glfwGetRequiredInstanceExtensions</span>(&amp;glfwExtensionCount);<br><br>createInfo.enabledExtensionCount = glfwExtensionCount;<br>createInfo.ppEnabledExtensionNames = glfwExtensions;<br><br><span class="hljs-comment">//这部分会在之后的设置验证层章节中填写</span><br>createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>注意这里并没有填写层数和层名，这部分会在下一章<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">验证层</a>中进行填写</p><hr><h2 id="创建vkinstance实例">创建VkInstance实例</h2><p>最后，一切就绪，可以使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html"><code>VkCreateInstance</code></a>创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>实例了，由于Vulkan中大多数创建实例的函数都会返回一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkResult.html"><code>VkResult</code></a>，于是我们一般通过下述方式创建实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateInstance</span>(&amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;instance) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create instance!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>很多Vulkan中的create函数都会具有一个可以传递用户自定义分配器的参数，在VulkanTutorial教程中该参数始终设为nullptr。</p><p>大功告成！我们可以将第二、三步的代码放到一个成员函数<i><font color="Green">voidcreateInstance()</font></i>中</p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/">上一篇：绘制基本流程梳理</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">下一篇：验证层</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>绘制基本流程梳理</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="写在前面">写在前面</h3><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Overview">Overview</a>章节</p><hr><h2 id="初始化及绘制的基本流程">初始化及绘制的基本流程</h2><p>下面按步骤给出绘制一个三角形所需的基本流程，这也构成了一个vulkan渲染程序最基础的框架</p><ul><li><p>创建一个用以描述你所创建的应用以及所需使用的API拓展的VkInstance。</p></li><li><p>查询硬件属性以挑选合适的物理设备VkPhysicalDevice。</p></li><li><p>从物理设备抽象出对应的逻辑设备VkDevice，并且创建用于接受提交命令的VkQueue。</p></li><li><p>创建用于显示渲染结果的窗口，以及一个处理跨平台窗口兼容性的的抽象层VkSurfaceKHR，然后创建用于提供渲染和展示画面的VkSwapchainKHR。</p></li><li><p>创建交换链中真正用于渲染和展示的VkImage,并且把这些图片包裹进用于指示图片的具体使用部分的VkImageView中。</p></li><li><p>创建用于指示渲染目标的类型用法等信息的VkRenderPass</p></li><li><p>在指定好渲染目标以及相应信息后，创建对应的载体VkFramebuffer，将创建好的VkImage用作它的颜色、深度或模板缓冲。</p></li><li><p>建立好包含整个渲染流程各个阶段信息的渲染管线对象VkPipeline。</p></li><li><p>准备好渲染所需的一切目标和信息后，从VkCommandPool分配出VkCommandBuffer，用于录制渲染流程中需要执行的命令。</p></li><li><p>开始主渲染循环，循环流程主要为从交换链获取图像，然后将录制好的命令提交给VkQueue执行，执行完毕后将图像归还交换链并展示渲染结果。</p><p>接下来的三角形绘制章节会详细解释每个步骤的具体流程和执行方式。</p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%BA%8F%E8%A8%80/">上一篇：序言</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">下一篇：创建Instance</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>序言</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%BA%8F%E8%A8%80/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%BA%8F%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="写在前面的话">写在前面的话</h2><p>刚学完<a href="https://vulkan-tutorial.com/Introduction">vulkantutorial</a>教程不久，感觉自己对其中的很多细节理解还不是很透彻，同时也不能很好地理清vulkan复杂的初始化流程，于是准备再学一遍教程，并且记录下自己的理解和梳理思路，希望能对vulkan的工作机制有更深入的理解。</p><h2 id="主要内容概要">主要内容概要</h2><p>本系列文章主要以梳理概括vulkan搭建的渲染流程为主，不多涉及对于图形硬件底层或者api工作原理的深入理解（苯萌新尚未进化至如此境界~~</p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/">下一篇：绘制基本流程梳理</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 847:访问所有节点的最短路径</title>
    <link href="/2024/09/19/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/Leetcode-847-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2024/09/19/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/Leetcode-847-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述">题目描述</h2><h3 id="题干">题干</h3><p>存在一个由 <code>n</code> 个节点组成的无向连通图，图中的节点按从<code>0</code> 到 <code>n - 1</code> 编号。</p><p>给你一个数组 <code>graph</code>表示这个图。其中，<code>graph[i]</code> 是一个列表，由所有与节点<code>i</code> 直接相连的节点组成。</p><p>返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。</p><h3 id="条件限制">条件限制</h3><ul><li><code>n == graph.length</code></li><li><code>1 &lt;= n &lt;= 12</code></li><li><code>0 &lt;= graph[i].length &lt; n</code></li><li><code>graph[i]</code> 不包含 <code>i</code></li><li>如果 <code>graph[a]</code> 包含 <code>b</code> ，那么<code>graph[b]</code> 也包含 <code>a</code></li><li>输入的图总是连通图</li></ul><h3 id="示例">示例</h3><figure><img src="/2024/09/19/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/Leetcode-847-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/example.png" alt="示例"><figcaption aria-hidden="true">示例</figcaption></figure><p><strong>输入</strong>：graph = [[1, 2, 3], [0], [0], [0]]</p><p><strong>输出</strong>：4</p><p><strong>解释</strong>：一种可能路径为[1, 0, 2, 0, 3]</p><hr><h2 id="错误解题思路">错误解题思路</h2><h3 id="思路">思路</h3><p>定义f[s][i]为位掩码为s且最后到达的节点为i时所走过的最短路径（如果在前述条件下不能遍历位掩码中的节点则记为INT_MAX，并且下面认为INT_MAX+1=INT_MAX)，简单地认为状态转移方程为：<span class="math display">\[f[s][i]\ =\mathop{min}\limits_{x\in graph[i]}(f[s\ \land\(1&lt;&lt;i)][x])\ +\ 1\]</span></p><h3 id="错误原因">错误原因</h3><p>事实上，位掩码为s且最后到达的节点为i时所走过的最短路径未必由除去i之后的位掩码下最后到达i的相邻节点x的最短路径转移而来，原因很简单，如果<span class="math inline">\(f[s\ \land\(1&lt;&lt;i)][x]\)</span>并非INT_MAX，那么这么转移是没有问题的，<u><mark><strong>但是，如果<span class="math inline">\(f[s\ \land\(1&lt;&lt;i)][x]\)</span>是INT_MAX呢？这是不是就意味着f[s][i]同样无法遍历得到了呢？当然不是</strong>。</mark></u>考虑上面示例，例如当位掩码为0111（即选择了0,1,2这三个节点），最后到达的节点为0时，如果按照上面错误的转移方程，我们有<span class="math display">\[f[0111][0]\ =\mathop{min}\{f[0110][1],\ f][0110][2]\}\ +\ 1\]</span>但是当位掩码仅为0110，也就是说要仅经过1,2两个节点的情况下遍历这两个节点都是不可能的，上面min的结果应该为INT_MAX，也就是说这么转移得到的f[0111][0]为INT_MAX，但是显然1-0-2-0为一条满足要求的路径，因此f[0111][0]最多也是3，因此这样的状态转移是不全面的。</p><hr><h2 id="正确解答">正确解答</h2><h3 id="思路一floyd最短路状压dp">思路一（Floyd最短路+状压dp）</h3><p>思路一延续前文错误思路的想法，只不过将状态转移方程改为 <span class="math display">\[f[s][i]\ =\mathop{min}\limits_{x\in \{0,1,\cdots,n-1\}}(f[s\ \land\(1&lt;&lt;i)][x])\ +\ dist(x,i)\]</span>其中dist(x,i)是节点x与i之间的最短距离，这个距离可以使用Floyd最短路径算法预计算出来。这样就不会出现漏掉一些状态转移方式的问题。</p><h4 id="floyd最短路径算法">Floyd最短路径算法</h4><p>算法原理以及描述这里不再赘述，读者可以在<a href="https://oi-wiki.org/graph/shortest-path/#floyd-%E7%AE%97%E6%B3%95">这里</a>找到关于该算法的具体描述和原理说明</p><p>Floyd算法的核心代码不过三层循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>  <span class="hljs-keyword">for</span> (x = <span class="hljs-number">1</span>; x &lt;= n; x++) &#123;<br>    <span class="hljs-keyword">for</span> (y = <span class="hljs-number">1</span>; y &lt;= n; y++) &#123;<br>      dist[k][x][y] = <span class="hljs-built_in">min</span>(dist[k - <span class="hljs-number">1</span>][x][y], dist[k - <span class="hljs-number">1</span>][x][k] + dist[k - <span class="hljs-number">1</span>][k][y]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中dist[k][x][y]表示只允许经过前k个节点的情况下由x到y的最短路径长度。由于外层状态k仅仅与k-1有关，所以实现的时候其实可以压缩掉一维：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>  <span class="hljs-keyword">for</span> (x = <span class="hljs-number">1</span>; x &lt;= n; x++) &#123;<br>    <span class="hljs-keyword">for</span> (y = <span class="hljs-number">1</span>; y &lt;= n; y++) &#123;<br>      dist[x][y] = <span class="hljs-built_in">min</span>(dist[x][y], dist[x][k] + dist[k][y]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中dist[x][y]直接定义为由x到y的最短路径长度。</p><h4 id="整体实现">整体实现</h4><p>首先预处理出任意两个节点之间的最短路径，然后使用上述正确状态转移方程求解，c++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestPathLength</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector <span class="hljs-title">dist</span><span class="hljs-params">(n, vector&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">1e9</span>))</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : graph[i]) &#123;<br>                dist[i][j] = dist[j][i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) dist[i][i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 预处理：floyd 求最短路</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                    dist[i][j] = <span class="hljs-built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//状压dp实现</span><br>        <span class="hljs-function">vector <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; n, vector&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">1e9</span>))</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) f[<span class="hljs-number">1</span> &lt;&lt; i][i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; (<span class="hljs-number">1</span> &lt;&lt; n); ++s) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (s &gt;&gt; i &amp; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                        <span class="hljs-keyword">if</span> ((s &gt;&gt; j &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>                            f[s | (<span class="hljs-number">1</span> &lt;&lt; j)][j] = <span class="hljs-built_in">min</span>(f[s | (<span class="hljs-number">1</span> &lt;&lt; j)][j], f[s][i] + dist[i][j]);<span class="hljs-comment">//转移方程形式上和前文略有差别，但本质上是一样的，这种写法会更方便</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//返回最终值</span><br>        <span class="hljs-keyword">return</span> *ranges::<span class="hljs-built_in">min_element</span>(f.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">begin</span>(),f.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">end</span>());<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="思路二bfs状压dp">思路二（BFS+状压dp）</h3><p>由于苯人还没有系统练习过BFS+队列存储的题目，这里暂时贴上leetcode上的<a href="https://leetcode.cn/problems/shortest-path-visiting-all-nodes/solutions/918634/gtalgorithm-tu-jie-fa-ba-hardbian-cheng-v5knb/">解答</a>，并且简述一下自己的一些理解，详细的思路说明留待之后补充~</p><h4 id="代码">代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestPathLength</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">// 1.初始化队列及标记数组，存入起点</span><br>        queue&lt; tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; q; <span class="hljs-comment">// 三个属性分别为 idx, mask, dist</span><br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">vis</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-number">1</span> &lt;&lt; n)); <span class="hljs-comment">// 节点编号及当前状态</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            q.<span class="hljs-built_in">push</span>(&#123;i, <span class="hljs-number">1</span> &lt;&lt; i, <span class="hljs-number">0</span>&#125;); <span class="hljs-comment">// 存入起点，起始距离0，标记</span><br>            vis[i][<span class="hljs-number">1</span> &lt;&lt; i] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 开始搜索</span><br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> [cur, mask, dist] = q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 弹出队头元素</span><br>            q.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-comment">// 找到答案，返回结果</span><br>            <span class="hljs-keyword">if</span>(mask == (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> dist;<br><br>            <span class="hljs-comment">// 扩展</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : graph[cur]) &#123;<br>                <span class="hljs-type">int</span> nextmask = mask | (<span class="hljs-number">1</span> &lt;&lt; x);<br>                <span class="hljs-keyword">if</span>(!vis[x][nextmask]) &#123;<br>                    q.<span class="hljs-built_in">push</span>(&#123;x, nextmask, dist + <span class="hljs-number">1</span>&#125;);<br>                    vis[x][nextmask] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="个人理解">个人理解</h4><p>q中每个tuple的三个元素存储的是当前位掩码mask，遍历mask中所有节点并最后到达的节点idx，以及满足前述两个条件的最短路径长度dist，vis[idx][mask]记录在当前位掩码为mask的状态下，最后到达节点idx的路径是否已经经过计算了，事实上，在下面的while循环过程中，我们可以保证只要vis[idx][mask]经过了一次计算（也就是设置为true了），这次计算算得的路径就是相应的最短路径，因此后续无需再次计算该状态下的最短路径。首先初始状态下，我们将所有仅含1个节点的状态(i,1&lt;&lt;i,0)入队，并且更改vis[i][1&lt;&lt;i]为true，然后开始正式搜索。观察while循环中的代码可以非常直观地得出一个重要的结论，就是每次循环入队的tuple元素的dist分量是单调递增的，因此在循环内部注释拓展部分，只有在vis[idx][mask]还没有计算得到的时候才将相应元素入队，如果它已经计算过了（也就是vis[idx][mask]已经设置为true了），那么根据前文所述单调递增的性质，第一次计算之后的计算得到的dist只会比第一次计算得到的更大，因此这种情况下相应的tuple不能入队。最终随着搜索的进行，当第一次发现搜索已经遍历了所有的节点之后，我们就可以立即返回相应的dist了，这还是源于dist在每层循环单调递增的特性，因为这意味着第一次遍历之后的遍历所对应tuple中的dist元素肯定至少大于等于第一次的dist，所以第一次的dist就是我们寻找的最短距离。另外，由于题目保证该图是连通的，也就是说一定可以求出这样的最短距离，所以其实最后的return0是用不上的，但必须加上这句代码以确保所有分支情况都有数返回（不然会报错）。</p><h2 id="补充">补充</h2><p>对于不熟悉状压dp及其写法的读者，可以参考OI Wiki中的<a href="https://oi-wiki.org/dp/state/">简介</a>，基础写法可以参考灵茶山艾府大神的几篇<a href="https://leetcode.cn/problems/find-the-minimum-cost-array-permutation/solutions/2775272/zhuang-ya-dpcong-ji-yi-hua-sou-suo-dao-d-s9t5/">题解</a>。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>状态压缩dp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
