<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>加载模型</title>
    <link href="/2024/12/21/CG_api/vulkan/vulkan_tutorial/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/12/21/CG_api/vulkan/vulkan_tutorial/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深度缓冲</title>
    <link href="/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/"/>
    <url>/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>当我们需要在屏幕上渲染多个三维空间中的物体时，如何正确地表现它们之间的遮挡关系就成了绕不开的问题。一个自然的想法是按照距离视点的远近从近到远排序，然后按顺序绘制每个物体，但这样的方式存在诸多问题，最直接的问题就是物体之间可能没有严格的顺序可言，比如物体A一部分在物体B后，但另一部分在B前。因此，我们引入深度缓冲来解决（非透明）物体的渲染顺序问题。当使用深度缓冲时，我们不再需要按照固定的顺序渲染物体，因为深度缓冲会将当前渲染像素的深度与像素中储存的深度值进行比较，保留较近的那一个。本节我们就来为程序添加上深度缓冲支持，这主要可以分为七步：</p><ul><li>修改顶点属性和着色器代码以加入深度值</li><li>创建深度图像和相应视图</li><li>修改渲染通道以添加深度附件</li><li>修改帧缓冲以添加深度附件</li><li>修改命令录制函数以添加深度清除值</li><li>修改渲染管线以添加深度模板状态</li><li>修改交换链重建函数以添加深度图像重建代码</li></ul><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Depth_buffering">Depthbuffering</a>章节。</p><hr><h2 id="修改顶点和着色器">修改顶点和着色器</h2><p>我们现在希望使用具有深度的物体，因此顶点坐标应该改为用一个三维向量表示，并且更新获取顶点属性的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vertex</span> &#123;<br>    glm::vec3 pos;<br>    glm::vec3 color;<br>    glm::vec2 texCoord;<br><br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-function"><span class="hljs-type">static</span> std::array&lt;VkVertexInputAttributeDescription, 3&gt; <span class="hljs-title">getAttributeDescriptions</span><span class="hljs-params">()</span> </span>&#123;<br>        std::array&lt;VkVertexInputAttributeDescription, 3&gt; attributeDescriptions&#123;&#125;;<br><br>        attributeDescriptions[<span class="hljs-number">0</span>].binding = <span class="hljs-number">0</span>;<br>        attributeDescriptions[<span class="hljs-number">0</span>].location = <span class="hljs-number">0</span>;<br>        attributeDescriptions[<span class="hljs-number">0</span>].format = VK_FORMAT_R32G32B32_SFLOAT;<br>        attributeDescriptions[<span class="hljs-number">0</span>].offset = <span class="hljs-built_in">offsetof</span>(Vertex, pos);<br><br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>为了展示深度缓冲对顺序无关渲染的作用，我们现在绘制两个重叠的四边形，先绘制底下的那个再绘制顶上的那个，因此相应修改实际的顶点数据如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;Vertex&gt; vertices = &#123;<br>    &#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;,<br><br>    &#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;<br>&#125;;<br><br><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">uint16_t</span>&gt; indices = &#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>着色器代码同样需要修改以正确传入三维向量表示的顶点坐标：<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inPosition;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">void</span> main() &#123;<br>    <span class="hljs-built_in">gl_Position</span> = ubo.proj * ubo.view * ubo.model * <span class="hljs-type">vec4</span>(inPosition, <span class="hljs-number">1.0</span>);<br>    fragColor = inColor;<br>    fragTexCoord = inTexCoord;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这里需要注意的是，我们需要通过<strong>glm::perspective</strong>构建透视投影矩阵并传递给着色器。如果我们保持GLM的默认行为的话那么这样创建的投影矩阵作用后会使得深度值在[-1,1]之间，这是符合OpenGL规范的，但是Vulkan要求深度值插值后需要在[0,1]之间，因此我们还需要在程序头定义宏<i><font color="Red">GLM_FORCE_DEPTH_ZERO_TO_ONE</font></i>以使得这样创建的投影矩阵满足Vulkan的需求。</p><p>如果我们不使用深度缓冲直接渲染，那么结果如下：</p><figure><img src="/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/without.png" alt="不使用深度缓冲"><figcaption aria-hidden="true">不使用深度缓冲</figcaption></figure><p>显然这样的渲染结果是不正确的，下面的图像反而遮挡住了上面的图像，这是因为我们没有对哪个图像应该渲染在上面做任何指定，因此后渲染的图像就会覆盖之前渲染的图像，不管它们实际顺序如何。下面我们就使用深度缓冲来解决这一问题。</p><hr><h2 id="创建深度缓冲有关资源">创建深度缓冲有关资源</h2><p>深度附件和颜色附件一样是基于图像的，但是和颜色附件不同的是交换链并不会为我们自动创建深度附件，因此我们需要手动创建一个深度附件（之所以只用创建一个附件，是因为不会有两个渲染操作同时进行，因此我们只需要令所有的颜色附件共用一个深度附件即可）。在类内添加一个<i><font color="Green">voidcreateDepthResources()</font></i>函数来创建深度附件有关的资源，包括深度图像，深度视图和深度图像的内存，因此在类内新添三个成员来保存这些资源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkImage depthImage;<br>VkDeviceMemory depthImageMemory;<br>VkImageView depthImageView;<br></code></pre></td></tr></table></figure><p>创建这些资源的流程和之前创建图像的流程基本一致，只不过我们需要设置对应于深度缓冲的图像格式，下面列举出一些适用于深度缓冲的图像格式：</p><ul><li><code>VK_FORMAT_D32_SFLOAT</code>: 32位浮点深度值</li><li><code>VK_FORMAT_D32_SFLOAT_S8_UINT</code>:32位符号浮点深度值和8位无符号整型模板值</li><li><code>VK_FORMAT_D24_UNORM_S8_UINT</code>:24位无符号归一化深度值和8位无符号整型模板值</li></ul><p>在不同的情境下，我们可能希望使用不同的深度图像格式（比如说有时候我们可能需要使用模板测试有时不需要，关于模板测试的更多介绍，可以参考<a href="https://learnopengl.com/Advanced-OpenGL/Stencil-testing">这个页面</a>，本教程不会涉及到模板测试），因此为了灵活性起见我们创建一个函数<i><font color="Green">VkFormatfindSupportedFormat(const std::vector<VkFormat>&amp; candidates,VkImageTiling tiling, VkFormatFeatureFlagsfeatures)</VkFormat></font></i>来挑选所需的格式。</p><p>对于形参<i><font color="Orange">candidates</font></i>中的每个格式，我们需要查询硬件上该格式所具有的特性和支持的操作以判断该格式是否满足我们的需求，这个查询操作通过调用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFormatProperties.html"><code>vkGetPhysicalDeviceFormatProperties</code></a>完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (VkFormat format : candidates) &#123;<br>    VkFormatProperties props;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceFormatProperties</span>(physicalDevice, format, &amp;props);<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>查询得到的<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkFormatProperties.html"><code>VkFormatProperties</code></a>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkFormatProperties</span> &#123;</span><br>    VkFormatFeatureFlags    linearTilingFeatures;<span class="hljs-comment">//tiling mode为VK_IMAGE_TILING_LINEAR的该格式图像支持的特性</span><br>    VkFormatFeatureFlags    optimalTilingFeatures;<span class="hljs-comment">//tiling mode为VK_IMAGE_TILING_OPTIMAL的该格式图像支持的特性</span><br>    VkFormatFeatureFlags    bufferFeatures;<span class="hljs-comment">//该格式缓冲区支持的特性</span><br>&#125; VkFormatProperties;<br></code></pre></td></tr></table></figure><p>只有前两个成员是和图像有关的，于是我们完整的查询代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkFormat <span class="hljs-title">findSupportedFormat</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;VkFormat&gt;&amp; candidates, VkImageTiling tiling, VkFormatFeatureFlags features)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (VkFormat format : candidates) &#123;<br>        VkFormatProperties props;<br>        <span class="hljs-built_in">vkGetPhysicalDeviceFormatProperties</span>(physicalDevice, format, &amp;props);<br><br>        <span class="hljs-keyword">if</span> (tiling == VK_IMAGE_TILING_LINEAR &amp;&amp; (props.linearTilingFeatures &amp; features) == features) &#123;<br>            <span class="hljs-keyword">return</span> format;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tiling == VK_IMAGE_TILING_OPTIMAL &amp;&amp; (props.optimalTilingFeatures &amp; features) == features) &#123;<br>            <span class="hljs-keyword">return</span> format;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to find supported format!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>假设我们需要寻找的合适的深度图像格式就是上文列举的三种格式之一，于是我们创建一个<i><font color="Green">VkFormatfindDepthFormat()</font></i>函数来专门处理深度图像格式的寻找，它只需要简单地调用<i><font color="Green">findSupportedFormat</font></i>函数即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkFormat <span class="hljs-title">findDepthFormat</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">findSupportedFormat</span>(<br>        &#123;VK_FORMAT_D32_SFLOAT, VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT&#125;,<br>        VK_IMAGE_TILING_OPTIMAL,<br>        VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkFormatFeatureFlagBits.html"><code>VkFormatFeatureFlags</code></a>和<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageUsageFlagBits.html"><code>VkImageUsageFlags</code></a>的区别：前者指定的是某图像格式所支持的使用方式，后者指定的是图像实际上的使用方式。我们这里当然需要该图像格式支持用作深度（模板）附件，因此需要传递<i><font color="Red">VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT</font></i>参数。</p><p>现在就可以在<i><font color="Green">createDepthResources</font></i>函数中使用<i><font color="Green">findDepthFormat</font></i>函数寻找满足要求的深度图像格式，然后据此创建所有的深度附件资源了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createDepthResources</span><span class="hljs-params">()</span> </span>&#123;<br>    VkFormat depthFormat = <span class="hljs-built_in">findDepthFormat</span>();<br><br>    <span class="hljs-built_in">createImage</span>(swapChainExtent.width, swapChainExtent.height, depthFormat, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, depthImage, depthImageMemory);<br>    depthImageView = <span class="hljs-built_in">createImageView</span>(depthImage, depthFormat, VK_IMAGE_ASPECT_DEPTH_BIT);<br>&#125;<br></code></pre></td></tr></table></figure><p>不过这里需要注意的是，我们对<i><font color="Green">createImageView</font></i>函数进行了更改，新添了一个参数用来传递视图反映的图像方面（之前我们使用的图像方面一直是<i><font color="Red">VK_IMAGE_ASPECT_COLOR_BIT</font></i>，但是深度图像需要的图像方面是<i><font color="Red">VK_IMAGE_ASPECT_DEPTH_BIT</font></i>），也就是说新的<i><font color="Green">createImageView</font></i>函数要做出如下更改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkImageView <span class="hljs-title">createImageView</span><span class="hljs-params">(VkImage image, VkFormat format, VkImageAspectFlags aspectFlags)</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    viewInfo.subresourceRange.aspectMask = aspectFlags;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然，这个函数改变后用到该函数的代码也需要做出相应的改变：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">swapChainImageViews[i] = <span class="hljs-built_in">createImageView</span>(swapChainImages[i], swapChainImageFormat, VK_IMAGE_ASPECT_COLOR_BIT);<br><span class="hljs-comment">//...</span><br>depthImageView = <span class="hljs-built_in">createImageView</span>(depthImage, depthFormat, VK_IMAGE_ASPECT_DEPTH_BIT);<br><span class="hljs-comment">//...</span><br>textureImageView = <span class="hljs-built_in">createImageView</span>(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_ASPECT_COLOR_BIT);<br></code></pre></td></tr></table></figure><p>最后需要注意的是，我们并不需要显式地转换深度附件图像的布局以用作深度附件，这个过程渲染通道会帮我们自动完成（根据<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentDescription.html"><code>VkAttachmentDescription</code></a>结构体中的<i><font color="Orange">initialLayout</font></i>和<i><font color="Orange">finalLayout</font></i>成员指定的布局），就像颜色附件的图像布局转换一样。</p><hr><h2 id="修改渲染通道">修改渲染通道</h2><p>创建好深度附件资源后，我们就需要在渲染通道中引用这个深度附件。在<i><font color="Green">createRenderPass</font></i>中添加引创建深度附件引用的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br><br>VkAttachmentDescription depthAttachment&#123;&#125;;<br>depthAttachment.format = <span class="hljs-built_in">findDepthFormat</span>();<br>depthAttachment.samples = VK_SAMPLE_COUNT_1_BIT;<br>depthAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;<br>depthAttachment.storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>depthAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;<br>depthAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>depthAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;<br>depthAttachment.finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;<br><br>VkAttachmentReference depthAttachmentRef&#123;&#125;;<br>depthAttachmentRef.attachment = <span class="hljs-number">1</span>;<br>depthAttachmentRef.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;<br></code></pre></td></tr></table></figure><p>我们并不关系渲染开始前深度缓冲中的内容是什么，因为这个内容会被清除颜色清除掉，所以<i><font color="Orange">initialLayout</font><?i>可以设置为<i><font color="Red">VK_IMAGE_LAYOUT_UNDEFINED</font></i>，另外，我们也不需要在渲染结束后存储得到的深度值，因此<i><font color="Orange">storeOp</font></i>设置为<i><font color="Red">VK_ATTACHMENT_STORE_OP_DONT_CARE</font></i>即可。</i></p><p>然后，我们需要将深度缓冲的引用添加到子通道和渲染通道中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSubpassDescription subpass&#123;&#125;;<br>subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;<br>subpass.colorAttachmentCount = <span class="hljs-number">1</span>;<br>subpass.pColorAttachments = &amp;colorAttachmentRef;<br>subpass.pDepthStencilAttachment = &amp;depthAttachmentRef;<br><br>std::array&lt;VkAttachmentDescription, 2&gt; attachments = &#123;colorAttachment, depthAttachment&#125;;<br>VkRenderPassCreateInfo renderPassInfo&#123;&#125;;<br>renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;<br>renderPassInfo.attachmentCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attachments.<span class="hljs-built_in">size</span>());<br>renderPassInfo.pAttachments = attachments.<span class="hljs-built_in">data</span>();<br>renderPassInfo.subpassCount = <span class="hljs-number">1</span>;<br>renderPassInfo.pSubpasses = &amp;subpass;<br>renderPassInfo.dependencyCount = <span class="hljs-number">1</span>;<br>renderPassInfo.pDependencies = &amp;dependency;<br></code></pre></td></tr></table></figure><p>注意在<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassDescription.html"><code>VkSubpassDescription</code></a>中我们可以指定多个颜色附件，但是深度模板附件只能指定一个，这是合理的，因为使用多个深度附件没有多大意义。</p><p>另外，子通道之间的依赖关系也需要适当修改以保证在深度值输出到深度缓冲的时候深度附件已经准备好了（和颜色附件一样），因此需要更新填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassDependency.html"><code>VkSubpassDependency</code></a>的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;<br>dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;<br>dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;<br></code></pre></td></tr></table></figure><p>我们希望在早期片段测试之前深度附件已经准备好了（不然无法使用附件中的深度数据执行测试），因此我们呢需要添加渲染子通道的等待阶段<i><font color="Red">VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT</font></i>和相应的等待操作<i><font color="Red">VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT</font></i>。</p><hr><h2 id="修改帧缓冲">修改帧缓冲</h2><p>接下来我们需要修改创建帧缓冲的代码以将深度图像绑定到帧缓冲的深度附件上。在<i><font color="Green">createFramebuffers</font></i>函数中修改代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::array&lt;VkImageView, 2&gt; attachments = &#123;<br>    swapChainImageViews[i],<br>    depthImageView<br>&#125;;<br><br>VkFramebufferCreateInfo framebufferInfo&#123;&#125;;<br>framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;<br>framebufferInfo.renderPass = renderPass;<br>framebufferInfo.attachmentCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attachments.<span class="hljs-built_in">size</span>());<br>framebufferInfo.pAttachments = attachments.<span class="hljs-built_in">data</span>();<br>framebufferInfo.width = swapChainExtent.width;<br>framebufferInfo.height = swapChainExtent.height;<br>framebufferInfo.layers = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>当然，这个函数需要在<i><font color="Green">createDepthResources</font></i>之后调用以确保深度附件所需的资源都已经创建好了。</p><hr><h2 id="修改命令录制函数">修改命令录制函数</h2><p>回忆在<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/">命令缓冲</a>章节中，我们在录制命令时首先需要录制启动渲染通道的命令然后才能开始渲染，为了录制开始渲染通道的命令<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRenderPass.html"><code>vkCmdBeginRenderPass</code></a>我们需要填写相应的信息结构体<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/VkRenderPassBeginInfo.html"><code>VkRenderPassBeginInfo</code></a>，该结构体中有两个和清除颜色有关的成员<i><font color="Orange">clearValueCount</font></i>和<i><font color="Orange">pClearValues</font></i>，由于我们现在有多个在渲染通道开始时<i><font color="Orange">loadOp</font></i>设置为<i><font color="Red">VK_ATTACHMENT_LOAD_OP_CLEAR</font></i>的附件，我们就需要为每个这样的附件指定一个清除色，相应代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::array&lt;VkClearValue, 2&gt; clearValues&#123;&#125;;<br>clearValues[<span class="hljs-number">0</span>].color = &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;;<br>clearValues[<span class="hljs-number">1</span>].depthStencil = &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0</span>&#125;;<br><br>renderPassInfo.clearValueCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(clearValues.<span class="hljs-built_in">size</span>());<br>renderPassInfo.pClearValues = clearValues.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>颜色附件我们使用黑色作为清除色，深度附件我们使用最大深度值1.0作为清除值以保证所有渲染物体的深度都可以写入。</p><p>另外注意，在指定多个清除颜色时，清除色的顺序需要和相应帧缓冲中的附件顺序保持一致。</p><hr><h2 id="修改渲染管线">修改渲染管线</h2><p>深度附件现在已经准备好了，但是我们还需要在构建渲染管线时显式地指定开启深度测试和深度写入才能使用深度附件。为此我们需要在创建渲染管线的函数<i><font color="Green">createGraphicsPipeline</font></i>中填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineDepthStencilStateCreateInfo.html"><code>VkPipelineDepthStencilStateCreateInfo</code></a>结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineDepthStencilStateCreateInfo</span> &#123;</span><br>    VkStructureType                           sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                               pNext;<br>    VkPipelineDepthStencilStateCreateFlags    flags;<br>    VkBool32                                  depthTestEnable;<br>    VkBool32                                  depthWriteEnable;<br>    VkCompareOp                               depthCompareOp;<br>    VkBool32                                  depthBoundsTestEnable;<span class="hljs-comment">//是否启用保留深度范围</span><br>    VkBool32                                  stencilTestEnable;<br>    VkStencilOpState                          front;<br>    VkStencilOpState                          back;<br>    <span class="hljs-type">float</span>                                     minDepthBounds;<span class="hljs-comment">//被保留的最小深度</span><br>    <span class="hljs-type">float</span>                                     maxDepthBounds;<span class="hljs-comment">//被保留的最大深度</span><br>&#125; VkPipelineDepthStencilStateCreateInfo;<br></code></pre></td></tr></table></figure><p>所有成员都是易于理解的，我们这里不需要进行模板测试，所以不填写模板测试有关的信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br><br>VkPipelineDepthStencilStateCreateInfo depthStencil&#123;&#125;;<br><br>depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;<br>depthStencil.depthTestEnable = VK_TRUE;<br>depthStencil.depthWriteEnable = VK_TRUE;<br>depthStencil.depthCompareOp = VK_COMPARE_OP_LESS;<br>depthStencil.depthBoundsTestEnable = VK_FALSE;<br>depthStencil.minDepthBounds = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span><br>depthStencil.maxDepthBounds = <span class="hljs-number">1.0f</span>; <span class="hljs-comment">// Optional</span><br>depthStencil.stencilTestEnable = VK_FALSE;<br>depthStencil.front = &#123;&#125;; <span class="hljs-comment">// Optional</span><br>depthStencil.back = &#123;&#125;; <span class="hljs-comment">// Optional</span><br><br>pipelineInfo.pDepthStencilState = &amp;depthStencil;<br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><hr><h2 id="修改重建交换链函数">修改重建交换链函数</h2><p>最后，因为深度图像的分辨率也需要和屏幕保持一致，所以在窗口大小缩放的时候我们也需要重建深度附件有关的资源。在<i><font color="Green">recreateSwapChain</font></i>函数中添加重建深度资源的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recreateSwapChain</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> width = <span class="hljs-number">0</span>, height = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (width == <span class="hljs-number">0</span> || height == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);<br>        <span class="hljs-built_in">glfwWaitEvents</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">vkDeviceWaitIdle</span>(device);<br><br>    <span class="hljs-built_in">cleanupSwapChain</span>();<br><br>    <span class="hljs-built_in">createSwapChain</span>();<br>    <span class="hljs-built_in">createImageViews</span>();<br>    <span class="hljs-built_in">createDepthResources</span>();<br>    <span class="hljs-built_in">createFramebuffers</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>大功告成！我们现在运行程序就可以看到正确的渲染结果了：</p><figure><img src="/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/right.png" alt="正确的渲染结果"><figcaption aria-hidden="true">正确的渲染结果</figcaption></figure><p>这样我们就为真正的3D渲染做好了准备。<a href="https://zpc-dsg.github.io/2024/12/21/CG_api/vulkan/vulkan_tutorial/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/">下一章</a>我们将加载模型到我们的程序中，开启丰富多彩的3D渲染大门！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E7%BB%84%E5%90%88%E5%9B%BE%E5%83%8F%E9%87%87%E6%A0%B7%E5%99%A8/">上一篇：组合图像采样器</a></p><p>--<a href="https://zpc-dsg.github.io/2024/12/21/CG_api/vulkan/vulkan_tutorial/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/">下一篇：加载模型</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>组合图像采样器</title>
    <link href="/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E7%BB%84%E5%90%88%E5%9B%BE%E5%83%8F%E9%87%87%E6%A0%B7%E5%99%A8/"/>
    <url>/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E7%BB%84%E5%90%88%E5%9B%BE%E5%83%8F%E9%87%87%E6%A0%B7%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>现在我们已经准备好了采样纹理所需的一切对象，包括纹理本身、纹理视图和纹理采样器。本节我们会将这些对象通过组合图像采样器这一特殊的描述符连结起来，最终完成着色器纹理采样的工作。主要过程可以分为三步：</p><ul><li>创建组合图像采样器描述符</li><li>调整顶点结构以传递纹理坐标</li><li>在着色器中使用纹理采样</li></ul><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Texture_mapping/Combined_image_sampler">Combinedimage sampler</a>章节。</p><hr><h2 id="创建组合图像采样器">创建组合图像采样器</h2><p>我们可以将创建组合图像采样器的代码放在之前创建统一缓冲区描述符的代码一起。首先修改<i><font color="Green">createDescriptorSetLayout</font></i>函数添加相应代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br><br>VkDescriptorSetLayoutBinding samplerLayoutBinding&#123;&#125;;<br>samplerLayoutBinding.binding = <span class="hljs-number">1</span>;<br>samplerLayoutBinding.descriptorCount = <span class="hljs-number">1</span>;<br>samplerLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;<br>samplerLayoutBinding.pImmutableSamplers = <span class="hljs-literal">nullptr</span>;<br>samplerLayoutBinding.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;<br><br>std::array&lt;VkDescriptorSetLayoutBinding, 2&gt; bindings = &#123;uboLayoutBinding, samplerLayoutBinding&#125;;<br>VkDescriptorSetLayoutCreateInfo layoutInfo&#123;&#125;;<br>layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;<br>layoutInfo.bindingCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(bindings.<span class="hljs-built_in">size</span>());<br>layoutInfo.pBindings = bindings.<span class="hljs-built_in">data</span>();<br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>我们将组合图像采样器的绑定点设置为统一缓冲描述符绑定点的后一个（即1），并且注意要正确设置描述符类型和使用该描述符的着色器阶段（我们目前需要在片段着色器中使用纹理采样，因此<i><font color="Orange">stageFlags</font></i>设置为<i><font color="Red">VK_SHADER_STAGE_FRAGMENT_BIT</font></i>，不过有时候我们也可能需要在顶点着色器中进行纹理采样，比如使用高度贴图的时候）。</p><p>在更改描述符布局以包含组合图像采样器后，我们还需要增大描述符池的大小以分配所需的组合图像采样器。于是我们更改<i><font color="Green">createDescriptorPool</font></i>函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br><br>std::array&lt;VkDescriptorPoolSize, 2&gt; poolSizes&#123;&#125;;<br>poolSizes[<span class="hljs-number">0</span>].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;<br>poolSizes[<span class="hljs-number">0</span>].descriptorCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(MAX_FRAMES_IN_FLIGHT);<br>poolSizes[<span class="hljs-number">1</span>].type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;<br>poolSizes[<span class="hljs-number">1</span>].descriptorCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(MAX_FRAMES_IN_FLIGHT);<br><br>VkDescriptorPoolCreateInfo poolInfo&#123;&#125;;<br>poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;<br>poolInfo.poolSizeCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(poolSizes.<span class="hljs-built_in">size</span>());<br>poolInfo.pPoolSizes = poolSizes.<span class="hljs-built_in">data</span>();<br>poolInfo.maxSets = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(MAX_FRAMES_IN_FLIGHT);<br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>最后，我们需要更改<i><font color="Green">createDescriptorSets</font></i>函数来添加所需的组合图像采样器描述符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123;<br>    VkDescriptorBufferInfo bufferInfo&#123;&#125;;<br>    bufferInfo.buffer = uniformBuffers[i];<br>    bufferInfo.offset = <span class="hljs-number">0</span>;<br>    bufferInfo.range = <span class="hljs-built_in">sizeof</span>(UniformBufferObject);<br><br>    VkDescriptorImageInfo imageInfo&#123;&#125;;<br>    imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;<br>    imageInfo.imageView = textureImageView;<br>    imageInfo.sampler = textureSampler;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//...</span><br><br>std::array&lt;VkWriteDescriptorSet, 2&gt; descriptorWrites&#123;&#125;;<br><br>descriptorWrites[<span class="hljs-number">0</span>].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;<br>descriptorWrites[<span class="hljs-number">0</span>].dstSet = descriptorSets[i];<br>descriptorWrites[<span class="hljs-number">0</span>].dstBinding = <span class="hljs-number">0</span>;<br>descriptorWrites[<span class="hljs-number">0</span>].dstArrayElement = <span class="hljs-number">0</span>;<br>descriptorWrites[<span class="hljs-number">0</span>].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;<br>descriptorWrites[<span class="hljs-number">0</span>].descriptorCount = <span class="hljs-number">1</span>;<br>descriptorWrites[<span class="hljs-number">0</span>].pBufferInfo = &amp;bufferInfo;<br><br>descriptorWrites[<span class="hljs-number">1</span>].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;<br>descriptorWrites[<span class="hljs-number">1</span>].dstSet = descriptorSets[i];<br>descriptorWrites[<span class="hljs-number">1</span>].dstBinding = <span class="hljs-number">1</span>;<br>descriptorWrites[<span class="hljs-number">1</span>].dstArrayElement = <span class="hljs-number">0</span>;<br>descriptorWrites[<span class="hljs-number">1</span>].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;<br>descriptorWrites[<span class="hljs-number">1</span>].descriptorCount = <span class="hljs-number">1</span>;<br>descriptorWrites[<span class="hljs-number">1</span>].pImageInfo = &amp;imageInfo;<br><br><span class="hljs-built_in">vkUpdateDescriptorSets</span>(device, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(descriptorWrites.<span class="hljs-built_in">size</span>()), descriptorWrites.<span class="hljs-built_in">data</span>(), <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br></code></pre></td></tr></table></figure><p>创建相应描述符的过程和创建统一缓冲描述符的过程几乎一致，只不过统一缓冲描述符所持有的对象是统一缓冲区，因此需要填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorBufferInfo.html"><code>VkDescriptorBufferInfo</code></a>信息，而组合图像采样器持有的是纹理对象，所以需要填写<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/VkDescriptorImageInfo.html"><code>VkDescriptorImageInfo</code></a>信息，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDescriptorImageInfo</span> &#123;</span><br>    VkSampler        sampler;<br>    VkImageView      imageView;<br>    VkImageLayout    imageLayout;<br>&#125; VkDescriptorImageInfo;<br></code></pre></td></tr></table></figure><p>每个成员都是易于理解的。</p><p>这样就完成了组合图像采样器的创建和配置。</p><hr><h2 id="调整顶点结构">调整顶点结构</h2><p>为了在着色器中使用纹理，我们需要给着色器传递相应图像的纹理坐标。于是，修改<i><font color="Orange">Vertex</font></i>结构体以包含一个2维向量表示的纹理坐标：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vertex</span> &#123;<br>    glm::vec2 pos;<br>    glm::vec3 color;<br>    glm::vec2 texCoord;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> VkVertexInputBindingDescription <span class="hljs-title">getBindingDescription</span><span class="hljs-params">()</span> </span>&#123;<br>        VkVertexInputBindingDescription bindingDescription&#123;&#125;;<br>        bindingDescription.binding = <span class="hljs-number">0</span>;<br>        bindingDescription.stride = <span class="hljs-built_in">sizeof</span>(Vertex);<br>        bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;<br><br>        <span class="hljs-keyword">return</span> bindingDescription;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> std::array&lt;VkVertexInputAttributeDescription, 3&gt; <span class="hljs-title">getAttributeDescriptions</span><span class="hljs-params">()</span> </span>&#123;<br>        std::array&lt;VkVertexInputAttributeDescription, 3&gt; attributeDescriptions&#123;&#125;;<br><br>        attributeDescriptions[<span class="hljs-number">0</span>].binding = <span class="hljs-number">0</span>;<br>        attributeDescriptions[<span class="hljs-number">0</span>].location = <span class="hljs-number">0</span>;<br>        attributeDescriptions[<span class="hljs-number">0</span>].format = VK_FORMAT_R32G32_SFLOAT;<br>        attributeDescriptions[<span class="hljs-number">0</span>].offset = <span class="hljs-built_in">offsetof</span>(Vertex, pos);<br><br>        attributeDescriptions[<span class="hljs-number">1</span>].binding = <span class="hljs-number">0</span>;<br>        attributeDescriptions[<span class="hljs-number">1</span>].location = <span class="hljs-number">1</span>;<br>        attributeDescriptions[<span class="hljs-number">1</span>].format = VK_FORMAT_R32G32B32_SFLOAT;<br>        attributeDescriptions[<span class="hljs-number">1</span>].offset = <span class="hljs-built_in">offsetof</span>(Vertex, color);<br><br>        attributeDescriptions[<span class="hljs-number">2</span>].binding = <span class="hljs-number">0</span>;<br>        attributeDescriptions[<span class="hljs-number">2</span>].location = <span class="hljs-number">2</span>;<br>        attributeDescriptions[<span class="hljs-number">2</span>].format = VK_FORMAT_R32G32_SFLOAT;<br>        attributeDescriptions[<span class="hljs-number">2</span>].offset = <span class="hljs-built_in">offsetof</span>(Vertex, texCoord);<br><br>        <span class="hljs-keyword">return</span> attributeDescriptions;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同时我们也需要修改<i><font color="Green">getAttributeDescriptions</font></i>静态函数以向顶点着色器正确传递更改后的顶点属性。</p><p>最后不要忘了更改实际传递给顶点着色器的顶点数据以包含实际的纹理坐标数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;Vertex&gt; vertices = &#123;<br>    &#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="着色器纹理采样">着色器纹理采样</h2><p>现在我们终于可以在着色器中使用纹理进行采样了！首先我们需要将顶点着色器中输入的纹理坐标传递给片段着色器使用：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inPosition;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inColor;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inTexCoord;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fragColor;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> fragTexCoord;<br><br><span class="hljs-type">void</span> main() &#123;<br>    <span class="hljs-built_in">gl_Position</span> = ubo.proj * ubo.view * ubo.model * <span class="hljs-type">vec4</span>(inPosition, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fragColor = inColor;<br>    fragTexCoord = inTexCoord;<br>&#125;<br></code></pre></td></tr></table></figure><p>在纹理坐标传递给片段着色器之前，光栅化器会插值这些纹理坐标到每个片段上，于是我们在片段着色器中就可以使用插值后的纹理坐标对每一个片段进行纹理采样了：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texSampler;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> fragColor;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> fragTexCoord;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outColor;<br><br><span class="hljs-type">void</span> main() &#123;<br>    outColor = <span class="hljs-built_in">texture</span>(texSampler, fragTexCoord);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终我们可以看到具有纹理的四边形显示在屏幕上：</p><figure><img src="/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E7%BB%84%E5%90%88%E5%9B%BE%E5%83%8F%E9%87%87%E6%A0%B7%E5%99%A8/texture.png" alt="纹理四边形"><figcaption aria-hidden="true">纹理四边形</figcaption></figure><p>大功告成！当然，我们可以在片段着色器中调整图像采样的方式，颜色混合的方式等等来实现各种各样有趣的效果！</p><p>纹理采样部分就此告一段落，接下来教程会开启几个独立的小主题作为本基础教程的收尾。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/">上一篇：图像视图和采样器</a></p><p>--<a href="https://zpc-dsg.github.io/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/">下一篇：深度缓冲</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图像视图和采样器</title>
    <link href="/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/"/>
    <url>/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>本章我们将创建纹理采样所必须的两个资源——图像视图和采样器。图像视图在<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/">图像视图</a>章节已经介绍过了，不过采样器对我们而言仍然是一个全新的知识，它主要控制着色器如何对纹理进行采样。本节我们就来分别创建<a href="https://zpc-dsg.github.io/2024/12/12/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F/">上一章</a>创建好的纹理所对应的这两个对象。</p><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Texture_mapping/Image_view_and_sampler">Imageview and sampler</a>章节。</p><hr><h2 id="创建纹理图像视图">创建纹理图像视图</h2><p>在<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/">图像视图</a>章节中我们已经创建了一个工具函数<i><font color="Green">createImageViews</font></i>来创建交换链中所有图像各自所需的图像视图。这里我们完全可以重用其中的代码来创建<a href="https://zpc-dsg.github.io/2024/12/12/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F/">上一章</a>创建的纹理对象对应的图像视图。在类内新建一个<i><font color="Green">VkImageViewcreateImageView(VkImage image, VkFormatformat)</font></i>函数来提取出创建一个图像视图所需的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkImageView <span class="hljs-title">createImageView</span><span class="hljs-params">(VkImage image, VkFormat format)</span> </span>&#123;<br>    VkImageViewCreateInfo viewInfo&#123;&#125;;<br>    viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;<br>    viewInfo.image = image;<br>    viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;<br>    viewInfo.format = format;<br>    viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br>    viewInfo.subresourceRange.baseMipLevel = <span class="hljs-number">0</span>;<br>    viewInfo.subresourceRange.levelCount = <span class="hljs-number">1</span>;<br>    viewInfo.subresourceRange.baseArrayLayer = <span class="hljs-number">0</span>;<br>    viewInfo.subresourceRange.layerCount = <span class="hljs-number">1</span>;<br><br>    VkImageView imageView;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateImageView</span>(device, &amp;viewInfo, <span class="hljs-literal">nullptr</span>, &amp;imageView) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create texture image view!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> imageView;<br>&#125;<br></code></pre></td></tr></table></figure><p>在类内新添一个成员<i><font color="Orange">textureImageView</font></i>来保存将要构建的纹理图像视图对象，并且新添一个<i><font color="Green">voidcreateTextureImageView()</font></i>函数来进行创建纹理视图有关的工作，于是该函数的代码可以简单地写成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createTextureImageView</span><span class="hljs-params">()</span> </span>&#123;<br>    textureImageView = <span class="hljs-built_in">createImageView</span>(textureImage, VK_FORMAT_R8G8B8A8_SRGB);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/">图像视图</a>章节创建的<i><font color="Green">createImageViews</font></i>函数现在也可以简化为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createImageViews</span><span class="hljs-params">()</span> </span>&#123;<br>    swapChainImageViews.<span class="hljs-built_in">resize</span>(swapChainImages.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainImages.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        swapChainImageViews[i] = <span class="hljs-built_in">createImageView</span>(swapChainImages[i], swapChainImageFormat);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就创建好了纹理对象的图像视图。</p><hr><h2 id="创建采样器">创建采样器</h2><p>事实上着色器也可以直接采样纹理，但是使用采样器进行采样几乎总是更好的选择，因为采样器会对图片进行合适的过滤和变换，然后将处理后的颜色递交给着色器以达到更好的图像质量。当图像过采样或者采样不足时，采样器会自动使用设置好的过滤模式对图像颜色进行过滤；当着色器采样到图像之外的点时，采样器会使用预先设置好的<strong>解决模式（Addressingmode）</strong>来决定此时的采样行为和最终结果。关于这一部分内容，这里假设读者已经有了一个基本的概念，不再赘述，不熟悉的读者可以参考<a href="https://learnopengl.com/Getting-started/Textures">这篇文章</a>。</p><p>接下来我们在类内创建一个<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkSampler.html"><code>VkSampler</code></a>类型的<i><font color="Orange">textureSampler</font></i>成员来储存纹理采样器，并且创建一个<i><font color="Green">voidcreateTextureSampler()</font></i>函数来创建该采样器。创建采样器的过程很简单，我们只需要填写相应的信息结构体<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerCreateInfo.html"><code>VkSamplerCreateInfo</code></a>即可，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSamplerCreateInfo</span> &#123;</span><br>    VkStructureType         sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*             pNext;<br>    VkSamplerCreateFlags    flags;<br>    VkFilter                magFilter;<br>    VkFilter                minFilter;<br>    VkSamplerMipmapMode     mipmapMode;<br>    VkSamplerAddressMode    addressModeU;<br>    VkSamplerAddressMode    addressModeV;<br>    VkSamplerAddressMode    addressModeW;<br>    <span class="hljs-type">float</span>                   mipLodBias;<br>    VkBool32                anisotropyEnable;<br>    <span class="hljs-type">float</span>                   maxAnisotropy;<br>    VkBool32                compareEnable;<br>    VkCompareOp             compareOp;<br>    <span class="hljs-type">float</span>                   minLod;<br>    <span class="hljs-type">float</span>                   maxLod;<br>    VkBorderColor           borderColor;<br>    VkBool32                unnormalizedCoordinates;<br>&#125; VkSamplerCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>可能的取值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkSamplerCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_EXT_fragment_density_map</span><br>    VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//表示采样器支持子采样（即从原始图像中选择一部分像素进行处理，而忽略其他像素）。这通常用于减少渲染负担，特别是在高分辨率的场景中</span><br>  <span class="hljs-comment">// Provided by VK_EXT_fragment_density_map</span><br>    VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//表示采样器支持粗略重建的子采样</span><br>  <span class="hljs-comment">// Provided by VK_EXT_descriptor_buffer</span><br>    VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//表示采样器支持描述符缓冲区的捕获和重放（指将描述符缓冲区的状态（即绑定的资源和参数）保存下来，以便在后续的渲染操作中重新使用）。这有助于在图形管线中更高效地管理资源</span><br>  <span class="hljs-comment">// Provided by VK_EXT_non_seamless_cube_map</span><br>    VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//表示采样器支持非无缝的立方体贴图。这意味着在采样立方体贴图时，边缘可能会有可见的接缝</span><br>  <span class="hljs-comment">// Provided by VK_QCOM_image_processing</span><br>    VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM = <span class="hljs-number">0x00000010</span>,<span class="hljs-comment">//表示采样器支持图像处理功能。这可能涉及对图像进行各种处理操作，例如滤波或转换</span><br>&#125; VkSamplerCreateFlagBits;<br></code></pre></td></tr></table></figure><p>接下来的<i><font color="Orange">magFilter</font></i>和<i><font color="Orange">minFilter</font></i>分别指定放大和缩小图像时的过滤模式。可能选取的过滤模式有以下几种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkFilter</span> &#123;</span><br>    VK_FILTER_NEAREST = <span class="hljs-number">0</span>,<br>    VK_FILTER_LINEAR = <span class="hljs-number">1</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_filter_cubic</span><br>    VK_FILTER_CUBIC_EXT = <span class="hljs-number">1000015000</span>,<br>  <span class="hljs-comment">// Provided by VK_IMG_filter_cubic</span><br>    VK_FILTER_CUBIC_IMG = VK_FILTER_CUBIC_EXT,<br>&#125; VkFilter;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">mipmapMode</font></i>、<i><font color="Orange">mipLodBias</font></i>、<i><font color="Orange">minLod</font></i>、<i><font color="Orange">maxLod</font></i>均与多级渐远纹理有关，在后续介绍Vulkan中的多级渐远时我们会详细介绍这一部分。</p><p>接下来的三个addressMode用于指定采样超出图像范围的解决模式，可能的取值有如下几种，它们的作用和效果基本上在<a href="https://learnopengl.com/Getting-started/Textures">这篇文章</a>中都有提及：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkSamplerAddressMode</span> &#123;</span><br>    VK_SAMPLER_ADDRESS_MODE_REPEAT = <span class="hljs-number">0</span>,<br>    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = <span class="hljs-number">1</span>,<br>    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = <span class="hljs-number">2</span>,<br>    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = <span class="hljs-number">3</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2, VK_KHR_sampler_mirror_clamp_to_edge</span><br>    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = <span class="hljs-number">4</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_sampler_mirror_clamp_to_edge</span><br>  <span class="hljs-comment">// VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR is a deprecated alias</span><br>    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,<br>&#125; VkSamplerAddressMode;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">compareEnable</font></i>和<i><font color="Orange">compareOp</font></i>指定图像颜色和一个固定颜色的比较操作，这在有些应用情景下是有用的，比如<strong>PCF(percentage-closerfiltering)</strong>（可以参考<a href="https://developer.nvidia.com/gpugems/gpugems/part-ii-lighting-and-shadows/chapter-11-shadow-map-antialiasing">这篇文章</a>或者<a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">这篇文章</a>来初步了解PCF，<a href="https://www.bilibili.com/video/BV1YK4y1T7yY?vd_source=96b763f75b621baa119e5118b6164aee&amp;p=3&amp;spm_id_from=333.788.videopod.episodes">games202</a>中有包括PCF在内的更多关于阴影处理技术的拓展）。</p><p><i><font color="Orange">borderColor</font></i>指定当解决模式设置为夹紧到边界有关的模式时使用的边界颜色。事实上这个颜色不能是任意值，而是必须为以下取值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkBorderColor</span> &#123;</span><br>    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = <span class="hljs-number">0</span>,<br>    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = <span class="hljs-number">1</span>,<br>    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = <span class="hljs-number">2</span>,<br>    VK_BORDER_COLOR_INT_OPAQUE_BLACK = <span class="hljs-number">3</span>,<br>    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = <span class="hljs-number">4</span>,<br>    VK_BORDER_COLOR_INT_OPAQUE_WHITE = <span class="hljs-number">5</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_custom_border_color</span><br>    VK_BORDER_COLOR_FLOAT_CUSTOM_EXT = <span class="hljs-number">1000287003</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_custom_border_color</span><br>    VK_BORDER_COLOR_INT_CUSTOM_EXT = <span class="hljs-number">1000287004</span>,<br>&#125; VkBorderColor;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">unnormalizedCoordinates</font></i>决定纹理坐标的范围。如果设置为<i><font color="Red">VK_TRUE</font></i>则代表纹理各维度坐标将是0到该维度像素数这个范围，一般我们都设置为<i><font color="Red">VK_FALSE</font></i>，此时纹理坐标范围为[0,1)，与图像像素多少无关。</p><p>最后我们来看成员<i><font color="Orange">anisotrophyEnable</font></i>和<i><font color="Orange">maxAnisotropy</font></i>，这两个成员和各向异性滤波有关。所谓各向异性滤波，指的是一种纹理过滤技术，通过动态调整过滤级别和加权平均样本从而改善斜角表面上纹理的质量。与之前成员不同的是，各向异性滤波涉及到GPU特性，需要我们手动开启才能使用（如果不开启直接使用验证层会报错），于是我们需要首先在<i><font color="Green">createLogicalDevice</font></i>函数中手动启用这个特性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPhysicalDeviceFeatures deviceFeatures&#123;&#125;;<br>deviceFeatures.samplerAnisotropy = VK_TRUE;<br><br><span class="hljs-comment">//...</span><br><br>VkDeviceCreateInfo createInfo&#123;&#125;;<br>createInfo.pEnabledFeatures = &amp;deviceFeatures;<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>当然，严格来讲我们应该还需要在开启这个特性之前先检查一下GPU是否支持该特性（这个特性几乎被所有的现代GPU所支持，所以大多数情况不去检查也没有大问题，不过为了完整性和严谨性起见我们还是添加上检查代码），于是在<i><font color="Green">isDeviceSuitable</font></i>中添加上检查硬件是否支持该特性的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br><br>VkPhysicalDeviceFeatures supportedFeatures;<br><span class="hljs-built_in">vkGetPhysicalDeviceFeatures</span>(device, &amp;supportedFeatures);<br><br><span class="hljs-keyword">return</span> indices.<span class="hljs-built_in">isComplete</span>() &amp;&amp; extensionsSupported &amp;&amp; swapChainAdequate &amp;&amp; supportedFeatures.samplerAnisotropy;<br></code></pre></td></tr></table></figure><p>这样我们就可以在创建采样器时开启该特性了。当然，除非出于性能考虑，不然我们没有理由不开启各向异性过滤来提高纹理采样质量。另外，启用该特性后，我们还需要查询设备所支持的各向异性滤波采样数目的最大值以填写<i><font color="Orange">maxAnisotropy</font></i>成员，这同样可以通过查询GPU特性来实现。于是我们填写该信息结构体的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSamplerCreateInfo samplerInfo&#123;&#125;;<br>samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;<br>samplerInfo.magFilter = VK_FILTER_LINEAR;<br>samplerInfo.minFilter = VK_FILTER_LINEAR;<br>samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;<br>samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;<br>samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;<br><br>samplerInfo.anisotropyEnable = VK_TRUE;<br>VkPhysicalDeviceProperties properties&#123;&#125;;<br><span class="hljs-built_in">vkGetPhysicalDeviceProperties</span>(physicalDevice, &amp;properties);<br>samplerInfo.maxAnisotropy = properties.limits.maxSamplerAnisotropy;<br><br>samplerInfo.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;<br>samplerInfo.unnormalizedCoordinates = VK_FALSE;<br>samplerInfo.compareEnable = VK_FALSE;<br>samplerInfo.compareOp = VK_COMPARE_OP_ALWAYS;<br><br>samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;<br>samplerInfo.mipLodBias = <span class="hljs-number">0.0f</span>;<br>samplerInfo.minLod = <span class="hljs-number">0.0f</span>;<br>samplerInfo.maxLod = <span class="hljs-number">0.0f</span>;<br></code></pre></td></tr></table></figure><p>然后我们就可以使用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSampler.html"><code>vkCreateSampler</code></a>创建所需的采样器对象了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateSampler</span>(device, &amp;samplerInfo, <span class="hljs-literal">nullptr</span>, &amp;textureSampler) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create texture sampler!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/12/12/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F/">上一篇：图像</a></p><p>--<a href="https://zpc-dsg.github.io/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E7%BB%84%E5%90%88%E5%9B%BE%E5%83%8F%E9%87%87%E6%A0%B7%E5%99%A8/">下一篇：组合图像采样器</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图像</title>
    <link href="/2024/12/12/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F/"/>
    <url>/2024/12/12/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>接下来的几个章节我们将开始纹理使用的学习。使用纹理可以给我们原本枯燥无味的程序添加大量有趣的细节。在Vulkan中使用纹理大致可以分为四步：</p><ul><li>创建纹理对象并且为其分配内存</li><li>将图片数据上传并复制到纹理中</li><li>创建图像视图和采样器</li><li>创建相应的组合图像采样器描述符（<strong>combined image samplerdescriptor</strong>）以便着色器采样纹理</li></ul><p>本节我们将首先完成前两步的工作。在之前的<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/">交换链</a>章节中我们提到过，在创建交换链对象的时候Vulkan会自动帮我们创建交换链使用的图像而无需我们自己创建，而在使用纹理的时候我们就需要自己完成创建图像的有关工作和细节了。创建纹理并且上传图片数据的过程主要可以细分为以下：</p><ul><li>将图片加载到程序中</li><li>将加载到程序中的图片数据复制给临时缓冲</li><li>创建纹理对象并且为其分配内存</li><li>在复制缓冲数据之前处理好图像布局的转换</li><li>将临时缓冲中的数据复制到纹理中</li></ul><p>可以看出构建并填充一个纹理对象的过程和构建并填充顶点缓冲的过程十分类似，不过最大的不同之处在于在将数据复制到纹理对象之前，我们需要处理好纹理布局。事实上，指定不同的图像布局会影响Vulkan对该图像执行操作的方式，一般在使用图像之前我们需要将图像布局转换为最适合接下来操作的那一个。在之前的<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/">渲染通道</a>章节中我们已经介绍过一些图像布局有关的知识，（这里有一个小疑点：<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/">渲染通道</a>章节中我们指定了帧缓冲的图像附件在渲染开始和结束后应该具备的布局，并且在之后的渲染过程中我们也并没有手动去进行布局的转换，但是GPT说即使在<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentDescription.html"><code>VkAttachmentDescription</code></a>中指定了附件的初始和最终布局，我们仍然需要在录制命令的时候手动进行布局转换以满足设置的布局要求，但是显然教程中没有这么做，我并不清楚是GPT说明有误还是教程漏写了。。。）。当我们需要自己处理布局转换有关的细节的时候，我们往往会采用管线屏障（<strong>pipelinebarrier</strong>）来同步转换前后需要指定顺序的操作，这同样会在本文的主要内容中介绍。</p><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Texture_mapping/Images#page_Preparing-the-texture-image">images</a>章节。</p><hr><h2 id="加载图片">加载图片</h2><p>有很多的库可以用于将图片加载至程序中，当然，自己写一个这样的库也并不困难。不过，为了性能和稳定性以及适用范围的考量，我们在这里还是选取一个十分通用的图像加载库：<a href="https://github.com/nothings/stb">stb_image</a>。这个库最大的特点和方便之处在于所有的代码都集中在一个文件中，省去了很多构建依赖关系的麻烦。想要使用这个库，我们只需要在程序中包含<strong>stb_image.h</strong>头文件，然后在程序头定义宏<i><font color="Red">STB_IMAGE_IMPLEMENTATION</font></i>即可。关于这个库提供的API以及有关使用方式我们不做过多介绍，想要详细了解的读者可以参考<strong>stb_image.h</strong>头文件中的<strong>DOCUMENTATION</strong>注释部分。</p><p>假设我们使用一张名为<strong>texture.jpg</strong>的图像，并且将其放在程序根目录下的子文件夹<strong>textures</strong>中。我们添加一个构建纹理的成员函数<i><font color="Green">voidcreateTextureImage()</font></i>，那么这个函数首先要做的就是加载图像到程序中来，加载图像的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createTextureImage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> texWidth, texHeight, texChannels;<br>    stbi_uc* pixels = <span class="hljs-built_in">stbi_load</span>(<span class="hljs-string">&quot;textures/texture.jpg&quot;</span>, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);<br>    VkDeviceSize imageSize = texWidth * texHeight * <span class="hljs-number">4</span>;<br><br>    <span class="hljs-keyword">if</span> (!pixels) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to load texture image!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里我们在<strong>stbi_load</strong>函数中使用了参数<i><font color="Red">STBI_rgb_alpha</font></i>，这意味着我们强制要求加载图片的透明通道，即使图片本身不具备该通道，这样加载的图片数据具有所有的四个通道。这么做可以使用统一的代码加载具有透明通道和不具有透明通道的图片。另外，加载后的图片数据大小<i><font color="Orange">imageSize</font></i>被定义为4倍的图像大小，因为加载后图片的每个像素都有4个通道，每个通道占一字节。</p><hr><h2 id="填充临时缓冲">填充临时缓冲</h2><p>填充临时缓冲的操作和<a href="https://zpc-dsg.github.io/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/">临时缓冲区</a>章节所述的步骤没什么区别：首先创建一个CPU可见且一致的临时缓冲对象并且为它分配内存，然后将该缓冲映射到CPU端，再将程序中的数据复制到该缓冲中，最后解除映射。整个代码流程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createTextureImage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <br>    VkBuffer stagingBuffer;<br>VkDeviceMemory stagingBufferMemory;<br>    <br>    <span class="hljs-built_in">createBuffer</span>(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);<br>    <br>    <span class="hljs-type">void</span>* data;<br><span class="hljs-built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="hljs-number">0</span>, imageSize, <span class="hljs-number">0</span>, &amp;data);<br>    <span class="hljs-built_in">memcpy</span>(data, pixels, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(imageSize));<br><span class="hljs-built_in">vkUnmapMemory</span>(device, stagingBufferMemory);<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然，不要忘了在图像数据复制到缓冲区后清理掉不再使用的<i><font color="Orange">pixels</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">stbi_image_free</span>(pixels);<br></code></pre></td></tr></table></figure><p>值得一提的是，实际上我们也可以使用临时图像来作为最终图像和CPU端数据的中介，不过在某些硬件上使用缓冲区作为中介的速度更快效果更好，所以我们还是使用临时缓冲区来传递数据。</p><hr><h2 id="创建纹理对象并分配内存">创建纹理对象并分配内存</h2><p>尽管在Vulkan中我们也可以使用缓冲区来存储并使用图像数据，但是Vulkan提供了专门用于使用图像的图像对象，通过图像对象我们就可以使用直观的坐标来获取像素颜色而无需通过字节来获取颜色信息，这显然是更方便的。并且Vulkan的图像对象还提供了各种布局以优化各种使用方式的效率。因此，使用图像对象来访问图片数据一般来讲是一个更好的选择。</p><p>现在我们已经将图片数据复制到了临时缓冲中，接下来我们需要创建GPU端真正用于存储数据的图像对象。为了创建这样一个图像对象，我们需要填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCreateInfo.html"><code>VkImageCreateInfo</code></a>结构体，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkImageCreateInfo</span> &#123;</span><br>    VkStructureType          sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*              pNext;<br>    VkImageCreateFlags       flags;<br>    VkImageType              imageType;<br>    VkFormat                 format;<br>    VkExtent3D               extent;<br>    <span class="hljs-type">uint32_t</span>                 mipLevels;<br>    <span class="hljs-type">uint32_t</span>                 arrayLayers;<br>    VkSampleCountFlagBits    samples;<br>    VkImageTiling            tiling;<br>    VkImageUsageFlags        usage;<br>    VkSharingMode            sharingMode;<br>    <span class="hljs-type">uint32_t</span>                 queueFamilyIndexCount;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*          pQueueFamilyIndices;<br>    VkImageLayout            initialLayout;<br>&#125; VkImageCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>指定了很多特性，详细可以参考<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCreateFlagBits.html">这个页面</a>，这里不做过多介绍。</p><p><i><font color="Orange">imageType</font></i>指定创建的图像对象类型，总共有三种类型：1D，2D和3D图像：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkImageType</span> &#123;</span><br>    VK_IMAGE_TYPE_1D = <span class="hljs-number">0</span>,<br>    VK_IMAGE_TYPE_2D = <span class="hljs-number">1</span>,<br>    VK_IMAGE_TYPE_3D = <span class="hljs-number">2</span>,<br>&#125; VkImageType;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">format</font></i>指定图像数据的格式，这个格式一般需要和临时缓冲区中存储图像的格式一致，不然的话在后续复制缓冲数据容易得到无法预知的错误结果。Vulkan支持的完整的图像格式可以参考<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkFormat.html">这个页面</a>。</p><p><i><font color="Orange">extent</font></i>是一个<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkExtent3D.html"><code>VkExtent3D</code></a>类型的成员，用于指定图像基础层级每个维度的像素数量，<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkExtent3D.html"><code>VkExtent3D</code></a>是一个包含三个维度像素数量成员的简单结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkExtent3D</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>    width;<br>    <span class="hljs-type">uint32_t</span>    height;<br>    <span class="hljs-type">uint32_t</span>    depth;<br>&#125; VkExtent3D;<br></code></pre></td></tr></table></figure><p>接下来的<i><font color="Orange">mipLevels</font></i>、<i><font color="Orange">arrayLayers</font></i>和<i><font color="Orange">samples</font></i>分别指定图像的多级渐远层级、图像层数以及多重采样采样数，我们暂时不需要使用多级渐远和多层图像，也暂时不会使用多重采样技术。</p><p><i><font color="Orange">tiling</font></i>指定了图像中的像素在内存中实际上的存储方式，它可以有以下取值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkImageTiling</span> &#123;</span><br>    VK_IMAGE_TILING_OPTIMAL = <span class="hljs-number">0</span>,<br>    VK_IMAGE_TILING_LINEAR = <span class="hljs-number">1</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_image_drm_format_modifier</span><br>    VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = <span class="hljs-number">1000158000</span>,<span class="hljs-comment">//主要用于支持 DRM（Direct Rendering Manager）格式修饰符的图像，这些修饰符允许驱动程序更好地利用硬件特性，以优化图像存储和访问。这个扩展使得 Vulkan 可以更好地与 Linux 的图形栈（如 Wayland 和 X11）集成</span><br>&#125; VkImageTiling;<br></code></pre></td></tr></table></figure><p>如果我们希望在后续的CPU端操作中获取图像中的内容，那么我们应该将<i><font color="Orange">tiling</font></i>设置为<i><font color="Red">VK_IMAGE_TILING_OPTIMAL</font></i>，但是如果我们希望在GPU端使用该图像，比如用于渲染采样等操作，那么应该将其设置为<i><font color="Red">VK_IMAGE_TILING_OPTIMAL</font></i>。注意铺砌方式和布局还是有所不同的：铺砌方式指定了图像数据在内存中的具体存储格式，而布局则是指定图像允许的使用方式。</p><p><i><font color="Orange">usage</font></i>指定图像的用途，关于Vulkan中图像允许的所有用途可以参考<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageUsageFlagBits.html">这个页面</a>。</p><p><i><font color="Orange">sharingMode</font></i>指定图像的共享模式，也就是是否能被多个队列家族所共享，下方的<i><font color="Orange">queueFamilyIndexCount</font></i>和<i><font color="Orange">pQueueFamilyIndices</font></i>就指定了可以共享该图像的队列家族索引。当然，如果共享模式不是<i><font color="Red">VK_SHARING_MODE_CONCURRENT</font></i>的话，这两个成员会被忽略，因此也就无需填写。</p><p><i><font color="Orange">initialLayout</font></i>指定图像的初始布局，也就是创建之初的布局。事实上，对于该变量我们的取值只有两种：</p><ul><li><i><font color="Red">VK_IMAGE_LAYOUT_UNDEFINED</font></i>：不可为GPU所用，并且在初次使用的布局转换之前会丢弃所有纹素内容。</li><li><i><font color="Red">VK_IMAGE_LAYOUT_PREINITIALIZED</font></i>：不可为GPU所用，但是在初次使用的布局转换之前会保存所有纹素内容。</li></ul><p>事实上，很少有情况需要我们在第一次布局转换之前保留纹素内容，不过也并没没有这种情况：比如我们使用临时图像传递图像数据，在将临时图像布局转换为适用于传递源的布局之前我们当然需要保留图像中复制而来的像素数据。不过在我们的应用程序中，我们将图像对象用作传输目的地，我们并不关心在接受临时缓冲里的图像数据之前该图像对象纹素中的内容是什么，因此我们应该将其初始布局设置为<i><font color="Red">VK_IMAGE_LAYOUT_UNDEFINED</font></i>。</p><p>于是创建我们所需要的纹理对象相应代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkImage textureImage;<br>VkDeviceMemory textureImageMemory;<br><br>VkImageCreateInfo imageInfo&#123;&#125;;<br>imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;<br>imageInfo.imageType = VK_IMAGE_TYPE_2D;<br>imageInfo.extent.width = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(texWidth);<br>imageInfo.extent.height = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(texHeight);<br>imageInfo.extent.depth = <span class="hljs-number">1</span>;<br>imageInfo.mipLevels = <span class="hljs-number">1</span>;<br>imageInfo.arrayLayers = <span class="hljs-number">1</span>;<br>imageInfo.format = VK_FORMAT_R8G8B8A8_SRGB;<br>imageInfo.tiling = VK_IMAGE_TILING_OPTIMAL;<br>imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;<br>imageInfo.usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;<br>imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;<br>imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateImage</span>(device, &amp;imageInfo, <span class="hljs-literal">nullptr</span>, &amp;textureImage) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create image!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们需要为创建好的图像分配内存，为图像分配内存的过程和为缓冲对象分配内存几乎一致，不熟悉的读者可以参考<a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/">创建顶点缓冲</a>章节有关内容。我们这里直接给出分配纹理内存的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkMemoryRequirements memRequirements;<br><span class="hljs-built_in">vkGetImageMemoryRequirements</span>(device, textureImage, &amp;memRequirements);<br><br>VkMemoryAllocateInfo allocInfo&#123;&#125;;<br>allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;<br>allocInfo.allocationSize = memRequirements.size;<br>allocInfo.memoryTypeIndex = <span class="hljs-built_in">findMemoryType</span>(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkAllocateMemory</span>(device, &amp;allocInfo, <span class="hljs-literal">nullptr</span>, &amp;textureImageMemory) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to allocate image memory!&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">vkBindImageMemory</span>(device, textureImage, textureImageMemory, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>终于完成了对图像对象的创建和分配内存操作。不过此时<i><font color="Green">createTextureImage</font></i>函数已经变得比较臃肿了，我们可以将其中创建图像和分配内存的代码放到一个新的工具函数<i><font color="Green">voidcreateImage(uint32_t width, uint32_t height, VkFormat format,VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlagsproperties, VkImage&amp; image, VkDeviceMemory&amp;imageMemory)</font></i>中来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createImage</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> width, <span class="hljs-type">uint32_t</span> height, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage&amp; image, VkDeviceMemory&amp; imageMemory)</span> </span>&#123;<br>    VkImageCreateInfo imageInfo&#123;&#125;;<br>    imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;<br>    imageInfo.imageType = VK_IMAGE_TYPE_2D;<br>    imageInfo.extent.width = width;<br>    imageInfo.extent.height = height;<br>    imageInfo.extent.depth = <span class="hljs-number">1</span>;<br>    imageInfo.mipLevels = <span class="hljs-number">1</span>;<br>    imageInfo.arrayLayers = <span class="hljs-number">1</span>;<br>    imageInfo.format = format;<br>    imageInfo.tiling = tiling;<br>    imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;<br>    imageInfo.usage = usage;<br>    imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;<br>    imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateImage</span>(device, &amp;imageInfo, <span class="hljs-literal">nullptr</span>, &amp;image) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create image!&quot;</span>);<br>    &#125;<br><br>    VkMemoryRequirements memRequirements;<br>    <span class="hljs-built_in">vkGetImageMemoryRequirements</span>(device, image, &amp;memRequirements);<br><br>    VkMemoryAllocateInfo allocInfo&#123;&#125;;<br>    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;<br>    allocInfo.allocationSize = memRequirements.size;<br>    allocInfo.memoryTypeIndex = <span class="hljs-built_in">findMemoryType</span>(memRequirements.memoryTypeBits, properties);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkAllocateMemory</span>(device, &amp;allocInfo, <span class="hljs-literal">nullptr</span>, &amp;imageMemory) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to allocate image memory!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">vkBindImageMemory</span>(device, image, imageMemory, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样<i><font color="Green">createTextureImage</font></i>函数就可以简化为以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createTextureImage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> texWidth, texHeight, texChannels;<br>    stbi_uc* pixels = <span class="hljs-built_in">stbi_load</span>(<span class="hljs-string">&quot;textures/texture.jpg&quot;</span>, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);<br>    VkDeviceSize imageSize = texWidth * texHeight * <span class="hljs-number">4</span>;<br><br>    <span class="hljs-keyword">if</span> (!pixels) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to load texture image!&quot;</span>);<br>    &#125;<br><br>    VkBuffer stagingBuffer;<br>    VkDeviceMemory stagingBufferMemory;<br>    <span class="hljs-built_in">createBuffer</span>(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);<br><br>    <span class="hljs-type">void</span>* data;<br>    <span class="hljs-built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="hljs-number">0</span>, imageSize, <span class="hljs-number">0</span>, &amp;data);<br>        <span class="hljs-built_in">memcpy</span>(data, pixels, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(imageSize));<br>    <span class="hljs-built_in">vkUnmapMemory</span>(device, stagingBufferMemory);<br><br>    <span class="hljs-built_in">stbi_image_free</span>(pixels);<br><br>    <span class="hljs-built_in">createImage</span>(texWidth, texHeight, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="布局转换">布局转换</h2><p>在创建好图像对象以及分配好相应的内存之后，我们接下来要做的就是将临时缓冲中的数据复制到图像对象中来。但是在复制之前，我们首先需要调整图像对象的布局以使其能够作为复制操作的目的地。</p><p>要实现布局的转换，我们同样需要将相应的命令提交到队列中执行。因此我们需要首先录制执行转换的命令。如今我们的程序中已经有多处需要用到命令缓冲了，因此不妨将相应代码提取出来重构成两个新的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkCommandBuffer <span class="hljs-title">beginSingleTimeCommands</span><span class="hljs-params">()</span> </span>&#123;<br>    VkCommandBufferAllocateInfo allocInfo&#123;&#125;;<br>    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;<br>    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;<br>    allocInfo.commandPool = commandPool;<br>    allocInfo.commandBufferCount = <span class="hljs-number">1</span>;<br><br>    VkCommandBuffer commandBuffer;<br>    <span class="hljs-built_in">vkAllocateCommandBuffers</span>(device, &amp;allocInfo, &amp;commandBuffer);<br><br>    VkCommandBufferBeginInfo beginInfo&#123;&#125;;<br>    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;<br>    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;<br><br>    <span class="hljs-built_in">vkBeginCommandBuffer</span>(commandBuffer, &amp;beginInfo);<br><br>    <span class="hljs-keyword">return</span> commandBuffer;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">endSingleTimeCommands</span><span class="hljs-params">(VkCommandBuffer commandBuffer)</span> </span>&#123;<br>    <span class="hljs-built_in">vkEndCommandBuffer</span>(commandBuffer);<br><br>    VkSubmitInfo submitInfo&#123;&#125;;<br>    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;<br>    submitInfo.commandBufferCount = <span class="hljs-number">1</span>;<br>    submitInfo.pCommandBuffers = &amp;commandBuffer;<br><br>    <span class="hljs-built_in">vkQueueSubmit</span>(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, VK_NULL_HANDLE);<br>    <span class="hljs-built_in">vkQueueWaitIdle</span>(graphicsQueue);<br><br>    <span class="hljs-built_in">vkFreeCommandBuffers</span>(device, commandPool, <span class="hljs-number">1</span>, &amp;commandBuffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>这些代码是从<i><font color="Green">copyBuffer</font></i>函数中提取出来的，这样<i><font color="Green">copyBuffer</font></i>函数就可以简化为以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copyBuffer</span><span class="hljs-params">(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size)</span> </span>&#123;<br>    VkCommandBuffer commandBuffer = <span class="hljs-built_in">beginSingleTimeCommands</span>();<br><br>    VkBufferCopy copyRegion&#123;&#125;;<br>    copyRegion.size = size;<br>    <span class="hljs-built_in">vkCmdCopyBuffer</span>(commandBuffer, srcBuffer, dstBuffer, <span class="hljs-number">1</span>, &amp;copyRegion);<br><br>    <span class="hljs-built_in">endSingleTimeCommands</span>(commandBuffer<br></code></pre></td></tr></table></figure><p>现在，我们创建一个<i><font color="Green">voidtransitionImageLayout(VkImage image, VkFormat format, VkImageLayoutoldLayout, VkImageLayoutnewLayout)</font></i>函数来完成布局转换相应的工作。我们将使用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageMemoryBarrier.html"><code>VkImageMemoryBarrier</code></a>（管线屏障的一种）来完成图像布局转换前后的同步操作。<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageMemoryBarrier.html"><code>VkImageMemoryBarrier</code></a>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkImageMemoryBarrier</span> &#123;</span><br>    VkStructureType            sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                pNext;<br>    VkAccessFlags              srcAccessMask;<br>    VkAccessFlags              dstAccessMask;<br>    VkImageLayout              oldLayout;<br>    VkImageLayout              newLayout;<br>    <span class="hljs-type">uint32_t</span>                   srcQueueFamilyIndex;<br>    <span class="hljs-type">uint32_t</span>                   dstQueueFamilyIndex;<br>    VkImage                    image;<br>    VkImageSubresourceRange    subresourceRange;<br>&#125; VkImageMemoryBarrier;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">srcAccessMask</font></i>和<i><font color="Orange">dstAccessMask</font></i>分别指定栅栏前需要完成的操作和栅栏后等待前述操作完成的操作，可能的取值可以参考<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/VkAccessFlagBits.html">这个页面</a>。</p><p><i><font color="Orange">srcQueueFamilyIndex</font></i>和<i><font color="Orange">dstQueueFamilyIndex</font></i>分别指定图像归属权转移操作中的源队列和目标队列。在这里我们并不会将该管线屏障用于图像归属权转移操作，但是这两个成员的默认值并不是屏蔽该用法，因此我们仍然需要赋予这两个成员<i><font color="Red">VK_QUEUE_FAMILY_IGNORED</font></i>以显式指定我们不进行队列间归属转移。</p><p><i><font color="Orange">subresourceRange</font></i>用于指定图像中被该屏障影响的部分。<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/VkImageSubresourceRange.html"><code>VkImageSubresourceRange</code></a>结构体的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkImageSubresourceRange</span> &#123;</span><br>    VkImageAspectFlags    aspectMask;<span class="hljs-comment">//图像的哪个方面（颜色、深度、模板等）会被影响</span><br>    <span class="hljs-type">uint32_t</span>              baseMipLevel;<span class="hljs-comment">//从哪个渐远层级开始被影响</span><br>    <span class="hljs-type">uint32_t</span>              levelCount;<span class="hljs-comment">//被影响的层级数</span><br>    <span class="hljs-type">uint32_t</span>              baseArrayLayer;<span class="hljs-comment">//从哪个图层开始被影响</span><br>    <span class="hljs-type">uint32_t</span>              layerCount;<span class="hljs-comment">//被影响的图像层数</span><br>&#125; VkImageSubresourceRange;<br></code></pre></td></tr></table></figure><p>随着我们程序的复杂化，我们可能需要处理多种不同类型的布局转换。就目前而言，我们需要处理的转换有两个：</p><ul><li>由最初的布局转换为数据传输目标布局</li><li>由传输目标布局转化为适合着色器读写布局</li></ul><p>于是在这两种转换中，填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageMemoryBarrier.html"><code>VkImageMemoryBarrier</code></a>结构体过程中唯一的不同就是对<i><font color="Orange">srcAccessMask</font></i>和<i><font color="Orange">dstAccessMask</font></i>的指定。对于从最初的布局到数据传输目标布局的转换，我们并不需要在复制数据到图像对象之前等待什么特别的操作先完成，于是<i><font color="Orange">srcAccessMask</font></i>直接填写为0即可。而<i><font color="Orange">dstAccessMask</font></i>显然应该指定为我们的复制写入操作，因此将其设置为<i><font color="Red">VK_ACCESS_TRANSFER_WRITE_BIT</font></i>比较合理。在成功复制数据之后，图像将供后续着色器读取纹理用，此时我们应该对其进行第二次的转换，即将其布局转换为适合着色器读取的布局。在进行这个转换时我们应该在转换前等待完成的操作是数据的写入操作，因为我们不希望在数据还未完全写入的时候就开始对图像进行转换操作，因此此时<i><font color="Orange">srcAccessMask</font></i>应该为<i><font color="Red">VK_ACCESS_TRANSFER_WRITE_BIT</font></i>，而<i><font color="Orange">dstAccessMask</font></i>应该为<i><font color="Red">VK_ACCESS_SHADER_READ_BIT</font></i>，因为后续着色器读取数据需要等待数据的填充完成之后才能进行。</p><p>在填写好这个信息结构体之后，我们需要使用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPipelineBarrier.html"><code>vkCmdPipelineBarrier</code></a>函数来完成管线屏障的提交工作，提交后队列会处理屏障所保障的布局转换操作。该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdPipelineBarrier</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    VkPipelineStageFlags                        srcStageMask,</span><br><span class="hljs-params">    VkPipelineStageFlags                        dstStageMask,</span><br><span class="hljs-params">    VkDependencyFlags                           dependencyFlags,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    memoryBarrierCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkMemoryBarrier*                      pMemoryBarriers,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    bufferMemoryBarrierCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkBufferMemoryBarrier*                pBufferMemoryBarriers,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    imageMemoryBarrierCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkImageMemoryBarrier*                 pImageMemoryBarriers)</span>;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">srcStageMask</font></i>和<i><font color="Orange">dstStageMask</font></i>分别指定屏障前需要完成的管线阶段和屏障后需要等待的管线阶段，这和之前在填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageMemoryBarrier.html"><code>VkImageMemoryBarrier</code></a>结构体中设置的<i><font color="Orange">srcAccessMask</font></i>和<i><font color="Orange">dstAccessMask</font></i>是相互对应的。在第一次转换中，我们无需等待任何操作，因此<i><font color="Orange">srcStageMask</font></i>可以直接设置为<i><font color="Red">VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</font></i>，而处于等待状态的操作是写入操作，因此<i><font color="Orange">dstStageMask</font></i>应该指定为<i><font color="Red">VK_PIPELINE_STAGE_TRANSFER_BIT</font></i>。不过这里注意，<i><font color="Red">VK_PIPELINE_STAGE_TRANSFER_BIT</font></i>实际上并不是一个真正存在的管线阶段，我们称其为一个<strong>伪阶段</strong>，它们是一种逻辑上存在的阶段，用于描述一些逻辑上的操作，阶段发生时间并不是固定的。<a href="https://docs.vulkan.org/spec/latest/chapters/synchronization.html#VkPipelineStageFlagBits">这个页面</a>有更多关于Vulkan中的伪阶段的信息。</p><p>接下来的<i><font color="Orange">dependencyFlags</font></i>用于指定执行和内存上的一些依赖关系。它可能的取值如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDependencyFlagBits</span> &#123;</span><br>    VK_DEPENDENCY_BY_REGION_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//当一个命令依赖于另一个命令的执行时，如果使用该标志，表示只需在依赖的区域内进行同步，而不是整个资源。这可以提高性能，因为只需同步必要的部分</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_DEPENDENCY_DEVICE_GROUP_BIT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//在多视图渲染中，该标志指示依赖关系仅适用于特定的视图。这意味着资源的访问和修改仅限于特定的视图，其他视图不受影响</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_DEPENDENCY_VIEW_LOCAL_BIT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//在使用多个 GPU 的情况下，该标志指示依赖关系涉及设备组中的多个设备。这有助于在多个设备之间管理资源的访问和同步，确保数据一致性</span><br>  <span class="hljs-comment">// Provided by VK_EXT_attachment_feedback_loop_layout</span><br>    VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//在某些渲染场景中，可能存在反馈循环（如图像处理），该标志指示依赖关系与这种反馈循环相关。使用该标志可以确保在处理反馈循环时适当地管理资源的依赖关系</span><br>  <span class="hljs-comment">// Provided by VK_KHR_multiview</span><br>    VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = VK_DEPENDENCY_VIEW_LOCAL_BIT,<br>  <span class="hljs-comment">// Provided by VK_KHR_device_group</span><br>    VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = VK_DEPENDENCY_DEVICE_GROUP_BIT,<br>&#125; VkDependencyFlagBits;<br></code></pre></td></tr></table></figure><p>接下来的六个成员分别对应三种不同的管线屏障。我们需要使用的是图像内存屏障，因此只需填写最后两个成员即可。</p><p>于是当前我们的<i><font color="Green">transitionImageLayout</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transitionImageLayout</span><span class="hljs-params">(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout)</span> </span>&#123;<br>    VkCommandBuffer commandBuffer = <span class="hljs-built_in">beginSingleTimeCommands</span>();<br><br>    VkImageMemoryBarrier barrier&#123;&#125;;<br>    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;<br>    barrier.oldLayout = oldLayout;<br>    barrier.newLayout = newLayout;<br>    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;<br>    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;<br>    barrier.image = image;<br>    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br>    barrier.subresourceRange.baseMipLevel = <span class="hljs-number">0</span>;<br>    barrier.subresourceRange.levelCount = <span class="hljs-number">1</span>;<br>    barrier.subresourceRange.baseArrayLayer = <span class="hljs-number">0</span>;<br>    barrier.subresourceRange.layerCount = <span class="hljs-number">1</span>;<br><br>    VkPipelineStageFlags sourceStage;<br>    VkPipelineStageFlags destinationStage;<br><br>    <span class="hljs-keyword">if</span> (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) &#123;<br>        barrier.srcAccessMask = <span class="hljs-number">0</span>;<br>        barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;<br><br>        sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;<br>        destinationStage = VK_PIPELINE_STAGE_TRANSFER_BIT;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL &amp;&amp; newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) &#123;<br>        barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;<br>        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;<br><br>        sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT;<br>        destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;unsupported layout transition!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">vkCmdPipelineBarrier</span>(<br>        commandBuffer,<br>        sourceStage, destinationStage,<br>        <span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>        <span class="hljs-number">1</span>, &amp;barrier<br>    );<br><br>    <span class="hljs-built_in">endSingleTimeCommands</span>(commandBuffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就完成了图像布局转换有关的工作。</p><hr><h2 id="复制数据到纹理">复制数据到纹理</h2><p>图像完成第一次布局转换后，我们就可以将临时缓冲中的数据复制到图像对象中来了。同样创建一个<i><font color="Green">voidcopyBufferToImage(VkBuffer buffer, VkImage image, uint32_t width,uint32_t height)</font></i>函数来完成相应的工作。</p><p>如同<a href="https://zpc-dsg.github.io/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/">临时缓冲区</a>章节中复制缓冲区到缓冲区时需要填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferCopy.html"><code>VkBufferCopy</code></a>结构体以指定复制区域，从缓冲区复制到图像同样需要指定复制区域和接收复制数据的图像区域，这是通过结构体<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferImageCopy.html"><code>VkBufferImageCopy</code></a>来指定的，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkBufferImageCopy</span> &#123;</span><br>    VkDeviceSize                bufferOffset;<br>    <span class="hljs-type">uint32_t</span>                    bufferRowLength;<br>    <span class="hljs-type">uint32_t</span>                    bufferImageHeight;<br>    VkImageSubresourceLayers    imageSubresource;<br>    VkOffset3D                  imageOffset;<br>    VkExtent3D                  imageExtent;<br>&#125; VkBufferImageCopy;<br></code></pre></td></tr></table></figure><p>大多数的成员含义是显而易见的，这里需要解释一下的是<i><font color="Orange">bufferRowLength</font></i>和<i><font color="Orange">bufferImageHeight</font></i>，这两个成员如果设置为非0值，则分别代表缓冲区的图像数据行宽度、列高度超过了实际图像每一行、每一列的像素数，这在处理图像填充或多层次图像时会比较有用。如果二者均设置为0，则代表不会有多余的填充，图像像素是紧密排列的。</p><p>于是我们填写该结构体的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkBufferImageCopy region&#123;&#125;;<br>region.bufferOffset = <span class="hljs-number">0</span>;<br>region.bufferRowLength = <span class="hljs-number">0</span>;<br>region.bufferImageHeight = <span class="hljs-number">0</span>;<br><br>region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br>region.imageSubresource.mipLevel = <span class="hljs-number">0</span>;<br>region.imageSubresource.baseArrayLayer = <span class="hljs-number">0</span>;<br>region.imageSubresource.layerCount = <span class="hljs-number">1</span>;<br><br>region.imageOffset = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>region.imageExtent = &#123;<br>    width,<br>    height,<br>    <span class="hljs-number">1</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>接下来就可以使用<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/vkCmdCopyBufferToImage.html"><code>vkCmdCopyBufferToImage</code></a>来录制图像数据的复制命令了，该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdCopyBufferToImage</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    VkBuffer                                    srcBuffer,</span><br><span class="hljs-params">    VkImage                                     dstImage,</span><br><span class="hljs-params">    VkImageLayout                               dstImageLayout,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    regionCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkBufferImageCopy*                    pRegions)</span>;<br></code></pre></td></tr></table></figure><p>这些参数的含义都是显而易见的。需要注意一下的是该函数原型的最后两个参数提示我们实际上可以同时将一个缓冲区的数据复制到图像的多个子区域上，不过这里我们并不需要，只需要复制完整的图像数据即可。</p><p>于是我们的<i><font color="Green">copyBufferToImage</font></i>函数代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">copyBufferToImage</span><span class="hljs-params">(VkBuffer buffer, VkImage image, <span class="hljs-type">uint32_t</span> width, <span class="hljs-type">uint32_t</span> height)</span> &#123;<br>    VkCommandBuffer commandBuffer = beginSingleTimeCommands();<br><br>    VkBufferImageCopy region&#123;&#125;;<br>    region.bufferOffset = <span class="hljs-number">0</span>;<br>    region.bufferRowLength = <span class="hljs-number">0</span>;<br>    region.bufferImageHeight = <span class="hljs-number">0</span>;<br>    region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br>    region.imageSubresource.mipLevel = <span class="hljs-number">0</span>;<br>    region.imageSubresource.baseArrayLayer = <span class="hljs-number">0</span>;<br>    region.imageSubresource.layerCount = <span class="hljs-number">1</span>;<br>    region.imageOffset = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    region.imageExtent = &#123;<br>        width,<br>        height,<br>        <span class="hljs-number">1</span><br>    &#125;;<br><br>    vkCmdCopyBufferToImage(commandBuffer, buffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, <span class="hljs-number">1</span>, &amp;region);<br><br>    endSingleTimeCommands(commandBuffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就准备好了构建着色器所需纹理的所有准备工作，利用这些工具函数我们终于可以完成<i><font color="Green">createTextureImage</font></i>函数了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createTextureImage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> texWidth, texHeight, texChannels;<br>    stbi_uc* pixels = <span class="hljs-built_in">stbi_load</span>(<span class="hljs-string">&quot;textures/texture.jpg&quot;</span>, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);<br>    VkDeviceSize imageSize = texWidth * texHeight * <span class="hljs-number">4</span>;<br><br>    <span class="hljs-keyword">if</span> (!pixels) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to load texture image!&quot;</span>);<br>    &#125;<br><br>    VkBuffer stagingBuffer;<br>    VkDeviceMemory stagingBufferMemory;<br>    <span class="hljs-built_in">createBuffer</span>(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);<br><br>    <span class="hljs-type">void</span>* data;<br>    <span class="hljs-built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="hljs-number">0</span>, imageSize, <span class="hljs-number">0</span>, &amp;data);<br>    <span class="hljs-built_in">memcpy</span>(data, pixels, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(imageSize));<br>    <span class="hljs-built_in">vkUnmapMemory</span>(device, stagingBufferMemory);<br><br>    <span class="hljs-built_in">stbi_image_free</span>(pixels);<br><br>    <span class="hljs-built_in">createImage</span>(texWidth, texHeight, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);<br><br>    <span class="hljs-built_in">transitionImageLayout</span>(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);<br>    <span class="hljs-built_in">copyBufferToImage</span>(stagingBuffer, textureImage, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(texWidth), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(texHeight));<br>    <span class="hljs-built_in">transitionImageLayout</span>(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);<br><br>    <span class="hljs-built_in">vkDestroyBuffer</span>(device, stagingBuffer, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">vkFreeMemory</span>(device, stagingBufferMemory, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/12/06/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B1%A0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86/">上一篇：描述符池和描述符集</a></p><p>--<a href="https://zpc-dsg.github.io/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/">下一篇：图像视图和采样器</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>描述符池和描述符集</title>
    <link href="/2024/12/06/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B1%A0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86/"/>
    <url>/2024/12/06/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B1%A0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>本章我们将创建包含统一缓冲的描述符集。主要过程分三步</p><ul><li>创建描述符池</li><li>创建描述符集</li><li>使用并绑定描述符集</li></ul><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Uniform_buffers/Descriptor_pool_and_sets#page_Multiple-descriptor-sets">Descriptorpool and sets</a>章节。</p><hr><h2 id="创建描述符池">创建描述符池</h2><p>如同命令缓冲需要从命令池中分配，描述符集也需要从描述符池中分配，不过不同的是，一个描述符池中可以分配多种描述符，但是一个命令池中只能分配提交给一种队列家族的命令缓冲。创建描述符池同样需要填写相应信息结构体<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolCreateInfo.html"><code>VkDescriptorPoolCreateInfo</code></a>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDescriptorPoolCreateInfo</span> &#123;</span><br>    VkStructureType                sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                    pNext;<br>    VkDescriptorPoolCreateFlags    flags;<br>    <span class="hljs-type">uint32_t</span>                       maxSets;<span class="hljs-comment">//最多分配的描述符集个数</span><br>    <span class="hljs-type">uint32_t</span>                       poolSizeCount;<br>    <span class="hljs-type">const</span> VkDescriptorPoolSize*    pPoolSizes;<br>&#125; VkDescriptorPoolCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>可能的取值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDescriptorPoolCreateFlagBits</span> &#123;</span><br>    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//允许在描述符池中自由释放描述符集。这意味着当一个描述符集不再使用时，可以将其释放回池中，而不需要在分配时保持特定的顺序</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//允许在绑定描述符集后更新描述符集引用的资源。使用此标志时，应用程序可以在描述符集绑定后对其进行更新，而不需要重新分配描述符集</span><br>  <span class="hljs-comment">// Provided by VK_EXT_mutable_descriptor_type</span><br>    VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//此标志指示描述符池仅用于主机访问的资源。这意味着该描述符池中的资源不会被分配给设备（GPU），而是仅在主机（CPU）上使用</span><br>  <span class="hljs-comment">// Provided by VK_NV_descriptor_pool_overallocation</span><br>    VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//允许描述符池的描述符集超分配。这意味着可以分配比池中实际可用的描述符更多的描述符集</span><br>  <span class="hljs-comment">// Provided by VK_NV_descriptor_pool_overallocation</span><br>    VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV = <span class="hljs-number">0x00000010</span>,<span class="hljs-comment">//允许描述符池本身超分配。这意味着可以创建一个描述符池，其中的描述符数量超过了实际分配的数量</span><br>  <span class="hljs-comment">// Provided by VK_EXT_descriptor_indexing</span><br>    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,<br>  <span class="hljs-comment">// Provided by VK_VALVE_mutable_descriptor_type</span><br>    VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE = VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT,<br>&#125; VkDescriptorPoolCreateFlagBits;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">poolSizeCount</font></i>指定池中子池的个数，每个子池只包含一种描述符集。<i><font color="Orange">pPoolSizes</font></i>指定实际的子池信息，其类型为<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolSize.html"><code>VkDescriptorPoolSize</code></a>结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDescriptorPoolSize</span> &#123;</span><br>    VkDescriptorType    type;<br>    <span class="hljs-type">uint32_t</span>            descriptorCount;<br>&#125; VkDescriptorPoolSize;<br></code></pre></td></tr></table></figure><p>成员含义都非常好理解。</p><p>我们需要给每帧分配一个不同的描述符，因此我们需要在类内添加一个<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPool.html"><code>VkDescriptorPool</code></a>类型成员，然后创建一个<i><font color="Green">voidcreateDescriptorPool()</font></i>成员函数来进行创建工作。将该函数置于<i><font color="Green">createUniformBuffers()</font></i>函数后，其代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createDescriptorPool</span><span class="hljs-params">()</span> </span>&#123;<br>VkDescriptorPoolSize poolSize&#123;&#125;;<br>poolSize.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;<br>poolSize.descriptorCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(MAX_FRAMES_IN_FLIGHT);<br><br>VkDescriptorPoolCreateInfo poolInfo&#123;&#125;;<br>poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;<br>poolInfo.poolSizeCount = <span class="hljs-number">1</span>;<br>poolInfo.pPoolSizes = &amp;poolSize;<br>poolInfo.maxSets = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(MAX_FRAMES_IN_FLIGHT);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateDescriptorPool</span>(device, &amp;poolInfo, <span class="hljs-literal">nullptr</span>, &amp;descriptorPool) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create descriptor pool!&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="创建描述符集">创建描述符集</h2><p>在创建好描述符池后，我们就可以从中分配描述符集了。在类内新添成员<i><font color="Orange">std::vector<VkDescriptorSet>descriptorSets</VkDescriptorSet></font></i>用于保存分配的描述符集，并且创建<i><font color="Green">voidcreateDescriptorSets()</font></i>函数来进行分配工作。</p><p>分配描述符集需要填写信息结构体<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetAllocateInfo.html"><code>VkDescriptorSetAllocateInfo</code></a>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDescriptorSetAllocateInfo</span> &#123;</span><br>    VkStructureType                 sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                     pNext;<br>    VkDescriptorPool                descriptorPool;<br>    <span class="hljs-type">uint32_t</span>                        descriptorSetCount;<br>    <span class="hljs-type">const</span> VkDescriptorSetLayout*    pSetLayouts;<br>&#125; VkDescriptorSetAllocateInfo;<br></code></pre></td></tr></table></figure><p>每个成员都是易于理解的。需要注意的是在分配描述符集的时候我们需要对每个分配的描述符集都指定其相应的描述符布局。分配描述符集代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;VkDescriptorSetLayout&gt; <span class="hljs-title">layouts</span><span class="hljs-params">(MAX_FRAMES_IN_FLIGHT, descriptorSetLayout)</span></span>;<br>VkDescriptorSetAllocateInfo allocInfo&#123;&#125;;<br>allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;<br>allocInfo.descriptorPool = descriptorPool;<br>allocInfo.descriptorSetCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(MAX_FRAMES_IN_FLIGHT);<br>allocInfo.pSetLayouts = layouts.<span class="hljs-built_in">data</span>();<br><br>descriptorSets.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkAllocateDescriptorSets</span>(device, &amp;allocInfo, descriptorSets.<span class="hljs-built_in">data</span>()) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to allocate descriptor sets!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意我们不需要在<i><font color="Green">cleanUp</font></i>函数中清理分配的描述符集，因为清理描述符池会自动清理掉其中分配的描述符集。</p><p>仅仅分配好描述符集是不够的。为了能够使用这些描述符集我们还需要指定这些描述符集引用的资源以及是如何更新这些资源的。我们需要指定的描述符资源是统一缓冲，于是我们需要为每个描述符填写<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/VkWriteDescriptorSet.html"><code>VkDescriptorBufferInfo</code></a>来指定这些描述符各自对应的资源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123;<br>    VkDescriptorBufferInfo bufferInfo&#123;&#125;;<br>    bufferInfo.buffer = uniformBuffers[i];<br>    bufferInfo.offset = <span class="hljs-number">0</span>;<br>    bufferInfo.range = <span class="hljs-built_in">sizeof</span>(UniformBufferObject);<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们需要指定怎么更新描述符集。可以指定的更新方式有两种：写入和复制。我们这里只需要填写写入方式，它使用<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/VkWriteDescriptorSet.html"><code>VkWriteDescriptorSet</code></a>结构体来指定，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkWriteDescriptorSet</span> &#123;</span><br>    VkStructureType                  sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                      pNext;<br>    VkDescriptorSet                  dstSet;<br>    <span class="hljs-type">uint32_t</span>                         dstBinding;<br>    <span class="hljs-type">uint32_t</span>                         dstArrayElement;<br>    <span class="hljs-type">uint32_t</span>                         descriptorCount;<br>    VkDescriptorType                 descriptorType;<br>    <span class="hljs-type">const</span> VkDescriptorImageInfo*     pImageInfo;<br>    <span class="hljs-type">const</span> VkDescriptorBufferInfo*    pBufferInfo;<br>    <span class="hljs-type">const</span> VkBufferView*              pTexelBufferView;<br>&#125; VkWriteDescriptorSet;<br></code></pre></td></tr></table></figure><p>每个成员都是易于理解的。我们这里指定的资源是统一缓冲，所以最后三个成员只需填写<i><font color="Orange">pBufferInfo</font></i>即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkWriteDescriptorSet descriptorWrite&#123;&#125;;<br>descriptorWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;<br>descriptorWrite.dstSet = descriptorSets[i];<br>descriptorWrite.dstBinding = <span class="hljs-number">0</span>;<br>descriptorWrite.dstArrayElement = <span class="hljs-number">0</span>;<br>descriptorWrite.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;<br>descriptorWrite.descriptorCount = <span class="hljs-number">1</span>;<br>descriptorWrite.pBufferInfo = &amp;bufferInfo;<br></code></pre></td></tr></table></figure><p>最后，我们使用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateDescriptorSets.html"><code>vkUpdateDescriptorSets</code></a>来更新描述符集：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkUpdateDescriptorSets</span>(device, <span class="hljs-number">1</span>, &amp;descriptorWrite, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br></code></pre></td></tr></table></figure><p>可以看出我们可以使用一个该命令同时更新多个描述符集，并且还可以指定两种更新方式。这里我们只指定了写入更新，未指定复制更新，所以后两个成员保持默认。</p><p>由于在我们当前的应用程序中，我们在运行时不需要更新描述符集绑定的资源，每个描述符集从头到尾使用的都是同一个统一缓冲，因此这里我们在<i><font color="Green">initVulkan</font></i>中就直接指定好了资源及更新方式。如果需要每帧更新描述符集引用的资源的话，我们就需要在每帧录制命令的时候指定引用资源及更新方式，然后再将描述符集绑定到管线上。</p><hr><h2 id="使用描述符集">使用描述符集</h2><p>在分配以及配置好描述符集之后，我们就可以在渲染管线中使用这些描述符集传递统一资源了。这只需要在录制命令中的绘制命令之前调用<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/vkCmdBindDescriptorSets.html"><code>vkCmdBindDescriptorSets</code></a>绑定描述符集即可，该函数原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdBindDescriptorSets</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    VkPipelineBindPoint                         pipelineBindPoint,</span><br><span class="hljs-params">    VkPipelineLayout                            layout,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    firstSet,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    descriptorSetCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkDescriptorSet*                      pDescriptorSets,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    dynamicOffsetCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*                             pDynamicOffsets)</span>;<br></code></pre></td></tr></table></figure></p><p>和顶点缓冲以及索引缓冲不同的是，描述符引用的资源可以用于渲染管线，也可以用于计算管线，所以在使用该函数绑定描述符集时我们需要显式指定<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineBindPoint.html"><code>VkPipelineBindPoint</code></a>。</p><p>显然，该函数原型告诉我们在绑定时我们可以使用一个命令同时绑定多个描述符集，并且我们可以在着色器中使用类似下面的语法来指定使用绑定点上的哪一个描述符集：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span>(set = <span class="hljs-number">0</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> UniformBufferObject &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>这里<strong>set</strong>对应的索引引用的描述符集就是<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/vkCmdBindDescriptorSets.html"><code>vkCmdBindDescriptorSets</code></a>命令中按照绑定顺序对应索引的描述符集。不过需要注意的是，如果在一次录制命令中调用多次<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/vkCmdBindDescriptorSets.html"><code>vkCmdBindDescriptorSets</code></a>，那么最后的调用中位于同一绑定点<strong>binding</strong>的描述符集会覆盖前几次调用在这个绑定点绑定的描述符集，当然，如果几次调用中描述符集对应的绑定点不重合，那么不会发生覆盖现象。</p><p>于是在录制命令函数<i><font color="Green">recordCommandBuffer</font></i>中的绘制命令<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexed.html"><code>vkCmdDrawIndexed</code></a>前添加上绑定统一缓冲的代码即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdBindDescriptorSets</span>(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;descriptorSets[currentFrame], <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br><span class="hljs-built_in">vkCmdDrawIndexed</span>(commandBuffer, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(indices.<span class="hljs-built_in">size</span>()), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>但是事实上此时我们运行应用程序会发现屏幕全黑，这是因为我们在之前为了图像上下方向的正确性翻转了y轴坐标，但是这同时也使得面片的正反方向对调了一下，于是之前我们设置的面剔除此时剔除了四边形的正面！所以为了得到正确的图像，我们应该将管线布局中光栅化阶段的面剔除方向设置为<i><font color="Red">VK_CULL_MODE_FRONT_BIT</font></i>或者将正面定义为<i><font color="Red">VK_FRONT_FACE_COUNTER_CLOCKWISE</font></i>。（有关面片的正面背面是怎么定义的，以及面剔除有关介绍，可以参考<a href="https://learnopengl.com/Advanced-OpenGL/Face-culling">这篇文章</a>。</p><p>现在我们就可以显示出正确的图像了！</p><figure><img src="/2024/12/06/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B1%A0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86/rectangle.png" alt="旋转四边形"><figcaption aria-hidden="true">旋转四边形</figcaption></figure><hr><h2 id="对齐要求">对齐要求</h2><p>最后我们其实还有一部分重要但较为隐晦的内容没有说明，那就是c++中的结构和着色器中对应的结构之间的数据匹配对齐问题。</p><p>事实上，Vulkan希望程序自定义的结构体中的成员能够按照某种特定的方式对齐，具体而言主要有以下几条：</p><ul><li>标量按N字节对齐（如果是32位浮点数那么N就是4）</li><li><strong>vec2</strong>按2N对齐</li><li><strong>vec3</strong>和<strong>vec4</strong>按4N对齐</li><li><strong>mat4</strong>对齐方式和<strong>vec4</strong>一致</li><li>内嵌结构体必须按照它成员的基础对齐（调整到16的倍数）对齐</li></ul><p>在<a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-resources-layout">这里</a>可以找到完整的对齐要求。</p><p>在我们的程序中，回忆一下我们对统一缓冲数据结构体以及着色器中相应结构体的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UniformBufferObject</span> &#123;<br>    glm::mat4 model;<br>    glm::mat4 view;<br>    glm::mat4 proj;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> UniformBufferObject &#123;<br>    <span class="hljs-type">mat4</span> model;<br>    <span class="hljs-type">mat4</span> view;<br>    <span class="hljs-type">mat4</span> proj;<br>&#125; ubo;<br></code></pre></td></tr></table></figure><p>即使我们不刻意调整对齐，它们也能完美符合要求，因为一开始成员<i><font color="Orange">model</font></i>的偏移为0，而一个<strong>mat4</strong>变量是64字节，因此成员<i><font color="Orange">view</font></i>成员的偏移是64字节，是16的整数倍，<i><font color="Orange">proj</font></i>同理，因此不会出现什么问题。</p><p>但是，如果我们改变一下这个结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UniformBufferObject</span> &#123;<br>    glm::vec2 foo;<br>    glm::mat4 model;<br>    glm::mat4 view;<br>    glm::mat4 proj;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> UniformBufferObject &#123;<br>    <span class="hljs-type">vec2</span> foo;<br>    <span class="hljs-type">mat4</span> model;<br>    <span class="hljs-type">mat4</span> view;<br>    <span class="hljs-type">mat4</span> proj;<br>&#125; ubo;<br></code></pre></td></tr></table></figure><p>我们会发现屏幕又黑了！这是因为<strong>vec2</strong>变量大小8字节，因此此时<i><font color="Orange">model</font></i>的偏移为8字节，并非要求的16字节的整数倍！</p><p>当然，有多种方法来解决这个问题，一种简单粗暴的方法是直接借助GLM为我们提供的宏<i><font color="Red">GLM_FORCE_DEFAULT_ALIGNED_GENTYPES</font></i>，这样GLM就会我们提供符合对齐要求的向量和矩阵对象；另一种方式是使用c++11为我们提供的<strong>alignas</strong>标志：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UniformBufferObject</span> &#123;<br>    glm::vec2 foo;<br>    <span class="hljs-built_in">alignas</span>(<span class="hljs-number">16</span>) glm::mat4 model;<br>    glm::mat4 view;<br>    glm::mat4 proj;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在大多数情况下这两种方法都可以工作地很好，但是实际上第一种方式仍然可能会有隐藏的问题。考虑下面这种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123;<br>    glm::vec2 v;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UniformBufferObject</span> &#123;<br>    Foo f1;<br>    Foo f2;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl">struct Foo &#123;<br>    <span class="hljs-type">vec2</span> v;<br>&#125;;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> UniformBufferObject &#123;<br>    Foo f1;<br>    Foo f2;<br>&#125; ubo;<br></code></pre></td></tr></table></figure><p>这种情况下<i><font color="Orange">UniformBufferObject</font></i>结构体中<i><font color="Orange">f2</font></i>的偏移会是8，但是规范要求该结构体的对齐必须上调至16的倍数，这样还是会引发错误的结果！因此，我们还是推荐使用第二种方法，不管怎样总是显式地指定对齐总是十分稳妥的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UniformBufferObject</span> &#123;<br>    <span class="hljs-built_in">alignas</span>(<span class="hljs-number">16</span>) glm::mat4 model;<br>    <span class="hljs-built_in">alignas</span>(<span class="hljs-number">16</span>) glm::mat4 view;<br>    <span class="hljs-built_in">alignas</span>(<span class="hljs-number">16</span>) glm::mat4 proj;<br>&#125;;<br></code></pre></td></tr></table></figure><p>终于大功告成！我们成功地显示出了第一个立体的图像！接下来的几章我们将开启一个新的主题：纹理映射。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/30/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%92%8C%E7%BB%9F%E4%B8%80%E7%BC%93%E5%86%B2/">上一篇：描述符布局和统一缓冲</a></p><p>--<a href="https://zpc-dsg.github.io/2024/12/12/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F/">下一篇：图像</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>描述符布局和统一缓冲</title>
    <link href="/2024/11/30/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%92%8C%E7%BB%9F%E4%B8%80%E7%BC%93%E5%86%B2/"/>
    <url>/2024/11/30/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%92%8C%E7%BB%9F%E4%B8%80%E7%BC%93%E5%86%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>当我们开始考虑更加复杂的程序功能时，比如说显示一个3D图像，我们不可避免地要在着色器中使用一些由程序传递的不断变动（甚至每一帧都可能在变动，比如MVP矩阵）的全局变量，这些变量当然不方便作为顶点缓冲的一部分传递给着色器，因为顶点缓冲的数据被设置为渲染管线的一部分，它在程序运行过程中是几乎不变动的。于是，我们需要一种新方式来传递这样一些不断变动的数据，这就是描述符。</p><p>描述符是一种帮助着色器获取并使用缓冲区、图像等数据的结构，一般而言使用描述符分为三步：</p><ul><li>在渲染管线构建过程中指定描述符布局</li><li>从描述符池中分配描述符集</li><li>在渲染的时候绑定描述符集到着色器</li></ul><p>描述符布局用于指定管线使用的资源类型有关的信息，就像渲染通道用于指定渲染管线使用的附件类型一样；同样地，描述符集用于指定实际渲染中会使用的资源（缓冲区或图像），一如帧缓冲用于指定实际绑定作为渲染附件的图像。</p><p>Vulkan包含许多种描述符，本节介绍其中的一种——<strong>统一缓冲（UBO）</strong>。本节以及下一节将开始迈向3D的世界，我们将实现一个旋转的三角形，本节内容主要分三部分：</p><ul><li>填写描述符布局以指定所用资源类型</li><li>定义实际所用的资源，即储存着色器全局变量的统一缓冲</li><li>改写着色器代码使用程序传递的缓冲数据</li></ul><p>下一节将着重于构建作为描述符布局和统一缓冲资源之间桥梁的描述符集。</p><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Uniform_buffers/Descriptor_layout_and_buffer">Descriptorlayout and buffer</a>章节。</p><hr><h2 id="填写描述符布局">填写描述符布局</h2><p>为了构建好所有管线需要的描述符布局，我们创建一个<i><font color="Green">voidcreateDescriptorSetLayout()</font></i>函数并在<i><font color="Green">initVulkan</font></i>中将其置于<i><font color="Green">createGraphicsPipeline</font></i>之前，因为我们在创建管线的时候需要使用到这些布局（通过<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkGraphicsPipelineCreateInfo.html"><code>VkGraphicsPipelineCreateInfo</code></a>的<i><font color="Orange">VkPipelineLayoutlayout</font></i>成员指定，参考<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/">渲染管线</a>章节）。</p><p>为了在渲染管线中指定描述符布局，我们需要填写相应的信息结构体<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayoutCreateInfo.html"><code>VkPipelineLayoutCreateInfo</code></a>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineLayoutCreateInfo</span> &#123;</span><br>    VkStructureType                 sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                     pNext;<br>    VkPipelineLayoutCreateFlags     flags;<br>    <span class="hljs-type">uint32_t</span>                        setLayoutCount;<br>    <span class="hljs-type">const</span> VkDescriptorSetLayout*    pSetLayouts;<br>    <span class="hljs-type">uint32_t</span>                        pushConstantRangeCount;<br>    <span class="hljs-type">const</span> VkPushConstantRange*      pPushConstantRanges;<br>&#125; VkPipelineLayoutCreateInfo;<br></code></pre></td></tr></table></figure><p>这个结构体我们曾在<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/">固定管线</a>章节中简单介绍过。由于目前我们只使用描述符，所以和<strong>pushconstant</strong>有关的成员无需填写。</p><p><i><font color="Orange">flags</font></i>可能的取值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_graphics_pipeline_library</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkPipelineLayoutCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_EXT_graphics_pipeline_library</span><br>    VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT = <span class="hljs-number">0x00000002</span>,<br>&#125; VkPipelineLayoutCreateFlagBits;<br></code></pre></td></tr></table></figure><p><i><font color="Red">VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT</font></i>要求实现确保某个特定描述符集的属性或缺失不会影响管道布局的其他属性。这意味着：</p><ul><li><strong>独立性</strong>：每个描述符集的配置是独立的，互不影响。这对于在创建管道布局时非常重要，特别是在使用管道库（pipelinelibraries）进行链接时。</li><li><strong>灵活性</strong>：即使没有启用<i><font color="Red">VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT</font></i>标志，开发者仍然可以创建一个只使用总描述符集子集的管道。这增加了在不同上下文中重用和组合管道的灵活性。</li></ul><p>目前我们希望使用一个包含MVP矩阵数据的描述符以供着色器使用，于是我们需要在类内创建一个[<code>VkDescriptorSetLayout</code>][id]类型的成员<i><font color="Orange">descriptorSetLayout</font></i>来指定相应的描述符布局，并且在创建描述符布局的信息结构体中指定使用该描述符布局，填写描述符布局信息过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineLayoutCreateInfo pipelineLayoutInfo&#123;&#125;;<br>pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;<br>pipelineLayoutInfo.setLayoutCount = <span class="hljs-number">1</span>;<br>pipelineLayoutInfo.pSetLayouts = &amp;descriptorSetLayout;<br></code></pre></td></tr></table></figure><p>在渲染管线构造中我们就可以指定管线布局包含上述描述符布局（原来我们是将这一项设为空的），然后像<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/">固定管线</a>章节一样使用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineLayout.html"><code>vkCreatePipelineLayout</code></a>构造管线布局就可以了。</p><p>现在我们来构造实际的描述符布局。</p><p>为了构建实际的描述符布局，我们同样需要填写相应的信息结构体<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutCreateInfo.html"><code>VkDescriptorSetLayoutCreateInfo</code></a>，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDescriptorSetLayoutCreateInfo</span> &#123;</span><br>    VkStructureType                        sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                            pNext;<br>    VkDescriptorSetLayoutCreateFlags       flags;<br>    <span class="hljs-type">uint32_t</span>                               bindingCount;<br>    <span class="hljs-type">const</span> VkDescriptorSetLayoutBinding*    pBindings;<br>&#125; VkDescriptorSetLayoutCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>较多，我们这里不做一一介绍，读者可以参考<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutCreateFlagBits.html">这个页面</a>。</p><p>可以看到<i><font color="Orange">pBindings</font></i>指向一个<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutBinding.html"><code>VkDescriptorSetLayoutBinding</code></a>对象，该类型同样是一个结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDescriptorSetLayoutBinding</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>              binding;<br>    VkDescriptorType      descriptorType;<br>    <span class="hljs-type">uint32_t</span>              descriptorCount;<br>    VkShaderStageFlags    stageFlags;<br>    <span class="hljs-type">const</span> VkSampler*      pImmutableSamplers;<br>&#125; VkDescriptorSetLayoutBinding;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">binding</font></i>指定该描述符的绑定点，它对应于着色器中使用该资源时指定的绑定点（我们在后文改写着色器的时候会看到）。</p><p><i><font color="Orange">descriptorType</font></i>指定描述符类型，我们需要使用的是统一缓冲类型的描述符，于是该变量应该指定为<i><font color="Red">VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</font></i>。</p><p><i><font color="Orange">descriptorCount</font></i>指定绑定到同一个绑定点的描述符个数，着色器将以数组的形式访问这些描述符（这在一些场景下是有用处的，比如说骨骼动画中，当我们希望传递给同一个对象的不同骨骼部分不同的变换矩阵时就需要用到多个描述符）。需要注意的是，如果描述符类型指定为<i><font color="Red">VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</font></i>，那么<i><font color="Orange">descriptorCount</font></i>用于指定内联统一块的字节数（内联统一块允许应用程序将小型的、常量的uniform数据直接嵌入到描述符集中，而不需要单独的缓冲区。这种方式可以提高性能，减少内存占用，并简化资源管理）。另外，如果<i><font color="Orange">descriptorCount</font></i>设置为0，则意味着这个绑定条目仍然存在于描述符集布局中，但它不对应任何实际的资源。它可以用于将来的扩展或占位符用途，但在当前的管线中，任何试图通过这个绑定访问资源的行为都是非法的。</p><p><i><font color="Orange">stageFlags</font></i>用于指定需要使用该描述符资源的着色器阶段，我们可以简单地使用<i><font color="Red">VK_SHADER_STAGE_ALL</font></i>来代指所有阶段。如果在该成员中没有指定某个阶段，那么那个阶段一定不能访问该描述符资源。在我们的应用程序中，我们希望在顶点着色器中使用MVP矩阵对位置进行变换，因此该成员应该设置为<i><font color="Red">VK_SHADER_STAGE_VERTEX_BIT</font></i>。</p><p>最后一个成员<i><font color="Orange">pImmutableSamplers</font></i>与图像采样有关，这里暂不介绍，我们会在后续有关纹理的章节中详细介绍这一部分。</p><p>综上，我们应该如下填写信息结构体并创建<i><font color="Orange">descriptorSetLayout</font></i>成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkDescriptorSetLayoutBinding uboLayoutBinding&#123;&#125;;<br>uboLayoutBinding.binding = <span class="hljs-number">0</span>;<br>uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;<br>uboLayoutBinding.descriptorCount = <span class="hljs-number">1</span>;<br>uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;<br>uboLayoutBinding.pImmutableSamplers = <span class="hljs-literal">nullptr</span>; <br><br>VkDescriptorSetLayoutCreateInfo layoutInfo&#123;&#125;;<br>layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;<br>layoutInfo.bindingCount = <span class="hljs-number">1</span>;<br>layoutInfo.pBindings = &amp;uboLayoutBinding;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateDescriptorSetLayout</span>(device, &amp;layoutInfo, <span class="hljs-literal">nullptr</span>, &amp;descriptorSetLayout) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create descriptor set layout!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="构建统一缓冲">构建统一缓冲</h2><p>接下来我们需要构建描述符引用的实际存储数据的缓冲对象。首先创建一个结构体来指定该缓冲中应该包含的数据信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UniformBufferObject</span> &#123;<br>    glm::mat4 model;<br>    glm::mat4 view;<br>    glm::mat4 proj;<br>&#125;;<br></code></pre></td></tr></table></figure><p>关于MVP矩阵以及坐标变换，我们假设读者已经十分熟悉，这里不做过多介绍，不熟悉的读者可以参考图形学入门圣经<a href="https://www.bilibili.com/video/BV1X7411F744/">games101课程</a>。</p><p>然后我们来创建保存MVP矩阵数据的统一缓冲。首先在类内添加几个成员<i><font color="Orange">std::vector<VkBuffer>uniformBuffers; std::vector<VkDeviceMemory> uniformBuffersMemory;std::vector&lt;void*&gt;uniformBuffersMapped;</VkDeviceMemory></VkBuffer></font></i>，然后创建一个<font color="Green">voidcreateUniformBuffers()</font>成员函数来创建统一缓冲。创建统一缓冲的逻辑和之前创建顶点缓冲、索引缓冲基本一致，只不过这里我们不再需要借助临时缓冲了，因为我们每一帧都需要向该缓冲传递新的数据，使用临时缓冲使得传输过程复杂化，可能反而会影响数据更新的效率。该函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createUniformBuffers</span><span class="hljs-params">()</span> </span>&#123;<br>    VkDeviceSize bufferSize = <span class="hljs-built_in">sizeof</span>(UniformBufferObject);<br><br>    uniformBuffers.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br>    uniformBuffersMemory.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br>    uniformBuffersMapped.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123;<br>        <span class="hljs-built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, uniformBuffers[i], uniformBuffersMemory[i]);<br><br>        <span class="hljs-built_in">vkMapMemory</span>(device, uniformBuffersMemory[i], <span class="hljs-number">0</span>, bufferSize, <span class="hljs-number">0</span>, &amp;uniformBuffersMapped[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码有两点需要注意：一是我们对每一帧使用了一个单独的统一缓冲，而顶点和索引数据却没有这么做，因为顶点和索引数据是始终不变的，我们不会在渲染过程中写入该缓冲新的数据，但是统一缓冲中的MVP数据每帧都可能会变动，我们每帧都需要更新该缓冲的数据，因此为了避免某一帧在更新统一缓冲时上一帧还在读取该缓冲数据内容，我们给每一帧分配一个单独的统一缓冲；二是代码并没有在映射完统一缓冲后解映射该缓冲，这种做法叫做<strong>持续映射（persistentmapping）</strong>，这样我们就不需要在每次需要更新这个缓冲的时候都重新映射一遍，我们可以在每帧更新时直接复制数据到该缓冲中。</p><p>在创建好统一缓冲后，我们顺便把每帧更新统一缓冲的逻辑给写好。创建一个<i><font color="Green">voidupdateUniformBuffer(uint32_tcurrentImage)</font></i>函数来完成这项工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateUniformBuffer</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> currentImage)</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> startTime = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br><br>    <span class="hljs-keyword">auto</span> currentTime = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-type">float</span> time = std::chrono::<span class="hljs-built_in">duration</span>&lt;<span class="hljs-type">float</span>, std::chrono::seconds::period&gt;(currentTime - startTime).<span class="hljs-built_in">count</span>();<br>    <br>    UniformBufferObject ubo&#123;&#125;;<br>ubo.model = glm::<span class="hljs-built_in">rotate</span>(glm::<span class="hljs-built_in">mat4</span>(<span class="hljs-number">1.0f</span>), time * glm::<span class="hljs-built_in">radians</span>(<span class="hljs-number">90.0f</span>), glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>));<br>    ubo.view = glm::<span class="hljs-built_in">lookAt</span>(glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">2.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">2.0f</span>), glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>), glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>));<br>    ubo.proj = glm::<span class="hljs-built_in">perspective</span>(glm::<span class="hljs-built_in">radians</span>(<span class="hljs-number">45.0f</span>), swapChainExtent.width / (<span class="hljs-type">float</span>) swapChainExtent.height, <span class="hljs-number">0.1f</span>, <span class="hljs-number">10.0f</span>);<br>    ubo.proj[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] *= <span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-built_in">memcpy</span>(uniformBuffersMapped[currentImage], &amp;ubo, <span class="hljs-built_in">sizeof</span>(ubo));<br>&#125;<br></code></pre></td></tr></table></figure><p>关于计时器<a href="https://en.cppreference.com/w/cpp/header/chrono"><code>std::chrono</code></a>以及更多的c++计时系统，读者可以参考<a href="https://en.cppreference.com/w/cpp/chrono">这个页面</a>。关于代码中使用glm库构建MVP矩阵的部分，读者可以在<a href="https://learnopengl.com/Getting-started/Coordinate-Systems">这篇文章</a>中找到详细的说明。</p><p>不过这里需要注意的是，我们这里对投影矩阵的y坐标取反，这是因为glm是为OpenGL设计的，OpenGL的坐标系统在竖直方向和Vulkan是相反的，为了保证渲染的图像不会颠倒我们必须将y坐标取反。</p><hr><h2 id="改写着色器">改写着色器</h2><p>为了在着色器中使用该统一缓冲区数据，我们需要改写原来的顶点着色器代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> UniformBufferObject &#123;<br>    <span class="hljs-type">mat4</span> model;<br>    <span class="hljs-type">mat4</span> view;<br>    <span class="hljs-type">mat4</span> proj;<br>&#125; ubo;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inPosition;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inColor;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fragColor;<br><br><span class="hljs-type">void</span> main() &#123;<br>    <span class="hljs-built_in">gl_Position</span> = ubo.proj * ubo.view * ubo.model * <span class="hljs-type">vec4</span>(inPosition, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fragColor = inColor;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们指定uniform变量的绑定点和之前在<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutBinding.html"><code>VkDescriptorSetLayoutBinding</code></a>中设定的绑定点一致。片段着色器不需要改变。最后不要忘记重新编译着色器代码以更新SPIR-V文件。</p><p>大功告成！</p><p>下一章我们将创建真正用于绑定的描述符集对象。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/">上一篇：索引缓冲</a></p><p>--<a href="https://zpc-dsg.github.io/2024/12/06/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B1%A0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86/">下一篇：描述符池和描述符集</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>索引缓冲</title>
    <link href="/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/"/>
    <url>/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>实际应用中我们绘制的3D图形的面片之间会共享很多顶点，如果每个面片的每个顶点都需要存储一份数据的话将浪费过多的内存空间。为了减少重复量，我们可以使用索引缓冲。索引缓冲本质上就是一列指向顶点缓冲的指针，这样我们就可以在顶点缓冲中存储所有互不相同的顶点，并且在索引缓冲中指定每个面片中顶点对应在顶点缓冲中的索引，从而大大减少了重复存储耗费的空间。</p><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Vertex_buffers/Index_buffer">Indexbuffer</a>章节。</p><hr><h2 id="创建并使用索引缓冲">创建并使用索引缓冲</h2><p>作为索引缓冲的使用示例，我们将绘制一个长方形到屏幕上。</p><p>为了使用索引缓冲，首先我们需要定义好顶点数据对应的索引数据。顶点数据也需要修改一下，剔除掉重复的顶点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;Vertex&gt; vertices = &#123;<br>    &#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>添加上索引构成长方形的两个三角形顶点（右上和左下）对应的索引数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">uint16_t</span>&gt; indices = &#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>现在，索引数据已经准备完毕了，接下来我们创建一个<i><font color="Green">voidcreateIndexBuffer(()</font></i>函数来创建需要的索引缓冲，同时在类内添加两个成员<i><font color="Orange">indexBuffer</font></i>和<i><font color="Orange">indexBufferMemory</font></i>来分别存储索引缓冲及其内存。创建索引缓冲的过程几乎和创建顶点缓冲的过程一致，也是先通过一个临时缓冲接受索引数据，然后将临时缓冲中的数据复制到高性能索引缓冲中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createIndexBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>    VkDeviceSize bufferSize = <span class="hljs-built_in">sizeof</span>(indices[<span class="hljs-number">0</span>]) * indices.<span class="hljs-built_in">size</span>();<br><br>    VkBuffer stagingBuffer;<br>    VkDeviceMemory stagingBufferMemory;<br>    <span class="hljs-built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);<br><br>    <span class="hljs-type">void</span>* data;<br>    <span class="hljs-built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="hljs-number">0</span>, bufferSize, <span class="hljs-number">0</span>, &amp;data);<br>    <span class="hljs-built_in">memcpy</span>(data, indices.<span class="hljs-built_in">data</span>(), (<span class="hljs-type">size_t</span>) bufferSize);<br>    <span class="hljs-built_in">vkUnmapMemory</span>(device, stagingBufferMemory);<br><br>    <span class="hljs-built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, indexBuffer, indexBufferMemory);<br><br>    <span class="hljs-built_in">copyBuffer</span>(stagingBuffer, indexBuffer, bufferSize);<br><br>    <span class="hljs-built_in">vkDestroyBuffer</span>(device, stagingBuffer, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">vkFreeMemory</span>(device, stagingBufferMemory, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里索引缓冲的使用方式应该设置为<i><font color="Red">VK_BUFFER_USAGE_INDEX_BUFFER_BIT</font></i>而不再是<i><font color="Red">VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</font></i>。</p><p>这样，我们就创建好了绘制长方形所需的索引缓冲，接下来只需在录制绘制命令之前将索引缓冲同顶点缓冲一起绑定到着色器绑定点上即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdBindVertexBuffers</span>(commandBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, vertexBuffers, offsets);<br><span class="hljs-built_in">vkCmdBindIndexBuffer</span>(commandBuffer, indexBuffer, <span class="hljs-number">0</span>, VK_INDEX_TYPE_UINT16);<br><br><span class="hljs-built_in">vkCmdDrawIndexed</span>(commandBuffer, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(indices.<span class="hljs-built_in">size</span>()), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindIndexBuffer.html"><code>vkCmdBindIndexBuffer</code></a>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdBindIndexBuffer</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    VkBuffer                                    buffer,</span><br><span class="hljs-params">    VkDeviceSize                                offset,<span class="hljs-comment">//读取索引缓冲的起点偏移字节数</span></span><br><span class="hljs-params">    VkIndexType                                 indexType)</span>;<span class="hljs-comment">//索引缓冲数据格式</span><br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexed.html"><code>vkCmdDrawIndexed</code></a>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdDrawIndexed</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    indexCount,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    instanceCount,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    firstIndex,</span><br><span class="hljs-params">    <span class="hljs-type">int32_t</span>                                     vertexOffset,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    firstInstance)</span>;<br></code></pre></td></tr></table></figure><p>这里我们并不使用实例渲染，因此<i><font color="Orange">instanceCount</font></i>设置为1，<i><font color="Orange">firstInstance</font></i>设置为0即可。另外这里需要注意的是<i><font color="Orange">firstIndex</font></i>指的是绘制索引起始处的偏移，这个偏移是按索引值而不是像<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexed.html"><code>vkCmdDrawIndexed</code></a>函数中<i><font color="Orange">offset</font></i>那样指定的偏移字节数。</p><p>其他操作不需要改变，这样我们就渲染出了一个长方形！</p><figure><img src="/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/rectangle.png" alt="索引缓冲绘制长方形"><figcaption aria-hidden="true">索引缓冲绘制长方形</figcaption></figure><p>大功告成！</p><p>最后我们需要提一嘴的是，在实际应用中我们不但提倡像<a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/">创建顶点缓冲</a>章节中所说的那样尽量将多个内存分配操作合并为一个，更进一步地，驱动开发人员还建议我们将多个缓冲区合并为一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBuffer.html"><code>VkBuffer</code></a>对象，然后在<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCmdBindVertexBuffers.html"><code>vkCmdBindVertexBuffers</code></a>等调用中通过偏移值来获取相应的缓冲，这样可以使我们的缓冲数据排列更加紧密从而使得缓存命中率提高，不失为一个提高应用程序效率的方法。另外，我们甚至可以在不同时发生的渲染等操作中重用同一块内存，只不过在不同的操作中赋予内存不同的数据，这叫做<strong>aliasing</strong>，也是提高程序效率的方法之一。</p><p>接下来我们将开启一个新的篇章：统一缓冲区。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/">上一篇：临时缓冲区</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/30/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%92%8C%E7%BB%9F%E4%B8%80%E7%BC%93%E5%86%B2/">下一篇：描述符布局和统一缓冲</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>临时缓冲区</title>
    <link href="/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/"/>
    <url>/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p><a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/">上一章</a>中，我们将GPU中的顶点缓冲内存映射到了一个CPU可见且一致的内存中，然后将顶点数据复制到这个映射后内存中。这么做当然可行，但是一般来讲可映射GPU内存对于GPU操作而言都不是最高性能的，而高性能内存又不支持内存映射。因此，为了能够更高效地使用顶点缓冲，这节我们将使用一个临时缓冲区接受复制后的顶点数据，然后再将这份数据复制到高性能缓冲区中供GPU使用。完成这个过程主要分为两步：</p><ul><li>创建临时缓冲区接受顶点数据</li><li>将临时缓冲区数据复制到高性能缓冲区中</li></ul><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Vertex_buffers/Staging_buffer">Stagingbuffer</a>章节。</p><hr><h2 id="创建临时缓冲区">创建临时缓冲区</h2><p>现在我们需要首先创建一个临时缓冲区，然后创建所需的顶点缓冲区。既然我们现在需要创建多个缓冲区，那么可以将创建缓冲区所需的公共代码提取出来构成一个新函数<i><font color="Green">voidcreateBuffer(VkDeviceSize size, VkBufferUsageFlags usage,VkMemoryPropertyFlags properties, VkBuffer&amp; buffer,VkDeviceMemory&amp; bufferMemory)</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createBuffer</span><span class="hljs-params">(VkDeviceSize size, VkBufferUsageFlags usage, VkMemoryPropertyFlags properties, VkBuffer&amp; buffer, VkDeviceMemory&amp; bufferMemory)</span> </span>&#123;<br>    VkBufferCreateInfo bufferInfo&#123;&#125;;<br>    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;<br>    bufferInfo.size = size;<br>    bufferInfo.usage = usage;<br>    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateBuffer</span>(device, &amp;bufferInfo, <span class="hljs-literal">nullptr</span>, &amp;buffer) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create buffer!&quot;</span>);<br>    &#125;<br><br>    VkMemoryRequirements memRequirements;<br>    <span class="hljs-built_in">vkGetBufferMemoryRequirements</span>(device, buffer, &amp;memRequirements);<br><br>    VkMemoryAllocateInfo allocInfo&#123;&#125;;<br>    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;<br>    allocInfo.allocationSize = memRequirements.size;<br>    allocInfo.memoryTypeIndex = <span class="hljs-built_in">findMemoryType</span>(memRequirements.memoryTypeBits, properties);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkAllocateMemory</span>(device, &amp;allocInfo, <span class="hljs-literal">nullptr</span>, &amp;bufferMemory) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to allocate buffer memory!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">vkBindBufferMemory</span>(device, buffer, bufferMemory, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以在<i><font color="Green">createVertexBuffer</font></i>函数中使用该函数以简化代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createVertexBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>    VkDeviceSize bufferSize = <span class="hljs-built_in">sizeof</span>(vertices[<span class="hljs-number">0</span>]) * vertices.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, vertexBuffer, vertexBufferMemory);<br><br>    <span class="hljs-type">void</span>* data;<br>    <span class="hljs-built_in">vkMapMemory</span>(device, vertexBufferMemory, <span class="hljs-number">0</span>, bufferSize, <span class="hljs-number">0</span>, &amp;data);<br>        <span class="hljs-built_in">memcpy</span>(data, vertices.<span class="hljs-built_in">data</span>(), (<span class="hljs-type">size_t</span>) bufferSize);<br>    <span class="hljs-built_in">vkUnmapMemory</span>(device, vertexBufferMemory);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们要在<i><font color="Green">createVertexBuffer</font></i>函数中添加创建临时缓冲区的代码，新的<i><font color="Green">createVertexBuffer</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createVertexBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>    VkDeviceSize bufferSize = <span class="hljs-built_in">sizeof</span>(vertices[<span class="hljs-number">0</span>]) * vertices.<span class="hljs-built_in">size</span>();<br><br>    VkBuffer stagingBuffer;<br>    VkDeviceMemory stagingBufferMemory;<br>    <span class="hljs-built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);<br><br>    <span class="hljs-type">void</span>* data;<br>    <span class="hljs-built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="hljs-number">0</span>, bufferSize, <span class="hljs-number">0</span>, &amp;data);<br>        <span class="hljs-built_in">memcpy</span>(data, vertices.<span class="hljs-built_in">data</span>(), (<span class="hljs-type">size_t</span>) bufferSize);<br>    <span class="hljs-built_in">vkUnmapMemory</span>(device, stagingBufferMemory);<br><br>    <span class="hljs-built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, vertexBuffer, vertexBufferMemory);<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>首先注意到我们并没有将临时缓冲区保存为类的一个成员，因为该缓冲区只负责暂时的数据交接工作，完成工作后就会被释放，我们并不需要保存它的句柄。</p><p>另外，我们设置临时缓冲区的使用方式为<i><font color="Red">VK_BUFFER_USAGE_TRANSFER_SRC_BIT</font></i>，这代表该缓冲区可以用作数据复制源使用。同样，我们也为顶点缓冲添加了一个使用方式<i><font color="Red">VK_BUFFER_USAGE_TRANSFER_DST_BIT</font></i>，也就是说它可以用作接受数据复制的缓冲。</p><p>这样我们就创建好了临时缓冲区并且将顶点数据复制到了该缓冲区内，接下来就要将这部分数据复制到高性能顶点缓冲中去了。</p><hr><h2 id="复制数据到高性能缓冲区">复制数据到高性能缓冲区</h2><p>复制缓冲区内容实际上也是一个需要队列来执行的命令，它需要的是一个能够执行缓冲复制的队列（<strong>Transferqueue</strong>）。不过一般来讲图形队列和计算队列都支持缓冲你复制命令，因此接下来我们将直接使用已有的图形队列执行缓冲复制工作。不过这里我们也还是大致梳理一下如果想要使用一个单独的转移队列（<strong>Transferqueue</strong>）来执行复制工作的话需要哪些步骤：</p><ul><li>在<i><font color="Green">findQueueFamilies</font></i>函数中添加寻找具有<i><font color="Red">VK_QUEUE_TRANSFER_BIT</font></i>标志位的队列家族的代码，并且将相应的队列家族索引保存在<i><font color="Orange">QueueFamilyIndices</font></i>中。</li><li>在<i><font color="Green">createLogicalDevice</font></i>中为逻辑设备添加上述寻找到的转移队列。</li><li>创建一个单独的命令池用于录制提交到该转移队列的命令</li><li>将顶点缓冲的<i><font color="Orange">sharingMode</font></i>改为<i><font color="Red">VK_SHARING_MODE_CONCURRENT</font></i>，并且指定图形队列和转移队列都可以使用该顶点缓冲（或者如教程评论区所说使用内存屏障，这个主题会在后续纹理有关章节中涉及到）。</li><li>将所有复制转移命令提交到该转移队列执行。</li></ul><p>回到本教程的方案上，我们希望将复制命令提交给图形队列执行，不过在此之前我们当然需要先录制好复制命令。创建一个成员函数<i><font color="Green">voidcopyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSizesize)</font></i>来执行复制命令的录制工作。</p><p>首先，我们需要从命令池中分配出供录制命令使用的命令缓冲：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copyBuffer</span><span class="hljs-params">(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size)</span> </span>&#123;<br>    VkCommandBufferAllocateInfo allocInfo&#123;&#125;;<br>    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;<br>    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;<br>    allocInfo.commandPool = commandPool;<br>    allocInfo.commandBufferCount = <span class="hljs-number">1</span>;<br><br>    VkCommandBuffer commandBuffer;<br>    <span class="hljs-built_in">vkAllocateCommandBuffers</span>(device, &amp;allocInfo, &amp;commandBuffer);<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们也不需要将该命令缓冲保存为类的一个成员，因为在复制完数据后这个命令缓冲就可以释放掉了。</p><p>接下来我们就可以开始录制命令了。首先还是填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBufferBeginInfo.html"><code>VkCommandBufferBeginInfo</code></a>，这部分内容在<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/">命令缓冲</a>章节中有详细讲解，这里不过多赘述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkCommandBufferBeginInfo beginInfo&#123;&#125;;<br>beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;<br>beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;<br><br><span class="hljs-built_in">vkBeginCommandBuffer</span>(commandBuffer, &amp;beginInfo);<br></code></pre></td></tr></table></figure><p>我们只需要录制复制缓冲区的命令，这是通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBuffer.html"><code>vkCmdCopyBuffer</code></a>实现的，该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdCopyBuffer</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    VkBuffer                                    srcBuffer,</span><br><span class="hljs-params">    VkBuffer                                    dstBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    regionCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkBufferCopy*                         pRegions)</span>;<br></code></pre></td></tr></table></figure><p>所有参数都是易于理解的。这里注意，根据函数原型，我们要复制缓冲，还需要填写复制区域<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferCopy.html"><code>VkBufferCopy</code></a>的信息，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkBufferCopy</span> &#123;</span><br>    VkDeviceSize    srcOffset;<br>    VkDeviceSize    dstOffset;<br>    VkDeviceSize    size;<br>&#125; VkBufferCopy;<br></code></pre></td></tr></table></figure><p>所有成员同样是易于理解的，于是我们录制部分代码代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkBufferCopy copyRegion&#123;&#125;;<br>copyRegion.srcOffset = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>copyRegion.dstOffset = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>copyRegion.size = size;<br><span class="hljs-built_in">vkCmdCopyBuffer</span>(commandBuffer, srcBuffer, dstBuffer, <span class="hljs-number">1</span>, &amp;copyRegion);<br><br><span class="hljs-built_in">vkEndCommandBuffer</span>(commandBuffer);<br></code></pre></td></tr></table></figure><p>在录制完命令后，我们将其提交至图形队列执行，提交命令在<a href="https://zpc-dsg.github.io/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/">渲染和显示</a>章节中已经详细介绍过了，我们这里同样不再赘述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSubmitInfo submitInfo&#123;&#125;;<br>submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;<br>submitInfo.commandBufferCount = <span class="hljs-number">1</span>;<br>submitInfo.pCommandBuffers = &amp;commandBuffer;<br><br><span class="hljs-built_in">vkQueueSubmit</span>(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, VK_NULL_HANDLE);<br><span class="hljs-built_in">vkQueueWaitIdle</span>(graphicsQueue);<br></code></pre></td></tr></table></figure><p>注意这里我们使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueueWaitIdle.html"><code>vkQueueWaitIdle</code></a>来等待复制操作执行完毕，以免出现还未完成数据复制就开始使用顶点缓冲或者销毁临时缓冲的情况。当然，这里我们并没有指定在CPU端等待的栅栏，读者可以想象，我们也可以在提交命令时附带一个栅栏来等待复制操作执行完毕，然后在CPU端等待该栅栏被点亮，这是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueueWaitIdle.html"><code>vkQueueWaitIdle</code></a>的一种替代方案。</p><p>最后，我们需要释放掉临时分配的命令缓冲：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkFreeCommandBuffers</span>(device, commandPool, <span class="hljs-number">1</span>, &amp;commandBuffer);<br></code></pre></td></tr></table></figure><p>现在，我们可以在<i><font color="Green">createVertexBuffer</font></i>中使用上面创建好的<i><font color="Green">copyBuffer</font></i>函数来完成从临时缓冲区复制顶点数据到顶点缓冲区的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createVertexBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <br><span class="hljs-built_in">copyBuffer</span>(stagingBuffer, vertexBuffer, bufferSize);<br><br>    <span class="hljs-built_in">vkDestroyBuffer</span>(device, stagingBuffer, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">vkFreeMemory</span>(device, stagingBufferMemory, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然不要忘记销毁临时缓冲并释放为之分配的内存。</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/">上一篇：创建顶点缓冲</a></p><p>--<a href>下一篇：索引缓冲</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>创建顶点缓冲</title>
    <link href="/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/"/>
    <url>/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在<a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0/">上一章</a>创建好实际的顶点数据以及顶点描述之后，现在我们需要创建用于读取、写入和存储这些数据以供GPU使用的部件，那就是顶点缓冲。创建和使用顶点缓冲可以分为四步：</p><ul><li>创建缓冲对象</li><li>分配缓冲内存</li><li>填充顶点数据</li><li>绑定顶点缓冲</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Vertex_buffers/Vertex_buffer_creation">Vertexbuffer creation</a>章节。</p><hr><h2 id="创建缓冲对象">创建缓冲对象</h2><p>首先，在<i><font color="Green">initVulkan</font></i>函数中的<i><font color="Green">createCommandBuffers</font></i>函数之前添加一个成员函数<i><font color="Green">voidcreateVertexBuffer()</font></i>用来完成顶点缓冲对象的创建，并且在类内新增一个成员<i><font color="Orange">VkBuffervertexBuffer</font></i>来保存创建的顶点缓冲对象。</p><p>要创建顶点缓冲，我们当然需要首先填写创建结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferCreateInfo.html"><code>VkBufferCreateInfo</code></a>有关信息，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkBufferCreateInfo</span> &#123;</span><br>    VkStructureType        sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*            pNext;<br>    VkBufferCreateFlags    flags;<br>    VkDeviceSize           size;<br>    VkBufferUsageFlags     usage;<br>    VkSharingMode          sharingMode;<br>    <span class="hljs-type">uint32_t</span>               queueFamilyIndexCount;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*        pQueueFamilyIndices;<br>&#125; VkBufferCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>涉及到稀疏内存等特殊的缓冲参数，这里我们不会使用到，不做过多介绍。</p><p><i><font color="Orange">usage</font></i>代表该缓冲区的使用方式，它的可能取值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkBufferUsageFlagBits</span> &#123;</span><br>    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = <span class="hljs-number">0x00000001</span>,<br>    VK_BUFFER_USAGE_TRANSFER_DST_BIT = <span class="hljs-number">0x00000002</span>,<br>    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = <span class="hljs-number">0x00000004</span>,<br>    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = <span class="hljs-number">0x00000008</span>,<br>    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = <span class="hljs-number">0x00000010</span>,<br>    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = <span class="hljs-number">0x00000020</span>,<br>    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = <span class="hljs-number">0x00000040</span>,<br>    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = <span class="hljs-number">0x00000080</span>,<br>    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = <span class="hljs-number">0x00000100</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = <span class="hljs-number">0x00020000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_decode_queue</span><br>    VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR = <span class="hljs-number">0x00002000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_decode_queue</span><br>    VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR = <span class="hljs-number">0x00004000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_transform_feedback</span><br>    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = <span class="hljs-number">0x00000800</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_transform_feedback</span><br>    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = <span class="hljs-number">0x00001000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_conditional_rendering</span><br>    VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = <span class="hljs-number">0x00000200</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> VK_ENABLE_BETA_EXTENSIONS</span><br>  <span class="hljs-comment">// Provided by VK_AMDX_shader_enqueue</span><br>    VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX = <span class="hljs-number">0x02000000</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br>    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = <span class="hljs-number">0x00080000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br>    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = <span class="hljs-number">0x00100000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_ray_tracing_pipeline</span><br>    VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR = <span class="hljs-number">0x00000400</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_encode_queue</span><br>    VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR = <span class="hljs-number">0x00008000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_encode_queue</span><br>    VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = <span class="hljs-number">0x00010000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_descriptor_buffer</span><br>    VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = <span class="hljs-number">0x00200000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_descriptor_buffer</span><br>    VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = <span class="hljs-number">0x00400000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_descriptor_buffer</span><br>    VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = <span class="hljs-number">0x04000000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_opacity_micromap</span><br>    VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = <span class="hljs-number">0x00800000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_opacity_micromap</span><br>    VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT = <span class="hljs-number">0x01000000</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_ray_tracing</span><br>    VK_BUFFER_USAGE_RAY_TRACING_BIT_NV = VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR,<br>  <span class="hljs-comment">// Provided by VK_EXT_buffer_device_address</span><br>    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,<br>  <span class="hljs-comment">// Provided by VK_KHR_buffer_device_address</span><br>    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,<br>&#125; VkBufferUsageFlagBits;<br></code></pre></td></tr></table></figure><p>可能的取值较多，我们不做一一介绍，这里我们希望将该缓冲区用作顶点缓冲，在之后的章节中我们会涉及到一些其它的缓冲类型。</p><p><i><font color="Orange">sharingMode</font></i>代表该缓冲的共享模式，缓冲区和交换链的图像一样可以被多个队列家族共享，我们这里只有一个队列家族需要使用该缓冲区，即图像队列家族，所以该成员设置为<i><font color="Red">VK_SHARING_MODE_EXCLUSIVE</font></i>即可。</p><p>最后的两个成员用于指定共享该缓冲的队列家族的数量及各自对应的索引，如果共享模式设置为<i><font color="Red">VK_SHARING_MODE_EXCLUSIVE</font></i>，那么这两个成员无需显式指定。</p><p>因此，我们的<i><font color="Green">createVertexBuffer</font></i>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createVertexBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>    VkBufferCreateInfo bufferInfo&#123;&#125;;<br>    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;<br>    bufferInfo.size = <span class="hljs-built_in">sizeof</span>(vertices[<span class="hljs-number">0</span>]) * vertices.<span class="hljs-built_in">size</span>();<br>    bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;<br>    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateBuffer</span>(device, &amp;bufferInfo, <span class="hljs-literal">nullptr</span>, &amp;vertexBuffer) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create vertex buffer!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="分配缓冲内存">分配缓冲内存</h2><p>与我们之前创建的那些Vulkan对象不同，缓冲对象在创建后Vulkan并不会为其自动分配内存，我们需要手动为缓冲对象分配内存。</p><p>在分配内存之前，我们首先需要查询创建的顶点缓冲对象对分配的内存有什么要求以及我们使用的物理设备可以分配的内存种类中是否有满足这些要求的种类，在查询有内存种类满足要求后我们才能真正为缓冲对象分配内存，下面我们依次进行这三步。</p><h4 id="查询内存要求">查询内存要求</h4><p>查询内存要求可以简单地通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetBufferMemoryRequirements.html"><code>vkGetBufferMemoryRequirements</code></a>函数来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkMemoryRequirements memRequirements;<br><span class="hljs-built_in">vkGetBufferMemoryRequirements</span>(device, vertexBuffer, &amp;memRequirements);<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkMemoryRequirements.html"><code>VkMemoryRequirements</code></a>结构体包含了缓冲对象对内存的要求明细，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkMemoryRequirements</span> &#123;</span><br>    VkDeviceSize    size;<br>    VkDeviceSize    alignment;<br>    <span class="hljs-type">uint32_t</span>        memoryTypeBits;<br>&#125; VkMemoryRequirements;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">size</font></i>描述需要分配内存的大小，这个大小有可能和内存中真正存储的缓冲数据大小不一致（因为存储在这块内存中的数据可能会有偏移）。</p><p><i><font color="Orange">alignment</font></i>代表缓冲数据的起始位置相对于缓冲内存的起始位置的偏移，这个数值取决于缓冲区的使用方式（<i><font color="Orange">usage</font></i>成员）以及标志位（<i><font color="Orange">flags</font></i>成员）。</p><p><i><font color="Orange">memoryTypeBits</font></i>代表适用于该缓冲的内存类型，它是一些内存类型的位组合，具体来说就是如果查询物理设备内存属性（使用<a href="https://vkdoc.net/man/vkGetPhysicalDeviceMemoryProperties"><code>VkGetPhysicalDeviceMemoryProperties</code></a>，也就是接下来的第二步）得到的结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryProperties.html"><code>VkPhysicalDeviceMemoryProperties</code></a>中的内存类型i （用位<strong>1&lt;&lt;i</strong>表示）支持用于该缓冲对象时，位 i就会被置位。</p><h4 id="寻找满足要求的内存类型">寻找满足要求的内存类型</h4><p>接下来我们需要寻找物理设备支持的内存类型中是否有满足顶点缓冲需求的类型。我们创建一个<i><font color="Green">uint32_tfindMemoryType(uint32_t typeFilter, VkMemoryPropertyFlagsproperties)</font></i>函数来完成有关工作。</p><p>首先，我们当然需要查询物理设备所支持的所有内存属性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPhysicalDeviceMemoryProperties memProperties;<br><span class="hljs-built_in">vkGetPhysicalDeviceMemoryProperties</span>(physicalDevice, &amp;memProperties);<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryProperties.html"><code>VkPhysicalDeviceMemoryProperties</code></a>结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VkPhysicalDeviceMemoryProperties</span> &#123;<br>    <span class="hljs-type">uint32_t</span>        memoryTypeCount;<br>    VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];<br>    <span class="hljs-type">uint32_t</span>        memoryHeapCount;<br>    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];<br>&#125; VkPhysicalDeviceMemoryProperties;<br></code></pre></td></tr></table></figure><p>该结构体主要包含两方面内存信息：内存类型和内存所属堆。内存堆指的是一些内存资源，如专用的显存（VRAM）和当显存不足时用于交换的RAM空间，不同种类的内存可能从不同种类的内存堆中分配。这里我们只考虑内存类型。</p><p>接下来我们从这些支持类型中寻找满足缓冲区需求的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; memProperties.memoryTypeCount; i++) &#123;<br>    <span class="hljs-keyword">if</span> ((typeFilter &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) &amp;&amp; (memProperties.memoryTypes[i].propertyFlags &amp; properties) == properties) &#123;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断一个类型是否满足需求分为两个方面：一是判断该类型对应的位i是否在缓冲区的<i><font color="Orange">memoryTypeBits</font></i>中置位，如果置位说明该类型可供缓冲区使用；二是判断该类型是否具有我们需要的内存属性，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkMemoryType.html"><code>VkMemoryType</code></a>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkMemoryType</span> &#123;</span><br>    VkMemoryPropertyFlags    propertyFlags;<br>    <span class="hljs-type">uint32_t</span>                 heapIndex;<br>&#125; VkMemoryType;<br></code></pre></td></tr></table></figure><p>有关属性的部分我们会在下一步详细描述。</p><h4 id="分配缓冲区内存">分配缓冲区内存</h4><p>如果寻找到了满足缓冲区要求的内存类型。接下来我们就可以分配相应的内存了。分配缓冲区内存需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkMemoryAllocateInfo.html"><code>VkMemoryAllocateInfo</code></a>结构体，其定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkMemoryAllocateInfo</span> &#123;</span><br>    VkStructureType    sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*        pNext;<br>    VkDeviceSize       allocationSize;<br>    <span class="hljs-type">uint32_t</span>           memoryTypeIndex;<br>&#125; VkMemoryAllocateInfo;<br></code></pre></td></tr></table></figure></p><p>每个成员的含义都是易于理解的，我们的分配代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkMemoryAllocateInfo allocInfo&#123;&#125;;<br>allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;<br>allocInfo.allocationSize = memRequirements.size;<br>allocInfo.memoryTypeIndex = <span class="hljs-built_in">findMemoryType</span>(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);<br></code></pre></td></tr></table></figure><p>这里我们传递给<i><font color="Green">findMemoryType</font></i>函数的属性参数为<i><font color="Red">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT|VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</font></i>。我们这里列举出属性所有可能的取值，并且大致解释以下它们每一个的含义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkMemoryPropertyFlagBits</span> &#123;</span><br>    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//分配的内存能够被设备高效使用</span><br>    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//分配的内存可以映射给CPU使用</span><br>    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//CPU上对该内存的一切修改操作都能立刻一致地同步到GPU上而不需要显式使用vkFlushMappedMemoryRanges和vkInvalidateMappedMemoryRanges同步内存数据一致性</span><br>    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//映射后的内存会置于CPU的高速缓存区，具有更快的访问效率，但是置于主内存的映射后内存一定是host coherent的</span><br>    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = <span class="hljs-number">0x00000010</span>,<span class="hljs-comment">//内存只允许设备访问，并且该内存可能是懒分配的，这个标志不能和VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT set同时使用</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_MEMORY_PROPERTY_PROTECTED_BIT = <span class="hljs-number">0x00000020</span>,<span class="hljs-comment">//内存只允许设备访问，并且只允许具有保护权限的队列操作访问。这个标志不能和VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT、VK_MEMORY_PROPERTY_HOST_COHERENT_BIT或者VK_MEMORY_PROPERTY_HOST_CACHED_BIT 中的任意一个同时使用</span><br>  <span class="hljs-comment">// Provided by VK_AMD_device_coherent_memory</span><br>    VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = <span class="hljs-number">0x00000040</span>,<span class="hljs-comment">//设备对内存的任何修改对CPU立即可见并且一致，一般作调试用，会影响内存使用效率，如非必要不建议使用</span><br>  <span class="hljs-comment">// Provided by VK_AMD_device_coherent_memory</span><br>    VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = <span class="hljs-number">0x00000080</span>,<span class="hljs-comment">//内存不会置于GPU高速缓存区，这样的内存一定是device coherent的</span><br>  <span class="hljs-comment">// Provided by VK_NV_external_memory_rdma</span><br>    VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = <span class="hljs-number">0x00000100</span>,<span class="hljs-comment">//其它设备可以直接访问这块内存</span><br>&#125; VkMemoryPropertyFlagBits;<br></code></pre></td></tr></table></figure><p>我们希望能够将CPU中的顶点数据复制给GPU，因此我们需要分配的缓冲区内存能够将自己映射到CPU上供CPU填充数据，因此我们需要设置<i><font color="Red">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</font></i>；另外，我们希望CPU将数据复值给映射后内存后，GPU能够立即同步该内存信息到自己的内存区域并且开始使用，因此我们需要设置<i><font color="Red">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</font></i>。</p><p>然后我们使用这份信息来分配顶点缓冲内存。首先在类内创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceMemory.html"><code>VkDeviceMemory</code></a>类型的成员<i><font color="Orange">vertexBufferMemory</font></i>，然后调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAllocateMemory.html"><code>vkAllocateMemory</code></a>即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkAllocateMemory</span>(device, &amp;allocInfo, <span class="hljs-literal">nullptr</span>, &amp;vertexBufferMemory) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to allocate vertex buffer memory!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们需要将这块分配好的内存绑定到对应的顶点缓冲区上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkBindBufferMemory</span>(device, vertexBuffer, vertexBufferMemory, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>最后一个参数代表缓冲在该内存中的偏移。我们的内存块中只有一个顶点缓冲，因此偏移设置为0即可，如果该值不为0，那么它一定需要被<i><font color="Orange">memRequirements.alignment</font></i>整除。</p><hr><h2 id="填充顶点数据">填充顶点数据</h2><p>现在我们需要将顶点数据填充至顶点缓存中，这需要我们首先将分配的顶点缓冲内存（在GPU中）映射到CPU可见的内存上，然后将CPU中的顶点数据复制到映射后内存中，之后设备会将该内存中的数据同步到缓冲区中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">void</span>* data;<br><span class="hljs-built_in">vkMapMemory</span>(device, vertexBufferMemory, <span class="hljs-number">0</span>, bufferInfo.size, <span class="hljs-number">0</span>, &amp;data);<br>    <span class="hljs-built_in">memcpy</span>(data, vertices.<span class="hljs-built_in">data</span>(), (<span class="hljs-type">size_t</span>) bufferInfo.size);<br><span class="hljs-built_in">vkUnmapMemory</span>(device, vertexBufferMemory);<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkMapMemory.html"><code>vkMapMemory</code></a>的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkMapMemory</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDevice                                    device,<span class="hljs-comment">//设备</span></span><br><span class="hljs-params">    VkDeviceMemory                              memory,<span class="hljs-comment">//映射的内存</span></span><br><span class="hljs-params">    VkDeviceSize                                offset,<span class="hljs-comment">//映射开始位置在内存中的偏移</span></span><br><span class="hljs-params">    VkDeviceSize                                size,<span class="hljs-comment">//映射内存的范围大小，还可以指定一个特殊值VK_WHOLE_SIZE，代表从偏移处到结尾的所有内存</span></span><br><span class="hljs-params">    VkMemoryMapFlags                            flags,<span class="hljs-comment">//标志位，指定特殊的操作</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span>**                                      ppData)</span>;<span class="hljs-comment">//映射后内存地址</span><br></code></pre></td></tr></table></figure><p>这样就完成了顶点数据的填充。</p><hr><h2 id="绑定顶点缓冲">绑定顶点缓冲</h2><p>最后，我们需要在绘制三角形命令之前将顶点缓冲绑定到着色器的绑定点以供着色器使用，这可以通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers.html"><code>vkCmdBindVertexBuffers</code></a>来完成，该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdBindVertexBuffers</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    firstBinding,<span class="hljs-comment">//第一个绑定点索引</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    bindingCount,<span class="hljs-comment">//绑定点总数</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkBuffer*                             pBuffers,<span class="hljs-comment">//需要绑定的一系列缓冲区</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkDeviceSize*                         pOffsets)</span>;<span class="hljs-comment">//每个缓冲区对应的开始读取数据的偏移</span><br><br></code></pre></td></tr></table></figure><p>然后在录制命令的函数<i><font color="Green">recordCommandBuffer</font></i>中添加录制绑定顶点缓冲区的代码即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdBindPipeline</span>(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);<br><br>VkBuffer vertexBuffers[] = &#123;vertexBuffer&#125;;<br>VkDeviceSize offsets[] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">vkCmdBindVertexBuffers</span>(commandBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, vertexBuffers, offsets);<br><br><span class="hljs-built_in">vkCmdDraw</span>(commandBuffer, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertices.<span class="hljs-built_in">size</span>()), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>大功告成！</p><p><a href="https://zpc-dsg.github.io/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/">下一章</a>我们将看到如何通过临时缓冲区更高效地使用顶点缓冲。</p><p>最后，还需要提一嘴的是，在实际应用中，我们的应用程序不可能仅仅绘制一个三角形，它可能会需要同时为很多的顶点缓冲分配内存，这时我们一般不可能像本节做的那样对每个分配内存操作调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAllocateMemory.html"><code>vkAllocateMemory</code></a>，因为事实上物理设备在同一时间段支持分配内存函数调用的次数是有上限的，而且这个上限可能并不高（4096），因此更可行的做法是一次<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAllocateMemory.html"><code>vkAllocateMemory</code></a>调用为多个缓冲区分配内存，这可能需要我们书写自己的内存分配器，并使用该分配器来合理分割分配得到的一大块内存区域以供多个缓冲使用，当然，你也可以使用一些开源的内存分配器（如<a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">VulkanMemoryAllocator</a>）来达到这个目的。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0/">上一篇：顶点输入描述</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/">下一篇：临时缓冲区</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>顶点输入描述</title>
    <link href="/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0/"/>
    <url>/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在接下来的几个章节中，我们将用顶点缓冲代替之前硬编码在着色器中的顶点数据。这一节中，我们首先关注顶点输入数据的描述。创建对顶点数据的描述可以分为三步：</p><ul><li>在CPU中准备好需要传入顶点着色器的数据</li><li>在顶点着色器中添加对输入数据的引用代码</li><li>创建对应于引用代码的两种顶点描述结构体供创建渲染管线时顶点输入阶段使用</li></ul><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Vertex_buffers/Vertex_input_description">Vertexinput description</a>章节。</p><hr><h2 id="定义顶点数据">定义顶点数据</h2><p>为了在CPU中定义我们需要的顶点数据，我们可以使用<a href="https://github.com/g-truc/glm">GLM数学库</a>作为辅助。在程序中新添一个表示每个顶点所包含数据的结构体<i><font color="Orange">Vertex</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vertex</span> &#123;<br>    glm::vec2 pos;<br>    glm::vec3 color;<br>&#125;;<br></code></pre></td></tr></table></figure><p>目前该结构体十分简单，因为我们绘制三角形的程序只需要每个顶点的二维坐标和颜色值。</p><p>然后，在程序代码中添加我们需要传递给顶点着色器的具体的顶点数据即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;Vertex&gt; vertices = &#123;<br>    &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">-0.5f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="着色器添加顶点引用">着色器添加顶点引用</h2><p>现在我们可以去掉顶点着色器中硬编码的顶点数据了。为了引用我们在CPU中定义的顶点数据，我们需要在顶点着色器中添加如下代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inPosition;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inColor;<br></code></pre></td></tr></table></figure><p>顶点着色器代码现在如下所示：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inPosition;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inColor;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fragColor;<br><br><span class="hljs-type">void</span> main() &#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(inPosition, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fragColor = inColor;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>in</strong>关键字代表这些数据将从顶点缓冲读入，<strong>location</strong>关键字代表了对应顶点属性在顶点数据中的位置，这个位置将在后文创建顶点描述结构体的时候被引用以和CPU中定义的顶点数据形成正确的对应从而确保输入着色器数据的正确性。</p><hr><h2 id="创建描述结构体">创建描述结构体</h2><p>下面我们就可以创建与着色器中顶点输入数据格式相匹配的顶点输入描述结构体了。我们需要创建两种结构体：<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkVertexInputBindingDescription.html"><code>VkVertexInputBindingDescription</code></a>和<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkVertexInputAttributeDescription.html"><code>VkVertexInputAttributeDescription</code></a>。</p><h4 id="vkvertexinputbindingdescription">VkVertexInputBindingDescription</h4><p>该结构体用于描述每个顶点的字节大小，即从一个顶点到下一个顶点在缓冲区中的字节距离，并且指定数据是逐顶点的还是逐实例提供的，它的定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkVertexInputBindingDescription</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>             binding;<span class="hljs-comment">//绑定的索引，表示在顶点输入阶段使用的顶点缓冲区的编号</span><br>    <span class="hljs-type">uint32_t</span>             stride;<span class="hljs-comment">//每个顶点的字节大小</span><br>    VkVertexInputRate    inputRate;<span class="hljs-comment">//指定数据是每个顶点（VK_VERTEX_INPUT_RATE_VERTEX）还是每个实例（VK_VERTEX_INPUT_RATE_INSTANCE）提供的</span><br>&#125; VkVertexInputBindingDescription;<br></code></pre></td></tr></table></figure></p><p>每个成员的含义都是易于理解的。为了创建这个描述结构体，我们在<i><font color="Orange">Vertex</font></i>结构体中新增一个创建该结构体的静态函数<i><font color="Green">staticVkVertexInputBindingDescription getBindingDescription()</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> VkVertexInputBindingDescription <span class="hljs-title">getBindingDescription</span><span class="hljs-params">()</span> </span>&#123;<br>    VkVertexInputBindingDescription bindingDescription&#123;&#125;;<br>    <br>    VkVertexInputBindingDescription bindingDescription&#123;&#125;;<br>bindingDescription.binding = <span class="hljs-number">0</span>;<br>bindingDescription.stride = <span class="hljs-built_in">sizeof</span>(Vertex);<br>bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;<br>    <br>    <span class="hljs-keyword">return</span> bindingDescription;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="vkvertexinputattributedescription">VkVertexInputAttributeDescription</h4><p>该结构体用于描述顶点属性，帮助开发者定义如何从顶点缓冲区中提取和解释数据，它的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VkVertexInputAttributeDescription</span> &#123;<br>    <span class="hljs-type">uint32_t</span>    location;<span class="hljs-comment">//属性的索引，表示在着色器中的位置，通常与顶点着色器中的输入变量对应</span><br>    <span class="hljs-type">uint32_t</span>    binding;<span class="hljs-comment">//绑定的索引，指向 VkVertexInputBindingDescription 中定义的绑定，表明该属性属于哪个顶点缓冲区</span><br>    VkFormat    format;<span class="hljs-comment">//属性的数据格式</span><br>    <span class="hljs-type">uint32_t</span>    offset;<span class="hljs-comment">//相对于绑定缓冲区中每个顶点的起始位置的偏移量，指明该属性在顶点数据中的具体位置</span><br>&#125; VkVertexInputAttributeDescription;<br></code></pre></td></tr></table></figure><p>有多少个顶点属性，我们就需要定义多少个相应的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkVertexInputAttributeDescription.html"><code>VkVertexInputAttributeDescription</code></a>结构体。该结构体中的第一个成员<i><font color="Orange">location</font></i>就对应了着色器代码中对应输入顶点属性的location。另外，结构体中的属性格式也要和着色器代码中对应属性数据格式相对应。一般来讲，该结构体中属性格式的颜色通道数应该要和着色器中属性数据的向量长度一致。同样，我们在<i><font color="Orange">Vertex</font></i>结构体中新增一个创建该结构体的静态函数<i><font color="Green">staticstd::array&lt;VkVertexInputAttributeDescription, 2&gt;getAttributeDescriptions()</font></i>（因为我们有两种属性，所以返回一个二元数组）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> std::array&lt;VkVertexInputAttributeDescription, 2&gt; <span class="hljs-title">getAttributeDescriptions</span><span class="hljs-params">()</span> </span>&#123;<br>    std::array&lt;VkVertexInputAttributeDescription, 2&gt; attributeDescriptions&#123;&#125;;<br><br>    attributeDescriptions[<span class="hljs-number">0</span>].binding = <span class="hljs-number">0</span>;<br>attributeDescriptions[<span class="hljs-number">0</span>].location = <span class="hljs-number">0</span>;<br>attributeDescriptions[<span class="hljs-number">0</span>].format = VK_FORMAT_R32G32_SFLOAT;<br>attributeDescriptions[<span class="hljs-number">0</span>].offset = <span class="hljs-built_in">offsetof</span>(Vertex, pos);<br>    <br>    attributeDescriptions[<span class="hljs-number">1</span>].binding = <span class="hljs-number">0</span>;<br>attributeDescriptions[<span class="hljs-number">1</span>].location = <span class="hljs-number">1</span>;<br>attributeDescriptions[<span class="hljs-number">1</span>].format = VK_FORMAT_R32G32B32_SFLOAT;<br>attributeDescriptions[<span class="hljs-number">1</span>].offset = <span class="hljs-built_in">offsetof</span>(Vertex, color);<br>    <br>    <span class="hljs-keyword">return</span> attributeDescriptions;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们准备好了所有顶点输入阶段需要的顶点数据描述结构体，最后我们只需要在创建渲染管线的顶点输入阶段时引用这两个结构体即可（之前我们是没有设置顶点输入阶段的，因为当时顶点数据硬编码在着色器中）。在<i><font color="Green">createGraphicsPipeline</font></i>函数中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> bindingDescription = Vertex::<span class="hljs-built_in">getBindingDescription</span>();<br><span class="hljs-keyword">auto</span> attributeDescriptions = Vertex::<span class="hljs-built_in">getAttributeDescriptions</span>();<br><br>vertexInputInfo.vertexBindingDescriptionCount = <span class="hljs-number">1</span>;<br>vertexInputInfo.vertexAttributeDescriptionCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attributeDescriptions.<span class="hljs-built_in">size</span>());<br>vertexInputInfo.pVertexBindingDescriptions = &amp;bindingDescription;<br>vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/22/CG_api/vulkan/vulkan_tutorial/%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/">上一篇：重建交换链</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/">下一篇：创建顶点缓冲</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>重建交换链</title>
    <link href="/2024/11/22/CG_api/vulkan/vulkan_tutorial/%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/"/>
    <url>/2024/11/22/CG_api/vulkan/vulkan_tutorial/%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>我们的绘制三角形程序已经基本完成了，但仍然有一些问题需要解决。其中一个重要的问题就是当窗口表面发生改变（如缩放）的时候，交换链就不再和窗口表面兼容了。此时为了显示正确的图像到屏幕上我们需要重新构建一个和当下窗口表面兼容的交换链。重建交换链主要需要考虑如下几个问题：</p><ul><li>怎么检测重建交换链的时机</li><li>如何重建交换链</li></ul><p>我们将创建一个<i><font color="Green">voidrecreateSwapchain()</font></i>函数来执行交换链的重建工作。</p><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Swap_chain_recreation">Swapchain recreation</a>章节。</p><hr><h2 id="检测时机方式">检测时机方式</h2><p>还记得我们在<a href="https://zpc-dsg.github.io/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/">渲染和显示</a>这篇文章中曾经提到我们会在之后完善对<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html"><code>vkAcquireNextImageKHR</code></a>和<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>的调试工作吗？事实上，这两个函数也会返回一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkResult.html"><code>VkResult</code></a>类型的值来反映函数执行情况。其中，有两个特殊的可能返回值就和当前交换链是否和窗口表面兼容有关，分别为：</p><ul><li><i><font color="Red">VK_ERROR_OUT_OF_DATE_KHR</font></i>：交换链和表面不兼容并且已经无法继续用于渲染了。</li><li><i><font color="Red">VK_SUBOPTIMAL_KHR</font></i>：交换链仍可用于渲染和显示，但是它和表面的属性已经不完全匹配了。</li></ul><p>因此，我们可以对这两个函数的返回值进行侦测并据此进一步判断是否需要重建交换链。本教程中对应的检测代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br><br>VkResult result = <span class="hljs-built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);<br><br><span class="hljs-keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR) &#123;<br>    <span class="hljs-built_in">recreateSwapChain</span>();<br>    <span class="hljs-keyword">return</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != VK_SUCCESS &amp;&amp; result != VK_SUBOPTIMAL_KHR) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to acquire swap chain image!&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br>result = <span class="hljs-built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);<br><br><span class="hljs-keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR) &#123;<br>    <span class="hljs-built_in">recreateSwapChain</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to present swap chain image!&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure></p><p>然而，这么写代码其实会诱发死锁：注意到栅栏已经在该代码之前重置为未点亮状态，并且需要后续的命令缓冲中的所有命令完成后才能点亮，如果我们缩放了窗口大小，函数会在重建交换链之后直接返回，然而此时栅栏就永远不会被点亮了！于是代码就卡死在了<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html"><code>vkWaitForFences</code></a>上。</p><p>为了解决这个问题，我们可以将<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/vkResetFences.html"><code>vkResetFences</code></a>放在对<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html"><code>vkAcquireNextImageKHR</code></a>返回结果的处理代码后，这样即使因为重建交换链返回了也可以保证此时栅栏仍然是点亮状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkWaitForFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);<br><br><span class="hljs-type">uint32_t</span> imageIndex;<br>VkResult result = <span class="hljs-built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);<br><br><span class="hljs-keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR) &#123;<br>    <span class="hljs-built_in">recreateSwapChain</span>();<br>    <span class="hljs-keyword">return</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != VK_SUCCESS &amp;&amp; result != VK_SUBOPTIMAL_KHR) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to acquire swap chain image!&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">vkResetFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame]);<br></code></pre></td></tr></table></figure><p>不过这还不算结束。尽管许多平台在窗口大小调整之后会自动触发<i><font color="Red">VK_ERROR_OUT_OF_DATE_KHR</font></i>，但并非所有的硬件都会保证这一点。因此，为了真正在所有平台上都能精准检测到窗口大小的变化，我们还应该显式地获取窗口大小信息以检测其大小变化。为了显式地获取窗口信息并据此决定是否重建交换链，我们需要设置一个窗口回调函数<i><font color="Green">staticvoid framebufferResizeCallback(GLFWwindow* window, int width, intheight)</font></i>以供<a href="https://www.glfw.org/docs/3.3/group__window.html#ga3c96d80d363e67d13a41b5d1821f3242"><code>GLFWwindow</code></a>对象在侦测到窗口大小改变时调用，并且在类内新建一个成员<i><font color="Orange">boolframebufferResized</font></i>用于指示窗口大小是否发生了变换。之所以将这个函数设置为静态函数是因为<a href="https://www.glfw.org/docs/3.3/group__window.html#ga3c96d80d363e67d13a41b5d1821f3242"><code>GLFWwindow</code></a>对象并不知道如何正确调用一个带有this指针的成员回调函数。</p><p>尽管<a href="https://www.glfw.org/docs/3.3/group__window.html#ga3c96d80d363e67d13a41b5d1821f3242"><code>GLFWwindow</code></a>对象不能正确处理this指针，但它允许使用<a href="https://www.glfw.org/docs/3.3/group__window.html#ga3d2fc6026e690ab31a13f78bc9fd3651"><code>glfwSetWindowUserPointer</code></a>在该对象内保存一个任意类型的指针。我们可以利用这个指针保存我们的this指针以便在回调函数中改变应用程序类中的<i><font color="Orange">framebufferResized</font></i>的值。</p><p>回调函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">framebufferResizeCallback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> app = <span class="hljs-built_in">reinterpret_cast</span>&lt;HelloTriangleApplication*&gt;(<span class="hljs-built_in">glfwGetWindowUserPointer</span>(window));<br>    app-&gt;framebufferResized = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们需要在GLFW窗口系统中设置这个回调函数，这可以通过在窗口初始化成员函数<i><font color="Green">initWindow</font></i>中使用<a href="https://www.glfw.org/docs/3.3/group__window.html#gab3fb7c3366577daef18c0023e2a8591f"><code>glfwSetFramebufferSizeCallback</code></a>函数来完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initWindow</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">glfwInit</span>();<br><br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CLIENT_API, GLFW_NO_API);<br><br>    window = <span class="hljs-built_in">glfwCreateWindow</span>(WIDTH, HEIGHT, <span class="hljs-string">&quot;Vulkan&quot;</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(window, framebufferResizeCallback);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们需要在检测<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>返回结果的代码中加入对<i><font color="Orange">framebufferResized</font></i>值的检测，一旦它变为真，就重建交换链：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">result = <span class="hljs-built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);<br><br><span class="hljs-keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || framebufferResized) &#123;<br>   framebufferResized = <span class="hljs-literal">false</span>;<br>   <span class="hljs-built_in">recreateSwapChain</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != VK_SUCCESS) &#123;<br>   <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to present swap chain image!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就处理好了因为窗口大小改变造成的交换链图像失效问题。</p><hr><h2 id="重建交换链">重建交换链</h2><p>重建交换链的函数<i><font color="Green">recreateSwapChain</font></i>完全可以重用我们之前创建交换链所使用的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recreateSwapChain</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">vkDeviceWaitIdle</span>(device);<br><br>    <span class="hljs-built_in">cleanupSwapChain</span>();<br>    <br>    <span class="hljs-built_in">createSwapChain</span>();<br>    <span class="hljs-built_in">createImageViews</span>();<br>    <span class="hljs-built_in">createFramebuffers</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>想要重建交换链，只需重新创建交换链对象，以及它对应的图像视图和帧缓冲对象即可。图像不用手动重新创建，因为交换链对象的创建本身会自动生成相应的图像。另外，我们在函数头也需要首先等待设备完成其它正在进行的工作，因为我们不希望在旧的交换链仍然有工作没有完成时就清除掉旧的交换链。</p><p>这里我们新创建了一个成员函数<i><font color="Green">voidcleanupSwapChain()</font></i>来完成对交换链的销毁工作，它同样可以重用<i><font color="Green">cleanup</font></i>函数中销毁交换链有关的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cleanupSwapChain</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainFramebuffers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-built_in">vkDestroyFramebuffer</span>(device, swapChainFramebuffers[i], <span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainImageViews.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-built_in">vkDestroyImageView</span>(device, swapChainImageViews[i], <span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">vkDestroySwapchainKHR</span>(device, swapChain, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就完成了重建交换链的工作。好吧，实际上还有一种特殊的情况我们没有给予关注，那就是最小化窗口的时候。窗口最小化的时候，我们有理由希望此时我们的应用程序暂时停止渲染有关的一切工作，直到用户再次打开应用界面。因此，我们可以在<i><font color="Green">recreateSwapChain</font></i>函数的开头处加入以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recreateSwapChain</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> width = <span class="hljs-number">0</span>, height = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);<br>    <span class="hljs-keyword">while</span> (width == <span class="hljs-number">0</span> || height == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);<br>        <span class="hljs-built_in">glfwWaitEvents</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">vkDeviceWaitIdle</span>(device);<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果最小化，那么帧缓冲大小会变为0，这样我们就可以通过判断该大小是否为0来决定是否需要暂时挂起我们的程序。</p><p>另外，教程评论区有人发现这段处理最小化的代码仍然有疏漏之处：如果在最小化窗口时右键点击任务栏程序图标关闭程序，那么此时尽管窗口关闭了，但<a href="https://www.glfw.org/docs/3.3/group__window.html#ga554e37d781f0a997656c26b2c56c835e"><code>glfwWaitEvents</code></a>仍然处于等待状态，因此此时程序并不会终止而是仍然处于挂起运行的状态。于是，我们需要在处理最小化的代码中显式处理窗口关闭的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (width == <span class="hljs-number">0</span> || height == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwWindowShouldClose</span>(window))<br>        <span class="hljs-keyword">return</span>;<br>    <br>        <span class="hljs-built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);<br>        <span class="hljs-built_in">glfwWaitEvents</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><p>终于大功告成！</p><p>接下来的章节我们将开启一个新的主题：顶点缓冲。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/20/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E5%B8%A7%E5%90%8C%E6%97%B6%E6%B8%B2%E6%9F%93/">上一篇：多帧同时渲染</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0/">下一篇：顶点输入描述</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多帧同时渲染</title>
    <link href="/2024/11/20/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E5%B8%A7%E5%90%8C%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    <url>/2024/11/20/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E5%B8%A7%E5%90%8C%E6%97%B6%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在<a href="https://zpc-dsg.github.io/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/">上一章</a>我们提到，目前应用程序只支持一帧一帧地渲染，但是我们会更希望下一帧的命令录制等操作可以和上一帧的渲染同时进行以提高效率。因此，本节就来实现多帧同时渲染。</p><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Frames_in_flight">Framesin flight</a>章节。</p><hr><h2 id="多帧同时渲染">多帧同时渲染</h2><p>首先，我们来指定需要多少帧同时进行工作，在类外定义一个帧数常量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_FRAMES_IN_FLIGHT = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>我们这里指定两帧。</p><p>接下来，我们需要将命令缓冲、信号量、栅栏资源数目均翻倍，因为我们希望每一帧拥有自己独立的命令和同步资源，这样两帧同时工作的时候就不会互相干扰。因此，将类内相应成员改动如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;VkCommandBuffer&gt; commandBuffers;<br><br>std::vector&lt;VkSemaphore&gt; imageAvailableSemaphores;<br>std::vector&lt;VkSemaphore&gt; renderFinishedSemaphores;<br>std::vector&lt;VkFence&gt; inFlightFences;<br></code></pre></td></tr></table></figure><p>现在，我们需要修改一下相应资源的构建函数。首先将构建命令缓冲的成员函数<i><font color="Green">createCommandBuffer</font></i>改为<i><font color="Green">createCommandBuffers</font></i>，将函数体做如下改动即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createCommandBuffers</span><span class="hljs-params">()</span> </span>&#123;<br>    commandBuffers.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br>    <span class="hljs-comment">//...</span><br>    allocInfo.commandBufferCount = (<span class="hljs-type">uint32_t</span>) commandBuffers.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkAllocateCommandBuffers</span>(device, &amp;allocInfo, commandBuffers.<span class="hljs-built_in">data</span>()) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to allocate command buffers!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样，<i><font color="Green">createSyncObjects</font></i>函数也需要做如下改动以创建多个信号量和栅栏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createSyncObjects</span><span class="hljs-params">()</span> </span>&#123;<br>    imageAvailableSemaphores.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br>    renderFinishedSemaphores.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br>    inFlightFences.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br><br>    VkSemaphoreCreateInfo semaphoreInfo&#123;&#125;;<br>    semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;<br><br>    VkFenceCreateInfo fenceInfo&#123;&#125;;<br>    fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;<br>    fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;imageAvailableSemaphores[i]) != VK_SUCCESS ||<br>            <span class="hljs-built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;renderFinishedSemaphores[i]) != VK_SUCCESS ||<br>            <span class="hljs-built_in">vkCreateFence</span>(device, &amp;fenceInfo, <span class="hljs-literal">nullptr</span>, &amp;inFlightFences[i]) != VK_SUCCESS) &#123;<br><br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create synchronization objects for a frame!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>资源创建完毕了，接下来我们就可以着手多帧渲染了。首先在类内添加一个成员<i><font color="Orange">currentFrame</font></i>代表初始帧索引：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> currentFrame = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>由于我们想要同时渲染两帧，因此每一帧的最后我们都需要将索引切换到另一个并且在该帧内使用相应索引的资源。对<i><font color="Green">drawFrame</font></i>函数的改动部分如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">vkWaitForFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);<br>    <span class="hljs-built_in">vkResetFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame]);<br><br>    <span class="hljs-built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);<br><br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-built_in">vkResetCommandBuffer</span>(commandBuffers[currentFrame],  <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">recordCommandBuffer</span>(commandBuffers[currentFrame], imageIndex);<br><br>    <span class="hljs-comment">//...</span><br><br>    submitInfo.pCommandBuffers = &amp;commandBuffers[currentFrame];<br><br>    <span class="hljs-comment">//...</span><br><br>    VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphores[currentFrame]&#125;;<br><br>    <span class="hljs-comment">//...</span><br><br>    VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphores[currentFrame]&#125;;<br><br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkQueueSubmit</span>(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//...</span><br>    <br>    currentFrame = (currentFrame + <span class="hljs-number">1</span>) % MAX_FRAMES_IN_FLIGHT;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们给出教程中<i><font color="Green">drawFrame</font></i>函数的完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">vkWaitForFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);<br>    <span class="hljs-built_in">vkResetFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame]);<br><br>    <span class="hljs-type">uint32_t</span> imageIndex;<br>    <span class="hljs-built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);<br><br>    <span class="hljs-built_in">vkResetCommandBuffer</span>(commandBuffers[currentFrame], <span class="hljs-comment">/*VkCommandBufferResetFlagBits*/</span> <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">recordCommandBuffer</span>(commandBuffers[currentFrame], imageIndex);<br><br>    VkSubmitInfo submitInfo&#123;&#125;;<br>    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;<br><br>    VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphores[currentFrame]&#125;;<br>    VkPipelineStageFlags waitStages[] = &#123;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&#125;;<br>    submitInfo.waitSemaphoreCount = <span class="hljs-number">1</span>;<br>    submitInfo.pWaitSemaphores = waitSemaphores;<br>    submitInfo.pWaitDstStageMask = waitStages;<br><br>    submitInfo.commandBufferCount = <span class="hljs-number">1</span>;<br>    submitInfo.pCommandBuffers = &amp;commandBuffers[currentFrame];<br><br>    VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphores[currentFrame]&#125;;<br>    submitInfo.signalSemaphoreCount = <span class="hljs-number">1</span>;<br>    submitInfo.pSignalSemaphores = signalSemaphores;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkQueueSubmit</span>(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to submit draw command buffer!&quot;</span>);<br>    &#125;<br><br>    VkPresentInfoKHR presentInfo&#123;&#125;;<br>    presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;<br><br>    presentInfo.waitSemaphoreCount = <span class="hljs-number">1</span>;<br>    presentInfo.pWaitSemaphores = signalSemaphores;<br><br>    VkSwapchainKHR swapChains[] = &#123;swapChain&#125;;<br>    presentInfo.swapchainCount = <span class="hljs-number">1</span>;<br>    presentInfo.pSwapchains = swapChains;<br><br>    presentInfo.pImageIndices = &amp;imageIndex;<br><br>    <span class="hljs-built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);<br><br>    currentFrame = (currentFrame + <span class="hljs-number">1</span>) % MAX_FRAMES_IN_FLIGHT;<br>&#125;<br></code></pre></td></tr></table></figure><p>大功告成！</p><hr><h2 id="一些疑点">一些疑点</h2><p>关于本篇教程我有一点同样百思不得其解。</p><p>显然在上文<i><font color="Green">drawFrame</font></i>代码中，索引不同的两帧之间的工作是互不干扰的，因为它们各自具有独立的一套命令缓冲和同步对象。但是问题在于如果这样的话，那么本应先后渲染的两帧最后渲染和显示的顺序不是也就不确定了吗？比如说有两帧在同时工作，本应先显示的前一帧因为某种原因工作时长较长，但是因为它和后一帧使用不同的信号量，因此前一帧还在工作并不能迫使后一帧等待前一帧完成工作，那么这不就可能出现后一帧先渲染显示的情况了吗？</p><p>在我看来，本篇教程的目的应该在于充分调动CPU，使得GPU在工作的时候已经完成本帧工作的CPU可以继续进行下一帧的工作，而GPU仍然应该按照顺序一帧一帧地运行。那么如果按照这么理解的话不是应该栅栏要有多个，而每个信号量成员仍然只有一个吗？这样才能在保证GPU上的运行顺序的同时让CPU进行更多的工作吧？大惑不解，望高人指点~</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/">上一篇：渲染和显示</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/22/CG_api/vulkan/vulkan_tutorial/%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/">下一篇：重建交换链</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>渲染和显示</title>
    <link href="/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/"/>
    <url>/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>现在我们已经做好了绘制三角形所需要的所有准备工作，下面我们将创建一个<i><font color="Green">voiddrawFrame()</font></i>函数用于渲染循环中来进行真正的绘制和显示三角形的工作。</p><p>一帧中需要进行的工作主要分为以下五步：</p><ul><li>等待上一帧结束</li><li>从交换链获取一张图像用于渲染</li><li>录制命令</li><li>提交命令进行渲染</li><li>显示渲染好的图像</li></ul><p>在这五步中，第二、四、五步的部分或全部工作在GPU上完成，但是Vulkan中许多在GPU上工作的函数都是异步的，也就是说这种函数返回时函数内部的指令可能仍然在运行。因此，我们需要适当的同步手段来保证这三步一定是按顺序进行的，后者只有在前者完成工作时才会继续执行。</p><p>另外，我们还希望在开始下一帧的渲染之前上一帧命令缓冲中的命令都已经执行完毕了，这样才能保证下一帧开始录制命令时不会重置或覆盖正在执行的命令。这种情形和上文描述的GPU同步略有不同，因为等待上一帧结束这个过程应该发生在CPU端，所以我们还希望能够有一种同步机制来调节GPU和CPU间的操作顺序。</p><p>本文将首先介绍为达到上述同步目的应该使用的同步机制与同步对象，然后再顺次介绍渲染一帧的完整流程。最后，我将给出一个对本章节自己百思不得其解的疑点，当作一个有待日后解答的开放性问题。</p><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Rendering_and_presentation#page_What-to-choose">Renderingand presentation</a>章节。</p><hr><h2 id="同步操作概述">同步操作概述</h2><p>概述部分我们已经看到了，需要同步的操作可以分成两类：交换链上的操作（获取图像和显示图像）以及等待上一帧结束的操作。这两种操作需要两种不同的同步量，因为前者完全发生在GPU上，后者涉及GPU和CPU的通信。这里我们将分别使用<strong>信号量（Semaphore）</strong>和<strong>栅栏（Fence）</strong>作为这两种操作的同步工具，下面分别介绍这两种同步量并且创建需要的对应同步对象。</p><hr><h2 id="同步对象创建">同步对象创建</h2><p>我们将在类内创建一个<i><font color="Green">voidcreateSyncObjects()</font></i>函数来创建所需的同步对象。</p><h4 id="信号量简介semaphore">信号量简介（Semaphore）</h4><p>事实上，Vulkan中的信号量包含两种：二进制信号量（BinarySemaphore）以及时间线信号量（TimelineSemaphore）。二进制信号量只能取两个值：0 或1。它通常用于实现互斥锁或简单的资源访问控制，而时间线信号量是一种更复杂的信号量，允许多个值，并且可以用于更复杂的同步场景。它通常用于图形编程和GPU任务调度。我们之后仅使用二进制信号量，因此后文但凡涉及信号量指的都是二进制信号量。</p><p>如没有任何特殊设置，信号量一开始是未点亮的（unsignaled），它的使用方法一般是需要先完成的操作负责点亮这个信号量，该操作会在完成后点亮信号量，而需要后完成的操作等待这个信号量被点亮，一旦它发现该信号量被点亮，该操作就可以开始执行了，并且此时信号量自动复位为未点亮状态，这样它就可以被继续使用了。</p><h4 id="栅栏简介fence">栅栏简介（Fence）</h4><p>栅栏和信号量的作用类似，但是它是用来同步CPU，也就是所谓的<strong>host</strong>上操作的顺序的。简单来讲，当CPU端需要知道GPU端什么时候完成了指定工作时，我们就可以使用栅栏。</p><p>栅栏的使用方式一般是给GPU上某一项工作指定一个栅栏对象，该对象会在该工作完成时被点亮，CPU端会等待这个栅栏被点亮之后再执行下一步的工作。但是使用栅栏会阻塞CPU端的工作，也就是说GPU端的工作没有完成的话，CPU端是无法做任何工作的（这与信号量不同，信号量并不会阻塞GPU执行其它工作）。另外，栅栏也并不会自动复位为未点亮状态，而是需要CPU端手动复位。</p><h4 id="创建所需信号量">创建所需信号量</h4><p>前面我们提到了，我们需要在从交换链获取图像和在渲染完毕后准备显示这两个节点处设置信号量以固定它们的执行顺序。因此，我们在类内创建两个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSemaphore.html"><code>VkSemaphore</code></a>成员<i><font color="Orange">imageAvailableSemaphore</font></i>和<i><font color="Orange">renderFinishedSemaphore</font></i>。为了创建信号量，我们同样需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSemaphoreCreateInfo.html"><code>VkSemaphoreCreateInfo</code></a>结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSemaphoreCreateInfo</span> &#123;</span><br>    VkStructureType           sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*               pNext;<br>    VkSemaphoreCreateFlags    flags;<span class="hljs-comment">//目前还没有</span><br>&#125; VkSemaphoreCreateInfo;<br></code></pre></td></tr></table></figure><p>这个信息结构体只包含最基本的几个成员，因此填写十分简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSemaphoreCreateInfo semaphoreInfo&#123;&#125;;<br>semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;<br></code></pre></td></tr></table></figure><p>接下来只需调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateSemaphore.html"><code>vkCreateSemaphore</code></a>创建相应对象即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;imageAvailableSemaphore) != VK_SUCCESS ||<br>    <span class="hljs-built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;renderFinishedSemaphore) != VK_SUCCESS || &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create semaphores!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建所需栅栏">创建所需栅栏</h4><p>我们需要创建一个用于告知CPU端GPU上的命令缓冲中的命令已经执行完毕，可以开启下一帧了。因此，在类内添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFence.html"><code>VkFence</code></a>类型的对象<i><font color="Orange">inFlightFence</font></i>，然后在<i><font color="Green">createSyncObjects</font></i>函数中填写创建信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFenceCreateInfo.html"><code>VkFenceCreateInfo</code></a>。其中<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFenceCreateInfo.html"><code>VkFenceCreateInfo</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkFenceCreateInfo</span> &#123;</span><br>    VkStructureType       sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*           pNext;<br>    VkFenceCreateFlags    flags;<br>&#125; VkFenceCreateInfo;<br></code></pre></td></tr></table></figure><p>这里<i><font color="Orange">flags</font></i>成员可能的取值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkFenceCreateFlagBits</span> &#123;</span><br>    VK_FENCE_CREATE_SIGNALED_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//指定栅栏在创建时为被点亮状态</span><br>&#125; VkFenceCreateFlagBits;<br></code></pre></td></tr></table></figure><p>于是填写栅栏信息和创建栅栏的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkFenceCreateInfo fenceInfo&#123;&#125;;<br>fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;<br>fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateFence</span>(device, &amp;fenceInfo, <span class="hljs-literal">nullptr</span>, &amp;inFlightFence) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create semaphores!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>至于这里为什么需要设置栅栏在创建时为点亮状态，我们将在<a href="#上一帧">等待上一帧小节</a>中 加以说明。</p><hr><h2 id="上一帧">等待上一帧</h2><p>在<i><font color="Green">drawFrame</font></i>函数的开头，我们首先需要等待上一帧的结束。为此，我们可以调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html"><code>vkWaitForFences</code></a>函数来等待上一帧的<i><font color="Orange">inFlightFence</font></i>被点亮（点亮操作会在渲染完成后执行）。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html"><code>vkWaitForFences</code></a>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkWaitForFences</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDevice                                    device,    <span class="hljs-comment">//栅栏所属逻辑设备</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    fenceCount,<span class="hljs-comment">//栅栏数目</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkFence*                              pFences,   <span class="hljs-comment">//栅栏</span></span><br><span class="hljs-params">    VkBool32                                    waitAll,   <span class="hljs-comment">//是否等待所有栅栏都被点亮</span></span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span>                                    timeout)</span>;  <span class="hljs-comment">//等待时长  </span><br></code></pre></td></tr></table></figure><p>可以看到，我们可以指定CPU端等待多个栅栏，<i><font color="Orange">waitAll</font></i>参数可以指定我们需要等待其中所有栅栏都被点亮还是等待其中任意一个被点亮。<i><font color="Orange">timeout</font></i>指定最长的等待时限，如果在该时限内等待的栅栏被点亮了，那么该函数将返回<i><font color="Red">VK_SUCCESS</font></i>，否则，该函数会返回<i><font color="Red">VK_TIMEOUT</font></i>。</p><p>在我们的应用程序中，我们只有一个栅栏，并且不需要设置等待时限，于是我们可以如下调用该函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">vkWaitForFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFence, VK_TRUE, UINT64_MAX);<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，在栅栏被成功点亮后，我们需要手动重置其为非点亮状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkResetFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFence);<br></code></pre></td></tr></table></figure><p>等待上一帧的操作就结束了。不过，细心的读者可能会注意到一个违和之处：每次进入下一帧的时候都要等待上一帧的栅栏被点亮，但如果是第一帧呢？它没办法等待上一帧点亮栅栏，因此在第一次循环进入到该函数时栅栏就处于未点亮的状态，那么<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html"><code>vkWaitForFences</code></a>永远无法成功返回！这个问题其实有很多的解决方案，在本教程中我们是通过上文创建栅栏时将其初始状态设置为点亮状态来实现的，这样就可以轻松解决这个问题~</p><hr><h2 id="获取交换链图像">获取交换链图像</h2><p>在上一帧命令执行结束后，我们就可以获取这一帧渲染需要的图像了。这通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html"><code>vkAcquireNextImageKHR</code></a>来完成。该函数原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br>VkResult <span class="hljs-title function_">vkAcquireNextImageKHR</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDevice                                    device,      <span class="hljs-comment">//需要获取图片的逻辑设备</span></span><br><span class="hljs-params">    VkSwapchainKHR                              swapchain,   <span class="hljs-comment">//图片所在交换链</span></span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span>                                    timeout,     <span class="hljs-comment">//等待获取时长</span></span><br><span class="hljs-params">    VkSemaphore                                 semaphore,   <span class="hljs-comment">//等待操作完成后点亮的信号量</span></span><br><span class="hljs-params">    VkFence                                     fence,       <span class="hljs-comment">//等待操作完成后点亮的栅栏</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>*                                   pImageIndex)</span>;<span class="hljs-comment">//获取的图片的索引</span><br></code></pre></td></tr></table></figure></p><p>我们只需设置一个信号量<i><font color="Orange">imageAvailableSemaphore</font></i>用于等待获取图像操作的结束，因此获取交换链图像的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> imageIndex;<br><span class="hljs-built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphore, VK_NULL_HANDLE, &amp;imageIndex);<br></code></pre></td></tr></table></figure><p>另外需要注意的是，这个函数保证在返回<i><font color="Red">VK_SUCCESS</font></i>时，<i><font color="Orange">imageIndex</font></i>一定是有效且正确的，但是并不保证返回时该函数所进行的一切工作都结束了。</p><hr><h2 id="录制命令">录制命令</h2><p>接下来我们可以录制对获取到的图像所需要进行的命令了（之前提到了尽管先前的<i><font color="Green">vkAcquireNextImageKHR</font></i>可能还没有执行完所有工作，但是图像索引已经得到了，录制命令这步工作是在CPU端进行的，并且只需要用到图像的索引，GPU端还有其它的工作未完成并不影响继续录制命令），因此我们调用<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/"><code>命令缓冲</code></a>章节添加的<i><font color="Green">recordCommandBuffer</font></i>函数来完成所需命令的录制。当然，在此之前我们需要先使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkResetCommandBuffer.html"><code>vkResetCommandBuffer</code></a>重置命令缓冲以清除上一帧录制的命令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkResetCommandBuffer</span>(commandBuffer, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">recordCommandBuffer</span>(commandBuffer, imageIndex);<br></code></pre></td></tr></table></figure><hr><h2 id="提交命令并渲染">提交命令并渲染</h2><p>录制好命令后我们就可以将命令缓冲中的命令提交给队列执行了。提交命令同样需要填写相应的信息<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo.html"><code>VkSubmitInfo</code></a>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSubmitInfo</span> &#123;</span><br>    VkStructureType                sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                    pNext;<br>    <span class="hljs-type">uint32_t</span>                       waitSemaphoreCount;<br>    <span class="hljs-type">const</span> VkSemaphore*             pWaitSemaphores;<br>    <span class="hljs-type">const</span> VkPipelineStageFlags*    pWaitDstStageMask;<br>    <span class="hljs-type">uint32_t</span>                       commandBufferCount;<br>    <span class="hljs-type">const</span> VkCommandBuffer*         pCommandBuffers;<br>    <span class="hljs-type">uint32_t</span>                       signalSemaphoreCount;<br>    <span class="hljs-type">const</span> VkSemaphore*             pSignalSemaphores;<br>&#125; VkSubmitInfo;<br></code></pre></td></tr></table></figure><p>这里唯一需要解释一下的参数就是<i><font color="Orange">pWaitDstStageMask</font></i>，它用于指定每个等待信号量对应在管线中等待的阶段，也就是管线中哪个阶段需要等待该信号量被点亮后才能继续执行。注意，如果渲染管线中对应阶段被执行了多次（比如一个渲染通道中有多个子通道），那么每个该阶段的执行都需要等待该信号量被点亮。</p><p>在我们的应用程序中，我们需要在绘制前等待图像获取完毕，于是我们需要等待的信号量为<i><font color="Orange">imageAvailableSemaphore</font></i>，等待的管线阶段可以设置为<i><font color="Red">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>（全部的管线阶段及其相关信息可以参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlagBits.html">这个页面</a>），这意味着我们只要求在绘制到帧缓冲之前图像必须获取完毕，而在之前的管线阶段，比如顶点着色器运行阶段等则并不要求图像获取完毕，这么做延长了图像获取操作的允许时长，提高了时间利用效率。在命令缓冲中的命令全部执行完毕后，我们还需要点亮<i><font color="Orange">renderFinishedSemaphore</font></i>以告知程序渲染已经完成，可以进行后续的显示操作了。因此，该信息结构体的填写代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSubmitInfo submitInfo&#123;&#125;;<br>submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;<br><br>VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphore&#125;;<br>VkPipelineStageFlags waitStages[] = &#123;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&#125;;<br>submitInfo.waitSemaphoreCount = <span class="hljs-number">1</span>;<br>submitInfo.pWaitSemaphores = waitSemaphores;<br>submitInfo.pWaitDstStageMask = waitStages;<br>submitInfo.commandBufferCount = <span class="hljs-number">1</span>;<br>submitInfo.pCommandBuffers = &amp;commandBuffer;<br>VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphore&#125;;<br>submitInfo.signalSemaphoreCount = <span class="hljs-number">1</span>;<br>submitInfo.pSignalSemaphores = signalSemaphores;<br></code></pre></td></tr></table></figure><p>接下来我们需要调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit.html"><code>vkQueueSubmit</code></a>函数执行提交操作，该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkQueueSubmit</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkQueue                                     <span class="hljs-built_in">queue</span>,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    submitCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkSubmitInfo*                         pSubmits,</span><br><span class="hljs-params">    VkFence                                     fence)</span>;<br></code></pre></td></tr></table></figure><p>每一个参数都是易于理解的，其中最后一个参数代表一个可选的在提交的命令运行结束后会被点亮的栅栏。我们显然应该将<i><font color="Orange">inFlightFence</font></i>赋予这个参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkQueueSubmit</span>(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, inFlightFence) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to submit draw command buffer!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，命令提交结束，渲染可以开始了。但是事实上这里仍然存在一个很隐晦的问题：还记得我们的渲染通道中指定了一个子通道吗？事实上，除了这个我们显式设置的通道之外，还存在两个隐式的通道，一个位于渲染通道的开始处，一个位于渲染通道的结束处，这些子通道会通过一种叫做<strong>Subpassdependencies</strong>的结构控制子通道之间图像格式的转换。如果不显式设置这种依赖关系，那么默认的开始处的子通道到我们设置的子通道之间格式的转换将发生在渲染管线的开始阶段（该阶段对应Vulkan中管线阶段的枚举值为<i><font color="Red">VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</font></i>），但是问题是，我们之前设置的提交命令的等待阶段为输出到帧缓冲的阶段，也就是说在<i><font color="Red">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>之前，我们甚至不能保证图像获取操作已经完全结束了，也就是说我们不能保证在这个阶段之前图象是完全有效的，甚至渲染管线开始的时候图像可能还根本没有获取到！当然，我们可以将之前<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo.html"><code>VkSubmitInfo</code></a>中的<i><font color="Orange">pWaitDstStageMask</font></i>设置为<i><font color="Red">VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</font></i>，但是一来这样会使得时间利用率降低，二来我们也希望借此机会探索一下<strong>Subpassdependencies</strong>的结构和设置方式。因此，我们接下来就在<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/"><code>渲染通道</code></a>章节中创建的<i><font color="Green">createRenderPass</font></i>函数中添加手动设置<strong>Subpassdependencies</strong>的相关代码：</p><p>首先还是来看一下依赖关系结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubpassDependency.html"><code>VkSubpassDependency</code></a>的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSubpassDependency</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>                srcSubpass;<span class="hljs-comment">//依赖关系的源子通道的索引。如果设置为 VK_SUBPASS_EXTERNAL，则表示依赖于外部命令（即在渲染通道开始之前的命令）</span><br>    <span class="hljs-type">uint32_t</span>                dstSubpass;<span class="hljs-comment">//依赖关系的目标子通道的索引。如果设置为 VK_SUBPASS_EXTERNAL，则表示依赖于外部命令（即在渲染通道结束之后的命令）。另外，该索引值一定要大于等于srcSubpass表示的索引值以避免循环依赖（除非dstSubpass为VK_SUBPASS_EXTERNAL）</span><br>    VkPipelineStageFlags    srcStageMask;<span class="hljs-comment">//指定源子通道中需要同步的管线阶段。这决定了哪些阶段的操作需要在目标子通道开始之前完成</span><br>    VkPipelineStageFlags    dstStageMask;<span class="hljs-comment">//指定目标子通道中需要同步的管线阶段。这决定了目标子通道中哪些阶段的操作需要等待源子通道的完成</span><br>    VkAccessFlags           srcAccessMask;<span class="hljs-comment">//指定在源子通道中访问的资源类型（如读取、写入等）。这用于确定在源子通道中需要等待的访问类型</span><br>    VkAccessFlags           dstAccessMask;<span class="hljs-comment">//指定在目标子通道中访问的资源类型。这用于确定目标子通道中需要等待的访问类型</span><br>    VkDependencyFlags       dependencyFlags;<span class="hljs-comment">//指定依赖关系的标志，控制依赖行为的特性</span><br>&#125; VkSubpassDependency;<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAccessFlagBits.html"><code>VkAccessFlagBits</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkAccessFlagBits</span> &#123;</span><br>    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = <span class="hljs-number">0x00000001</span>,<br>    VK_ACCESS_INDEX_READ_BIT = <span class="hljs-number">0x00000002</span>,<br>    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = <span class="hljs-number">0x00000004</span>,<br>    VK_ACCESS_UNIFORM_READ_BIT = <span class="hljs-number">0x00000008</span>,<br>    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = <span class="hljs-number">0x00000010</span>,<br>    VK_ACCESS_SHADER_READ_BIT = <span class="hljs-number">0x00000020</span>,<br>    VK_ACCESS_SHADER_WRITE_BIT = <span class="hljs-number">0x00000040</span>,<br>    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = <span class="hljs-number">0x00000080</span>,<br>    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = <span class="hljs-number">0x00000100</span>,<br>    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = <span class="hljs-number">0x00000200</span>,<br>    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = <span class="hljs-number">0x00000400</span>,<br>    VK_ACCESS_TRANSFER_READ_BIT = <span class="hljs-number">0x00000800</span>,<br>    VK_ACCESS_TRANSFER_WRITE_BIT = <span class="hljs-number">0x00001000</span>,<br>    VK_ACCESS_HOST_READ_BIT = <span class="hljs-number">0x00002000</span>,<br>    VK_ACCESS_HOST_WRITE_BIT = <span class="hljs-number">0x00004000</span>,<br>    VK_ACCESS_MEMORY_READ_BIT = <span class="hljs-number">0x00008000</span>,<br>    VK_ACCESS_MEMORY_WRITE_BIT = <span class="hljs-number">0x00010000</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_ACCESS_NONE = <span class="hljs-number">0</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_transform_feedback</span><br>    VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = <span class="hljs-number">0x02000000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_transform_feedback</span><br>    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = <span class="hljs-number">0x04000000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_transform_feedback</span><br>    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = <span class="hljs-number">0x08000000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_conditional_rendering</span><br>    VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = <span class="hljs-number">0x00100000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_blend_operation_advanced</span><br>    VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = <span class="hljs-number">0x00080000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br>    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = <span class="hljs-number">0x00200000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br>    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = <span class="hljs-number">0x00400000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_fragment_density_map</span><br>    VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = <span class="hljs-number">0x01000000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_fragment_shading_rate</span><br>    VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = <span class="hljs-number">0x00800000</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_device_generated_commands</span><br>    VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV = <span class="hljs-number">0x00020000</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_device_generated_commands</span><br>    VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV = <span class="hljs-number">0x00040000</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_shading_rate_image</span><br>    VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR,<br>  <span class="hljs-comment">// Provided by VK_NV_ray_tracing</span><br>    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR,<br>  <span class="hljs-comment">// Provided by VK_NV_ray_tracing</span><br>    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR,<br>  <span class="hljs-comment">// Provided by VK_KHR_synchronization2</span><br>    VK_ACCESS_NONE_KHR = VK_ACCESS_NONE,<br>  <span class="hljs-comment">// Provided by VK_EXT_device_generated_commands</span><br>    VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT = VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV,<br>  <span class="hljs-comment">// Provided by VK_EXT_device_generated_commands</span><br>    VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT = VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV,<br>&#125; VkAccessFlagBits;<br></code></pre></td></tr></table></figure><p>每一个枚举都代表一种资源访问类型，我们这里不做过多解释。</p><p><a href="https://www.zhihu.com/question/424430509/answer/1632072443"><code>VkDependencyFlagBits</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDependencyFlagBits</span> &#123;</span><br>    VK_DEPENDENCY_BY_REGION_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//表示依赖关系是基于区域的。这意味着在源和目标子通道之间的依赖关系是区域相关的，确保在访问同一区域时不会发生数据竞争</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_DEPENDENCY_DEVICE_GROUP_BIT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//表示依赖关系涉及设备组。这在使用多个 GPU 时特别有用，确保在设备组中的不同设备之间的操作顺序</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_DEPENDENCY_VIEW_LOCAL_BIT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//表示依赖关系是视图局部的。这通常用于多视图渲染，确保在不同视图之间的依赖关系是局部的，适合多视图场景的渲染</span><br>  <span class="hljs-comment">// Provided by VK_EXT_attachment_feedback_loop_layout</span><br>    VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//这是一个扩展标志，表示存在反馈循环的依赖关系。这通常用于处理需要在多个渲染通道之间进行反馈的场景</span><br>  <span class="hljs-comment">// Provided by VK_KHR_multiview</span><br>    VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = VK_DEPENDENCY_VIEW_LOCAL_BIT,<br>  <span class="hljs-comment">// Provided by VK_KHR_device_group</span><br>    VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = VK_DEPENDENCY_DEVICE_GROUP_BIT,<br>&#125; VkDependencyFlagBits;<br></code></pre></td></tr></table></figure><p>根据前文的叙述，我们需要重新设置开始处子通道和我们设置的子通道之间的依赖关系。相应的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSubpassDependency dependency&#123;&#125;;<br><br>dependency.srcSubpass = VK_SUBPASS_EXTERNAL;<br>dependency.dstSubpass = <span class="hljs-number">0</span>;<br>dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;<br>dependency.srcAccessMask = <span class="hljs-number">0</span>;<br>dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;<br>dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;<br></code></pre></td></tr></table></figure><p>我们将<i><font color="Orange">srcStageMask</font></i>设置为<i><font color="Red">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>，这样开始时的图像格式转换就会发生在该阶段之后，此时可以保证图像是存在有效的。另外，将<i><font color="Orange">srcAccessMask</font></i>设置为0意味着我们并不需要等待开始处子通道完成任何资源访问操作，事实上我们也没有在该子通道处有什么特别的操作要进行。之后<i><font color="Orange">dstStageMask</font></i>同样设置为<i><font color="Red">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>，资源访问操作<i><font color="Orange">dstAccessMask</font></i>设置为<i><font color="Red">VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</font></i>以指定将渲染结果写入帧缓冲的操作要在图像格式已经成功转换之后再执行。（不过知乎上的<a href="https://www.zhihu.com/question/424430509/answer/1632072443">一篇文章</a>里说这部分其实写的有问题，我也始终感觉这一部分想得不明不白的。。。望高人指点</p><p>最后不要忘了在<i><font color="Orange">renderPassInfo</font></i>中指定依赖关系成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">renderPassInfo.dependencyCount = <span class="hljs-number">1</span>;<br>renderPassInfo.pDependencies = &amp;dependency;<br></code></pre></td></tr></table></figure><hr><h2 id="显示图像">显示图像</h2><p>最后，我们只需要将渲染好的图像显示到屏幕上即可。为此，我们需要首先填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPresentInfoKHR.html"><code>VkPresentInfoKHR</code></a>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPresentInfoKHR</span> &#123;</span><br>    VkStructureType          sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*              pNext;<br>    <span class="hljs-type">uint32_t</span>                 waitSemaphoreCount;<br>    <span class="hljs-type">const</span> VkSemaphore*       pWaitSemaphores;<br>    <span class="hljs-type">uint32_t</span>                 swapchainCount;<br>    <span class="hljs-type">const</span> VkSwapchainKHR*    pSwapchains;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*          pImageIndices;<br>    VkResult*                pResults;<br>&#125; VkPresentInfoKHR;<br></code></pre></td></tr></table></figure><p>这里只需要解释一下最后一个成员<i><font color="Orange">pResults</font></i>，该参数会返回每个对应交换链显示图像的结果是否成功。如果只有一个交换链（事实上绝大多数的情况也是如此），那么就没有必要指定这个成员，因为我们可以直接使用显示函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>的返回值来查看图像显示是否成功。</p><p>我们的填写代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPresentInfoKHR presentInfo&#123;&#125;;<br>presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;<br><br>presentInfo.waitSemaphoreCount = <span class="hljs-number">1</span>;<br>presentInfo.pWaitSemaphores = signalSemaphores;<br><br>VkSwapchainKHR swapChains[] = &#123;swapChain&#125;;<br>presentInfo.swapchainCount = <span class="hljs-number">1</span>;<br>presentInfo.pSwapchains = swapChains;<br>presentInfo.pImageIndices = &amp;imageIndex;<br></code></pre></td></tr></table></figure><p>由于我们需要等待渲染操作结束才能显示图像，因此<i><font color="Orange">pWaitSemaphores</font></i>应该设置为<i><font color="Orange">renderFinishedSemaphore</font></i>。</p><p>最后，使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>显示图像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);<br></code></pre></td></tr></table></figure><p>注意到这里我们并没有使用这个函数调用的返回值，包括之前在调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html"><code>vkAcquireNextImageKHR</code></a>的时候我们也没有这么做，因为和之前的函数不同，这两个函数即使返回错误值，也不意味着我们需要立即终止我们的程序，所以我们会在之后的章节中单独处理这两个函数的调试。</p><p>这样，我们终于成功绘制了Vulkan中的第一个三角形！天哪，这真是一段漫长的旅程。。。</p><figure><img src="/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/first_triangle.png" alt="第一个三角形"><figcaption aria-hidden="true">第一个三角形</figcaption></figure><p>不过没有那么多时间沉浸在自我感动中了，因为接下来赶到战场的是验证层的报错。。。是的，心满意足地欣赏完近1000行代码编写出来的“鸿篇巨制”之后，准备退出程序的你此时却必然会受到验证层的最后一击：</p><figure><img src="/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/validation_error.png" alt="不老实的验证层"><figcaption aria-hidden="true">不老实的验证层</figcaption></figure><p>这是为什么？</p><p>事实上原因在于我们在最后一帧结束程序时，退出循环后CPU会执行<i><font color="Green">cleanup</font></i>函数来清理掉所有Vulkan对象，但是还记得我们之前说GPU上的一些函数在返回后相应的工作还可能在运行吗？问题就出在这里！有些GPU上的工作还没执行完毕我们就清理掉了相应的资源！</p><p>解决方法也有很多，我们这里采取一种简单粗暴的方式即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mainLoop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">glfwWindowShouldClose</span>(window)) &#123;<br>        <span class="hljs-built_in">glfwPollEvents</span>();<br>        <span class="hljs-built_in">drawFrame</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">vkDeviceWaitIdle</span>(device);<br>&#125;<br></code></pre></td></tr></table></figure><p>在渲染循环之后加入<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDeviceWaitIdle.html"><code>vkDeviceWaitIdle</code></a>来等待所有的队列操作执行完毕再进行清理工作，这样我们终于可以安心退出程序而不用担心验证层的抱怨了！太棒了！</p><hr><h2 id="一个小疑点">一个小疑点</h2><p>关于这一节我仍然有一个疑问没有解决，那就是关于显示图像的同步问题。</p><p>假设这么一种情况：当前帧运行到了<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>，由于该函数运行在GPU上，它可能没有完成显示就已经返回了，此时<i><font color="Green">drawFrame</font></i>函数进入下一帧，由于此时所有的信号量、栅栏、命令缓冲等都处于可用状态，因此下一帧会畅通无阻地运行到<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>，那么万一此时上一帧的显示因为种种原因还没有完成呢？岂不是会同时显示两帧图像？</p><p>我发现Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Rendering_and_presentation#page_What-to-choose">Renderingand presentation</a>章节评论区中有人也提出了类似的问题：</p><figure><img src="/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/comments.png" alt="疑点"><figcaption aria-hidden="true">疑点</figcaption></figure><p>可以看到有人给出了一些可能的解释，不过也并没有完全回答这种类似的问题。因此暂时保留该疑问，以待日后思考~</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/">上一篇：命令缓冲</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/20/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E5%B8%A7%E5%90%8C%E6%97%B6%E6%B8%B2%E6%9F%93/">下一篇：多帧同时渲染</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>命令缓冲</title>
    <link href="/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/"/>
    <url>/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在Vulkan中，执行命令不是简单地通过调用函数来实现的。我们需要将命令记录在命令缓冲中，然后将该缓冲提交给队列执行。这么做的优点是我们可以将所有命令统一打包提交以便Vulkan优化执行过程。</p><p>记录下绘制一个三角形需要的命令主要分为三步：</p><ul><li>创建命令池<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandPool.html"><code>VkCommandPool</code></a></li><li>从命令池分配出需要数目的命令缓冲<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html"><code>VkCommandBuffer</code></a></li><li>录制需要执行的命令到分配出的命令缓冲</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Command_buffers">Commandbuffers</a>章节。</p><hr><h2 id="创建命令池">创建命令池</h2><p>命令缓冲必须从某个管理缓冲内存的内存池中分配。因此我们在应用程序类内添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandPool.html"><code>VkCommandPool</code></a>类型的成员<i><font color="Orange">commandPool</font></i>，并且创建一个<i><font color="Green">voidcreateCommandPool()</font></i>函数来构建该对象。</p><p>首先我们当然需要填写构建信息<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateInfo.html"><code>VkCommandPoolCreateInfo</code></a>，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkCommandPoolCreateInfo</span> &#123;</span><br>    VkStructureType             sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                 pNext;<br>    VkCommandPoolCreateFlags    flags;<br>    <span class="hljs-type">uint32_t</span>                    queueFamilyIndex;<br>&#125; VkCommandPoolCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>可以是以下值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkCommandPoolCreateFlagBits</span> &#123;</span><br>    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = <span class="hljs-number">0x00000001</span>,<br>    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = <span class="hljs-number">0x00000002</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_COMMAND_POOL_CREATE_PROTECTED_BIT = <span class="hljs-number">0x00000004</span>,<br>&#125; VkCommandPoolCreateFlagBits;<br></code></pre></td></tr></table></figure><p>我们来详细解释一下这些标志位：</p><ul><li><p><i><font color="Red">VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</font></i>标志位表明从这个命令池分配的命令缓冲都是临时的，也就是说它们会经常地被重置或释放再分配。这可以帮助命令池调整它的内存管理行为，适合于动态场景中快速更换命令缓冲区的情况。</p></li><li><p><i><font color="Red">VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</font></i>标志位设置后，将允许显示使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkResetCommandBuffer.html"><code>vkResetCommandBuffer</code></a>重置单个命令缓冲（如果该标志位没有设置，则一定不能使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkResetCommandBuffer.html"><code>vkResetCommandBuffer</code></a>重置命令缓冲，只能隐式通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkBeginCommandBuffer.html">vkBeginCommandBuffer</a>重置或者直接释放并重新分配新的缓冲）。这一版用于需要反复使用相同命令缓冲区的场景。</p></li><li><p><i><font color="Red">VK_COMMAND_POOL_CREATE_PROTECTED_BIT</font></i>用于创建保护模式命令池从而分配保护模式命令缓冲区，这些缓冲区只能在具有保护访问权限的设备上执行。这通常用于处理敏感数据的场景，例如加密或DRM（数字版权管理）内容，确保数据不会被未授权的访问所读取或修改。</p></li></ul><p>我们在绘制三角形时每一帧使用的都是相同的命令，因此可以将该标志设置为<i><font color="Red">VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</font></i>。</p><p>接下来，<i><font color="Orange">queueFamilyIndex</font></i>指定从该命令池分配的命令缓冲的提交队列。每个命令池分配的缓冲只能提交至一种队列。我们希望录制绘制三角形的命令，因此应该将该成员设置为图形队列。</p><p>最终填写代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">QueueFamilyIndices queueFamilyIndices = <span class="hljs-built_in">findQueueFamilies</span>(physicalDevice);<br><br>VkCommandPoolCreateInfo poolInfo&#123;&#125;;<br>poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;<br>poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;<br>poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily.<span class="hljs-built_in">value</span>();<br></code></pre></td></tr></table></figure><p>然后就可以创建命令池了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateCommandPool</span>(device, &amp;poolInfo, <span class="hljs-literal">nullptr</span>, &amp;commandPool) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create command pool!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="分配命令缓冲">分配命令缓冲</h2><p>构建好命令池后，我们就可以分配命令缓冲了。</p><p>我们目前只需要一个命令缓冲区，因此在类内创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html"><code>VkCommandBuffer</code></a>类型的成员<i><font color="Orange">commandBuffer</font></i>，并且创建一个<i><font color="Green">voidcreateCommandBuffer()</font></i>来分配该对象。</p><p>为了从命令池分配该对象，我们需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBufferAllocateInfo.html"><code>VkCommandBufferAllocateInfo</code></a>信息。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkCommandBufferAllocateInfo</span> &#123;</span><br>    VkStructureType         sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*             pNext;<br>    VkCommandPool           commandPool;<br>    VkCommandBufferLevel    level;<br>    <span class="hljs-type">uint32_t</span>                commandBufferCount;<br>&#125; VkCommandBufferAllocateInfo;<br></code></pre></td></tr></table></figure><p>这里唯一需要解释的成员是<i><font color="Orange">level</font></i>。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBufferLevel.html"><code>VkCommandBufferLevel</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkCommandBufferLevel</span> &#123;</span><br>    VK_COMMAND_BUFFER_LEVEL_PRIMARY = <span class="hljs-number">0</span>,<br>    VK_COMMAND_BUFFER_LEVEL_SECONDARY = <span class="hljs-number">1</span>,<br>&#125; VkCommandBufferLevel;<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><i><font color="Red">VK_COMMAND_BUFFER_LEVEL_PRIMARY</font></i>指定该命令缓冲区为初级命令缓冲，意味着该缓冲区可以直接提交队列执行，但不能被其它命令缓冲调用</li><li><i><font color="Red">VK_COMMAND_BUFFER_LEVEL_SECONDARY</font></i>指定该命令缓冲区为次级命令缓冲，意味着该缓冲区不能直接提交队列执行，但是可以被初级命令缓冲调用</li></ul><p>我们无需使用次级命令缓冲，因此<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBufferAllocateInfo.html"><code>VkCommandBufferAllocateInfo</code></a>信息填写与缓冲区分配代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkCommandBufferAllocateInfo allocInfo&#123;&#125;;<br>allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;<br>allocInfo.commandPool = commandPool;<br>allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;<br>allocInfo.commandBufferCount = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkAllocateCommandBuffers</span>(device, &amp;allocInfo, &amp;commandBuffer) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to allocate command buffers!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="录制命令">录制命令</h2><p>接下来我们可以开始录制命令了。创建一个<i><font color="Green">voidrecordCommandBuffer(VkCommandBuffer commandBuffer, uint32_timageIndex)</font></i>函数用于命令的录制。使用图像索引作为参数是因为我们希望给每个图像绘制都录制好相应的绘制命令。</p><p>为了开始录制，我们总是需要填写一个指定命令缓冲使用上的一些细节的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBufferBeginInfo.html"><code>VkCommandBufferBeginInfo</code></a>结构体。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkCommandBufferBeginInfo</span> &#123;</span><br>    VkStructureType                          sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                              pNext;<br>    VkCommandBufferUsageFlags                flags;<br>    <span class="hljs-type">const</span> VkCommandBufferInheritanceInfo*    pInheritanceInfo;<br>&#125; VkCommandBufferBeginInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>指定命令缓冲的用法有关信息，它可以是如下值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkCommandBufferUsageFlagBits</span> &#123;</span><br>    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = <span class="hljs-number">0x00000001</span>,<br>    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = <span class="hljs-number">0x00000002</span>,<br>    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = <span class="hljs-number">0x00000004</span>,<br>&#125; VkCommandBufferUsageFlagBits;<br></code></pre></td></tr></table></figure><p>我们分别解释每个枚举的含义：</p><ul><li><i><font color="Red">VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</font></i>表明该命令缓冲只会被提交一次，提交后该缓冲区立刻变得无效。在两次提交之间该缓冲区一定要被重置并且重新录制。</li><li><i><font color="Red">VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</font></i>针对次级缓冲区，表明该缓冲完全处于一个渲染通道中。这意味着该次级命令缓冲区的命令可以在当前渲染通道中继续执行，而不需要结束当前的渲染通道。这允许Vulkan驱动程序在执行命令时进行更高效的优化。如果不设置该标志位则一定要在一个新的渲染通道中执行该次级缓冲中的命令（也就是说如果当前已经使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html"><code>vkCmdBeginRenderPass</code></a>开启了一个渲染通道并且还未结束，那么如果要调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdExecuteCommands.html"><code>vkCmdExecuteCommands</code></a>录制执行次级缓冲的命令，那么一定要在这之前使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdEndRenderPass.html"><code>vkCmdEndRenderPass</code></a>结束当前渲染通道并开启一个新的渲染通道来执行次级缓冲命令）。如果针对一个初级缓冲设置该标志位，则该标志位会被忽略。</li><li><i><font color="Red">VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</font></i>针对次级缓冲，表明该命令缓冲区可以在它处于待处理（pending）状态时被多次提交到同一个队列族的任何队列。这意味着我们可以在命令缓冲区尚未被执行完成时，重新提交它。这个标志位还允许一个命令缓冲区被录制到多个主命令缓冲区中。这意味着我们可以在不同的主命令缓冲区中重复使用同一个次级命令缓冲区，而不需要重新录制（如果不设置该标志位，那么次级缓冲一旦在某个初级缓冲中使用过后就立马变成无效状态）。</li></ul><p>我们目前不需要设置任何标志位。</p><p>接下来的<i><font color="Orange">pInheritanceInfo</font></i>仅用于次级缓冲区，它用于指定该次级缓冲从调用它的初级缓冲中继承的一些渲染通道状态信息。我们这里无需指定。</p><p>填写好该结构体后，我们就可以开启录制了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkCommandBufferBeginInfo beginInfo&#123;&#125;;<br>beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;<br>beginInfo.flags = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>beginInfo.pInheritanceInfo = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkBeginCommandBuffer</span>(commandBuffer, &amp;beginInfo) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to begin recording command buffer!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们希望录制绘制命令，那么首先需要开启绘制使用的渲染通道，这通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html"><code>vkCmdBeginRenderPass</code></a>完成（Vulkan中所有的录制命令名称中都带有<strong>Cmd</strong>）。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html"><code>vkCmdBeginRenderPass</code></a>的主要功能包括：</p><ul><li><strong>设置渲染状态</strong>：通过指定渲染通道的描述符，设置当前的渲染状态，包括使用的帧缓冲、附件格式等。</li><li><strong>绑定帧缓冲</strong>：绑定与渲染通道相关的帧缓冲对象，这些帧缓冲将用于存储渲染结果。</li><li><strong>初始化附件</strong>：根据渲染通道的设置，初始化颜色、深度和模板附件。这些附件会被清空或设置为特定的初始值（如清除颜色）。</li><li><strong>开始绘制命令</strong>：一旦渲染通道开始，后续的绘制命令（如绘制三角形、绑定管线等）将被记录并在该渲染通道内执行。</li></ul><p>为了实现这些功能，我们需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRenderPassBeginInfo.html"><code>VkRenderPassBeginInfo</code></a>结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkRenderPassBeginInfo</span> &#123;</span><br>    VkStructureType        sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*            pNext;<br>    VkRenderPass           renderPass;<br>    VkFramebuffer          framebuffer;<br>    VkRect2D               renderArea;<span class="hljs-comment">//着色器绘制的区域，此区域之外的像素颜色将未定义</span><br>    <span class="hljs-type">uint32_t</span>               clearValueCount;<br>    <span class="hljs-type">const</span> VkClearValue*    pClearValues;<br>&#125; VkRenderPassBeginInfo;<br></code></pre></td></tr></table></figure><p>每个成员都是易于理解的，我们如下填写该结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkRenderPassBeginInfo renderPassInfo&#123;&#125;;<br>renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;<br>renderPassInfo.renderPass = renderPass;<br>renderPassInfo.framebuffer = swapChainFramebuffers[imageIndex];<br>renderPassInfo.renderArea.offset = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>renderPassInfo.renderArea.extent = swapChainExtent;<br>VkClearValue clearColor = &#123;&#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;&#125;;<span class="hljs-comment">//使用完全不透明的黑色作为清除色（我们之前指定了渲染开始前图像的颜色将会重置为清除色）</span><br>renderPassInfo.clearValueCount = <span class="hljs-number">1</span>;<br>renderPassInfo.pClearValues = &amp;clearColor;<br></code></pre></td></tr></table></figure><p>接下来只需调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html"><code>vkCmdBeginRenderPass</code></a>即可。该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdBeginRenderPass</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkRenderPassBeginInfo*                pRenderPassBegin,</span><br><span class="hljs-params">    VkSubpassContents                           contents)</span>;<br></code></pre></td></tr></table></figure><p>需要解释的是第三个参数。<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/"><code>VkSubpassContents</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkSubpassContents</span> &#123;</span><br>    VK_SUBPASS_CONTENTS_INLINE = <span class="hljs-number">0</span>,<span class="hljs-comment">//表示在渲染通道中使用的是内联命令。这意味着所有的绘制命令和状态设置都直接在主命令缓冲区中执行，而不涉及任何次级命令缓冲区的调用。</span><br>    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = <span class="hljs-number">1</span>,<span class="hljs-comment">//表示在渲染通道中将使用次级命令缓冲区。也就是说，主命令缓冲区会调用一个或多个次级命令缓冲区来执行绘制命令和状态设置。在这种模式下，主命令缓冲区只能使用 vkCmdExecuteCommands 这个命令来执行次级命令缓冲区的内容。也就是说，您不能在这个命令缓冲区中执行其他类型的命令，直到调用 vkCmdNextSubpass 或 vkCmdEndRenderPass。</span><br>  <span class="hljs-comment">// Provided by VK_KHR_maintenance7</span><br>    VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR = <span class="hljs-number">1000451000</span>,<span class="hljs-comment">//表示在同一个渲染通道中可以同时使用内联命令和次级命令缓冲区。这允许更灵活的命令组织，可以在同一个渲染通道中混合使用这两种类型的命令。</span><br>  <span class="hljs-comment">// Provided by VK_EXT_nested_command_buffer</span><br>    VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT = VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR,<br>&#125; VkSubpassContents;<br></code></pre></td></tr></table></figure><p>我们只使用初级缓冲，因此该参数应该设定为<i><font color="Red">VK_SUBPASS_CONTENTS_INLINE</font></i>。</p><p>然后调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html"><code>vkCmdBeginRenderPass</code></a>绑定渲染通道：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdBeginRenderPass</span>(commandBuffer, &amp;renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);<br></code></pre></td></tr></table></figure><p>现在我们就可以录制绘制命令了。首先需要绑定渲染管线对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdBindPipeline</span>(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);<br></code></pre></td></tr></table></figure><p>第二个参数指定我们绑定的是图形渲染管线而不是计算管线。</p><p>另外，在之前的<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/">固定管线</a>章节，我们指定视口裁剪阶段为动态阶段，这也就意味着在渲染管线对象中我们并没有设置关于它们的信息，这里在录制绘制命令之前我们必须把这些动态阶段信息也给录制好，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkViewport viewport&#123;&#125;;<br>viewport.x = <span class="hljs-number">0.0f</span>;<br>viewport.y = <span class="hljs-number">0.0f</span>;<br>viewport.width = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(swapChainExtent.width);<br>viewport.height = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(swapChainExtent.height);<br>viewport.minDepth = <span class="hljs-number">0.0f</span>;<br>viewport.maxDepth = <span class="hljs-number">1.0f</span>;<br><span class="hljs-built_in">vkCmdSetViewport</span>(commandBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;viewport);<br><br>VkRect2D scissor&#123;&#125;;<br>scissor.offset = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>scissor.extent = swapChainExtent;<br><span class="hljs-built_in">vkCmdSetScissor</span>(commandBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;scissor);<br></code></pre></td></tr></table></figure><p>现在渲染管线和渲染通道都已经就绪，我们就可以录制最终的绘制命令了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdDraw</span>(commandBuffer, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDraw.html"><code>vkCmdDraw</code></a>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdDraw</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    vertexCount,<span class="hljs-comment">//顶点数</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    instanceCount,<span class="hljs-comment">//实例数</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    firstVertex,<span class="hljs-comment">//首顶点偏移</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    firstInstance<span class="hljs-comment">//首实例偏移);</span></span><br></code></pre></td></tr></table></figure><p>所有参数的含义都是一目了然的。我们的应用程序并不使用实例渲染，因此第三个参数指定为1即可。对实例渲染不熟的读者可以参考<a href="https://learnopengl.com/Advanced-OpenGL/Instancing">这篇文章</a>。</p><p>现在我们已经完成了绘制一个基本的三角形所有命令的录制，最后结束渲染管线与命令录制即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdEndRenderPass</span>(commandBuffer);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkEndCommandBuffer</span>(commandBuffer) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to record command buffer!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%B8%A7%E7%BC%93%E5%86%B2/">上一篇：帧缓冲</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/">下一篇：渲染和显示</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>帧缓冲</title>
    <link href="/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%B8%A7%E7%BC%93%E5%86%B2/"/>
    <url>/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%B8%A7%E7%BC%93%E5%86%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在之前的章节中我们已经提到多次帧缓冲了，但直到现在我们也还没有创建一个真正的帧缓冲对象。本节就来创建相应的帧缓冲对象。</p><p>帧缓冲对象可以看成是对渲染通道中指定的附件以及之前创建的图像视图的收纳箱。对于每一个交换链中的图像，我们都将创建一个与之相对应的帧缓冲对象。因此，我们需要在类内添加一个向量成员：<i><font color="Orange">std::vector<VkFramebuffer>swapChainFramebuffers</VkFramebuffer></font></i>，并且添加一个成员函数<i><font color="Green">voidcreateFramebuffers()</font></i>来完成帧缓冲的构建。</p><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Framebuffers">Framebuffers</a>章节。</p><hr><h2 id="创建帧缓冲对象">创建帧缓冲对象</h2><p>首先，我们还是需要将帧缓冲向量大小调整为图像视图向量的大小：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createFramebuffers</span><span class="hljs-params">()</span> </span>&#123;<br>    swapChainFramebuffers.<span class="hljs-built_in">resize</span>(swapChainImageViews.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们需要循环填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFramebufferCreateInfo.html"><code>VkFramebufferCreateInfo</code></a>，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkFramebufferCreateInfo</span> &#123;</span><br>    VkStructureType             sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                 pNext;<br>    VkFramebufferCreateFlags    flags;<br>    VkRenderPass                renderPass;     <span class="hljs-comment">//兼容的渲染管线</span><br>    <span class="hljs-type">uint32_t</span>                    attachmentCount;<span class="hljs-comment">//图像视图数量</span><br>    <span class="hljs-type">const</span> VkImageView*          pAttachments;<span class="hljs-comment">//图像视图</span><br>    <span class="hljs-type">uint32_t</span>                    width;<br>    <span class="hljs-type">uint32_t</span>                    height;<br>    <span class="hljs-type">uint32_t</span>                    layers;    <span class="hljs-comment">//图像层数</span><br>&#125; VkFramebufferCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>可以是下面列出的枚举值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkFramebufferCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//表示帧缓冲的附件不需要在创建帧缓冲时关联具体的图像视图。这意味着帧缓冲可以在创建时不直接指定图像，而是通过其他方式（如在渲染过程中）动态创建或绑定图像。</span><br>  <span class="hljs-comment">// Provided by VK_KHR_imageless_framebuffer</span><br>    VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR = VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT,<br>&#125; VkFramebufferCreateFlagBits;<br></code></pre></td></tr></table></figure><p>这里需要解释一下所谓“兼容的渲染管线”的意思：在 Vulkan中，判断一个帧缓冲和一个渲染通道是否兼容主要涉及以下几个方面：</p><ul><li><strong>颜色、深度和模板附件格式</strong>：帧缓冲中的每个附件的格式必须与渲染通道中定义的相应附件格式匹配。你可以通过检查帧缓冲创建时指定的图像视图的格式与渲染通道中附件描述符的格式是否一致来确认。</li><li><strong>样本数</strong>：帧缓冲中的每个附件的样本数必须与渲染通道中相应附件的样本数相同。这意味着，如果渲染通道中的某个附件是多重采样的，帧缓冲中的对应附件也必须是多重采样的，并且样本数必须一致。</li><li><strong>附件数量</strong>：帧缓冲中的附件数量必须与渲染通道中定义的附件数量相同。如果渲染通道定义了多个颜色附件，帧缓冲也必须提供相同数量的颜色附件。</li><li><strong>图像视图的维度</strong>：帧缓冲中的图像视图的维度（例如，2D、3D、立方体等）必须与渲染通道中相应的附件类型匹配。</li><li><strong>图像视图的大小</strong>：帧缓冲中每个图像视图的宽度和高度必须与渲染通道中的相应附件的宽度和高度匹配。</li></ul><p>于是，我们的帧缓冲创建过程如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainImageViews.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    VkImageView attachments[] = &#123;<br>        swapChainImageViews[i]<br>    &#125;;<br><br>    VkFramebufferCreateInfo framebufferInfo&#123;&#125;;<br>    framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;<br>    framebufferInfo.renderPass = renderPass;<br>    framebufferInfo.attachmentCount = <span class="hljs-number">1</span>;<br>    framebufferInfo.pAttachments = attachments;<br>    framebufferInfo.width = swapChainExtent.width;<br>    framebufferInfo.height = swapChainExtent.height;<br>    framebufferInfo.layers = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateFramebuffer</span>(device, &amp;framebufferInfo, <span class="hljs-literal">nullptr</span>, &amp;swapChainFramebuffers[i]) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create framebuffer!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/">上一篇：渲染管线</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/">下一篇：命令缓冲</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>渲染管线</title>
    <link href="/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
    <url>/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>现在我们已经准备好了一切创建渲染管线需要的信息，主要包括四大块：</p><ul><li>可编程管线阶段（我们只指定了顶点着色器和片段着色器）</li><li>固定管线阶段</li><li>管线布局</li><li>渲染通道</li></ul><p>下面我们在类内新增一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipeline.html"><code>VkPipeline</code></a>类型的成员<i><font color="Orange">graphicsPipeline</font></i>来保存渲染管线对象，并且在<i><font color="Green">createGraphicsPipeline</font></i>函数中创建该对象（注意创建代码要放在销毁着色器模型之前，因为在创建管线对象的时候还需要将着色器模型包含的字节码编译为机器码）。</p><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Conclusion">Conclusion</a>章节。</p><hr><h2 id="创建渲染管线">创建渲染管线</h2><p>首先填写创建信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkGraphicsPipelineCreateInfo.html"><code>VkGraphicsPipelineCreateInfo</code></a>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkGraphicsPipelineCreateInfo</span> &#123;</span><br>    VkStructureType                                  sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                      pNext;<br>    VkPipelineCreateFlags                            flags;<br>    <span class="hljs-type">uint32_t</span>                                         stageCount;<br>    <span class="hljs-type">const</span> VkPipelineShaderStageCreateInfo*           pStages;<br>    <span class="hljs-type">const</span> VkPipelineVertexInputStateCreateInfo*      pVertexInputState;<br>    <span class="hljs-type">const</span> VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;<br>    <span class="hljs-type">const</span> VkPipelineTessellationStateCreateInfo*     pTessellationState;<br>    <span class="hljs-type">const</span> VkPipelineViewportStateCreateInfo*         pViewportState;<br>    <span class="hljs-type">const</span> VkPipelineRasterizationStateCreateInfo*    pRasterizationState;<br>    <span class="hljs-type">const</span> VkPipelineMultisampleStateCreateInfo*      pMultisampleState;<br>    <span class="hljs-type">const</span> VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;<br>    <span class="hljs-type">const</span> VkPipelineColorBlendStateCreateInfo*       pColorBlendState;<br>    <span class="hljs-type">const</span> VkPipelineDynamicStateCreateInfo*          pDynamicState;<br>    VkPipelineLayout                                 layout;<br>    VkRenderPass                                     renderPass;<br>    <span class="hljs-type">uint32_t</span>                                         subpass;<br>    VkPipeline                                       basePipelineHandle;<br>    <span class="hljs-type">int32_t</span>                                          basePipelineIndex;<br>&#125; VkGraphicsPipelineCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>比较复杂，可以参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCreateFlagBits.html">这个页面</a>。我们这里并不需要额外的标志功能。</p><p>除了最后两个成员之外，其它的成员分别指定我们之前已经设定好的各个阶段的信息，我们只需引用那些我们已经设定好的信息和对象就好了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkGraphicsPipelineCreateInfo pipelineInfo&#123;&#125;;<br>pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;<br>pipelineInfo.stageCount = <span class="hljs-number">2</span>;<br>pipelineInfo.pStages = shaderStages;<br>pipelineInfo.pVertexInputState = &amp;vertexInputInfo;<br>pipelineInfo.pInputAssemblyState = &amp;inputAssembly;<br>pipelineInfo.pViewportState = &amp;viewportState;<br>pipelineInfo.pRasterizationState = &amp;rasterizer;<br>pipelineInfo.pMultisampleState = &amp;multisampling;<br>pipelineInfo.pDepthStencilState = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br>pipelineInfo.pColorBlendState = &amp;colorBlending;<br>pipelineInfo.pDynamicState = &amp;dynamicState;<br>pipelineInfo.layout = pipelineLayout;<br>pipelineInfo.renderPass = renderPass;<br>pipelineInfo.subpass = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>这里注意，每个渲染管线中只能指定一个子通道（即使指定的渲染通道有多个子通道也只能指定其中一个子通道）！这意味着如果有多个<code>subpass</code>，我们需要为每个子通道创建单独的图形管线。</p><p>最后，<i><font color="Orange">basePipelineHandle</font></i>指定一个构建好的渲染管线对象，新的渲染管线对象将会从这个对象衍生出来；同样，<i><font color="Orange">basePipelineIndex</font></i>指定某个基础管线的索引，新的管线将从它衍生相互来，如果指定一个负数，则代表不使用该衍生功能。注意，这两个成员是互斥的，也就是说我们不能同时指定这二者为一个有效的对象。我们这里并不需要派生，因此只需如下设置即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; <span class="hljs-comment">// Optional</span><br>pipelineInfo.basePipelineIndex = <span class="hljs-number">-1</span>; <span class="hljs-comment">// Optional</span><br></code></pre></td></tr></table></figure><p>最后我们可以创建渲染管线对象了！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateGraphicsPipelines</span>(device, VK_NULL_HANDLE, <span class="hljs-number">1</span>, &amp;pipelineInfo, <span class="hljs-literal">nullptr</span>, &amp;graphicsPipeline) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create graphics pipeline!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateGraphicsPipelines.html"><code>vkCreateGraphicsPipelines</code></a>比我们之前见过的一般的Vulkan构建函数多了两个参数。该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkCreateGraphicsPipelines</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDevice                                    device,</span><br><span class="hljs-params">    VkPipelineCache                             pipelineCache,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    createInfoCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkGraphicsPipelineCreateInfo*         pCreateInfos,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkAllocationCallbacks*                pAllocator,</span><br><span class="hljs-params">    VkPipeline*                                 pPipelines)</span>;<br></code></pre></td></tr></table></figure><p>第二个参数指定一个<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineCache.html"><code>VkPipelineCache</code></a>类型的管线缓冲对象。管线缓冲对象可以存储多次管线构造函数调用有关的数据和信息以便加速之后的管线构造过程。本教程不涉及该对象的使用。</p><p>下面的的<i><font color="Orange">createInfoCount</font></i>指定管线构建信息的个数。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateGraphicsPipelines.html"><code>vkCreateGraphicsPipelines</code></a>允许我们一次性构建多个渲染管线以提高效率，因此我们需要指定管线个数。</p><p>大功告成！接下来我们终于可以开始着手构建帧缓冲并且为最后的绘制做好准备了！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/">上一篇：渲染通道</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%B8%A7%E7%BC%93%E5%86%B2/">下一篇：帧缓冲</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>渲染通道</title>
    <link href="/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/"/>
    <url>/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在创建渲染管线对象之前，我们还需要指定渲染目标需要的颜色附件、深度附件、模板附件的数目，以及它们使用的采样数和被使用的方式。这些信息将通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRenderPass.html"><code>VkRenderPass</code></a>来指定。接下来我们将创建一个<i><font color="Green">voidcreateRenderPass()</font></i>函数来创建这个对象。主要的创建过程分三步：</p><ul><li>指定附件信息</li><li>指定子通道附件引用并创建子通道（subPass）</li><li>创建渲染通道</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes"><code>Render passes</code></a>章节。</p><hr><h2 id="指定附件描述">指定附件描述</h2><p>附件描述<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescription.html"><code>VkAttachmentDescription</code></a>结构体的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkAttachmentDescription</span> &#123;</span><br>    VkAttachmentDescriptionFlags    flags;<br>    VkFormat                        format;<br>    VkSampleCountFlagBits           samples;<br>    VkAttachmentLoadOp              loadOp;<br>    VkAttachmentStoreOp             storeOp;<br>    VkAttachmentLoadOp              stencilLoadOp;<br>    VkAttachmentStoreOp             stencilStoreOp;<br>    VkImageLayout                   initialLayout;<br>    VkImageLayout                   finalLayout;<br>&#125; VkAttachmentDescription;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>可以是如下枚举：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkAttachmentDescriptionFlagBits</span> &#123;</span><br>    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = <span class="hljs-number">0x00000001</span>,<br>&#125; VkAttachmentDescriptionFlagBits;<br></code></pre></td></tr></table></figure><p>若设置了这个唯一的枚举<i><font color="Red">VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT</font></i>，则Vulkan可以优化资源的使用，因为它可以假设某些附件可能会重用同一块内存。</p><p>对于我们的应用而言，我们只需要一个颜色附件，它的格式一定要和交换链的图像格式匹配。因此<i><font color="Orange">format</font></i>需要设置为之前在<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/">交换链</a>章节我们保存在类内的成员<i><font color="Orange">swapChainImageFormat</font></i>的值。</p><p>由于我们不进行多重采样，因此<i><font color="Orange">samples</font></i>设置为<i><font color="Red">VK_SAMPLE_COUNT_1_BIT</font></i>即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createRenderPass</span><span class="hljs-params">()</span> </span>&#123;<br>    VkAttachmentDescription colorAttachment&#123;&#125;;<br>    colorAttachment.format = swapChainImageFormat;<br>    colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来的<i><font color="Orange">loadOp</font></i>和<i><font color="Orange">storeOp</font></i>分别代表在渲染前后应该如何处理图像上的信息，它们针对的是颜色和深度附件。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAttachmentLoadOp.html"><code>VkAttachmentLoadOp</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkAttachmentLoadOp</span> &#123;</span><br>    VK_ATTACHMENT_LOAD_OP_LOAD = <span class="hljs-number">0</span>,<span class="hljs-comment">//保存图像信息不变</span><br>    VK_ATTACHMENT_LOAD_OP_CLEAR = <span class="hljs-number">1</span>,<span class="hljs-comment">//将图像内容重置为特定颜色值，该颜色值可以通过VkClearValue在VkRenderPassBeginInfo中指定</span><br>    VK_ATTACHMENT_LOAD_OP_DONT_CARE = <span class="hljs-number">2</span>,<span class="hljs-comment">//图像内容不会保存，处于未知的状态</span><br>  <span class="hljs-comment">// Provided by VK_KHR_load_store_op_none</span><br>    VK_ATTACHMENT_LOAD_OP_NONE_KHR = <span class="hljs-number">1000400000</span>,<span class="hljs-comment">//不加载附件，不进行任何操作</span><br>  <span class="hljs-comment">// Provided by VK_EXT_load_store_op_none</span><br>    VK_ATTACHMENT_LOAD_OP_NONE_EXT = VK_ATTACHMENT_LOAD_OP_NONE_KHR,<br>&#125; VkAttachmentLoadOp;<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAttachmentStoreOp.html"><code>VkAttachmentStoreOp</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkAttachmentStoreOp</span> &#123;</span><br>    VK_ATTACHMENT_STORE_OP_STORE = <span class="hljs-number">0</span>,<span class="hljs-comment">//渲染内容会被保存在内存中</span><br>    VK_ATTACHMENT_STORE_OP_DONT_CARE = <span class="hljs-number">1</span>,<span class="hljs-comment">//渲染后的内容不会被保存，将处于未知状态</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_ATTACHMENT_STORE_OP_NONE = <span class="hljs-number">1000301000</span>,<span class="hljs-comment">//如果附件没有写入操作，则不进行任何储存操作，否则效果等同于VK_ATTACHMENT_STORE_OP_DONT_CARE</span><br>  <span class="hljs-comment">// Provided by VK_KHR_dynamic_rendering, VK_KHR_load_store_op_none</span><br>    VK_ATTACHMENT_STORE_OP_NONE_KHR = VK_ATTACHMENT_STORE_OP_NONE,<br>  <span class="hljs-comment">// Provided by VK_QCOM_render_pass_store_ops</span><br>    VK_ATTACHMENT_STORE_OP_NONE_QCOM = VK_ATTACHMENT_STORE_OP_NONE,<br>  <span class="hljs-comment">// Provided by VK_EXT_load_store_op_none</span><br>    VK_ATTACHMENT_STORE_OP_NONE_EXT = VK_ATTACHMENT_STORE_OP_NONE,<br>&#125; VkAttachmentStoreOp;<br></code></pre></td></tr></table></figure><p>对于我们的程序，可以如下指定这两个成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;<br>colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;<br></code></pre></td></tr></table></figure><p>对于模板附件，我们通过<i><font color="Orange">stencilLoadOp</font></i>和<i><font color="Orange">stencilStoreOp</font></i>单独指定它的加载和保存操作。本教程并不会用到模板缓冲，因此我们始终将这两个成员设置为<i><font color="Red">VK_ATTACHMENT_LOAD_OP_DONT_CARE</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;<br>colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br></code></pre></td></tr></table></figure><p>关于模板测试的简单介绍和应用，可以参考<a href="https://learnopengl.com/Advanced-OpenGL/Stencil-testing">这篇文章</a>。</p><p>最后，我们需要指定附件图像的初始布局和最终布局。Vulkan中图像像素的布局是可以改变的，这允许我们针对接下来要进行的操作设置最优的像素布局以优化性能。这个布局是通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html"><code>VkImageLayout</code></a>指定的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkImageLayout</span> &#123;</span><br>    VK_IMAGE_LAYOUT_UNDEFINED = <span class="hljs-number">0</span>,<br>    VK_IMAGE_LAYOUT_GENERAL = <span class="hljs-number">1</span>,<br>    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = <span class="hljs-number">2</span>,<br>    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = <span class="hljs-number">3</span>,<br>    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = <span class="hljs-number">4</span>,<br>    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = <span class="hljs-number">5</span>,<br>    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = <span class="hljs-number">6</span>,<br>    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = <span class="hljs-number">7</span>,<br>    VK_IMAGE_LAYOUT_PREINITIALIZED = <span class="hljs-number">8</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = <span class="hljs-number">1000117000</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = <span class="hljs-number">1000117001</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = <span class="hljs-number">1000241000</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = <span class="hljs-number">1000241001</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = <span class="hljs-number">1000241002</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = <span class="hljs-number">1000241003</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL = <span class="hljs-number">1000314000</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL = <span class="hljs-number">1000314001</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br>    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = <span class="hljs-number">1000001002</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_decode_queue</span><br>    VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR = <span class="hljs-number">1000024000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_decode_queue</span><br>    VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR = <span class="hljs-number">1000024001</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_decode_queue</span><br>    VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR = <span class="hljs-number">1000024002</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_shared_presentable_image</span><br>    VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = <span class="hljs-number">1000111000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_fragment_density_map</span><br>    VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = <span class="hljs-number">1000218000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_fragment_shading_rate</span><br>    VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = <span class="hljs-number">1000164003</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_dynamic_rendering_local_read</span><br>    VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR = <span class="hljs-number">1000232000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_encode_queue</span><br>    VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR = <span class="hljs-number">1000299000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_encode_queue</span><br>    VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR = <span class="hljs-number">1000299001</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_encode_queue</span><br>    VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR = <span class="hljs-number">1000299002</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_attachment_feedback_loop_layout</span><br>    VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT = <span class="hljs-number">1000339000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_maintenance2</span><br>    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_KHR_maintenance2</span><br>    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_NV_shading_rate_image</span><br>    VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV = VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR,<br>  <span class="hljs-comment">// Provided by VK_KHR_separate_depth_stencil_layouts</span><br>    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_KHR_separate_depth_stencil_layouts</span><br>    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_KHR_separate_depth_stencil_layouts</span><br>    VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_KHR_separate_depth_stencil_layouts</span><br>    VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_KHR_synchronization2</span><br>    VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_KHR_synchronization2</span><br>    VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL,<br>&#125; VkImageLayout;<br></code></pre></td></tr></table></figure><p>可以看到布局方式有非常多种。我们在后续的学习中会陆续遇到其中的一些，在遇到这些布局方式的时候我们再对其加以解释。</p><p>在这里，我们希望如下指定布局：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;<br>colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">initialLayout</font></i>指定了图像在渲染通道开始之前应该是怎么布局的。我们并不关系渲染开始前图像的布局与内容，因为根据我们对<i><font color="Orange">loadOp</font></i>的设置，它的内容会在加载的时候被清空。<i><font color="Orange">finalLayout</font></i>指定图像在渲染通道结束后被自动转化为的布局类型。我们在渲染结束后希望将图像显示到屏幕上，因此该布局应该设置为<i><font color="Red">VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</font></i>以获取显示最优的布局。</p><p>至此附件描述填写完毕。</p><hr><h2 id="创建子通道">创建子通道</h2><p>一个渲染通道可以包含多个子通道。子通道指的是一系列的渲染操作，每一个子通道可以使用上一个子通道的渲染结果进行后处理等操作。我们可以将许多连续的渲染操作分为多个子通道并整合在一个渲染通道中，这样Vulkan可以适当地重排操作顺序以节省内存和带宽从而优化性能。不过对于我们绘制三角形的程序而言，创建一个子通道就足够了。</p><p>每一个子通道都需要引用一些创建好的附件描述信息。附件引用结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAttachmentReference.html"><code>VkAttachmentReference</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkAttachmentReference</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>         attachment;<br>    VkImageLayout    layout;<br>&#125; VkAttachmentReference;<br></code></pre></td></tr></table></figure><p>我们只需要指定它引用的附件索引以及在引用它的子通道的操作中它应该具有的布局即可。由于我们只创建了一个附件描述信息，因此<i><font color="Orange">attachment</font></i>设置为0即可。由于在子通道中进行渲染时，我们希望把上述附件作为颜色附件使用，因此<i><font color="Orange">layout</font></i>应该设置为<i><font color="Red">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</font></i>。</p><p>接下来我们就可以填写子通道的描述信息<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubpassDescription.html"><code>VkSubpassDescription</code></a>了，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSubpassDescription</span> &#123;</span><br>    VkSubpassDescriptionFlags       flags;<br>    VkPipelineBindPoint             pipelineBindPoint;<br>    <span class="hljs-type">uint32_t</span>                        inputAttachmentCount;<br>    <span class="hljs-type">const</span> VkAttachmentReference*    pInputAttachments;<br>    <span class="hljs-type">uint32_t</span>                        colorAttachmentCount;<br>    <span class="hljs-type">const</span> VkAttachmentReference*    pColorAttachments;<br>    <span class="hljs-type">const</span> VkAttachmentReference*    pResolveAttachments;<br>    <span class="hljs-type">const</span> VkAttachmentReference*    pDepthStencilAttachment;<br>    <span class="hljs-type">uint32_t</span>                        preserveAttachmentCount;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*                 pPreserveAttachments;<br>&#125; VkSubpassDescription;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>所有可能的取值及其含义可以参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubpassDescriptionFlagBits.html">这个页面</a>，这里我们并不需要指定任何特殊的标志。</p><p>由于未来Vulkan有可能会指定计算子通道，因此为了这个可能的拓展，我们必须指定我们在该渲染通道中使用的是哪种子通道。我们使用的是图形子通道，因此填写<i><font color="Red">VK_PIPELINE_BIND_POINT_GRAPHICS</font></i>即可。</p><p>接下来的所有参数指定了子通道对不同种类的附件的绑定情况。子通道可以引用的附件类型包括：</p><ul><li>输入附件（Inputattachments）：允许在渲染通道的子通道中读取来自其他子通道的附件内容，它主要用于实现多通道渲染和后处理效果</li><li>颜色附件（Color attachments）：存储渲染输出的颜色数据</li><li>多重采样附件（Resolveattachments）：主要作用是将多重采样的结果解析（resolve）到一个单一的颜色附件中，从而实现抗锯齿效果</li><li>深度模板附件（DepthStencilattachments）：储存渲染输出的深度和模板数据</li><li>保留附件（Preserveattachments）：主要用于在渲染过程中保持其内容不被修改。这种附件通常在多个渲染通道之间共享，允许在不同的渲染操作中保留数据，这有助于提高渲染效率，避免不必要的内存操作，因为它们不需要在每次渲染时进行加载和存储</li></ul><p>我们这里只需要颜色附件的位置绑上之前指定的附件引用就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSubpassDescription subpass&#123;&#125;;<br>subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;<br>subpass.colorAttachmentCount = <span class="hljs-number">1</span>;<br>subpass.pColorAttachments = &amp;colorAttachmentRef;<br></code></pre></td></tr></table></figure><hr><h2 id="创建渲染通道">创建渲染通道</h2><p>现在我们可以创建真正的渲染通道对象了。在类内新添一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRenderPass.html"><code>VkRenderPass</code></a>类型的成员<i><font color="Orange">renderPass</font></i>，接下来我们来填写创建信息<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateInfo.html"><code>VkRenderPassCreateInfo</code></a>，该结构体定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkRenderPassCreateInfo</span> &#123;</span><br>    VkStructureType                   sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                       pNext;<br>    VkRenderPassCreateFlags           flags;<br>    <span class="hljs-type">uint32_t</span>                          attachmentCount;<br>    <span class="hljs-type">const</span> VkAttachmentDescription*    pAttachments;<br>    <span class="hljs-type">uint32_t</span>                          subpassCount;<br>    <span class="hljs-type">const</span> VkSubpassDescription*       pSubpasses;<br>    <span class="hljs-type">uint32_t</span>                          dependencyCount;<br>    <span class="hljs-type">const</span> VkSubpassDependency*        pDependencies;<br>&#125; VkRenderPassCreateInfo;<br></code></pre></td></tr></table></figure></p><p><i><font color="Orange">flags</font></i>可能的取值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkRenderPassCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_QCOM_render_pass_transform</span><br>    VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//该标志允许开发者在创建渲染通道时对渲染目标进行几何变换。这意味着可以在渲染时对图像进行旋转、翻转或其他变换操作，而无需在应用程序中手动处理这些变换</span><br>&#125; VkRenderPassCreateFlagBits;<br></code></pre></td></tr></table></figure><p>接下来我们需要指定该渲染通道绑定的附件（注意此时指定的是附件本身而不是附件引用）以及子通道。</p><p>最后如果有多于一个的子通道，我们还需要指定它们之间的依赖关系（dependency）以确保在一个子通道完成之前，另一个子通道不会开始执行。这对于处理资源的读写冲突和同步至关重要。由于我们这里只有一个子通道，所以不需要指定这部分内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkRenderPassCreateInfo renderPassInfo&#123;&#125;;<br>renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;<br>renderPassInfo.attachmentCount = <span class="hljs-number">1</span>;<br>renderPassInfo.pAttachments = &amp;colorAttachment;<br>renderPassInfo.subpassCount = <span class="hljs-number">1</span>;<br>renderPassInfo.pSubpasses = &amp;subpass;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateRenderPass</span>(device, &amp;renderPassInfo, <span class="hljs-literal">nullptr</span>, &amp;renderPass) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create render pass!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就设置好了渲染通道的信息，下一章我们终于可以创建真正的渲染管线对象了！</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/">上一篇：固定管线</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/">下一篇：渲染管线</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>固定管线</title>
    <link href="/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/"/>
    <url>/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p><a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/">上一章</a>中我们已经构建好了渲染管线中的可编程阶段。本节将继续构建管线中的固定函数阶段。我们需要分别构建：</p><ul><li>顶点输入</li><li>输入汇编阶段</li><li>视口和裁剪</li><li>光栅化阶段</li><li>多重采样</li><li>深度模板测试</li><li>颜色混合阶段</li><li>管线布局</li></ul><p>下面我们依次构建所有的固定函数和阶段。</p><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions">Fixedfunctions</a>章节。</p><hr><h2 id="顶点输入">顶点输入</h2><p>首先我们需要指定顶点输入数据的格式。主要需要关注两部分：</p><ul><li>绑定方式：即数据之间的排列间隙以及数据是逐顶点的还是逐索引的</li><li>属性描述：即数据属性的类别以及它们对应的绑定点和在在数据块中的偏移</li></ul><p>指定数据输入格式是通过填写 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineVertexInputStateCreateInfo.html"><code>VkPipelineVertexInputStateCreateInfo</code></a>完成的，它的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineVertexInputStateCreateInfo</span> &#123;</span><br>    VkStructureType                             sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                 pNext;<br>    VkPipelineVertexInputStateCreateFlags       flags;<span class="hljs-comment">//暂时没有选项</span><br>    <span class="hljs-type">uint32_t</span>                                    vertexBindingDescriptionCount;<br>    <span class="hljs-type">const</span> VkVertexInputBindingDescription*      pVertexBindingDescriptions;<br>    <span class="hljs-type">uint32_t</span>                                    vertexAttributeDescriptionCount;<br>    <span class="hljs-type">const</span> VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;<br>&#125; VkPipelineVertexInputStateCreateInfo;<br></code></pre></td></tr></table></figure><p>其中<i><font color="Orange">pVertexBindingDescriptions</font></i>对应的就是绑定方式，<i><font color="Orange">pVertexAttributeDescriptions</font></i>对应的就是属性描述。</p><p>由于我们暂时是将顶点数据硬编码在顶点着色器中的，所以我们暂时不需要填写这些成员。在后续顶点缓冲章节我们会进行更详细得说明。</p><hr><h2 id="输入汇编阶段">输入汇编阶段</h2><p>输入汇编阶段通过 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineInputAssemblyStateCreateInfo.html"><code>VkPipelineInputAssemblyStateCreateInfo</code></a>指定。该结构体指定两方面的信息：</p><ul><li>顶点构成的图元种类</li><li>图元重启是否开启</li></ul><p>其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineInputAssemblyStateCreateInfo</span> &#123;</span><br>    VkStructureType                            sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                pNext;<br>    VkPipelineInputAssemblyStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    VkPrimitiveTopology                        topology;<br>    VkBool32                                   primitiveRestartEnable;<br>&#125; VkPipelineInputAssemblyStateCreateInfo;<br></code></pre></td></tr></table></figure><p>其中<i><font color="Orange">topology</font></i>指定的就是图元的种类，有关图元的所有种类可以参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPrimitiveTopology.html">这个页面</a>。</p><p><i><font color="Orange">primitiveRestartEnable</font></i>指定是否开启图元重启。图元重启（PrimitiveRestart）是图形渲染中的一种机制，用于在绘制图元（如三角形、线段等）时，允许在同一绘制调用中重启图元的绘制过程。这在处理复杂的几何体时非常有用，尤其是当使用索引缓冲区时。在绘制过程中，PrimitiveRestart 允许通过一个特殊的重启索引值（通常是一个特定的无效索引，如<code>0xFFFFFFFF</code>）来指示图元的重启。当遇到这个重启索引时，渲染管线会停止当前图元的绘制，并开始绘制一个新的图元。</p><p>为了绘制第一个三角形，这里我们只需如下指定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineInputAssemblyStateCreateInfo inputAssembly&#123;&#125;;<br>inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;<br>inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;<br>inputAssembly.primitiveRestartEnable = VK_FALSE;<br></code></pre></td></tr></table></figure><hr><h2 id="视口和裁剪">视口和裁剪</h2><p>视口和裁剪的设置比较特殊，它们既可以作为渲染管线的一部分被预先设置好并烘培至管线内，也可以在命令缓冲中动态设定以便在程序运行时动态改变而不重新建立渲染管线。</p><p>如果需要预先设置好，可以先分别填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkViewport.html"><code>VkViewport</code></a>和<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRect2D.html"><code>VkRect2D</code></a>结构体，它们的定义分别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkViewport</span> &#123;</span><br>    <span class="hljs-type">float</span>    x;<br>    <span class="hljs-type">float</span>    y;<br>    <span class="hljs-type">float</span>    width;<br>    <span class="hljs-type">float</span>    height;<br>    <span class="hljs-type">float</span>    minDepth;<br>    <span class="hljs-type">float</span>    maxDepth;<br>&#125; VkViewport;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkRect2D</span> &#123;</span><br>    VkOffset2D    offset;<br>    VkExtent2D    extent;<br>&#125; VkRect2D;<br></code></pre></td></tr></table></figure><p>先看<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkViewport.html"><code>VkViewport</code></a>：前两个坐标指定的是视口左上角的位置，最后两个值指定的是帧缓冲中坐标的深度范围，这个深度范围一定要在<strong>[0.0,1.0]</strong>中，但是最小深度允许在指定的时候大于最大深度。绝大多数情况下我们都希望视口范围和图像范围一样大，并且深度范围就是<strong>[0.0,1.0]</strong>，因此一般来讲可以这样填写该结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkViewport viewport&#123;&#125;;<br>viewport.x = <span class="hljs-number">0.0f</span>;<br>viewport.y = <span class="hljs-number">0.0f</span>;<br>viewport.width = (<span class="hljs-type">float</span>) swapChainExtent.width;<br>viewport.height = (<span class="hljs-type">float</span>) swapChainExtent.height;<br>viewport.minDepth = <span class="hljs-number">0.0f</span>;<br>viewport.maxDepth = <span class="hljs-number">1.0f</span>;<br></code></pre></td></tr></table></figure><p>对于裁剪范围，它由一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRect2D.html"><code>VkRect2D</code></a>结构体指定，它的两个成员分别指定偏移量和范围大小。如果不需要特殊的效果，一般来讲我们不需要裁剪图像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkRect2D scissor&#123;&#125;;<br>scissor.offset = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>scissor.extent = swapChainExtent;<br></code></pre></td></tr></table></figure><p>如果需要将视口和裁剪设置为动态阶段（dynamicstate），那么我们需要使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineDynamicStateCreateInfo.html"><code>VkPipelineDynamicStateCreateInfo</code></a>指定动态阶段的信息。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineDynamicStateCreateInfo</span> &#123;</span><br>    VkStructureType                      sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                          pNext;<br>    VkPipelineDynamicStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    <span class="hljs-type">uint32_t</span>                             dynamicStateCount;<br>    <span class="hljs-type">const</span> VkDynamicState*                pDynamicStates;<br>&#125; VkPipelineDynamicStateCreateInfo;<br></code></pre></td></tr></table></figure><p>因此我们需要如下填写该结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;VkDynamicState&gt; dynamicStates = &#123;<br>    VK_DYNAMIC_STATE_VIEWPORT,<br>    VK_DYNAMIC_STATE_SCISSOR<br>&#125;;<br><br>VkPipelineDynamicStateCreateInfo dynamicState&#123;&#125;;<br>dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;<br>dynamicState.dynamicStateCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(dynamicStates.<span class="hljs-built_in">size</span>());<br>dynamicState.pDynamicStates = dynamicStates.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>不管采取哪种方式，在指定好视口和裁剪的信息后，我们都需要通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportStateCreateInfo.html"><code>VkPipelineViewportStateCreateInfo</code></a>结构体告诉渲染管线我们使用的视口和裁剪，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineViewportStateCreateInfo</span> &#123;</span><br>    VkStructureType                       sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                           pNext;<br>    VkPipelineViewportStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    <span class="hljs-type">uint32_t</span>                              viewportCount;<br>    <span class="hljs-type">const</span> VkViewport*                     pViewports;<br>    <span class="hljs-type">uint32_t</span>                              scissorCount;<br>    <span class="hljs-type">const</span> VkRect2D*                       pScissors;<br>&#125; VkPipelineViewportStateCreateInfo;<br></code></pre></td></tr></table></figure><p>如果视口和裁剪使用动态阶段，那么我们无需填写<i><font color="Orange">pViewports</font></i>和<i><font color="Orange">pScissors</font></i>成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineViewportStateCreateInfo viewportState&#123;&#125;;<br>viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;<br>viewportState.viewportCount = <span class="hljs-number">1</span>;<br>viewportState.scissorCount = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>否则我们还需指定使用的视口和裁剪范围：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">viewportState.pViewports = &amp;viewport;<br>viewportState.pScissors = &amp;scissor;<br></code></pre></td></tr></table></figure><p>另外，从结构体的定义不难看出渲染管线是允许指定多视口和裁剪区域的，但是要这么做要求GPU具有相应的特性，这可以通过查询物理设备特性的函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures.html"><code>vkGetPhysicalDeviceFeatures</code></a>来查询，大致的查询结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPhysicalDeviceFeatures features;<br><span class="hljs-built_in">vkGetPhysicalDeviceFeatures</span>(physicalDevice, &amp;features);<br><br><span class="hljs-keyword">if</span> (features.multiViewport) &#123;<br>    <span class="hljs-comment">// 支持多视口</span><br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-keyword">if</span> (features.multiDrawIndirect) &#123;<br>    <span class="hljs-comment">// 支持多裁剪区域</span><br>    <span class="hljs-comment">///...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们解释一下视口区域和裁剪区域的区别。视口实际上可以看成是由图像到帧缓冲区的一个变换，它并不会导致图像上部分区域的丢失，只会拉伸或者压缩图像；而裁剪区域指定的是图像哪些像素会被保留，裁剪区域之外的部分会在光栅化阶段丢弃，它更像是一个过滤器。下面这张图很好地说明了这两者的区别与联系：</p><figure><img src="/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/视口裁剪.png" alt="视口和裁剪"><figcaption aria-hidden="true">视口和裁剪</figcaption></figure><hr><h2 id="光栅化阶段">光栅化阶段</h2><p>光栅化阶段将几何体分割为片段，并且执行提前深度测试、面剔除、裁剪测试等操作，它还决定了多边形绘制模式。这些信息都是通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateCreateInfo.html"><code>VkPipelineRasterizationStateCreateInfo</code></a>设定的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineRasterizationStateCreateInfo</span> &#123;</span><br>    VkStructureType                            sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                pNext;<br>    VkPipelineRasterizationStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    VkBool32                                   depthClampEnable;<br>    VkBool32                                   rasterizerDiscardEnable;<br>    VkPolygonMode                              polygonMode;<br>    VkCullModeFlags                            cullMode;<br>    VkFrontFace                                frontFace;<br>    VkBool32                                   depthBiasEnable;<br>    <span class="hljs-type">float</span>                                      depthBiasConstantFactor;<br>    <span class="hljs-type">float</span>                                      depthBiasClamp;<br>    <span class="hljs-type">float</span>                                      depthBiasSlopeFactor;<br>    <span class="hljs-type">float</span>                                      lineWidth;<br>&#125; VkPipelineRasterizationStateCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">depthClampEnable</font></i>指定深度值在<strong>[0.0,1.0]</strong>范围外的片段该如何处理，如果为<i><font color="Red">VK_TRUE</font></i>，那么相当于这些片段的深度值做clamp操作（这在阴影映射中有用，可以参考<a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">这篇文章</a>）；反之则简单地丢弃这些片段。启用该功能同样需要GPU特性<i><font color="Orange">VkPhysicalDeviceFeatures::depthClamp</font></i>为<i><font color="Red">VK_TRUE</font></i>。</p><p>接下来，如果<i><font color="Orange">rasterizerDiscardEnable</font></i>设置为<i><font color="Red">VK_TRUE</font></i>，那么意味着不会有任何几何形体通过光栅化阶段最终输出到帧缓冲上。为了得到渲染结果这个成员几乎总是设置为<i><font color="Red">VK_FALSE</font></i>。</p><p><i><font color="Orange">polygonMode</font></i>指定了多边形绘制模式，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPolygonMode.html"><code>VkPolygonMode</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkPolygonMode</span> &#123;</span><br>    VK_POLYGON_MODE_FILL = <span class="hljs-number">0</span>,<span class="hljs-comment">//以填充方式绘制多边形</span><br>    VK_POLYGON_MODE_LINE = <span class="hljs-number">1</span>,<span class="hljs-comment">//以线框方式绘制多边形</span><br>    VK_POLYGON_MODE_POINT = <span class="hljs-number">2</span>,<span class="hljs-comment">//以点模式绘制多边形</span><br>  <span class="hljs-comment">// Provided by VK_NV_fill_rectangle</span><br>    VK_POLYGON_MODE_FILL_RECTANGLE_NV = <span class="hljs-number">1000153000</span>,<span class="hljs-comment">//这是一个扩展的模式，专门用于填充矩形。这是由 VK_NV_fill_rectangle 扩展提供的，允许更高效地绘制矩形</span><br>&#125; VkPolygonMode;<br></code></pre></td></tr></table></figure><p>除了<i><font color="Red">VK_POLYGON_MODE_FILL</font></i>以外的模式都需要GPU具有相应的特性。</p><p><i><font color="Orange">lineWidth</font></i>成员指定多边形边界线宽度（以片段为单位）。一般来讲它设定为<strong>1.0</strong>，如果需要比这更宽的宽度则需要GPU具有特性<i><font color="Orange">wideLines</font></i>。</p><p>接下来的<i><font color="Orange">cullMode</font></i>和<i><font color="Orange">frontFace</font></i>指定了面剔除的方式。下面是它们可能的取值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkCullModeFlagBits</span> &#123;</span><br>    VK_CULL_MODE_NONE = <span class="hljs-number">0</span>,<br>    VK_CULL_MODE_FRONT_BIT = <span class="hljs-number">0x00000001</span>,<br>    VK_CULL_MODE_BACK_BIT = <span class="hljs-number">0x00000002</span>,<br>    VK_CULL_MODE_FRONT_AND_BACK = <span class="hljs-number">0x00000003</span>,<br>&#125; VkCullModeFlagBits;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkFrontFace</span> &#123;</span><br>    VK_FRONT_FACE_COUNTER_CLOCKWISE = <span class="hljs-number">0</span>,<br>    VK_FRONT_FACE_CLOCKWISE = <span class="hljs-number">1</span>,<br>&#125; VkFrontFace;<br></code></pre></td></tr></table></figure><p>这些枚举值的含义均易于理解，这里不再赘述。</p><p>最后的四个成员用于指定对深度值的一些操作，这些操作在阴影映射中有一定的运用，不过我们这里并不需要指定该功能。</p><p>最终，我们的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateCreateInfo.html"><code>VkPipelineRasterizationStateCreateInfo</code></a>结构体应该填写如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineRasterizationStateCreateInfo rasterizer&#123;&#125;;<br>rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;<br>rasterizer.depthClampEnable = VK_FALSE;<br>rasterizer.rasterizerDiscardEnable = VK_FALSE;<br>rasterizer.polygonMode = VK_POLYGON_MODE_FILL;<br>rasterizer.lineWidth = <span class="hljs-number">1.0f</span>;<br>rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;<br>rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;<br>rasterizer.depthBiasEnable = VK_FALSE;<br></code></pre></td></tr></table></figure><hr><h2 id="多重采样">多重采样</h2><p>对多重采样的指定通过填写 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineMultisampleStateCreateInfo.html"><code>VkPipelineMultisampleStateCreateInfo</code></a>来完成。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineMultisampleStateCreateInfo</span> &#123;</span><br>    VkStructureType                          sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                              pNext;<br>    VkPipelineMultisampleStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    VkSampleCountFlagBits                    rasterizationSamples;<br>    VkBool32                                 sampleShadingEnable;<br>    <span class="hljs-type">float</span>                                    minSampleShading;<br>    <span class="hljs-type">const</span> VkSampleMask*                      pSampleMask;<br>    VkBool32                                 alphaToCoverageEnable;<br>    VkBool32                                 alphaToOneEnable;<br>&#125; VkPipelineMultisampleStateCreateInfo;<br></code></pre></td></tr></table></figure><p>目前我们并不需要使用多重采样功能，所以只需禁用该功能即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineMultisampleStateCreateInfo multisampling&#123;&#125;;<br>multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;<br>multisampling.sampleShadingEnable = VK_FALSE;<br>multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;<br>multisampling.minSampleShading = <span class="hljs-number">1.0f</span>; <span class="hljs-comment">// Optional</span><br>multisampling.pSampleMask = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br>multisampling.alphaToCoverageEnable = VK_FALSE; <span class="hljs-comment">// Optional</span><br>multisampling.alphaToOneEnable = VK_FALSE; <span class="hljs-comment">// Optional</span><br></code></pre></td></tr></table></figure><p>多重采样是一种重要且高效的抗锯齿方式，它不需要像SSAA一样提高分辨率，而是只在边界上对一个像素的多个采样点运行多次片段着色器，最终对同一个像素中每个样本的颜色进行一个平均即可，可以大幅降低计算复杂度。关于MSAA原理的更详细的介绍可以阅读<a href="https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing">这篇文章</a>。</p><hr><h2 id="深度模板测试">深度模板测试</h2><p>由于我们目前希望渲染一个2D的三角形，这并不需要深度或者模板测试，因此我们暂时不需要填写相应的<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineDepthStencilStateCreateInfo.html"><code>VkPipelineDepthStencilStateCreateInfo</code></a>结构体，这部分会在之后开始绘制3维图像的时候介绍。</p><hr><h2 id="颜色混合阶段">颜色混合阶段</h2><p>在片段着色器计算出每个像素的颜色值之后，输出的颜色值需要和作为输出目标的帧缓冲中对应像素的颜色值进行混合。颜色混合有两种方式：</p><ul><li>直接混合两个颜色向量</li><li>对颜色值进行位运算</li></ul><p>设定颜色混合的信息结构体也有两个：<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>指定特定颜色附件的颜色混合设置，而<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendStateCreateInfo.html"><code>VkPipelineColorBlendStateCreateInfo</code></a>指定全局的颜色混合设置（适用于所有颜色附件）。它们的定义分别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineColorBlendAttachmentState</span> &#123;</span><br>    VkBool32                 blendEnable;<span class="hljs-comment">//如果为VK_FALSE，则着色器输出颜色直接覆盖帧缓冲对应像素上的颜色</span><br>    VkBlendFactor            srcColorBlendFactor;<br>    VkBlendFactor            dstColorBlendFactor;<br>    VkBlendOp                colorBlendOp;<br>    VkBlendFactor            srcAlphaBlendFactor;<br>    VkBlendFactor            dstAlphaBlendFactor;<br>    VkBlendOp                alphaBlendOp;<br>    VkColorComponentFlags    colorWriteMask;<span class="hljs-comment">//指定RGBA四通道分别是否可写</span><br>&#125; VkPipelineColorBlendAttachmentState;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">/ Provided by VK_VERSION_1_0<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineColorBlendStateCreateInfo</span> &#123;</span><br>    VkStructureType                               sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                   pNext;<br>    VkPipelineColorBlendStateCreateFlags          flags;<br>    VkBool32                                      logicOpEnable;<br>    VkLogicOp                                     logicOp;<br>    <span class="hljs-type">uint32_t</span>                                      attachmentCount;<br>    <span class="hljs-type">const</span> VkPipelineColorBlendAttachmentState*    pAttachments;<br>    <span class="hljs-type">float</span>                                         blendConstants[<span class="hljs-number">4</span>];<br>&#125; VkPipelineColorBlendStateCreateInfo;<br></code></pre></td></tr></table></figure><p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>允许我们指定每个颜色附件第一种混合方式的设置，该结构体除第一个成员和最后一个成员之外的所有成员均用于最后混合颜色的计算，计算的伪代码大致如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (blendEnable) &#123;<br>    finalColor.rgb = (srcColorBlendFactor * newColor.rgb) &lt;colorBlendOp&gt; (dstColorBlendFactor * oldColor.rgb);<br>    finalColor.a = (srcAlphaBlendFactor * newColor.a) &lt;alphaBlendOp&gt; (dstAlphaBlendFactor * oldColor.a);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    finalColor = newColor;<br>&#125;<br><br>finalColor = finalColor &amp; colorWriteMask;<br></code></pre></td></tr></table></figure><p>关于混合运算符<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBlendOp.html"><code>VkBlendOp</code></a>以及<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBlendFactor.html"><code>VkBlendFactor</code></a>，可以分别参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBlendOp.html"><code>这个页面</code></a>以及<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBlendFactor.html"><code>这个页面</code></a>，大多数的运算符以及运算因子的含义都是显而易见的，我们这里不再过多介绍。</p><p>接下来介绍一下全局设置结构体<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendStateCreateInfo.html"><code>VkPipelineColorBlendStateCreateInfo</code></a>。</p><p><i><font color="Orange">flags</font></i>是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendStateCreateFlagBits.html"><code>VkPipelineColorBlendStateCreateFlagBits</code></a>的位组合，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_rasterization_order_attachment_access</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkPipelineColorBlendStateCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_EXT_rasterization_order_attachment_access</span><br>    VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//指示颜色混合状态的创建将允许按照光栅化顺序访问附件。这意味着在处理多个颜色附件时，可以按照它们在渲染目标中的顺序进行访问，从而优化渲染性能。</span><br>  <span class="hljs-comment">// Provided by VK_ARM_rasterization_order_attachment_access</span><br>    VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM = VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT,<br>&#125; VkPipelineColorBlendStateCreateFlagBits;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">logicOpEnable</font></i>指定是否使用第二种方式混合颜色。这个成员设置为<i><font color="Red">VK_TRUE</font></i>的效果和所有颜色附件的<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>结构体中<i><font color="Orange">blendEnable</font></i>设置为<i><font color="Red">VK_FALSE</font></i>的效果是一样的，也就是说第一种颜色混合方式将被禁用。</p><p>逻辑运算符我们在这里也不过多介绍，可以参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkLogicOp.html">这个页面</a>。</p><p>下面的<i><font color="Orange">attachmentCount</font></i>和<i><font color="Orange">pAttachments</font></i>指定所有填写好的的颜色附件混合模式结构体<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>。最后的<i><font color="Orange">blendConstants</font></i>数组指定了<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>中指定的混合因子的具体值（<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>中指定的是一个抽象的混合因子，这个因子具体的值由<i><font color="Orange">blendConstants</font></i>数组指定）。</p><p>对于我们绘制三角形的程序，我们只有一个颜色附件，也不需要有特殊的混合操作，因此我们只需如下设置即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineColorBlendAttachmentState colorBlendAttachment&#123;&#125;;<br>colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;<br>colorBlendAttachment.blendEnable = VK_FALSE;<br>colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; <span class="hljs-comment">// Optional</span><br><br>VkPipelineColorBlendStateCreateInfo colorBlending&#123;&#125;;<br>colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;<br>colorBlending.logicOpEnable = VK_FALSE;<br>colorBlending.logicOp = VK_LOGIC_OP_COPY; <span class="hljs-comment">// Optional</span><br>colorBlending.attachmentCount = <span class="hljs-number">1</span>;<br>colorBlending.pAttachments = &amp;colorBlendAttachment;<br>colorBlending.blendConstants[<span class="hljs-number">0</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span><br>colorBlending.blendConstants[<span class="hljs-number">1</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span><br>colorBlending.blendConstants[<span class="hljs-number">2</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span><br>colorBlending.blendConstants[<span class="hljs-number">3</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span><br></code></pre></td></tr></table></figure><hr><h2 id="管线布局">管线布局</h2><p>在程序运行过程中我们往往需要动态地向着色器传入某些值，比如说uniform变量。尽管我们现在并不需要这么做，我们仍然需要创建一个空的<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineLayout.html"><code>VkPipelineLayout</code></a>来指定这些值。</p><p>在类内创建一个<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineLayout.html"><code>VkPipelineLayout</code></a>类型的成员<i><font color="Orange">pipelineLayout</font></i>，然后在<i><font color="Green">createGraphicsPipeline</font></i>函数中构建这个对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineLayoutCreateInfo pipelineLayoutInfo&#123;&#125;;<br>pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;<br>pipelineLayoutInfo.setLayoutCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>pipelineLayoutInfo.pSetLayouts = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br>pipelineLayoutInfo.pushConstantRangeCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>pipelineLayoutInfo.pPushConstantRanges = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreatePipelineLayout</span>(device, &amp;pipelineLayoutInfo, <span class="hljs-literal">nullptr</span>, &amp;pipelineLayout) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create pipeline layout!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineLayoutCreateInfo.html"><code>VkPipelineLayoutCreateInfo</code></a>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineLayoutCreateInfo</span> &#123;</span><br>    VkStructureType                 sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                     pNext;<br>    VkPipelineLayoutCreateFlags     flags;<br>    <span class="hljs-type">uint32_t</span>                        setLayoutCount;<br>    <span class="hljs-type">const</span> VkDescriptorSetLayout*    pSetLayouts;<br>    <span class="hljs-type">uint32_t</span>                        pushConstantRangeCount;<br>    <span class="hljs-type">const</span> VkPushConstantRange*      pPushConstantRanges;<br>&#125; VkPipelineLayoutCreateInfo;<br></code></pre></td></tr></table></figure><p>注意这个结构体可以指定两种传递给着色器的变量：<strong>uniformvalues</strong>和<strong>push constants</strong>。<strong>pushconstants</strong>实际上就是比较小型的数据块，它们直接嵌入到指令流中，因此在性能上优于使用缓冲区对象。不过它们的大小受到限制，一般为128字节。</p><p>大功告成！我们终于完成了所有固定管线阶段信息的填写。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/">上一篇：着色器模块</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/">下一篇：渲染通道</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>渲染管线简介</title>
    <link href="/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/"/>
    <url>/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>本节主要简单介绍一下渲染管线的各个阶段及其所做的工作，本节对应VulkanTutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Introduction">Graphicspipeline basics/Introduction</a>章节。</p><hr><h2 id="流程梳理">流程梳理</h2><p>下图给出了渲染管线的基本流程：</p><figure><img src="/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/pipeline.png" alt="渲染管线"><figcaption aria-hidden="true">渲染管线</figcaption></figure><ul><li><p>输入汇编器（inputassembler）阶段收集用户在缓冲区中指定的定点信息和顶点索引信息。</p></li><li><p>顶点着色器（vertexshader）阶段对各个顶点进行坐标变换并且向后传递逐顶点信息。</p></li><li><p>曲面细分（tessellation）阶段允许用户进一步细分几何以增加面片质量和精细度。</p></li><li><p>几何着色器（geometryshader）阶段作用于每个基本图元，增加或丢弃部分图元。</p></li><li><p>光栅化（rasterization）阶段将图元打散成片段并且丢弃在屏幕外面的那些片段。</p></li><li><p>片段着色器（fragmentshader）阶段决定每个片段的输出位置以及它们各自的输出结果。</p></li><li><p>颜色混合（colorblending）阶段采用指定的方式混合对应于同一像素的不同片段的值。</p></li></ul><p>图中绿色的阶段代表该阶段不可编程，也就是说我们只能设置与该阶段运作有关的一些参数，但不能自己编写该阶段的运行逻辑；而橙色阶段代表该阶段可编程，也就是说我们可以自己书写代码来指定该阶段的工作流程。</p><p>Vulkan中的渲染管线不同于OpenGL，绝大多数情况下我们不能在运行时改变管线的设置，一旦发生变化，我们一般会需要重新建立一个管线，这么做的好处是由于对管线的操作是提前预知且固定的，硬件就可以对管线进行一些优化。</p><p>接下来的章节，我们将建立一个<i><font color="Green">voidcreateGraphicsPipeline()</font></i>成员函数来建立起一个基本的渲染管线。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/">上一篇：图像视图</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/">下一篇：着色器模块</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>着色器模块</title>
    <link href="/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/"/>
    <url>/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>这一章节我们将完成渲染管线中可编程阶段的构建。目前我们只简单地考虑构建顶点着色器和片段着色器阶段。</p><p>与之前的图形API不同，Vulkan使用的着色器代码需要是<a href="https://www.khronos.org/spir">SPIR-V</a>格式的，它的优点是相比于易于我们阅读的GLSL和HLSL代码，<a href="https://www.khronos.org/spir">SPIR-V</a>代码更容易被转化为GPU使用的机器码，并且GLSL和HLSL代码可能会因为GPU产商所设定的不同标准产生在不同机器上的不兼容现象，<a href="https://www.khronos.org/spir">SPIR-V</a>代码就不会出现这种问题。</p><p>不过幸运的是，我们并不需要自己手写<a href="https://www.khronos.org/spir">SPIR-V</a>代码，这里我们将使用VulkanSDK自带的glslc.exe来将GLSL代码编译为<a href="https://www.khronos.org/spir">SPIR-V</a>代码。</p><p>创建着色器模块主要分为四步：</p><ul><li>编写着色器代码</li><li>将着色器文件编译为<a href="https://www.khronos.org/spir">SPIR-V</a>代码</li><li>加载着色器文件到程序中并包裹在<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html"><code>VkShaderModule</code></a>对象中</li><li>填写渲染管线着色器阶段信息</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules">Shadermodules</a>章节。</p><hr><h2 id="编写着色器代码">编写着色器代码</h2><p>假设读者已经对GLSL基本语法比较熟悉了。由于我们的第一个应用程序只需要简单地绘制一个三角形，所以顶点着色器代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-type">vec2</span> positions[<span class="hljs-number">3</span>] = <span class="hljs-type">vec2</span>[](<br>    <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">-0.5</span>),<br>    <span class="hljs-type">vec2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>),<br>    <span class="hljs-type">vec2</span>(<span class="hljs-number">-0.5</span>, <span class="hljs-number">0.5</span>)<br>);<br><br><span class="hljs-type">vec3</span> colors[<span class="hljs-number">3</span>] = <span class="hljs-type">vec3</span>[](<br>    <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>),<br>    <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>),<br>    <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>)<br>);<br><br><span class="hljs-type">void</span> main() &#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(positions[gl_VertexIndex], <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fragColor = colors[gl_VertexIndex];<br>&#125;<br></code></pre></td></tr></table></figure><p>目前我们还没有介绍顶点缓冲，因此我们暂时将顶点数据硬编码在着色器文件中。另外，每个顶点我们都赋予不同的颜色，以便在后续光栅化阶段插值该颜色以形成渐变色的效果。</p><p>注意，<i><font color="Orange">gl_VertexIndex</font></i>代表的是当前处理的顶点对应的索引，这是一个glsl内建变量。</p><p>片段着色器代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outColor;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> fragColor;<br><br><span class="hljs-type">void</span> main() &#123;<br>    outColor = <span class="hljs-type">vec4</span>(fragColor, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>片段着色器的输入数据并不需要和顶点着色器中对应的输出数据名称一致，但是需要指定它们的location一致，这样才能将对应的输出输入链接到一起。</p><hr><h2 id="编译为spir-v代码">编译为SPIR-V代码</h2><p>windows下编译为<a href="https://www.khronos.org/spir">SPIR-V</a>代码很简单，我们可以将上面的两个文件（分别命名为<font color="Purple">shader.vert</font>，<font color="Purple">shader,frag</font>）保存在项目根目录下的一个文件夹<font color="Purple">shaders</font>中，然后在该文件下创建一个批处理文件<font color="Purple">compile.bat</font>：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bat"><span class="hljs-built_in">path</span>/to/glslc.exe shader.vert -o vert.spv<br><span class="hljs-built_in">path</span>/to/glslc.exe shader.frag -o frag.spv<br><span class="hljs-built_in">pause</span><br></code></pre></td></tr></table></figure><p>将<i><font color="Orange">path/to/glslc.exe</font></i>替换为自己电脑上对应的glslc.exe文件路径即可。</p><p>双击bat文件运行即可在同一文件夹下创建对应的<a href="https://www.khronos.org/spir">SPIR-V</a>文件。</p><p>当然，这只是创建<a href="https://www.khronos.org/spir">SPIR-V</a>文件的一种方式，VulkanSDK还提供了<a href="https://github.com/google/shaderc">libshaderc</a>，它允许我们在程序代码中将glsl文件编译为<a href="https://www.khronos.org/spir">SPIR-V</a>文件。</p><hr><h2 id="创建vkshadermodule">创建VkShaderModule</h2><p>接下来我们需要将编译好的<a href="https://www.khronos.org/spir">SPIR-V</a>文件加载到程序中来。创建一个静态函数<i><font color="Green">staticstd::vector<char> readFile(const std::string&amp;filename)</char></font></i>来完成这个工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> std::vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">readFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename)</span> </span>&#123;<br>    <span class="hljs-function">std::ifstream <span class="hljs-title">file</span><span class="hljs-params">(filename, std::ios::ate | std::ios::binary)</span></span>;<br><span class="hljs-comment">//ate代表指针定位到文件末尾，这样可以通过tellg知道文件的大小；binary代表以二进制文件格式读取文件</span><br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">is_open</span>()) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to open file!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-type">size_t</span> fileSize = (<span class="hljs-type">size_t</span>) file.<span class="hljs-built_in">tellg</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(fileSize)</span></span>;<br>    <br>    file.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//定位到文件头，准备开始读取文件</span><br>    file.<span class="hljs-built_in">read</span>(buffer.<span class="hljs-built_in">data</span>(), fileSize);<br>    <br>    file.<span class="hljs-built_in">close</span>();<br><br><span class="hljs-keyword">return</span> buffer;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，在<i><font color="Green">crearteGraphicsPipeline</font></i>函数中，我们就可以使用这个函数来读取我们写好的顶点着色器和片段着色器文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createGraphicsPipeline</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> vertShaderCode = <span class="hljs-built_in">readFile</span>(<span class="hljs-string">&quot;shaders/vert.spv&quot;</span>);<br>    <span class="hljs-keyword">auto</span> fragShaderCode = <span class="hljs-built_in">readFile</span>(<span class="hljs-string">&quot;shaders/frag.spv&quot;</span>);<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>读取文件之后，我们需要使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html"><code>VkShaderModule</code></a>包裹住这个文件内容才能使用，因此我们创建一个<i><font color="Green">VkShaderModulecreateShaderModule(const std::vector<char>&amp;code)</char></font></i>来完成这项工作。</p><p>为了创建[<code>VkShaderModule</code><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html">id0</a>对象，我们当然也需要填写相关的信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModuleCreateInfo.html"><code>VkShaderModuleCreateInfo</code></a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkShaderModuleCreateInfo</span> &#123;</span><br>    VkStructureType              sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                  pNext;<br>    VkShaderModuleCreateFlags    flags;   <span class="hljs-comment">//目前还没有</span><br>    <span class="hljs-type">size_t</span>                       codeSize;<span class="hljs-comment">//文件大小</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*              pCode;  <span class="hljs-comment">//文件内容</span><br>&#125; VkShaderModuleCreateInfo;<br></code></pre></td></tr></table></figure><p>这里需要注意的是，我们传给<i><font color="Green">createShaderModule</font></i>的参数为字符向量，但是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModuleCreateInfo.html"><code>VkShaderModuleCreateInfo</code></a>需要的参数<i><font color="Orange">pCode</font></i>是字节码，也就是一个指向<i><font color="Orange">uint32_t</font></i>的指针，因此我们需要如下编写代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkShaderModule <span class="hljs-title">createShaderModule</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">char</span>&gt;&amp; code)</span> </span>&#123;<br>VkShaderModuleCreateInfo createInfo&#123;&#125;;<br>createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;<br>createInfo.codeSize = code.<span class="hljs-built_in">size</span>();<br>createInfo.pCode = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*&gt;(code.<span class="hljs-built_in">data</span>());<br>    <br>    VkShaderModule shaderModule;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateShaderModule</span>(device, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;shaderModule) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create shader module!&quot;</span>);<br>&#125;<br>    <br>    <span class="hljs-keyword">return</span> shaderModule;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以使用这个函数在<i><font color="Green">crearteGraphicsPipeline</font></i>函数中构建着色器文件相应的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html"><code>VkShaderModule</code></a>对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createGraphicsPipeline</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> vertShaderCode = <span class="hljs-built_in">readFile</span>(<span class="hljs-string">&quot;shaders/vert.spv&quot;</span>);<br>    <span class="hljs-keyword">auto</span> fragShaderCode = <span class="hljs-built_in">readFile</span>(<span class="hljs-string">&quot;shaders/frag.spv&quot;</span>);<br><br>    VkShaderModule vertShaderModule = <span class="hljs-built_in">createShaderModule</span>(vertShaderCode);<br>    VkShaderModule fragShaderModule = <span class="hljs-built_in">createShaderModule</span>(fragShaderCode);<br>    <span class="hljs-comment">//...</span><br>    <br>    <span class="hljs-built_in">vkDestroyShaderModule</span>(device, fragShaderModule, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">vkDestroyShaderModule</span>(device, vertShaderModule, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，在使用完着色器模块后要使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyShaderModule.html"><code>vkDestroyShaderModule</code></a>清理掉相应对象。注意，这里我们并没有将着色器模块保存为类的成员，因为着色器模块在渲染管线构建完成之后会被GPU编译链接为真正执行用的机器码，此后着色器模块对象就不再需要了，因此我们可以在<i><font color="Green">crearteGraphicsPipeline</font></i>函数最后将其销毁掉，没有保存的必要。</p><hr><h2 id="填写着色器阶段信息">填写着色器阶段信息</h2><p>创建好着色器模块后，我们需要将这个模块插入到渲染管线对应的着色器阶段中。为此我们需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateInfo.html"><code>VkPipelineShaderStageCreateInfo</code></a>以供后续创建渲染管线对象时使用。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateInfo.html"><code>VkPipelineShaderStageCreateInfo</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineShaderStageCreateInfo</span> &#123;</span><br>    VkStructureType                     sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                         pNext;<br>    VkPipelineShaderStageCreateFlags    flags;<br>    VkShaderStageFlagBits               stage;<br>    VkShaderModule                      module;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                         pName;              <span class="hljs-comment">//着色器入口函数名称</span><br>    <span class="hljs-type">const</span> VkSpecializationInfo*         pSpecializationInfo;<span class="hljs-comment">//特化常量信息</span><br>&#125; VkPipelineShaderStageCreateInfo;<br></code></pre></td></tr></table></figure><p><a href="https://zpc-dsg.github.io/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/"><code>VkPipelineShaderStageCreateFlags</code></a>是<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E5%87%BD%E6%95%B0/"><code>VkPipelineShaderStageCreateFlagBits</code></a>的位组合，后者定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkPipelineShaderStageCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//允许在该着色器阶段使用可变大小的子组（subgroup）。这意味着在执行过程中，子组的大小可以变化，从而提供更大的灵活性，适用于某些计算任务。</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//要求该着色器阶段使用完整的子组。即所有子组的大小必须是指定的最大子组大小，这通常用于保证性能和一致性，确保所有线程在子组内都能得到相同的执行路径。</span><br>  <span class="hljs-comment">// Provided by VK_EXT_subgroup_size_control</span><br>    VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT,<br>  <span class="hljs-comment">// Provided by VK_EXT_subgroup_size_control</span><br>    VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT,<br>&#125; VkPipelineShaderStageCreateFlagBits;<br></code></pre></td></tr></table></figure><p>首先需要解释的是<i><font color="Orange">pName</font></i>成员，该形参指定着色器代码的入口点。一般来讲我们的glsl着色器代码入口点为<i><font color="Green">main</font></i>函数，但是Vulkan允许我们指定其它函数名作为入口函数，这也意味着我们可以在一个着色器模块中绑定多个具有不同入口名的着色器文件。</p><p>另外，<i><font color="Orange">pSpecializationInfo</font></i>指定的是需要传给着色器的特化常量的信息。特化常量是在着色器编译时指定的常量值。它们在着色器代码中声明为特化常量，并在编译时被替换为具体的值。这使得可以在不同的管线实例中使用不同的常量值，提高了性能，因为编译器能够针对这些常量进行优化。在GLSL 中，特化常量通常使用 <code>const</code> 关键字来声明，但在 Vulkan中，需要使用特化常量的机制来定义和传递这些值。特化常量与C中的预编译命令<code>#define</code>类似，不过特化常量是有类型的，编译器能够进行类型检查，并且特化常量的作用域通常局限于声明它们的着色器阶段，因此相比来讲特化常量具有类型安全和更好的作用域控制。</p><p>现在我们在<i><font color="Green">crearteGraphicsPipeline</font></i>函数中填写顶点着色器和片段着色器对应的着色器阶段信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineShaderStageCreateInfo vertShaderStageInfo&#123;&#125;;<br>vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;<br>vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;<br>vertShaderStageInfo.<span class="hljs-keyword">module</span> = vertShaderModule;<br>vertShaderStageInfo.pName = <span class="hljs-string">&quot;main&quot;</span>;<br><br>VkPipelineShaderStageCreateInfo fragShaderStageInfo&#123;&#125;;<br>fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;<br>fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;<br>fragShaderStageInfo.<span class="hljs-keyword">module</span> = fragShaderModule;<br>fragShaderStageInfo.pName = <span class="hljs-string">&quot;main&quot;</span>;<br><br>VkPipelineShaderStageCreateInfo shaderStages[] = &#123;vertShaderStageInfo, fragShaderStageInfo&#125;;<br></code></pre></td></tr></table></figure><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/">上一篇：渲染管线简介</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E5%87%BD%E6%95%B0/">下一篇：固定管线</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图像视图</title>
    <link href="/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/"/>
    <url>/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>为了使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImage.html"><code>VkImage</code></a>，我们需要相应的视图<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageView.html"><code>VkImageView</code></a>。图像视图的作用是描述图像应该如何被使用以及图像的哪部分可以被使用。接下来我们将创建一个<i><font color="Green">voidcreateImageViews()</font></i>函数来创建所有的图像视图。创建图像视图的过程比较简单，主要分为两步：</p><ul><li>填写创建信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateInfo.html"><code>VkImageViewCreateInfo</code></a></li><li>创建图像视图对象</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Image_views">Imageviews</a>章节。</p><hr><h2 id="填写创建信息">填写创建信息</h2><p>由于对于每张图像我们都需要有对应的视图，因此我们在<i><font color="Green">createImageViews</font></i>函数中创建一个循环来填写每个视图的信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createImageViews</span><span class="hljs-params">()</span> </span>&#123;<br>    swapChainImageViews.<span class="hljs-built_in">resize</span>(swapChainImages.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainImages.<span class="hljs-built_in">size</span>(); i++) &#123;<br>VkImageViewCreateInfo createInfo&#123;&#125;;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateInfo.html"><code>VkImageViewCreateInfo</code></a>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkImageViewCreateInfo</span> &#123;</span><br>    VkStructureType            sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                pNext;<br>    VkImageViewCreateFlags     flags;<br>    VkImage                    image;<br>    VkImageViewType            viewType;<br>    VkFormat                   format;<br>    VkComponentMapping         components;<br>    VkImageSubresourceRange    subresourceRange;<br>&#125; VkImageViewCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateFlagBits.html"><code>VkImageViewCreateFlagBits</code></a>的位组合，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateFlagBits.html"><code>VkImageViewCreateFlagBits</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkImageViewCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_EXT_fragment_density_map</span><br>    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//此标志指示图像视图将用于动态片段密度映射（fragment density map）。动态片段密度映射允许在运行时调整每个像素的片段密度，以优化渲染性能和资源使用。</span><br>  <span class="hljs-comment">// Provided by VK_EXT_descriptor_buffer</span><br>    VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//表示图像视图将用于延迟片段密度映射。这种方式允许在后续渲染阶段处理片段密度，而不是在每个绘制调用中立即处理，从而提高效率。</span><br>  <span class="hljs-comment">// Provided by VK_EXT_fragment_density_map2</span><br>    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//此标志用于描述符缓冲区的捕获和重放。它指示图像视图可以在捕获和重放的上下文中使用，这对于调试和性能分析工具非常有用。</span><br>&#125; VkImageViewCreateFlagBits;<br></code></pre></td></tr></table></figure><p>我们在这里不指定任何标志。</p><p>接下来需要解释的是<i><font color="Orange">viewType</font></i>，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewType.html"><code>VkImageViewType</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkImageViewType</span> &#123;</span><br>    VK_IMAGE_VIEW_TYPE_1D = <span class="hljs-number">0</span>,<br>    VK_IMAGE_VIEW_TYPE_2D = <span class="hljs-number">1</span>,<br>    VK_IMAGE_VIEW_TYPE_3D = <span class="hljs-number">2</span>,<br>    VK_IMAGE_VIEW_TYPE_CUBE = <span class="hljs-number">3</span>,<br>    VK_IMAGE_VIEW_TYPE_1D_ARRAY = <span class="hljs-number">4</span>,<br>    VK_IMAGE_VIEW_TYPE_2D_ARRAY = <span class="hljs-number">5</span>,<br>    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = <span class="hljs-number">6</span>,<br>&#125; VkImageViewType;<br></code></pre></td></tr></table></figure><p>显然作为颜色缓冲的图像类型应该被指定为<i><font color="Red">VK_IMAGE_VIEW_TYPE_2D</font></i>。</p><p>之后的<i><font color="Orange">format</font></i>也应当和该视图对应的图像一致，因此我们将上一章保存在应用程序类内的成员<i><font color="Orange">swapChainImageFormat</font></i>为其赋值。</p><p><i><font color="Orange">components</font></i>指定了图像颜色通道的再映射。我们这里不需要任何特殊的映射，因此我们只需简单地指定映射为恒等变换即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;<br>createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;<br>createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;<br>createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;<br></code></pre></td></tr></table></figure><p>最后，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceRange.html"><code>VkImageSubresourceRange</code></a>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkImageSubresourceRange</span> &#123;</span><br>    VkImageAspectFlags    aspectMask;    <span class="hljs-comment">//图像的方面，即图像数据的不同特性或组成部分</span><br>    <span class="hljs-type">uint32_t</span>              baseMipLevel;  <span class="hljs-comment">//基础多级渐远级别</span><br>    <span class="hljs-type">uint32_t</span>              levelCount; <span class="hljs-comment">//多级渐远级数</span><br>    <span class="hljs-type">uint32_t</span>              baseArrayLayer;<span class="hljs-comment">//基础图像层</span><br>    <span class="hljs-type">uint32_t</span>              layerCount; <span class="hljs-comment">//图像层数目</span><br>&#125; VkImageSubresourceRange;<br></code></pre></td></tr></table></figure><p>我们希望交换链中的图像用作颜色缓冲，因此<i><font color="Orange">subresourceRange.aspectMask</font></i>应该指定为<i><font color="Red">VK_IMAGE_ASPECT_COLOR_BIT</font></i>。颜色缓冲不需要生成多级渐远纹理，因此<i><font color="Orange">subresourceRange.baseMipLevel</font></i>设为0，<i><font color="Orange">subresourceRange.levelCount</font></i>设为1。由于我们并非创建一个3D项目，因此并不需要多图像层，因此<i><font color="Orange">subresourceRange.baseArrayLayer</font></i>设为0，<i><font color="Orange">subresourceRange.layerCount</font></i>设为1即可。</p><p>这样我们就完成了信息的填写。</p><hr><h2 id="创建视图">创建视图</h2><p>创建过程一如以往：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateImageView</span>(device, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;swapChainImageViews[i]) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create image views!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，即使创建好了图像视图，也不意味着图像已经可以作为渲染目标使用了，我们还需要创建帧缓冲对象来存储图像视图才能进行渲染，后续章节会介绍这一部分内容。</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/">上一篇：交换链</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/">下一篇：渲染管线简介</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>交换链</title>
    <link href="/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/"/>
    <url>/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>Vulkan中并没有所谓的“默认帧缓冲”的概念，所以我们需要一个能够储存渲染后图像以便之后显示到屏幕上的设施，这个设施就是交换链（swapChain）。交换链本质上就是一列图像，我们的应用程序会不断获取其中的一张，显示到屏幕上，然后归还给交换链。</p><p>创建一个交换链主要分为三步：</p><ul><li>查询显卡是否支持交换链并启用相应拓展</li><li>填写创建交换链所需的必要信息</li><li>创建交换链并保存有关对象为类成员</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain#page_Surface-format">Swapchain</a>章节。</p><hr><h2 id="查询支持">查询支持</h2><p>查询硬件是否支持交换链可以分为两步：查询交换链是否可用，以及查询交换链是否完整地具有所需的功能。</p><h4 id="查询交换链可用性">查询交换链可用性</h4><p>首先来查询物理设备是否支持交换链。事实上，如果一个物理设备支持显示队列的话，那么它一定支持交换链拓展。不过，在Vulkan中清晰地展示出一切细节总不是件坏事。所以这里我们还是选择查询一下设备对交换链的支持。</p><p>交换链支持拓展名为<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_swapchain.html"><code>VK_KHR_swapchain</code></a>，它是一个设备层面的拓展。于是我们在类外创建一个全局变量保存我们可能需要的所有设备层面的拓展名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; deviceExtensions = &#123;<br>    VK_KHR_SWAPCHAIN_EXTENSION_NAME<span class="hljs-comment">//字符串&quot;VK_KHR_swapchain&quot;对应的宏，用它避免拼写错误</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>下面，我们需要查询物理设备是否支持这个拓展。于是添加一个<i><font color="Green">checkDeviceExtensionSupport</font></i>函数来统一处理设备层面拓展的支持查询：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkDeviceExtensionSupport</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> extensionCount;<br>    <span class="hljs-built_in">vkEnumerateDeviceExtensionProperties</span>(device, <span class="hljs-literal">nullptr</span>, &amp;extensionCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkExtensionProperties&gt; <span class="hljs-title">availableExtensions</span><span class="hljs-params">(extensionCount)</span></span>;<br>    <span class="hljs-built_in">vkEnumerateDeviceExtensionProperties</span>(device, <span class="hljs-literal">nullptr</span>, &amp;extensionCount, availableExtensions.<span class="hljs-built_in">data</span>());<br><br>    <span class="hljs-function">std::set&lt;std::string&gt; <span class="hljs-title">requiredExtensions</span><span class="hljs-params">(deviceExtensions.begin(), deviceExtensions.end())</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; extension : availableExtensions) &#123;<br>        requiredExtensions.<span class="hljs-built_in">erase</span>(extension.extensionName);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> requiredExtensions.<span class="hljs-built_in">empty</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是易于理解的。</p><p>接下来我们要做的就是在<i><font color="Green">isDeviceSuitable</font></i>函数中使用<i><font color="Green">checkDeviceExtensionSupport</font></i>检查给定的物理设备是否支持指定的拓展：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(device);<br><br>    <span class="hljs-type">bool</span> extensionsSupported = <span class="hljs-built_in">checkDeviceExtensionSupport</span>(device);<br><br>    <span class="hljs-keyword">return</span> indices.<span class="hljs-built_in">isComplete</span>() &amp;&amp; extensionsSupported;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，如果选择的物理设备支持交换链拓展，那么我们需要启用这个拓展。启用拓展只需略微修改逻辑设备的createInfo，将原来的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.enabledExtensionCount = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>改为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.enabledExtensionCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(deviceExtensions.<span class="hljs-built_in">size</span>());<br>createInfo.ppEnabledExtensionNames = deviceExtensions.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>即可。</p><h4 id="查询交换链完整性">查询交换链完整性</h4><p>仅仅查询交换链是否可用是不够的，我们还需要知道选定的支持交换链的物理设备是否具有所需的和显示有关的表面功能特性。我们需要查询的主要细节有三点：</p><ul><li>基本表面属性，包括交换链可以具有的最少/最多图像数目，图像的最小/最大尺寸等</li><li>表面格式，具体而言指的是像素格式和颜色空间</li><li>可用显示模式</li></ul><p>于是建立一个结构体<i><font color="Orange">SwapChainSupportDetails</font></i>来保存这些查询结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SwapChainSupportDetails</span> &#123;<br>    VkSurfaceCapabilitiesKHR capabilities;<br>    std::vector&lt;VkSurfaceFormatKHR&gt; formats;<br>    std::vector&lt;VkPresentModeKHR&gt; presentModes;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在类内建立一个成员函数<i><font color="Green">SwapChainSupportDetailsquerySwapChainSupport(VkPhysicalDevicedevice)</font></i>来负责具体的查询：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SwapChainSupportDetails <span class="hljs-title">querySwapChainSupport</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    SwapChainSupportDetails details;<br><br>    <span class="hljs-built_in">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</span>(device, surface, &amp;details.capabilities);<br>    <br>    <span class="hljs-type">uint32_t</span> formatCount;<br><span class="hljs-built_in">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(device, surface, &amp;formatCount, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-keyword">if</span> (formatCount != <span class="hljs-number">0</span>) &#123;<br>    details.formats.<span class="hljs-built_in">resize</span>(formatCount);<br>    <span class="hljs-built_in">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(device, surface, &amp;formatCount, details.formats.<span class="hljs-built_in">data</span>());<br>&#125;<br>    <br>    <span class="hljs-type">uint32_t</span> presentModeCount;<br><span class="hljs-built_in">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(device, surface, &amp;presentModeCount, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-keyword">if</span> (presentModeCount != <span class="hljs-number">0</span>) &#123;<br>    details.presentModes.<span class="hljs-built_in">resize</span>(presentModeCount);<br>    <span class="hljs-built_in">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(device, surface, &amp;presentModeCount, details.presentModes.<span class="hljs-built_in">data</span>());<br>&#125;<br>    <span class="hljs-keyword">return</span> details;<br>&#125;<br></code></pre></td></tr></table></figure><p>查询过程就是单纯地依次填充每个结构体成员。在这里我们只是简单地要求表面格式和显示模式均至少要有一种，这样就认为该物理设备的交换链是完整可用的。</p><p>现在我们需要再次修改一下<i><font color="Green">isDeviceSuitable</font></i>函数以添加检查交换链完整性的逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(device);<br><br>    <span class="hljs-type">bool</span> extensionsSupported = <span class="hljs-built_in">checkDeviceExtensionSupport</span>(device);<br><br>    <span class="hljs-type">bool</span> swapChainAdequate = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (extensionsSupported) &#123;<br>        SwapChainSupportDetails swapChainSupport = <span class="hljs-built_in">querySwapChainSupport</span>(device);<br>        swapChainAdequate = !swapChainSupport.formats.<span class="hljs-built_in">empty</span>() &amp;&amp; !swapChainSupport.presentModes.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> indices.<span class="hljs-built_in">isComplete</span>() &amp;&amp; extensionsSupported &amp;&amp; swapChainAdequate;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="填写创建信息">填写创建信息</h2><p>下面我们创建一个<i><font color="Green">voidcreateSwapChain()</font></i>函数来创建交换链。首先我们需要查询交换链有关的表面信息以方便后续交换链创建信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>的填写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createSwapChain</span><span class="hljs-params">()</span> </span>&#123;<br>    SwapChainSupportDetails swapChainSupport = <span class="hljs-built_in">querySwapChainSupport</span>(physicalDevice);<br><br>    VkSwapchainCreateInfoKHR createInfo&#123;&#125;;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>交换链创建信息需要指定的信息量相较于之前创建的对象要多得多，我们逐个填写。</p><p>首先总览一下交换链创建信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSwapchainCreateInfoKHR</span> &#123;</span><br>    VkStructureType                  sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                      pNext;<br>    VkSwapchainCreateFlagsKHR        flags;<br>    VkSurfaceKHR                     surface; <span class="hljs-comment">//对应的表面</span><br>    <span class="hljs-type">uint32_t</span>                         minImageCount;<br>    VkFormat                         imageFormat;<br>    VkColorSpaceKHR                  imageColorSpace;<br>    VkExtent2D                       imageExtent;<br>    <span class="hljs-type">uint32_t</span>                         imageArrayLayers;<br>    VkImageUsageFlags                imageUsage;<br>    VkSharingMode                    imageSharingMode;<br>    <span class="hljs-type">uint32_t</span>                         queueFamilyIndexCount;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*                  pQueueFamilyIndices;<br>    VkSurfaceTransformFlagBitsKHR    preTransform;<br>    VkCompositeAlphaFlagBitsKHR      compositeAlpha;<br>    VkPresentModeKHR                 presentMode;<br>    VkBool32                         clipped;<br>    VkSwapchainKHR                   oldSwapchain;<br>&#125; VkSwapchainCreateInfoKHR;<br></code></pre></td></tr></table></figure><p>首先看第三个成员<i><font color="Orange">flags</font></i>，它是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateFlagBitsKHR.html"><code>VkSwapchainCreateFlagBitsKHR</code></a>的位组合。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateFlagBitsKHR.html"><code>VkSwapchainCreateFlagBitsKHR</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkSwapchainCreateFlagBitsKHR</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1 with VK_KHR_swapchain, VK_KHR_device_group with VK_KHR_swapchain</span><br>    VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//表示交换链的图像可以在不同的实例中进行绑定，这对于多实例的设备组（Device Group）非常有用。它允许在不同的设备实例之间共享交换链图像</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1 with VK_KHR_swapchain</span><br>    VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//指定交换链中的图像是受保护的。这意味着这些图像的内容在某些情况下（例如，受保护的内容播放）不会被访问或修改。这个标志通常用于需要内容保护的应用程序，如播放受版权保护的媒体</span><br>  <span class="hljs-comment">// Provided by VK_KHR_swapchain_mutable_format</span><br>    VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//允许交换链的格式在创建后进行更改。这对于需要动态调整图像格式的应用程序非常有用，比如在不同的显示设备上使用不同的格式</span><br>  <span class="hljs-comment">// Provided by VK_EXT_swapchain_maintenance1</span><br>    VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//指示交换链的图像内存分配可以延迟到实际使用时。这有助于优化内存使用，特别是在不确定图像会被使用的情况下</span><br>&#125; VkSwapchainCreateFlagBitsKHR;<br></code></pre></td></tr></table></figure><p>我们这里不需要设置任何标志位;</p><p>接下来要填写<i><font color="Orange">minImageCount</font></i>成员。这可以通过查询我们之前自定义的结构体<i><font color="Orange">SwapChainSupportDetails</font></i>的成员<i><font color="Orange">capabilities</font></i>的<i><font color="Orange">minImageCount</font></i>和<i><font color="Orange">maxImageCount</font></i>成员来决定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> imageCount = swapChainSupport.capabilities.minImageCount + <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span> (swapChainSupport.capabilities.maxImageCount &gt; <span class="hljs-number">0</span> &amp;&amp; imageCount &gt; swapChainSupport.capabilities.maxImageCount) &#123;<br>    imageCount = swapChainSupport.capabilities.maxImageCount;<br>&#125;<br><br>createInfo.minImageCount = imageCount;<br></code></pre></td></tr></table></figure><p>这里有两个需要解释的地方：第一行中加1是因为如果仅仅使用最少数量的图像可能意味着我们有时可能需要等待驱动程序完成内部操作，才能获取另一个图像进行渲染，因此我们要求至少多一张图像；另外maxImageCount==0其实意味着交换链可以拥有的图像没有上界，因此当这个值大于0时，我们需要控制要求的交换链图像数目不超过其可能上界。</p><p>接下来，对于<i><font color="Orange">imageFormat</font></i>和<i><font color="Orange">imageColorSpace</font></i>成员，我们可以通过<i><font color="Orange">SwapChainSupportDetails</font></i>结构体的成员<i><font color="Orange">formats</font></i>成员来获取相关信息。<i><font color="Orange">formats</font></i>包含了交换链支持的所有表面图像格式信息，我们需要从中挑选最符合我们要求的那个格式。因此，我们创建一个<i><font color="Green">VkSurfaceFormatKHRchooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>&amp;availableFormats)</VkSurfaceFormatKHR></font></i>函数来达到上述目的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkSurfaceFormatKHR <span class="hljs-title">chooseSwapSurfaceFormat</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;VkSurfaceFormatKHR&gt;&amp; availableFormats)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; availableFormat : availableFormats) &#123;<br>        <span class="hljs-keyword">if</span> (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB &amp;&amp; availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) &#123;<br>            <span class="hljs-keyword">return</span> availableFormat;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> availableFormats[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>我们希望挑选的颜色格式是<i><font color="Red">VK_FORMAT_B8G8R8A8_SRGB</font></i>，希望图像所处的颜色空间为sRGB颜色空间<i><font color="Red">VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</font></i>（关于sRGB空间和伽马矫正的原理介绍，可以参考<a href="https://learnopengl.com/Introduction">LearnOpenGL</a>教程的<a href="https://learnopengl.com/Advanced-Lighting/Gamma-Correction">GammaCorrection</a>章节），如果不支持这种格式的图像的话，那就退而求其次，直接返回第一个支持的格式（当然我们可以自定义一些更复杂的选择逻辑）。</p><p>这样，我们就可以填写<i><font color="Orange">imageFormat</font></i>和<i><font color="Orange">imageColorSpace</font></i>成员的信息了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSurfaceFormatKHR surfaceFormat = <span class="hljs-built_in">chooseSwapSurfaceFormat</span>(swapChainSupport.formats);<br><br>createInfo.imageFormat = surfaceFormat.format;<br>createInfo.imageColorSpace = surfaceFormat.colorSpace;<br></code></pre></td></tr></table></figure><p>然后我们来填写<i><font color="Orange">imageExtent</font></i>成员。这个形参代表的是交换链图像的分辨率。一般来讲，这个分辨率要和屏幕的分辨率一致，此时我们可以直接通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilitiesKHR.html"><code>VkSurfaceCapabilitiesKHR</code></a>结构体的<i><font color="Orange">currentExtent</font></i>成员来获取图像的尺寸。但是有的窗口系统会允许交换链图像的分辨率与屏幕分辨率不一致，此时<i><font color="Orange">currentExtent</font></i>会被设置为<a href="https://en.cppreference.com/w/cpp/types/numeric_limits/max"><code>std::numeric_limits&lt;uint32_t&gt;::max()</code></a>，这种时候我们就必须自己决定最匹配屏幕的图像分辨率了。我们可以创建一个<i><font color="Green">VkExtent2DchooseSwapExtent(const VkSurfaceCapabilitiesKHR&amp;capabilities)</font></i>函数来决定图像分辨率：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkExtent2D <span class="hljs-title">chooseSwapExtent</span><span class="hljs-params">(<span class="hljs-type">const</span> VkSurfaceCapabilitiesKHR&amp; capabilities)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (capabilities.currentExtent.width != std::numeric_limits&lt;<span class="hljs-type">uint32_t</span>&gt;::<span class="hljs-built_in">max</span>()) &#123;<br>        <span class="hljs-keyword">return</span> capabilities.currentExtent;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> width, height;<br>        <span class="hljs-built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);<br><br>        VkExtent2D actualExtent = &#123;<br>            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(width),<br>            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(height)<br>        &#125;;<br><br>        actualExtent.width = std::<span class="hljs-built_in">clamp</span>(actualExtent.width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width);<br>        actualExtent.height = std::<span class="hljs-built_in">clamp</span>(actualExtent.height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height);<br><br>        <span class="hljs-keyword">return</span> actualExtent;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要注意，GLFW有两种分辨率单位，一种是屏幕坐标，另一种是像素个数，这二者未必总是相同的，例如在高DPI设备上实际像素数就要高于屏幕坐标范围。由于Vulkan指定的图像分辨率是通过像素个数指定的，所以我们需要使用<a href="https://www.glfw.org/docs/3.3/group__window.html#ga0e2637a4161afb283f5300c7f94785c9"><code>glfwGetFramebufferSize</code></a>来获取当前屏幕的像素数。另外，我们需要控制选取的图像像素数不超过[minImageExtent,maxImageExtent]的范围，这通过<a href="https://en.cppreference.com/w/cpp/algorithm/clamp"><code>std::clamp</code></a>实现。</p><p>这样我们就可以使用该函数得到createInfo中需要的图像尺寸了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkExtent2D extent = <span class="hljs-built_in">chooseSwapExtent</span>(swapChainSupport.capabilities);<br><br>createInfo.imageExtent = extent;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">VkSwapchainCreateInfoKHR</font></i>结构体中接下来的成员<i><font color="Orange">imageArrayLayers</font></i>是多视图/立体表面中的视图数量。对于非立体3D应用程序，这个值为1。我们直接将其设为1即可。</p><p>接下来我们需要指定交换链中图像的用途。我们目前希望交换链中的图像用作渲染目标，于是可以给<i><font color="Orange">imageUsage</font></i>成员赋予<i><font color="Red">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</font></i>，也就是指定图像作为渲染的颜色缓冲。之后我们会接触到更多的图像使用方式。</p><p>下面我们要指定交换链中的图像要怎么用于多个队列家族中。当我们之前选定的图像队列和显示队列不一致的时候，我们就有两个不同队列家族种的队列了，此时我们需要指定这两个队列共享图像的模式，这通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html"><code>VkSharingMode</code></a>来指定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkSharingMode</span> &#123;</span><br>    VK_SHARING_MODE_EXCLUSIVE = <span class="hljs-number">0</span>,<span class="hljs-comment">//不允许同时有多个队列家族的队列访问图像</span><br>    VK_SHARING_MODE_CONCURRENT = <span class="hljs-number">1</span>,<span class="hljs-comment">//可以同时有多个队列家族的队列访问图像</span><br>&#125; VkSharingMode;<br></code></pre></td></tr></table></figure><p>如果有多个队列家族都需要访问交换链图像，此时如果选择<i><font color="Red">VK_SHARING_MODE_EXCLUSIVE</font></i>，那么我们还需要处理图像所有权在不同队列之间的转移问题。因此在这种情况下我们就简单地使用<i><font color="Red">VK_SHARING_MODE_CONCURRENT</font></i>模式就好了。如果只有一个队列家族（图像队列和显示队列一致），那么直接使用<i><font color="Red">VK_SHARING_MODE_EXCLUSIVE</font></i>就可以了。当然，在指定了共享模式之后，我们还需要指定共享这些图像的队列家族个数和索引：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(physicalDevice);<br><span class="hljs-type">uint32_t</span> queueFamilyIndices[] = &#123;indices.graphicsFamily.<span class="hljs-built_in">value</span>(), indices.presentFamily.<span class="hljs-built_in">value</span>()&#125;;<br><br><span class="hljs-keyword">if</span> (indices.graphicsFamily != indices.presentFamily) &#123;<br>    createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;<br>    createInfo.queueFamilyIndexCount = <span class="hljs-number">2</span>;<br>    createInfo.pQueueFamilyIndices = queueFamilyIndices;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;<br>    createInfo.queueFamilyIndexCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>    createInfo.pQueueFamilyIndices = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们可以指定显示图像之前作用于交换链图像上的变换<i><font color="Orange">preTransform</font></i>。我们目前并不需要任何预变换，所以像下面这样设置就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.preTransform = swapChainSupport.capabilities.currentTransform;<br></code></pre></td></tr></table></figure><p>我们还需要填写<i><font color="Orange">compositeAlpha</font></i>成员，该成员指定alpha通道是否可以用来和窗口系统中的其它窗口混合，这几乎总是被忽略的，因此我们只需赋予它<i><font color="Red">VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR</font></i>即可。</p><p>接下来我们需要指定交换链的显示类型。通过<i><font color="Green">querySwapChainSupport</font></i>函数我们可以获得交换链所支持的所有显示类型，我们可以从其中选择所需的类型。</p><p>显示类型由一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html"><code>VkPresentModeKHR</code></a>枚举类型表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_surface</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkPresentModeKHR</span> &#123;</span><br>    VK_PRESENT_MODE_IMMEDIATE_KHR = <span class="hljs-number">0</span>,<br>    VK_PRESENT_MODE_MAILBOX_KHR = <span class="hljs-number">1</span>,<br>    VK_PRESENT_MODE_FIFO_KHR = <span class="hljs-number">2</span>,<br>    VK_PRESENT_MODE_FIFO_RELAXED_KHR = <span class="hljs-number">3</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_shared_presentable_image</span><br>    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = <span class="hljs-number">1000111000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_shared_presentable_image</span><br>    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = <span class="hljs-number">1000111001</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_present_mode_fifo_latest_ready</span><br>    VK_PRESENT_MODE_FIFO_LATEST_READY_EXT = <span class="hljs-number">1000361000</span>,<br>&#125; VkPresentModeKHR;<br></code></pre></td></tr></table></figure><p>我们不详细解释每种类型的含义，只具体解释两种经常使用的类型：<i><font color="Red">VK_PRESENT_MODE_FIFO_KHR</font></i>和<i><font color="Red">VK_PRESENT_MODE_MAILBOX_KHR</font></i>。前者指定当屏幕刷新的时候从队列头获取一张图像，同时程序将渲染好的图像放到队列的尾部，如果队列已经满了，那么程序就需要等待队列出现空间时再插入新图片。后者和前者基本相同，区别在于当队列满的时候，程序会直接使用新渲染的图像替代队列尾的图像，这可以提高渲染效率并降低延迟，但相应的开销也会更大。因此很多移动设备仍然会选择前者作为显示模式。另外，<i><font color="Red">VK_PRESENT_MODE_FIFO_KHR</font></i>被保证在任何支持交换链的设备上都是一定可用的，因此我们可以写一个选择显示模式的函数<i><font color="Green">VkPresentModeKHRchooseSwapPresentMode(const std::vector<VkPresentModeKHR>&amp;availablePresentModes)</VkPresentModeKHR></font></i>，它优先选择<i><font color="Red">VK_PRESENT_MODE_MAILBOX_KHR</font></i>，如果该模式不可用，那么再选择<i><font color="Red">VK_PRESENT_MODE_FIFO_KHR</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkPresentModeKHR <span class="hljs-title">chooseSwapPresentMode</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;VkPresentModeKHR&gt;&amp; availablePresentModes)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; availablePresentMode : availablePresentModes) &#123;<br>        <span class="hljs-keyword">if</span> (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) &#123;<br>            <span class="hljs-keyword">return</span> availablePresentMode;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> VK_PRESENT_MODE_FIFO_KHR;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>结构体的<i><font color="Orange">presentMode</font></i>成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.presentMode = presentMode;<br></code></pre></td></tr></table></figure><p>然后我们需要指定<i><font color="Orange">createInfo</font></i>的<i><font color="Orange">clipped</font></i>成员。这个成员如果为<i><font color="Red">VK_TRUE</font></i>，就表明我们不在乎那些被其它窗口挡住的应用程序窗口的像素，那部分可以不进行显示。为了性能起见这个选项一般会设为<i><font color="Red">VK_TRUE</font></i>。</p><p>最后，在Vulkan程序运行的过程中，交换链很有可能会变得不再有效或者不再是性能最优的，比如窗口缩放等操作都会造成这种问题。因此，我们可能需要经常从头构建一个新的交换链。因此在一个新交换链的构建信息中指定一个旧交换链可以有助于减少资源的重新分配，提高性能，还能保证在新交换链创建后，旧交换链的资源能够被正确管理和释放，避免资源泄漏。交换链的更新是一个比较复杂的主题，我们将在后面介绍。在这里我们仅简单地将最后一个成员<i><font color="Orange">oldSwapchain</font></i>设置为<i><font color="Red">VK_NULL_HANDLE</font></i>。</p><p>终于，我们完成了<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>结构体的填写！</p><hr><h2 id="创建交换链">创建交换链</h2><p>接下来我们终于可以创建交换链对象了。在类内新增一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainKHR.html"><code>VkSwapchainKHR</code></a>成员，构建过程我们已经非常熟悉：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateSwapchainKHR</span>(device, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;swapChain) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create swap chain!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，在后续章节涉及到渲染的时候我们还需要在代码中使用交换链中的图像，因此我们将这些图像也保存为类内成员<i><font color="Orange">std::vector<VkImage>swapChainImages</VkImage></font></i>，然后我们紧接着创建交换链之后来获取这些图像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkGetSwapchainImagesKHR</span>(device, swapChain, &amp;imageCount, <span class="hljs-literal">nullptr</span>);<br>swapChainImages.<span class="hljs-built_in">resize</span>(imageCount);<br><span class="hljs-built_in">vkGetSwapchainImagesKHR</span>(device, swapChain, &amp;imageCount, swapChainImages.<span class="hljs-built_in">data</span>());<br></code></pre></td></tr></table></figure><p>另外注意，在交换链销毁的时候这些交换链中的图像会被自动销毁，因此我们并不需要手动销毁它们。</p><p>我们在后续章节还会用到这些图像的图像格式以及图像尺寸，因此在类内再新增两个成员<i><font color="Orange">VkFormatswapChainImageFormat</font></i>以及<i><font color="Orange">VkExtent2DswapChainExtent</font></i>分别保存这两者，并且在设置<i><font color="Orange">VkSwapchainCreateInfoKHR</font></i>的相应形参的时候顺便保存这两个成员就可以了。</p><p>大功告成！可喜可贺~</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/">上一篇：窗口表面</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/">下一篇：图像视图</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>窗口表面</title>
    <link href="/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/"/>
    <url>/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述">概述</h2><p>因为Vulkan本身是平台无关的，所以它并不会直接和不同的窗口系统打交道，而是要通过所谓的WSI(WindowSystemIntegration)拓展来达到和窗口系统交互的目的。这一节我们将讨论该拓展提供的表面对象<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html"><code>VkSurfaceKHR</code></a>，该对象用于提供展示渲染结果所需的窗口表面。该对象将由我们使用的窗口系统GLFW负责创建。</p><p>值得一提的是，WSI拓展其实是一个Instance层面的拓展而非设备层面。之所以将这个Instance层面的拓展延后到本节来讲而不是在<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">创建Instance</a>章节讲是因为表面和接下来要讲的有关展示图像的内容部分关系紧密，所以将这些内容放在一起会更加自然。</p><p>另外，表面对象一定要在选择物理设备之前创建，因为表面其实会影响物理设备的选择。不过并非所有的应用程序都需要这样一个表面对象，因为有的程序只需要离屏渲染即可。对于这种应用程序，可以为它们创建一个不可见的窗口。</p><p>创建窗口表面分为三步：</p><ul><li>创建并保存<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html"><code>VkSurfaceKHR</code></a>对象</li><li>查询支持将图像显示到该表面的物理设备</li><li>构建该设备展示显示图像所需的显示队列</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Window_surface">Windowsurface</a>章节。</p><hr><h2 id="创建表面">创建表面</h2><p>在应用程序类内添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html"><code>VkSurfaceKHR</code></a>成员<i><font color="Orange">surface</font></i>用于保存表面对象。</p><p>创建一个表面对象很简单，首先我们需要启用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_surface.html"><code>VK_KHR_surface</code></a>拓展。幸运的是这个拓展已经包含在<a href="https://www.glfw.org/docs/3.3/group__vulkan.html#ga99ad342d82f4a3421e2864978cb6d1d6"><code>glfwGetRequiredInstanceExtensions</code></a>所返回的拓展中了，我们无需额外添加。接下来只需调用<a href="https://www.glfw.org/docs/3.3/group__vulkan.html#ga1a24536bec3f80b08ead18e28e6ae965"><code>glfwCreateWindowSurface</code></a>函数，GLFW就会帮我们处理好一切平台相关的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createSurface</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwCreateWindowSurface</span>(instance, window, <span class="hljs-literal">nullptr</span>, &amp;surface) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create window surface!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过虽然glfw负责创建该表面对象，销毁它仍然使用的是Vulkan的API：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkDestroySurfaceKHR</span>(instance, surface, <span class="hljs-literal">nullptr</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="查询支持设备">查询支持设备</h2><p>Vulkan本身是支持WSI的，但这并不意味着所有的显卡都可以支持这个拓展。为了保证选取的物理设备支持该拓展，我们需要拓展<i><font color="Green">isDeviceSuitable</font></i>函数以保证选择的物理设备支持将图像显示到创建的表面上。由于显示图像其实是一个和队列有关的特性，因此我们其实需要的是选择一个具有支持显示对象到指定表面功能的队列家族的物理设备。</p><p>因此，我们首先拓展一下<i><font color="Orange">QueueFamilyIndices</font></i>结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">QueueFamilyIndices</span> &#123;<br>    std::optional&lt;<span class="hljs-type">uint32_t</span>&gt; graphicsFamily;<br>    std::optional&lt;<span class="hljs-type">uint32_t</span>&gt; presentFamily;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isComplete</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> graphicsFamily.<span class="hljs-built_in">has_value</span>() &amp;&amp; presentFamily.<span class="hljs-built_in">has_value</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意，支持显示图像的队列家族和支持图像功能的的队列家族未必相同，虽然它们大概率一致，但保险起见我们还是使用两个队列家族分别存储。</p><p>接下来我们需要修改<i><font color="Green">findQueueFamilies</font></i>函数来寻找<i><font color="Orange">presentFamily</font></i>。为了寻找这样一个队列家族，我们使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceSupportKHR.html"><code>vkGetPhysicalDeviceSurfaceSupportKHR</code></a>函数。现在<i><font color="Green">findQueueFamilies</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QueueFamilyIndices <span class="hljs-title">findQueueFamilies</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices;<br><br>    <span class="hljs-type">uint32_t</span> queueFamilyCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkQueueFamilyProperties&gt; <span class="hljs-title">queueFamilies</span><span class="hljs-params">(queueFamilyCount)</span></span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, queueFamilies.<span class="hljs-built_in">data</span>());<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; queueFamily : queueFamilies) &#123;<br>        <span class="hljs-keyword">if</span> (queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) &#123;<br>            indices.graphicsFamily = i;<br>        &#125;<br><br>        VkBool32 presentSupport = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">vkGetPhysicalDeviceSurfaceSupportKHR</span>(device, i, surface, &amp;presentSupport);<br><br>        <span class="hljs-keyword">if</span> (presentSupport) &#123;<br>            indices.presentFamily = i;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (indices.<span class="hljs-built_in">isComplete</span>()) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        i++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> indices;<br>    &#125;<br></code></pre></td></tr></table></figure><p><i><font color="Green">isDeviceSuitable</font></i>函数的代码并不需要改动，因为它通过调用<i><font color="Orange">QueueFamilyIndices</font></i>结构体的成员函数<i><font color="Green">isComplete</font></i>来检查物理设备是否满足要求，而<font color="Green">isComplete</font>已经更新了并包含了目前一切需要检查的信息。</p><hr><h2 id="构建展示队列">构建展示队列</h2><p>接下来如同图形队列一样，设备对应的显示队列也应该保存在类内一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkQueue.html"><code>VkQueue</code></a>类型的成员<i><font color="Orange">presentQueue</font></i>中。</p><p>现在我们的逻辑设备已经有两个需要的队列了（如果它们不是同一个的话），因此在逻辑设备的创建信息<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateInfo.html"><code>VkDeviceCreateInfo</code></a>中我们需要两个对应的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html"><code>VkDeviceQueueCreateInfo</code></a>。因此我们需要更新<i><font color="Green">createLogicalDevice</font></i>函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createLogicalDevice</span><span class="hljs-params">()</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(physicalDevice);<br><br>    std::vector&lt;VkDeviceQueueCreateInfo&gt; queueCreateInfos;<br>    std::set&lt;<span class="hljs-type">uint32_t</span>&gt; uniqueQueueFamilies = &#123;indices.graphicsFamily.<span class="hljs-built_in">value</span>(), indices.presentFamily.<span class="hljs-built_in">value</span>()&#125;;<br><br>    <span class="hljs-type">float</span> queuePriority = <span class="hljs-number">1.0f</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> queueFamily : uniqueQueueFamilies) &#123;<br>        VkDeviceQueueCreateInfo queueCreateInfo&#123;&#125;;<br>        queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;<br>        queueCreateInfo.queueFamilyIndex = queueFamily;<br>        queueCreateInfo.queueCount = <span class="hljs-number">1</span>;<br>        queueCreateInfo.pQueuePriorities = &amp;queuePriority;<br>        queueCreateInfos.<span class="hljs-built_in">push_back</span>(queueCreateInfo);<br>    &#125;<br><br>    VkPhysicalDeviceFeatures deviceFeatures&#123;&#125;;<br><br>    VkDeviceCreateInfo createInfo&#123;&#125;;<br>    createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;<br><br>    createInfo.queueCreateInfoCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(queueCreateInfos.<span class="hljs-built_in">size</span>());<br>    createInfo.pQueueCreateInfos = queueCreateInfos.<span class="hljs-built_in">data</span>();<br><br>    createInfo.pEnabledFeatures = &amp;deviceFeatures;<br><br>    createInfo.enabledExtensionCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>        createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateDevice</span>(physicalDevice, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;device) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create logical device!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">vkGetDeviceQueue</span>(device, indices.graphicsFamily.<span class="hljs-built_in">value</span>(), <span class="hljs-number">0</span>, &amp;graphicsQueue);<br>    <span class="hljs-built_in">vkGetDeviceQueue</span>(device, indices.presentFamily.<span class="hljs-built_in">value</span>(), <span class="hljs-number">0</span>, &amp;presentQueue);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个函数的最后，如同对图形队列所做的那样，我们调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue.html"><code>vkGetDeviceQueue</code></a>来获得该逻辑设备对应的显示队列并保存到<i><font color="Orange">presentQueue</font></i>成员中。</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/">上一篇：逻辑设备和队列</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/">下一篇：交换链</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>逻辑设备和队列</title>
    <link href="/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>如果说Instance是Vulkan库的接口和抽象，那么逻辑设备就是物理设备的接口和抽象。可以认为逻辑设备是对物理设备功能的一个“定制化”视图，允许开发者选择所需的功能集。构建与物理设备关联的逻辑设备可以分为三步：</p><ul><li>从选定物理设备的队列家族中分配所需数目的队列供逻辑设备使用</li><li>指定逻辑设备所需要的物理设备特性和功能拓展等</li><li>创建逻辑设备</li></ul><p>接下来我们将创建一个<i><font color="Green">voidcreateLogicalDevice()</font></i>函数用于构建逻辑设备，并添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDevice.html"><code>VkDevice</code></a>成员<i><font color="Orange">device</font></i>来存储创建的逻辑设备。</p><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Logical_device_and_queues">Logicaldevice and queues</a>章节</p><hr><h2 id="指定队列">指定队列</h2><p>指定逻辑设备需要使用的队列很简单，我们只需要创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html"><code>VkDeviceQueueCreateInfo</code></a>并填写相应信息即可。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDeviceQueueCreateInfo</span> &#123;</span><br>    VkStructureType             sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                 pNext;<br>    VkDeviceQueueCreateFlags    flags;<br>    <span class="hljs-type">uint32_t</span>                    queueFamilyIndex;<span class="hljs-comment">//队列家族索引，上一章在QueueFamilyIndices结构体中已经存储好了</span><br>    <span class="hljs-type">uint32_t</span>                    queueCount;      <span class="hljs-comment">//需要从该队列家族分配的队列数</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span>*                pQueuePriorities;<span class="hljs-comment">//队列优先级</span><br>&#125; VkDeviceQueueCreateInfo;<br></code></pre></td></tr></table></figure><p>其中<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlags.html"><code>VkDeviceQueueCreateFlags</code></a>是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlagBits.html"><code>VkDeviceQueueCreateFlagBits</code></a>的位组合，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlagBits.html"><code>VkDeviceQueueCreateFlagBits</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDeviceQueueCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//受保护的队列，用于处理敏感数据或需要额外安全性的操作</span><br>&#125; VkDeviceQueueCreateFlagBits;<br></code></pre></td></tr></table></figure><p>另外，队列优先级是一个0.0到1.0之间的数，规定了队列中的命令被执行的顺序，优先级大的优先执行和访问资源。注意，即使只有一个队列也应该指定优先级。</p><p>在这里我们只需要一个队列就可以了，事实上，大多数的时候我们也不需要分配多个队列，因为Vulkan允许在多线程上创建命令然后在主线程上一次性提交所有命令到一个队列。填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html"><code>VkDeviceQueueCreateInfo</code></a>过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(physicalDevice);<br><br>VkDeviceQueueCreateInfo queueCreateInfo&#123;&#125;;<br>queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;<br>queueCreateInfo.queueFamilyIndex = indices.graphicsFamily.<span class="hljs-built_in">value</span>();<br>queueCreateInfo.queueCount = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">float</span> queuePriority = <span class="hljs-number">1.0f</span>;<br>queueCreateInfo.pQueuePriorities = &amp;queuePriority;<br></code></pre></td></tr></table></figure><hr><h2 id="指定物理设备特性">指定物理设备特性</h2><p>物理设备特性通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures.html"><code>vkGetPhysicalDeviceFeatures</code></a>得到。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkGetPhysicalDeviceFeatures</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkPhysicalDevice                            physicalDevice,</span><br><span class="hljs-params">    VkPhysicalDeviceFeatures*                   pFeatures)</span>;<br></code></pre></td></tr></table></figure><p>我们暂时还不需要指定任何特性，所以只需在<i><font color="Green">createLogicalDevice</font></i>函数中把<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html"><code>VkPhysicalDeviceFeatures</code></a>结构体留空即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPhysicalDeviceFeatures deviceFeatures&#123;&#125;;<br></code></pre></td></tr></table></figure><p>一如我们之前一直做的那样，创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDevice.html"><code>VkDevice</code></a>同样需要我们填写相应的信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateInfo.html"><code>VkDeviceCreateInfo</code></a>。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDeviceCreateInfo</span> &#123;</span><br>    VkStructureType                    sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                        pNext;<br>    VkDeviceCreateFlags                flags;<br>    <span class="hljs-type">uint32_t</span>                           queueCreateInfoCount;<br>    <span class="hljs-type">const</span> VkDeviceQueueCreateInfo*     pQueueCreateInfos;<br>    <span class="hljs-comment">// enabledLayerCount is deprecated and should not be used</span><br>    <span class="hljs-type">uint32_t</span>                           enabledLayerCount;<br>    <span class="hljs-comment">// ppEnabledLayerNames is deprecated and should not be used</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*                 ppEnabledLayerNames;<br>    <span class="hljs-type">uint32_t</span>                           enabledExtensionCount;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*                 ppEnabledExtensionNames;<br>    <span class="hljs-type">const</span> VkPhysicalDeviceFeatures*    pEnabledFeatures;<br>&#125; VkDeviceCreateInfo;<br></code></pre></td></tr></table></figure><p>可以看到为了填充该结构体，我们还需要指定逻辑设备需要的拓展以及层。在<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">验证层</a>章节已经提到，如今Vulkan已经不再使用devicespecific layers了，instance specificlayer适用于一切的Vulkan调用。然而，为了与旧代码兼容，显示地指定设备层仍然是一个好的选择。另外，当前我们对于设备所需要的拓展尚且没有什么要求，因此填充信息代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkDeviceCreateInfo createInfo&#123;&#125;;<br>createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;<br><br>createInfo.pQueueCreateInfos = &amp;queueCreateInfo;<br>createInfo.queueCreateInfoCount = <span class="hljs-number">1</span>;<br><br>createInfo.pEnabledFeatures = &amp;deviceFeatures;<br><br>createInfo.enabledExtensionCount = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>    createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>    createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="创建逻辑设备">创建逻辑设备</h2><p>一切就绪，我们可以构建逻辑设备对象了，构建过程一如我们之前构建对象时一直做的那样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateDevice</span>(physicalDevice, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;device) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create logical device!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑设备就此构建完成，但我们还有一些工作需要做。由于之后我们可能需要在代码中使用逻辑设备对应的队列对象，但目前在应用程序类中并没有保存这个对象，所以我们需要添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkQueue.html"><code>VkQueue</code></a>类型的成员<i><font color="Orange">graphicsQueue</font></i>来保存这个对象。可以使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue.html"><code>vkGetDeviceQueue</code></a>函数得到赋予该逻辑设备的队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkGetDeviceQueue</span>(device, indices.graphicsFamily.<span class="hljs-built_in">value</span>(), <span class="hljs-number">0</span>, &amp;graphicsQueue);<br><span class="hljs-comment">//0代表获取的队列在队列家族中的索引。由于我们只需要一个队列，所以该值为0。</span><br></code></pre></td></tr></table></figure><p>大功告成！设备层面的建立以及完成了，接下来的章节我们将处理和图像处理及展示有关的初始化流程。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97%E5%AE%B6%E6%97%8F/">上一篇：物理设备和队列家族</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/">下一篇：窗口表面</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>物理设备和队列家族</title>
    <link href="/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97%E5%AE%B6%E6%97%8F/"/>
    <url>/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97%E5%AE%B6%E6%97%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在创建好了Instance之后，我们需要选择一个合适的物理设备（显卡）来执行实际的操作。实际上我们可以选择多张显卡同时工作，不过简单起见本文只选择一张显卡进行操作。选择合适的显卡主要分为两步：</p><ul><li>决定应用程序需要显卡具有的功能和属性。</li><li>从所有显卡中选择合适的那个作为物理设备。</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Physical_devices_and_queue_families">Physicaldevices and queue families</a>章节。</p><hr><h2 id="显卡要求">显卡要求</h2><p>显卡在Vulkan中的对应句柄对象为<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html"><code>VkPhysicalDevice</code></a>，我们可以创建一个<i><font color="Green">boolisDeviceSuitable(VkPhysicalDevicedevice)</font></i>函数来决定一张显卡是否满足我们的需求。目前我们只需要显卡支持图形队列家族（Graphicsqueuefamilies），也就是能够接受图形有关命令的队列家族，于是对于一个给定的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html"><code>VkPhysicalDevice</code></a>，我们可以创建一个<i><font color="Green">QueueFamilyIndicesfindQueueFamilies(VkPhysicalDevicedevice)</font></i>函数来检查它是否支持该队列家族。其中，我们定义结构体<i><font color="Orange">QueueFamilyIndices</font></i>如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">QueueFamilyIndices</span> &#123;<br>    std::optional&lt;<span class="hljs-type">uint32_t</span>&gt; graphicsFamily;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isComplete</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> graphicsFamily.<span class="hljs-built_in">has_value</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>为c++17定义的一个模板类，它有一个成员函数<i><font color="Green">constexprbool has_value() const noexcept</font></i>，该函数在赋予了<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>包裹的对象值后返回true，否则返回false。如此设计是因为有时在考虑应用程序需要的队列家族的时候，有些队列家族是可选的，也就是说显卡有该家族的话更好，没有的话也不应该直接终止程序，而是选择别的替代品，因此我们可以通过<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>包裹对象是否存储了一个找到的值来做出决策。另外，该结构体目前只包含一个成员，随着应用程序的深入和复杂化，也会有更多的队列家族需求，也就会有更多的成员添加到这个结构体中来。</p><p>接下来看一下<i><font color="Green">findQueueFamilies</font></i>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QueueFamilyIndices <span class="hljs-title">findQueueFamilies</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices;<br><br>    <span class="hljs-type">uint32_t</span> queueFamilyCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkQueueFamilyProperties&gt; <span class="hljs-title">queueFamilies</span><span class="hljs-params">(queueFamilyCount)</span></span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, queueFamilies.<span class="hljs-built_in">data</span>());<br>    <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; queueFamily : queueFamilies) &#123;<br>        <span class="hljs-keyword">if</span> (queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) &#123;<br>            indices.graphicsFamily = i;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (indices.<span class="hljs-built_in">isComplete</span>()) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        i++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> indices;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数的代码是直观易懂的，这里不做过多解释了。</p><p>于是，接下来我们就可以在<i><font color="Green">isDeviceSuitable</font></i>函数中使用这个函数来判断一个物理设备是否符合要求（当前来讲就是是否具有图形队列家族）。当然，随着应用程序的复杂化，<i><font color="Green">isDeviceSuitable</font></i>函数还会逐渐地拓展：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(device);<br><br>    <span class="hljs-keyword">return</span> indices.graphicsFamily.<span class="hljs-built_in">has_value</span>();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="选择显卡">选择显卡</h2><p>在决定好对于设备的要求之后，是时候开始挑选符合要求的显卡了！首先我们当然要枚举出Instance所具有的所有物理设备，并且在类内创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html"><code>VkPhysicalDevice</code></a>成员<i><font color="Orange">physicalDevice</font></i>来存储满足需求的显卡对象（将这个成员初始化为<i><font color="Orange">VK_NULL_HANDLE</font></i>。我们创建一个<i><font color="Green">voidpickPhysicalDevice()</font></i>成员函数来挑选需要的显卡：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pickPhysicalDevice</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">uint32_t</span> deviceCount = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">vkEnumeratePhysicalDevices</span>(instance, &amp;deviceCount, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span> (deviceCount == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to find GPUs with Vulkan support!&quot;</span>);<br>&#125;<br>    <span class="hljs-function">std::vector&lt;VkPhysicalDevice&gt; <span class="hljs-title">devices</span><span class="hljs-params">(deviceCount)</span></span>;<br><span class="hljs-built_in">vkEnumeratePhysicalDevices</span>(instance, &amp;deviceCount, devices.<span class="hljs-built_in">data</span>());<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来对于每一个显卡，检查它是否满足需求，简单起见，我们这里采取的策略是一旦找到了一张满足要求的显卡，就直接使用它。当然你可以自定义更加复杂的选取策略以寻找最合适的那张显卡。测试显卡是否满足要求只需使用上文创建的<i><font color="Green">isDeviceSuitable</font></i>函数即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//接pickPhysicalDevice函数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; device : devices) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isDeviceSuitable</span>(device)) &#123;<br>        physicalDevice = device;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (physicalDevice == VK_NULL_HANDLE) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to find a suitable GPU!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，由于Instance被销毁时，对应的物理设备会被自动销毁，所以我们不需要在<i><font color="Green">cleanup</font></i>函数中显示销毁它。</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">上一篇：验证层</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/">下一篇：逻辑设备和队列</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>验证层</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>VulkanAPI本身几乎不自带任何错误检测功能，不过这并不意味着我们不能添加相应的错误检测功能。Vulkan的验证层（validationlayer）就是为此而生。验证层是可选的组件，它们会挂钩到 Vulkan函数调用中，以执行额外的操作，包括：</p><ul><li>检查参数类型以避免错误调用</li><li>跟踪对象的创建和销毁以防止内存泄漏</li><li>检查线程安全性</li><li>把调用信息以及其参数输出到标准输出</li><li>跟踪调用以便性能优化和复现</li></ul><p>Vulkan中有两种验证层：instance layer和devicelayer。最初的想法是instance layer用于检查全局的Vulkan调用，而devicelayer用于检查特定GPU相关的调用。不过现在devicelayer已经逐渐被废弃了，也就是说现在可以将instancelayer用于检查任何Vulkan调用。当然，如果是为了和旧代码兼容，仍然可以使用devicelayer。</p><p>验证层的使用主要分为以下三步：</p><ul><li>启用验证层</li><li>设置回调函数</li><li>创建debug messenger以使用回调函数控制输出验证层产生的信息</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Validation_layers#page_Message-callback">Validationlayers</a>章节</p><hr><h2 id="启用验证层">启用验证层</h2><p>我们需要启用的是Vulkan中几乎包含了所有有用验证功能的层，它的名称为<i><font color="Orange">VK_LAYER_KHRONOS_validation</font></i>。在启用之前，如同拓展一样，我们也需要检查层的可用性，检查的方式和拓展如出一辙。首先我们需要列举出硬件支持的所有层：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkValidationLayerSupport</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> layerCount;<br>    <span class="hljs-built_in">vkEnumerateInstanceLayerProperties</span>(&amp;layerCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkLayerProperties&gt; <span class="hljs-title">availableLayers</span><span class="hljs-params">(layerCount)</span></span>;<br>    <span class="hljs-built_in">vkEnumerateInstanceLayerProperties</span>(&amp;layerCount, availableLayers.<span class="hljs-built_in">data</span>());<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们需要的是<i><font color="Orange">VK_LAYER_KHRONOS_validation</font></i>，它由名称对应的字符串给出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; validationLayers = &#123;<br>    <span class="hljs-string">&quot;VK_LAYER_KHRONOS_validation&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>于是我们需要检查这个层是否可用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//接上述checkValidationLayerSupport函数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span>* layerName : validationLayers) &#123;<br>    <span class="hljs-type">bool</span> layerFound = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; layerProperties : availableLayers) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(layerName, layerProperties.layerName) == <span class="hljs-number">0</span>) &#123;<br>            layerFound = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!layerFound) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>检查完毕后，我们还需要决定什么时候启用这个验证层。由于验证层输出的调试信息应该只能被开发应用程序的程序员看见，因此调试模式下我们理应启用该验证层，而发布模式下我们当然应该关闭该验证层功能。这可以通过宏来做到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> NDEBUG</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> enableValidationLayers = <span class="hljs-literal">false</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> enableValidationLayers = <span class="hljs-literal">true</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>另外，<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">上一篇</a>中我们没有填上<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>结构体中的层信息，现在就可以填上我们选取的验证层信息了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>    createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>    createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//发布模式不需要启用验证层，因此结构体中层信息也不需要填写</span><br>    createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="设置回调函数">设置回调函数</h2><p>默认情况下验证层会将调试信息输出到标准输出。但是更多时候我们希望自己控制输出信息的种类以及详细程度等。因此我们需要设置一个回调函数来指定信息输出的方式。</p><p>为了设置回调函数，我们需要一个新的拓展：<i><font color="Orange">VK_EXT_debug_utils</font></i>，因此我们可以创建一个<i><font color="Green">getRequiredExtensions</font></i>函数来统一处理所有需要的拓展：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; <span class="hljs-title">getRequiredExtensions</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> glfwExtensionCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>** glfwExtensions;<br>    glfwExtensions = <span class="hljs-built_in">glfwGetRequiredInstanceExtensions</span>(&amp;glfwExtensionCount);<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; <span class="hljs-title">extensions</span><span class="hljs-params">(glfwExtensions, glfwExtensions + glfwExtensionCount)</span></span>;<br><br>    <span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>        extensions.<span class="hljs-built_in">push_back</span>(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);<br>        <span class="hljs-comment">//VK_EXT_DEBUG_UTILS_EXTENSION_NAME是字符串&quot;VK_EXT_debug_utils&quot;等价的宏，使用宏可以避免拼写错误问题</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> extensions;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到的拓展用于Instance的创建：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> extensions = <span class="hljs-built_in">getRequiredExtensions</span>();<br>createInfo.enabledExtensionCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(extensions.<span class="hljs-built_in">size</span>());<br>createInfo.ppEnabledExtensionNames = extensions.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>在启用了回调函数所需要的拓展之后，就可以创建回调函数本身了。Vulkan通过函数指针<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/PFN_vkDebugUtilsMessengerCallbackEXT.html"><code>PFN_vkDebugUtilsMessengerCallbackEXT</code></a>指明了一个回调函数所应该具有的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">VkBool32</span> <span class="hljs-params">(VKAPI_PTR *PFN_vkDebugUtilsMessengerCallbackEXT)</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDebugUtilsMessageSeverityFlagBitsEXT           messageSeverity,</span><br><span class="hljs-params">    VkDebugUtilsMessageTypeFlagsEXT                  messageTypes,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkDebugUtilsMessengerCallbackDataEXT*      pCallbackData,</span><br><span class="hljs-params">    <span class="hljs-type">void</span>*                                            pUserData)</span>;<br></code></pre></td></tr></table></figure><p>第一个成员通过[<code>VkDebugUtilsMessageSeverityFlagBitsEXT</code><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessageSeverityFlagBitsEXT.html">id4</a>的位掩码指定输出信息的严重性，该枚举定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDebugUtilsMessageSeverityFlagBitsEXT</span> &#123;</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//所有诊断信息</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = <span class="hljs-number">0x00000010</span>, <span class="hljs-comment">//信息性消息，如资源细节</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = <span class="hljs-number">0x00000100</span>,<span class="hljs-comment">//警告信息</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = <span class="hljs-number">0x00001000</span>,  <span class="hljs-comment">//错误信息</span><br>&#125; VkDebugUtilsMessageSeverityFlagBitsEXT;<br></code></pre></td></tr></table></figure><p>第二个成员通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessageTypeFlagBitsEXT.html"><code>VkDebugUtilsMessageTypeFlagsBitsEXT</code></a>的位掩码指定输出信息的种类，该枚举定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDebugUtilsMessageTypeFlagBitsEXT</span> &#123;</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = <span class="hljs-number">0x00000001</span>,    <span class="hljs-comment">//与使用规范或性能无关的一般事件消息</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = <span class="hljs-number">0x00000002</span>, <span class="hljs-comment">//未遵循Vulkan使用规则</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//性能浪费</span><br>  <span class="hljs-comment">// Provided by VK_EXT_device_address_binding_report</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//地址绑定信息</span><br>&#125; VkDebugUtilsMessageTypeFlagBitsEXT;<br></code></pre></td></tr></table></figure><p>第三个成员指向一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCallbackDataEXT.html"><code>VkDebugUtilsMessengerCallbackDataEXT</code></a>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDebugUtilsMessengerCallbackDataEXT</span> &#123;</span><br>    VkStructureType                              sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                  pNext;<br>    VkDebugUtilsMessengerCallbackDataFlagsEXT    flags; <span class="hljs-comment">//目前只有0</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                                  pMessageIdName;  <span class="hljs-comment">//消息相关名称标识符</span><br>    <span class="hljs-type">int32_t</span>                                      messageIdNumber; <span class="hljs-comment">//该名称对应ID</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                                  pMessage;  <span class="hljs-comment">//具体调试信息</span><br>    <span class="hljs-type">uint32_t</span>                                     queueLabelCount; <span class="hljs-comment">//队列标签数</span><br>    <span class="hljs-type">const</span> VkDebugUtilsLabelEXT*                  pQueueLabels;    <span class="hljs-comment">//队列标签</span><br>    <span class="hljs-type">uint32_t</span>                                     cmdBufLabelCount;<span class="hljs-comment">//命令缓冲标签数</span><br>    <span class="hljs-type">const</span> VkDebugUtilsLabelEXT*                  pCmdBufLabels;  <span class="hljs-comment">//命令缓冲标签</span><br>    <span class="hljs-type">uint32_t</span>                                     objectCount;  <span class="hljs-comment">//消息相关对象数</span><br>    <span class="hljs-type">const</span> VkDebugUtilsObjectNameInfoEXT*         pObjects;  <span class="hljs-comment">//消息相关对象</span><br>&#125; VkDebugUtilsMessengerCallbackDataEXT;<br></code></pre></td></tr></table></figure><p>该成员包含了回调函数输出信息的具体方式和细节。</p><p>最后一个成员指定用户自己提供的额外信息，一般为nullptr。</p><p>回调函数返回一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBool32.html"><code>VkBool32</code></a>类型的值，如果它返回<i><font color="Red">VK_TRUE</font></i>，则意味着产生验证层信息的函数应该被终止，这一般只用于验证调试层是否生效，因此我们一般返回<i><font color="Red">VK_FALSE</font></i>。</p><p>于是，我们可以创建一个自己的回调函数（注意要把它设置为静态函数）。<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Validation_layers#page_Message-callback">验证层</a>章节给出的一个简单的例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> VKAPI_ATTR VkBool32 VKAPI_CALL <span class="hljs-title">debugCallback</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,</span></span><br><span class="hljs-params"><span class="hljs-function">    VkDebugUtilsMessageTypeFlagsEXT messageType,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">void</span>* pUserData)</span> </span>&#123;<br><br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;validation layer: &quot;</span> &lt;&lt; pCallbackData-&gt;pMessage &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> VK_FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VKAPI_CALL.html"><code>VKAPI_CALL</code></a>和<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VKAPI_ATTR.html"><code>VKAPI_ATTR</code></a>宏用于指定和编译器有关的调用方式，前者指定MSVC-style的编译器调用方式，后者指定GCC/Clang-style的编译器调用方式。</p><hr><h2 id="创建debug-messenger">创建Debug Messenger</h2><p>设置好回调函数的形式后，现在我们需要告知Vulkan我们设置了一个回调函数。这可以通过创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerEXT.html"><code>VkDebugUtilsMessengerEXT</code></a>句柄对象来实现。</p><p>创建该对象同样需要填写相应的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>信息，我们可以创建一个<i><font color="Green">voidsetupDebugMessenger()</font></i>函数来处理该对象的构建。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VkDebugUtilsMessengerCreateInfoEXT</span> &#123;<br>    VkStructureType                         sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                             pNext;<br>    VkDebugUtilsMessengerCreateFlagsEXT     flags;    <span class="hljs-comment">//目前只有0</span><br>    VkDebugUtilsMessageSeverityFlagsEXT     messageSeverity;<br>    VkDebugUtilsMessageTypeFlagsEXT         messageType;<br>    PFN_vkDebugUtilsMessengerCallbackEXT    pfnUserCallback;<br>    <span class="hljs-type">void</span>*                                   pUserData;<br>&#125; VkDebugUtilsMessengerCreateInfoEXT;<br></code></pre></td></tr></table></figure><p>容易注意到后四个成员中倒数第二个成员就是我们需要指定的回调函数，其它三个成员是我们需要传递给该回调函数的实参。</p><p>于是<i><font color="Green">voidsetupDebugMessenger()</font></i>函数可以如下编写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setupDebugMessenger</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!enableValidationLayers) <span class="hljs-keyword">return</span>;<br><br>    VkDebugUtilsMessengerCreateInfoEXT createInfo&#123;&#125;;<br>    <br>    createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;<br>    createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |   VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;<br>    createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;<br>    createInfo.pfnUserCallback = debugCallback;<br>    createInfo.pUserData = <span class="hljs-literal">nullptr</span>;<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来只需要创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerEXT.html"><code>VkDebugUtilsMessengerEXT</code></a>对象即可。但是到这里还有一个小问题，那就是创建对象的函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>是一个拓展函数，它不是自动加载的，而是需要我们手动使用[<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetInstanceProcAddr.html"><code>vkGetInstanceProcAddr</code></a>去寻找它的地址后才能使用。因此我们可以创建一个（全局的）工具函数VkResultCreateDebugUtilsMessengerEXT(VkInstance instance, constVkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, constVkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT*pDebugMessenger)函数来加载<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetInstanceProcAddr.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>进行加载。于是我们可以创建一个（全局的）<i><font color="Green">VkResultCreateDebugUtilsMessengerEXT(VkInstance instance, constVkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, constVkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT*pDebugMessenger)</font></i>函数加载<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>并在加载成功后使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>创建DebugMessenger对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkResult <span class="hljs-title">CreateDebugUtilsMessengerEXT</span><span class="hljs-params">(VkInstance instance, <span class="hljs-type">const</span> VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, <span class="hljs-type">const</span> VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pDebugMessenger)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> func = (PFN_vkCreateDebugUtilsMessengerEXT) <span class="hljs-built_in">vkGetInstanceProcAddr</span>(instance, <span class="hljs-string">&quot;vkCreateDebugUtilsMessengerEXT&quot;</span>);<br>    <span class="hljs-keyword">if</span> (func != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(instance, pCreateInfo, pAllocator, pDebugMessenger);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> VK_ERROR_EXTENSION_NOT_PRESENT;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，只需要在<i><font color="Green">setupDebugMessenger</font></i>函数末尾使用该函数来创建句柄对象即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//接setupDebugMessenger函数</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">CreateDebugUtilsMessengerEXT</span>(instance, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;debugMessenger) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to set up debug messenger!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>另外注意，销毁<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerEXT.html"><code>VkDebugUtilsMessengerEXT</code></a>对象的函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyDebugUtilsMessengerEXT.html"><code>vkDestroyDebugUtilsMessengerEXT</code></a>也是一个拓展函数，同样需要我们手动加载，我们也写一个工具函数来完成加载该函数和销毁的工作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyDebugUtilsMessengerEXT</span><span class="hljs-params">(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, <span class="hljs-type">const</span> VkAllocationCallbacks* pAllocator)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> func = (PFN_vkDestroyDebugUtilsMessengerEXT) <span class="hljs-built_in">vkGetInstanceProcAddr</span>(instance, <span class="hljs-string">&quot;vkDestroyDebugUtilsMessengerEXT&quot;</span>);<br>    <span class="hljs-keyword">if</span> (func != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-built_in">func</span>(instance, debugMessenger, pAllocator);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后只需在应用程序类的<i><font color="Green">cleanup()</font></i>函数中调用该加载函数即可。</p><hr><h2 id="instance创建和销毁函数内部的调试">Instance创建和销毁函数内部的调试</h2><p>大功告成了吗？其实还没有。注意到<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>函数需要创建的Instance作为参数，这也就意味着Instance的创建函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html"><code>vkCreateInstance</code></a>和销毁函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyInstance.html"><code>vkDestroyInstance</code></a>是在DebugMessenger的作用范围之外的，它们的调试信息无法被显示出来。</p><p>解决办法是将<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>信息传递给<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>结构体的pNext成员指针。具体而言，我们可以创建一个<i><font color="Green">voidpopulateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT&amp;createInfo)</font></i>函数来抽象出填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>的代码以便在<i><font color="Green">createInstance</font></i>函数和<i><font color="Green">setupDebugMessenger</font></i>函数中复用，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++|">void populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT&amp; createInfo) &#123;<br>    createInfo = &#123;&#125;;<br>    <br>    createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;<br>    createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;<br>    createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;<br>    createInfo.pfnUserCallback = debugCallback;<br>&#125;<br></code></pre></td></tr></table></figure><p><i><font color="Green">setupDebugMessenger</font></i>函数现在改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setupDebugMessenger</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!enableValidationLayers) <span class="hljs-keyword">return</span>;<br><br>    VkDebugUtilsMessengerCreateInfoEXT createInfo;<br>    <span class="hljs-built_in">populateDebugMessengerCreateInfo</span>(createInfo);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CreateDebugUtilsMessengerEXT</span>(instance, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;debugMessenger) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to set up debug messenger!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><i><font color="Green">createInstance</font></i>函数添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br><br>    VkInstanceCreateInfo createInfo&#123;&#125;;<br>    createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;<br>    createInfo.pApplicationInfo = &amp;appInfo;<br><br>    ...<br><br>    VkDebugUtilsMessengerCreateInfoEXT debugCreateInfo&#123;&#125;;<br>    <span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>        createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br><br>        <span class="hljs-built_in">populateDebugMessengerCreateInfo</span>(debugCreateInfo);<br>        createInfo.pNext = (VkDebugUtilsMessengerCreateInfoEXT*) &amp;debugCreateInfo;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br><br>        createInfo.pNext = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateInstance</span>(&amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;instance) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create instance!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以实现在Instance的构造和销毁函数中也能输出调试信息。现在终于是大功告成了！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">上一篇：创建Instance</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/">下一篇：物理设备和队列家族</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>创建Instance</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>是沟通应用程序和vulkan库的桥梁，它将你的应用程序的信息提供给图形驱动。创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>主要分为三步：</p><ul><li>检查instance所需的拓展是否可用</li><li>填写包含了创建instance所需信息的结构体</li><li>将该结构体传递给<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html"><code>vkCreateInstance</code></a>函数创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>实例</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Instance">Instance</a>章节。</p><hr><h2 id="检查拓展">检查拓展</h2><p>使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html"><code>vkEnumerateInstanceExtensionProperties</code></a>函数分两步检查拓展：</p><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html"><code>vkEnumerateInstanceExtensionProperties</code></a>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkEnumerateInstanceExtensionProperties</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                                 pLayerName,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>*                                   pPropertyCount,</span><br><span class="hljs-params">    VkExtensionProperties*                      pProperties)</span>;<br></code></pre></td></tr></table></figure><p>需要解释的是该函数第一个参数，该参数指定层名，如果为nullptr则则查询全局可用的扩展属性，否则查询指定层提供的额外拓展属性。</p><p>具体使用上，一般分两步进行，也就是先查询拓展个数再查询具体拓展，许多vulkan查询操作都分为这两步进行（假设这里不需要具体层名）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> extensionCount = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="hljs-literal">nullptr</span>, &amp;extensionCount, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-function">std::vector&lt;VkExtensionProperties&gt; <span class="hljs-title">extensions</span><span class="hljs-params">(extensionCount)</span></span>;<br><span class="hljs-built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="hljs-literal">nullptr</span>, &amp;extensionCount, extensions.<span class="hljs-built_in">data</span>());<span class="hljs-comment">// T* std::vector&lt;T,Allocator&gt;::data()返回指向vector底部数组元素的指针</span><br></code></pre></td></tr></table></figure><hr><h2 id="填写创建信息">填写创建信息</h2><p>为了创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>实例，需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>。Vulkan中很多创建实例的函数都需要一个createInfo结构体作为参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkInstanceCreateInfo</span> &#123;</span><br>    VkStructureType             sType;                  <span class="hljs-comment">//类型</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                 pNext;     <span class="hljs-comment">//拓展结构体，此教程均为nullptr</span><br>    VkInstanceCreateFlags       flags;  <br>    <span class="hljs-type">const</span> VkApplicationInfo*    pApplicationInfo;<br>    <span class="hljs-type">uint32_t</span>                    enabledLayerCount;    <span class="hljs-comment">//层数</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*          ppEnabledLayerNames;  <span class="hljs-comment">//层名</span><br>    <span class="hljs-type">uint32_t</span>                    enabledExtensionCount;  <span class="hljs-comment">//拓展数</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*          ppEnabledExtensionNames;<span class="hljs-comment">//拓展名</span><br>&#125; VkInstanceCreateInfo;<br></code></pre></td></tr></table></figure><p>第三个成员代表一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateFlagBits.html"><code>VkInstanceCreateFlagBits</code></a>的位掩码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkInstanceCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_KHR_portability_enumeration</span><br>    VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR = <span class="hljs-number">0x00000001</span>,<br>&#125; VkInstanceCreateFlagBits;<br></code></pre></td></tr></table></figure><p>其中只有一个标志位<i><font color="Red">VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR</font></i>，当设置这个标志时，表示应用程序希望能够在不同的设备和平台上更好地支持Vulkan的可移植性扩展。这对于那些希望在多种硬件和操作系统上运行的应用程序尤其重要。</p><p>第四个成员是一个指向<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkApplicationInfo.html"><code>VkApplicationInfo</code></a>结构体的指针，该结构体代表一个可选的应用程序信息，提供该信息可能有助于驱动优化应用程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkApplicationInfo</span> &#123;</span><br>    VkStructureType    sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*        pNext;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*        pApplicationName;<br>    <span class="hljs-type">uint32_t</span>           applicationVersion;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*        pEngineName;<br>    <span class="hljs-type">uint32_t</span>           engineVersion;<br>    <span class="hljs-type">uint32_t</span>           apiVersion;<br>&#125; VkApplicationInfo;<br></code></pre></td></tr></table></figure><p>该结构体每个成员都很好理解，<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Instance">Instance</a>章节中的使用范例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkApplicationInfo appInfo&#123;&#125;;<br>VkApplicationInfo appInfo&#123;&#125;;<br>appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;<br>appInfo.pApplicationName = <span class="hljs-string">&quot;Hello Triangle&quot;</span>;<br>appInfo.applicationVersion = <span class="hljs-built_in">VK_MAKE_VERSION</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>appInfo.pEngineName = <span class="hljs-string">&quot;No Engine&quot;</span>;<br>appInfo.engineVersion = <span class="hljs-built_in">VK_MAKE_VERSION</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>appInfo.apiVersion = VK_API_VERSION_1_0;<br></code></pre></td></tr></table></figure><p>解释完所有成员代表的意思之后，正式开始填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkInstanceCreateInfo createInfo&#123;&#125;;<br>createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;<br>createInfo.pApplicationInfo = &amp;appInfo;<br><br><span class="hljs-type">uint32_t</span> glfwExtensionCount = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>** glfwExtensions;<br><br><span class="hljs-comment">//获取glfw窗口系统所需的拓展，可以在获取前先使用步骤1检查以下拓展是否可用</span><br>glfwExtensions = <span class="hljs-built_in">glfwGetRequiredInstanceExtensions</span>(&amp;glfwExtensionCount);<br><br>createInfo.enabledExtensionCount = glfwExtensionCount;<br>createInfo.ppEnabledExtensionNames = glfwExtensions;<br><br><span class="hljs-comment">//这部分会在之后的设置验证层章节中填写</span><br>createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>注意这里并没有填写层数和层名，这部分会在下一章<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">验证层</a>中进行填写</p><hr><h2 id="创建vkinstance实例">创建VkInstance实例</h2><p>最后，一切就绪，可以使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html"><code>VkCreateInstance</code></a>创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>实例了，由于Vulkan中大多数创建实例的函数都会返回一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkResult.html"><code>VkResult</code></a>，于是我们一般通过下述方式创建实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateInstance</span>(&amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;instance) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create instance!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>很多Vulkan中的create函数都会具有一个可以传递用户自定义分配器的参数，在VulkanTutorial教程中该参数始终设为nullptr。</p><p>大功告成！我们可以将第二、三步的代码放到一个成员函数<i><font color="Green">voidcreateInstance()</font></i>中</p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/">上一篇：绘制基本流程梳理</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">下一篇：验证层</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>绘制基本流程梳理</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="写在前面">写在前面</h3><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Overview">Overview</a>章节</p><hr><h2 id="初始化及绘制的基本流程">初始化及绘制的基本流程</h2><p>下面按步骤给出绘制一个三角形所需的基本流程，这也构成了一个vulkan渲染程序最基础的框架</p><ul><li><p>创建一个用以描述你所创建的应用以及所需使用的API拓展的VkInstance。</p></li><li><p>查询硬件属性以挑选合适的物理设备VkPhysicalDevice。</p></li><li><p>从物理设备抽象出对应的逻辑设备VkDevice，并且创建用于接受提交命令的VkQueue。</p></li><li><p>创建用于显示渲染结果的窗口，以及一个处理跨平台窗口兼容性的的抽象层VkSurfaceKHR，然后创建用于提供渲染和展示画面的VkSwapchainKHR。</p></li><li><p>创建交换链中真正用于渲染和展示的VkImage,并且把这些图片包裹进用于指示图片的具体使用部分的VkImageView中。</p></li><li><p>创建用于指示渲染目标的类型用法等信息的VkRenderPass</p></li><li><p>在指定好渲染目标以及相应信息后，创建对应的载体VkFramebuffer，将创建好的VkImage用作它的颜色、深度或模板缓冲。</p></li><li><p>建立好包含整个渲染流程各个阶段信息的渲染管线对象VkPipeline。</p></li><li><p>准备好渲染所需的一切目标和信息后，从VkCommandPool分配出VkCommandBuffer，用于录制渲染流程中需要执行的命令。</p></li><li><p>开始主渲染循环，循环流程主要为从交换链获取图像，然后将录制好的命令提交给VkQueue执行，执行完毕后将图像归还交换链并展示渲染结果。</p><p>接下来的三角形绘制章节会详细解释每个步骤的具体流程和执行方式。</p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%BA%8F%E8%A8%80/">上一篇：序言</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">下一篇：创建Instance</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>序言</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%BA%8F%E8%A8%80/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%BA%8F%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="写在前面的话">写在前面的话</h2><p>刚学完<a href="https://vulkan-tutorial.com/Introduction">vulkantutorial</a>教程不久，感觉自己对其中的很多细节理解还不是很透彻，同时也不能很好地理清vulkan复杂的初始化流程，于是准备再学一遍教程，并且记录下自己的理解和梳理思路，希望能对vulkan的工作机制有更深入的理解。</p><h2 id="主要内容概要">主要内容概要</h2><p>本系列文章主要以梳理概括vulkan搭建的渲染流程为主，不多涉及对于图形硬件底层或者api工作原理的深入理解（苯萌新尚未进化至如此境界~~</p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/">下一篇：绘制基本流程梳理</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 847:访问所有节点的最短路径</title>
    <link href="/2024/09/19/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/Leetcode-847-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2024/09/19/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/Leetcode-847-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述">题目描述</h2><h3 id="题干">题干</h3><p>存在一个由 <code>n</code> 个节点组成的无向连通图，图中的节点按从<code>0</code> 到 <code>n - 1</code> 编号。</p><p>给你一个数组 <code>graph</code>表示这个图。其中，<code>graph[i]</code> 是一个列表，由所有与节点<code>i</code> 直接相连的节点组成。</p><p>返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。</p><h3 id="条件限制">条件限制</h3><ul><li><code>n == graph.length</code></li><li><code>1 &lt;= n &lt;= 12</code></li><li><code>0 &lt;= graph[i].length &lt; n</code></li><li><code>graph[i]</code> 不包含 <code>i</code></li><li>如果 <code>graph[a]</code> 包含 <code>b</code> ，那么<code>graph[b]</code> 也包含 <code>a</code></li><li>输入的图总是连通图</li></ul><h3 id="示例">示例</h3><figure><img src="/2024/09/19/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/Leetcode-847-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/example.png" alt="示例"><figcaption aria-hidden="true">示例</figcaption></figure><p><strong>输入</strong>：graph = [[1, 2, 3], [0], [0], [0]]</p><p><strong>输出</strong>：4</p><p><strong>解释</strong>：一种可能路径为[1, 0, 2, 0, 3]</p><hr><h2 id="错误解题思路">错误解题思路</h2><h3 id="思路">思路</h3><p>定义f[s][i]为位掩码为s且最后到达的节点为i时所走过的最短路径（如果在前述条件下不能遍历位掩码中的节点则记为INT_MAX，并且下面认为INT_MAX+1=INT_MAX)，简单地认为状态转移方程为：<span class="math display">\[f[s][i]\ =\mathop{min}\limits_{x\in graph[i]}(f[s\ \land\(1&lt;&lt;i)][x])\ +\ 1\]</span></p><h3 id="错误原因">错误原因</h3><p>事实上，位掩码为s且最后到达的节点为i时所走过的最短路径未必由除去i之后的位掩码下最后到达i的相邻节点x的最短路径转移而来，原因很简单，如果<span class="math inline">\(f[s\ \land\(1&lt;&lt;i)][x]\)</span>并非INT_MAX，那么这么转移是没有问题的，<u><mark><strong>但是，如果<span class="math inline">\(f[s\ \land\(1&lt;&lt;i)][x]\)</span>是INT_MAX呢？这是不是就意味着f[s][i]同样无法遍历得到了呢？当然不是</strong>。</mark></u>考虑上面示例，例如当位掩码为0111（即选择了0,1,2这三个节点），最后到达的节点为0时，如果按照上面错误的转移方程，我们有<span class="math display">\[f[0111][0]\ =\mathop{min}\{f[0110][1],\ f][0110][2]\}\ +\ 1\]</span>但是当位掩码仅为0110，也就是说要仅经过1,2两个节点的情况下遍历这两个节点都是不可能的，上面min的结果应该为INT_MAX，也就是说这么转移得到的f[0111][0]为INT_MAX，但是显然1-0-2-0为一条满足要求的路径，因此f[0111][0]最多也是3，因此这样的状态转移是不全面的。</p><hr><h2 id="正确解答">正确解答</h2><h3 id="思路一floyd最短路状压dp">思路一（Floyd最短路+状压dp）</h3><p>思路一延续前文错误思路的想法，只不过将状态转移方程改为 <span class="math display">\[f[s][i]\ =\mathop{min}\limits_{x\in \{0,1,\cdots,n-1\}}(f[s\ \land\(1&lt;&lt;i)][x])\ +\ dist(x,i)\]</span>其中dist(x,i)是节点x与i之间的最短距离，这个距离可以使用Floyd最短路径算法预计算出来。这样就不会出现漏掉一些状态转移方式的问题。</p><h4 id="floyd最短路径算法">Floyd最短路径算法</h4><p>算法原理以及描述这里不再赘述，读者可以在<a href="https://oi-wiki.org/graph/shortest-path/#floyd-%E7%AE%97%E6%B3%95">这里</a>找到关于该算法的具体描述和原理说明</p><p>Floyd算法的核心代码不过三层循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>  <span class="hljs-keyword">for</span> (x = <span class="hljs-number">1</span>; x &lt;= n; x++) &#123;<br>    <span class="hljs-keyword">for</span> (y = <span class="hljs-number">1</span>; y &lt;= n; y++) &#123;<br>      dist[k][x][y] = <span class="hljs-built_in">min</span>(dist[k - <span class="hljs-number">1</span>][x][y], dist[k - <span class="hljs-number">1</span>][x][k] + dist[k - <span class="hljs-number">1</span>][k][y]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中dist[k][x][y]表示只允许经过前k个节点的情况下由x到y的最短路径长度。由于外层状态k仅仅与k-1有关，所以实现的时候其实可以压缩掉一维：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>  <span class="hljs-keyword">for</span> (x = <span class="hljs-number">1</span>; x &lt;= n; x++) &#123;<br>    <span class="hljs-keyword">for</span> (y = <span class="hljs-number">1</span>; y &lt;= n; y++) &#123;<br>      dist[x][y] = <span class="hljs-built_in">min</span>(dist[x][y], dist[x][k] + dist[k][y]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中dist[x][y]直接定义为由x到y的最短路径长度。</p><h4 id="整体实现">整体实现</h4><p>首先预处理出任意两个节点之间的最短路径，然后使用上述正确状态转移方程求解，c++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestPathLength</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector <span class="hljs-title">dist</span><span class="hljs-params">(n, vector&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">1e9</span>))</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : graph[i]) &#123;<br>                dist[i][j] = dist[j][i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) dist[i][i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 预处理：floyd 求最短路</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                    dist[i][j] = <span class="hljs-built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//状压dp实现</span><br>        <span class="hljs-function">vector <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; n, vector&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">1e9</span>))</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) f[<span class="hljs-number">1</span> &lt;&lt; i][i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; (<span class="hljs-number">1</span> &lt;&lt; n); ++s) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (s &gt;&gt; i &amp; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                        <span class="hljs-keyword">if</span> ((s &gt;&gt; j &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>                            f[s | (<span class="hljs-number">1</span> &lt;&lt; j)][j] = <span class="hljs-built_in">min</span>(f[s | (<span class="hljs-number">1</span> &lt;&lt; j)][j], f[s][i] + dist[i][j]);<span class="hljs-comment">//转移方程形式上和前文略有差别，但本质上是一样的，这种写法会更方便</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//返回最终值</span><br>        <span class="hljs-keyword">return</span> *ranges::<span class="hljs-built_in">min_element</span>(f.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">begin</span>(),f.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">end</span>());<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="思路二bfs状压dp">思路二（BFS+状压dp）</h3><p>由于苯人还没有系统练习过BFS+队列存储的题目，这里暂时贴上leetcode上的<a href="https://leetcode.cn/problems/shortest-path-visiting-all-nodes/solutions/918634/gtalgorithm-tu-jie-fa-ba-hardbian-cheng-v5knb/">解答</a>，并且简述一下自己的一些理解，详细的思路说明留待之后补充~</p><h4 id="代码">代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestPathLength</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">// 1.初始化队列及标记数组，存入起点</span><br>        queue&lt; tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; q; <span class="hljs-comment">// 三个属性分别为 idx, mask, dist</span><br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">vis</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-number">1</span> &lt;&lt; n)); <span class="hljs-comment">// 节点编号及当前状态</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            q.<span class="hljs-built_in">push</span>(&#123;i, <span class="hljs-number">1</span> &lt;&lt; i, <span class="hljs-number">0</span>&#125;); <span class="hljs-comment">// 存入起点，起始距离0，标记</span><br>            vis[i][<span class="hljs-number">1</span> &lt;&lt; i] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 开始搜索</span><br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> [cur, mask, dist] = q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 弹出队头元素</span><br>            q.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-comment">// 找到答案，返回结果</span><br>            <span class="hljs-keyword">if</span>(mask == (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> dist;<br><br>            <span class="hljs-comment">// 扩展</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : graph[cur]) &#123;<br>                <span class="hljs-type">int</span> nextmask = mask | (<span class="hljs-number">1</span> &lt;&lt; x);<br>                <span class="hljs-keyword">if</span>(!vis[x][nextmask]) &#123;<br>                    q.<span class="hljs-built_in">push</span>(&#123;x, nextmask, dist + <span class="hljs-number">1</span>&#125;);<br>                    vis[x][nextmask] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="个人理解">个人理解</h4><p>q中每个tuple的三个元素存储的是当前位掩码mask，遍历mask中所有节点并最后到达的节点idx，以及满足前述两个条件的最短路径长度dist，vis[idx][mask]记录在当前位掩码为mask的状态下，最后到达节点idx的路径是否已经经过计算了，事实上，在下面的while循环过程中，我们可以保证只要vis[idx][mask]经过了一次计算（也就是设置为true了），这次计算算得的路径就是相应的最短路径，因此后续无需再次计算该状态下的最短路径。首先初始状态下，我们将所有仅含1个节点的状态(i,1&lt;&lt;i,0)入队，并且更改vis[i][1&lt;&lt;i]为true，然后开始正式搜索。观察while循环中的代码可以非常直观地得出一个重要的结论，就是每次循环入队的tuple元素的dist分量是单调递增的，因此在循环内部注释拓展部分，只有在vis[idx][mask]还没有计算得到的时候才将相应元素入队，如果它已经计算过了（也就是vis[idx][mask]已经设置为true了），那么根据前文所述单调递增的性质，第一次计算之后的计算得到的dist只会比第一次计算得到的更大，因此这种情况下相应的tuple不能入队。最终随着搜索的进行，当第一次发现搜索已经遍历了所有的节点之后，我们就可以立即返回相应的dist了，这还是源于dist在每层循环单调递增的特性，因为这意味着第一次遍历之后的遍历所对应tuple中的dist元素肯定至少大于等于第一次的dist，所以第一次的dist就是我们寻找的最短距离。另外，由于题目保证该图是连通的，也就是说一定可以求出这样的最短距离，所以其实最后的return0是用不上的，但必须加上这句代码以确保所有分支情况都有数返回（不然会报错）。</p><h2 id="补充">补充</h2><p>对于不熟悉状压dp及其写法的读者，可以参考OI Wiki中的<a href="https://oi-wiki.org/dp/state/">简介</a>，基础写法可以参考灵茶山艾府大神的几篇<a href="https://leetcode.cn/problems/find-the-minimum-cost-array-permutation/solutions/2775272/zhuang-ya-dpcong-ji-yi-hua-sou-suo-dao-d-s9t5/">题解</a>。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>状态压缩dp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
