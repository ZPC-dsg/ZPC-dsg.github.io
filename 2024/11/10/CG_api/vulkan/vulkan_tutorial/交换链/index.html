<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/icon/mikuicon.jpg"><link rel="icon" href="/images/icon/mikuicon.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="ZPC-dsg"><meta name="keywords" content=""><meta name="description" content="概要 Vulkan中并没有所谓的“默认帧缓冲”的概念，所以我们需要一个能够储存渲染后图像以便之后显示到屏幕上的设施，这个设施就是交换链（swapChain）。交换链本质上就是一列图像，我们的应用程序会不断获取其中的一张，显示到屏幕上，然后归还给交换链。 创建一个交换链主要分为三步：  查询显卡是否支持交换链并启用相应拓展 填写创建交换链所需的必要信息 创建交换链并保存有关对象为类成员"><meta property="og:type" content="article"><meta property="og:title" content="交换链"><meta property="og:url" content="http://example.com/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/index.html"><meta property="og:site_name" content="ZPC の Blog"><meta property="og:description" content="概要 Vulkan中并没有所谓的“默认帧缓冲”的概念，所以我们需要一个能够储存渲染后图像以便之后显示到屏幕上的设施，这个设施就是交换链（swapChain）。交换链本质上就是一列图像，我们的应用程序会不断获取其中的一张，显示到屏幕上，然后归还给交换链。 创建一个交换链主要分为三步：  查询显卡是否支持交换链并启用相应拓展 填写创建交换链所需的必要信息 创建交换链并保存有关对象为类成员"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/images/textbg/CG_api/vk_tuto_swapchain.jpg"><meta property="article:published_time" content="2024-11-10T07:46:07.000Z"><meta property="article:modified_time" content="2024-11-11T11:16:54.213Z"><meta property="article:author" content="ZPC-dsg"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/images/textbg/CG_api/vk_tuto_swapchain.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>交换链 - ZPC の Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:"measurement_id:G-X8N3TZCB57",tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>ZPC の Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/images/textbg/CG_api/vk_tuto_swapchain.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="交换链"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> ZPC-dsg </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-11-10 15:46" pubdate>2024年11月10日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.8k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 32 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">交换链</h1><div class="markdown-body"><h2 id="概要">概要</h2><p>Vulkan中并没有所谓的“默认帧缓冲”的概念，所以我们需要一个能够储存渲染后图像以便之后显示到屏幕上的设施，这个设施就是交换链（swapChain）。交换链本质上就是一列图像，我们的应用程序会不断获取其中的一张，显示到屏幕上，然后归还给交换链。</p><p>创建一个交换链主要分为三步：</p><ul><li>查询显卡是否支持交换链并启用相应拓展</li><li>填写创建交换链所需的必要信息</li><li>创建交换链并保存有关对象为类成员</li></ul><p>本文对应Vulkan Tutorial的<a target="_blank" rel="noopener" href="https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain#page_Surface-format">Swap chain</a>章节。</p><hr><h2 id="查询支持">查询支持</h2><p>查询硬件是否支持交换链可以分为两步：查询交换链是否可用，以及查询交换链是否完整地具有所需的功能。</p><h4 id="查询交换链可用性">查询交换链可用性</h4><p>首先来查询物理设备是否支持交换链。事实上，如果一个物理设备支持显示队列的话，那么它一定支持交换链拓展。不过，在Vulkan中清晰地展示出一切细节总不是件坏事。所以这里我们还是选择查询一下设备对交换链的支持。</p><p>交换链支持拓展名为<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_swapchain.html"><code>VK_KHR_swapchain</code></a>，它是一个设备层面的拓展。于是我们在类外创建一个全局变量保存我们可能需要的所有设备层面的拓展名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; deviceExtensions = &#123;<br>    VK_KHR_SWAPCHAIN_EXTENSION_NAME<span class="hljs-comment">//字符串&quot;VK_KHR_swapchain&quot;对应的宏，用它避免拼写错误</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>下面，我们需要查询物理设备是否支持这个拓展。于是添加一个<i><font color="Green">checkDeviceExtensionSupport</font></i>函数来统一处理设备层面拓展的支持查询：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkDeviceExtensionSupport</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> extensionCount;<br>    <span class="hljs-built_in">vkEnumerateDeviceExtensionProperties</span>(device, <span class="hljs-literal">nullptr</span>, &amp;extensionCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkExtensionProperties&gt; <span class="hljs-title">availableExtensions</span><span class="hljs-params">(extensionCount)</span></span>;<br>    <span class="hljs-built_in">vkEnumerateDeviceExtensionProperties</span>(device, <span class="hljs-literal">nullptr</span>, &amp;extensionCount, availableExtensions.<span class="hljs-built_in">data</span>());<br><br>    <span class="hljs-function">std::set&lt;std::string&gt; <span class="hljs-title">requiredExtensions</span><span class="hljs-params">(deviceExtensions.begin(), deviceExtensions.end())</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; extension : availableExtensions) &#123;<br>        requiredExtensions.<span class="hljs-built_in">erase</span>(extension.extensionName);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> requiredExtensions.<span class="hljs-built_in">empty</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是易于理解的。</p><p>接下来我们要做的就是在<i><font color="Green">isDeviceSuitable</font></i>函数中使用<i><font color="Green">checkDeviceExtensionSupport</font></i>检查给定的物理设备是否支持指定的拓展：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(device);<br><br>    <span class="hljs-type">bool</span> extensionsSupported = <span class="hljs-built_in">checkDeviceExtensionSupport</span>(device);<br><br>    <span class="hljs-keyword">return</span> indices.<span class="hljs-built_in">isComplete</span>() &amp;&amp; extensionsSupported;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，如果选择的物理设备支持交换链拓展，那么我们需要启用这个拓展。启用拓展只需略微修改逻辑设备的createInfo，将原来的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.enabledExtensionCount = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>改为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.enabledExtensionCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(deviceExtensions.<span class="hljs-built_in">size</span>());<br>createInfo.ppEnabledExtensionNames = deviceExtensions.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>即可。</p><h4 id="查询交换链完整性">查询交换链完整性</h4><p>仅仅查询交换链是否可用是不够的，我们还需要知道选定的支持交换链的物理设备是否具有所需的和显示有关的表面功能特性。我们需要查询的主要细节有三点：</p><ul><li>基本表面属性，包括交换链可以具有的最少/最多图像数目，图像的最小/最大尺寸等</li><li>表面格式，具体而言指的是像素格式和颜色空间</li><li>可用显示模式</li></ul><p>于是建立一个结构体<i><font color="Orange">SwapChainSupportDetails</font></i>来保存这些查询结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SwapChainSupportDetails</span> &#123;<br>    VkSurfaceCapabilitiesKHR capabilities;<br>    std::vector&lt;VkSurfaceFormatKHR&gt; formats;<br>    std::vector&lt;VkPresentModeKHR&gt; presentModes;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在类内建立一个成员函数<i><font color="Green">SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device)</font></i>来负责具体的查询：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SwapChainSupportDetails <span class="hljs-title">querySwapChainSupport</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    SwapChainSupportDetails details;<br><br>    <span class="hljs-built_in">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</span>(device, surface, &amp;details.capabilities);<br>    <br>    <span class="hljs-type">uint32_t</span> formatCount;<br>	<span class="hljs-built_in">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(device, surface, &amp;formatCount, <span class="hljs-literal">nullptr</span>);<br><br>	<span class="hljs-keyword">if</span> (formatCount != <span class="hljs-number">0</span>) &#123;<br>    	details.formats.<span class="hljs-built_in">resize</span>(formatCount);<br>    	<span class="hljs-built_in">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(device, surface, &amp;formatCount, 		details.formats.<span class="hljs-built_in">data</span>());<br>	&#125;<br>    <br>    <span class="hljs-type">uint32_t</span> presentModeCount;<br>	<span class="hljs-built_in">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(device, surface, &amp;presentModeCount, <span class="hljs-literal">nullptr</span>);<br><br>	<span class="hljs-keyword">if</span> (presentModeCount != <span class="hljs-number">0</span>) &#123;<br>    	details.presentModes.<span class="hljs-built_in">resize</span>(presentModeCount);<br>    	<span class="hljs-built_in">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(device, surface, &amp;presentModeCount, 	details.presentModes.<span class="hljs-built_in">data</span>());<br>	&#125;<br>    <span class="hljs-keyword">return</span> details;<br>&#125;<br></code></pre></td></tr></table></figure><p>查询过程就是单纯地依次填充每个结构体成员。在这里我们只是简单地要求表面格式和显示模式均至少要有一种，这样就认为该物理设备的交换链是完整可用的。</p><p>现在我们需要再次修改一下<i><font color="Green">isDeviceSuitable</font></i>函数以添加检查交换链完整性的逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(device);<br><br>    <span class="hljs-type">bool</span> extensionsSupported = <span class="hljs-built_in">checkDeviceExtensionSupport</span>(device);<br><br>    <span class="hljs-type">bool</span> swapChainAdequate = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (extensionsSupported) &#123;<br>        SwapChainSupportDetails swapChainSupport = <span class="hljs-built_in">querySwapChainSupport</span>(device);<br>        swapChainAdequate = !swapChainSupport.formats.<span class="hljs-built_in">empty</span>() &amp;&amp; !swapChainSupport.presentModes.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> indices.<span class="hljs-built_in">isComplete</span>() &amp;&amp; extensionsSupported &amp;&amp; swapChainAdequate;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="填写创建信息">填写创建信息</h2><p>下面我们创建一个<i><font color="Green">void createSwapChain()</font></i>函数来创建交换链。首先我们需要查询交换链有关的表面信息以方便后续交换链创建信息结构体<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>的填写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createSwapChain</span><span class="hljs-params">()</span> </span>&#123;<br>    SwapChainSupportDetails swapChainSupport = <span class="hljs-built_in">querySwapChainSupport</span>(physicalDevice);<br><br>    VkSwapchainCreateInfoKHR createInfo&#123;&#125;;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>交换链创建信息需要指定的信息量相较于之前创建的对象要多得多，我们逐个填写。</p><p>首先总览一下交换链创建信息结构体<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSwapchainCreateInfoKHR</span> &#123;</span><br>    VkStructureType                  sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                      pNext;<br>    VkSwapchainCreateFlagsKHR        flags;<br>    VkSurfaceKHR                     surface;			 <span class="hljs-comment">//对应的表面</span><br>    <span class="hljs-type">uint32_t</span>                         minImageCount;<br>    VkFormat                         imageFormat;<br>    VkColorSpaceKHR                  imageColorSpace;<br>    VkExtent2D                       imageExtent;<br>    <span class="hljs-type">uint32_t</span>                         imageArrayLayers;<br>    VkImageUsageFlags                imageUsage;<br>    VkSharingMode                    imageSharingMode;<br>    <span class="hljs-type">uint32_t</span>                         queueFamilyIndexCount;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*                  pQueueFamilyIndices;<br>    VkSurfaceTransformFlagBitsKHR    preTransform;<br>    VkCompositeAlphaFlagBitsKHR      compositeAlpha;<br>    VkPresentModeKHR                 presentMode;<br>    VkBool32                         clipped;<br>    VkSwapchainKHR                   oldSwapchain;<br>&#125; VkSwapchainCreateInfoKHR;<br></code></pre></td></tr></table></figure><p>首先看第三个参数<i><font color="Orange">flags</font></i>，它是<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateFlagBitsKHR.html"><code>VkSwapchainCreateFlagBitsKHR</code></a>的位组合。<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateFlagBitsKHR.html"><code>VkSwapchainCreateFlagBitsKHR</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkSwapchainCreateFlagBitsKHR</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1 with VK_KHR_swapchain, VK_KHR_device_group with VK_KHR_swapchain</span><br>    VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//表示交换链的图像可以在不同的实例中进行绑定，这对于多实例的设备组（Device Group）非常有用。它允许在不同的设备实例之间共享交换链图像</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1 with VK_KHR_swapchain</span><br>    VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//指定交换链中的图像是受保护的。这意味着这些图像的内容在某些情况下（例如，受保护的内容播放）不会被访问或修改。这个标志通常用于需要内容保护的应用程序，如播放受版权保护的媒体</span><br>  <span class="hljs-comment">// Provided by VK_KHR_swapchain_mutable_format</span><br>    VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//允许交换链的格式在创建后进行更改。这对于需要动态调整图像格式的应用程序非常有用，比如在不同的显示设备上使用不同的格式</span><br>  <span class="hljs-comment">// Provided by VK_EXT_swapchain_maintenance1</span><br>    VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//指示交换链的图像内存分配可以延迟到实际使用时。这有助于优化内存使用，特别是在不确定图像会被使用的情况下</span><br>&#125; VkSwapchainCreateFlagBitsKHR;<br></code></pre></td></tr></table></figure><p>我们这里不需要设置任何标志位参数;</p><p>接下来要填写<i><font color="Orange">minImageCount</font></i>形参。这可以通过查询我们之前自定义的结构体<i><font color="Orange">SwapChainSupportDetails</font></i>的成员<i><font color="Orange">capabilities</font></i>的<i><font color="Orange">minImageCount</font></i>和<i><font color="Orange">maxImageCount</font></i>成员来决定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> imageCount = swapChainSupport.capabilities.minImageCount + <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span> (swapChainSupport.capabilities.maxImageCount &gt; <span class="hljs-number">0</span> &amp;&amp; imageCount &gt; swapChainSupport.capabilities.maxImageCount) &#123;<br>    imageCount = swapChainSupport.capabilities.maxImageCount;<br>&#125;<br><br>createInfo.minImageCount = imageCount;<br></code></pre></td></tr></table></figure><p>这里有两个需要解释的地方：第一行中加1是因为如果仅仅使用最少数量的图像可能意味着我们有时可能需要等待驱动程序完成内部操作，才能获取另一个图像进行渲染，因此我们要求至少多一张图像；另外maxImageCount ==0其实意味着交换链可以拥有的图像没有上界，因此当这个值大于0时，我们需要控制要求的交换链图像数目不超过其可能上界。</p><p>接下来，对于<i><font color="Orange">imageFormat</font></i>和<i><font color="Orange">imageColorSpace</font></i>成员，我们可以通过<i><font color="Orange">SwapChainSupportDetails</font></i>结构体的成员<i><font color="Orange">formats</font></i>成员来获取相关信息。<i><font color="Orange">formats</font></i>包含了交换链支持的所有表面图像格式信息，我们需要从中挑选最符合我们要求的那个格式。因此，我们创建一个<i><font color="Green">VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<vksurfaceformatkhr>&amp; availableFormats)</vksurfaceformatkhr></font></i>函数来达到上述目的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkSurfaceFormatKHR <span class="hljs-title">chooseSwapSurfaceFormat</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;VkSurfaceFormatKHR&gt;&amp; availableFormats)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; availableFormat : availableFormats) &#123;<br>        <span class="hljs-keyword">if</span> (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB &amp;&amp; availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) &#123;<br>            <span class="hljs-keyword">return</span> availableFormat;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> availableFormats[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>我们希望挑选的颜色格式是<i><font color="Red">VK_FORMAT_B8G8R8A8_SRGB</font></i>，希望图像所处的颜色空间为sRGB颜色空间<i><font color="Red">VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</font></i>（关于sRGB空间和伽马矫正的原理介绍，可以参考<a target="_blank" rel="noopener" href="https://learnopengl.com/Introduction">LearnOpenGL</a>教程的<a target="_blank" rel="noopener" href="https://learnopengl.com/Advanced-Lighting/Gamma-Correction">Gamma Correction</a>章节），如果不支持这种格式的图像的话，那就退而求其次，直接返回第一个支持的格式（当然我们可以自定义一些更复杂的选择逻辑）。</p><p>这样，我们就可以填写<i><font color="Orange">imageFormat</font></i>和<i><font color="Orange">imageColorSpace</font></i>成员的信息了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSurfaceFormatKHR surfaceFormat = <span class="hljs-built_in">chooseSwapSurfaceFormat</span>(swapChainSupport.formats);<br><br>createInfo.imageFormat = surfaceFormat.format;<br>createInfo.imageColorSpace = surfaceFormat.colorSpace;<br></code></pre></td></tr></table></figure><p>然后我们来填写<i><font color="Orange">imageExtent</font></i>形参。这个形参代表的是交换链图像的分辨率。一般来讲，这个分辨率要和屏幕的分辨率一致，此时我们可以直接通过<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilitiesKHR.html"><code>VkSurfaceCapabilitiesKHR</code></a>结构体的<i><font color="Orange">currentExtent</font></i>成员来获取图像的尺寸。但是有的窗口系统会允许交换链图像的分辨率与屏幕分辨率不一致，此时<i><font color="Orange">currentExtent</font></i>会被设置为<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/types/numeric_limits/max"><code>std::numeric_limits&lt;uint32_t&gt;::max()</code></a>，这种时候我们就必须自己决定最匹配屏幕的图像分辨率了。我们可以创建一个<i><font color="Green">VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR&amp; capabilities)</font></i>函数来决定图像分辨率：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkExtent2D <span class="hljs-title">chooseSwapExtent</span><span class="hljs-params">(<span class="hljs-type">const</span> VkSurfaceCapabilitiesKHR&amp; capabilities)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (capabilities.currentExtent.width != std::numeric_limits&lt;<span class="hljs-type">uint32_t</span>&gt;::<span class="hljs-built_in">max</span>()) &#123;<br>        <span class="hljs-keyword">return</span> capabilities.currentExtent;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> width, height;<br>        <span class="hljs-built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);<br><br>        VkExtent2D actualExtent = &#123;<br>            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(width),<br>            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(height)<br>        &#125;;<br><br>        actualExtent.width = std::<span class="hljs-built_in">clamp</span>(actualExtent.width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width);<br>        actualExtent.height = std::<span class="hljs-built_in">clamp</span>(actualExtent.height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height);<br><br>        <span class="hljs-keyword">return</span> actualExtent;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要注意，GLFW有两种分辨率单位，一种是屏幕坐标，另一种是像素个数，这二者未必总是相同的，例如在高DPI设备上实际像素数就要高于屏幕坐标范围。由于Vulkan指定的图像分辨率是通过像素个数指定的，所以我们需要使用<a target="_blank" rel="noopener" href="https://www.glfw.org/docs/3.3/group__window.html#ga0e2637a4161afb283f5300c7f94785c9"><code>glfwGetFramebufferSize</code></a>来获取当前屏幕的像素数。另外，我们需要控制选取的图像像素数不超过[minImageExtent,maxImageExtent]的范围，这通过<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/algorithm/clamp"><code>std::clamp</code></a>实现。</p><p>这样我们就可以使用该函数得到createInfo中需要的图像尺寸了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkExtent2D extent = <span class="hljs-built_in">chooseSwapExtent</span>(swapChainSupport.capabilities);<br><br>createInfo.imageExtent = extent;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">VkSwapchainCreateInfoKHR</font></i>结构体中接下来的形参<i><font color="Orange">imageArrayLayers</font></i>是多视图/立体表面中的视图数量。对于非立体3D应用程序，这个值为1。我们直接将其设为1即可。</p><p>接下来我们需要指定交换链中图像的用途。我们目前希望交换链中的图像用作渲染目标，于是可以给<i><font color="Orange">imageUsage</font></i>形参赋予<i><font color="Red">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</font></i>，也就是指定图像作为渲染的颜色缓冲。之后我们会接触到更多的图像使用方式。</p><p>下面我们要指定交换链中的图像要怎么用于多个队列家族中。当我们之前选定的图像队列和显示队列不一致的时候，我们就有两个不同队列家族种的队列了，此时我们需要指定这两个队列共享图像的模式，这通过<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html"><code>VkSharingMode</code></a>来指定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkSharingMode</span> &#123;</span><br>    VK_SHARING_MODE_EXCLUSIVE = <span class="hljs-number">0</span>,<span class="hljs-comment">//不允许同时有多个队列家族的队列访问图像</span><br>    VK_SHARING_MODE_CONCURRENT = <span class="hljs-number">1</span>,<span class="hljs-comment">//可以同时有多个队列家族的队列访问图像</span><br>&#125; VkSharingMode;<br></code></pre></td></tr></table></figure><p>如果有多个队列家族都需要访问交换链图像，此时如果选择<i><font color="Red">VK_SHARING_MODE_EXCLUSIVE</font></i>，那么我们还需要处理图像所有权在不同队列之间的转移问题。因此在这种情况下我们就简单地使用<i><font color="Red">VK_SHARING_MODE_CONCURRENT</font></i>模式就好了。如果只有一个队列家族（图像队列和显示队列一致），那么直接使用<i><font color="Red">VK_SHARING_MODE_EXCLUSIVE</font></i>就可以了。当然，在指定了共享模式之后，我们还需要指定共享这些图像的队列家族个数和索引：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(physicalDevice);<br><span class="hljs-type">uint32_t</span> queueFamilyIndices[] = &#123;indices.graphicsFamily.<span class="hljs-built_in">value</span>(), indices.presentFamily.<span class="hljs-built_in">value</span>()&#125;;<br><br><span class="hljs-keyword">if</span> (indices.graphicsFamily != indices.presentFamily) &#123;<br>    createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;<br>    createInfo.queueFamilyIndexCount = <span class="hljs-number">2</span>;<br>    createInfo.pQueueFamilyIndices = queueFamilyIndices;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;<br>    createInfo.queueFamilyIndexCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>    createInfo.pQueueFamilyIndices = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们可以指定显示图像之前作用于交换链图像上的变换<i><font color="Orange">preTransform</font></i>。我们目前并不需要任何预变换，所以像下面这样设置就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.preTransform = swapChainSupport.capabilities.currentTransform;<br></code></pre></td></tr></table></figure><p>我们还需要填写<i><font color="Orange">compositeAlpha</font></i>成员，该成员指定alpha通道是否可以用来和窗口系统中的其它窗口混合，这几乎总是被忽略的，因此我们只需赋予它<i><font color="Red">VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR</font></i>即可。</p><p>接下来我们需要指定交换链的显示类型。通过<i><font color="Green"> querySwapChainSupport</font></i>函数我们可以获得交换链所支持的所有显示类型，我们可以从其中选择所需的类型。</p><p>显示类型由一个<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html"><code>VkPresentModeKHR</code></a>枚举类型表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_surface</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkPresentModeKHR</span> &#123;</span><br>    VK_PRESENT_MODE_IMMEDIATE_KHR = <span class="hljs-number">0</span>,<br>    VK_PRESENT_MODE_MAILBOX_KHR = <span class="hljs-number">1</span>,<br>    VK_PRESENT_MODE_FIFO_KHR = <span class="hljs-number">2</span>,<br>    VK_PRESENT_MODE_FIFO_RELAXED_KHR = <span class="hljs-number">3</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_shared_presentable_image</span><br>    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = <span class="hljs-number">1000111000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_shared_presentable_image</span><br>    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = <span class="hljs-number">1000111001</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_present_mode_fifo_latest_ready</span><br>    VK_PRESENT_MODE_FIFO_LATEST_READY_EXT = <span class="hljs-number">1000361000</span>,<br>&#125; VkPresentModeKHR;<br></code></pre></td></tr></table></figure><p>我们不详细解释每种类型的含义，只具体解释两种经常使用的类型：<i><font color="Red">VK_PRESENT_MODE_FIFO_KHR</font></i>和<i><font color="Red">VK_PRESENT_MODE_MAILBOX_KHR</font></i>。前者指定当屏幕刷新的时候从队列头获取一张图像，同时程序将渲染好的图像放到队列的尾部，如果队列已经满了，那么程序就需要等待队列出现空间时再插入新图片。后者和前者基本相同，区别在于当队列满的时候，程序会直接使用新渲染的图像替代队列尾的图像，这可以提高渲染效率并降低延迟，但相应的开销也会更大。因此很多移动设备仍然会选择前者作为显示模式。另外，<i><font color="Red">VK_PRESENT_MODE_FIFO_KHR</font></i>被保证在任何支持交换链的设备上都是一定可用的，因此我们可以写一个选择显示模式的函数<i><font color="Green">VkPresentModeKHR chooseSwapPresentMode(const std::vector<vkpresentmodekhr>&amp; availablePresentModes)</vkpresentmodekhr></font></i>，它优先选择<i><font color="Red">VK_PRESENT_MODE_MAILBOX_KHR</font></i>，如果该模式不可用，那么再选择<i><font color="Red">VK_PRESENT_MODE_FIFO_KHR</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkPresentModeKHR <span class="hljs-title">chooseSwapPresentMode</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;VkPresentModeKHR&gt;&amp; availablePresentModes)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; availablePresentMode : availablePresentModes) &#123;<br>        <span class="hljs-keyword">if</span> (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) &#123;<br>            <span class="hljs-keyword">return</span> availablePresentMode;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> VK_PRESENT_MODE_FIFO_KHR;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以填写<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>结构体的<i><font color="Orange">presentMode</font></i>形参：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.presentMode = presentMode;<br></code></pre></td></tr></table></figure><p>然后我们需要指定<i><font color="Orange">createInfo</font></i>的<i><font color="Orange">clipped</font></i>形参。这个形参如果为<i><font color="Red">VK_TRUE</font></i>，就表明我们不在乎那些被其它窗口挡住的应用程序窗口的像素，那部分可以不进行显示。为了性能起见这个选项一般会设为<i><font color="Red">VK_TRUE</font></i>。</p><p>最后，在Vulkan程序运行的过程中，交换链很有可能会变得不再有效或者不再是性能最优的，比如窗口缩放等操作都会造成这种问题。因此，我们可能需要经常从头构建一个新的交换链。因此在一个新交换链的构建信息中指定一个旧交换链可以有助于减少资源的重新分配，提高性能，还能保证在新交换链创建后，旧交换链的资源能够被正确管理和释放，避免资源泄漏。交换链的更新是一个比较复杂的主题，我们将在后面介绍。在这里我们仅简单地将最后一个形参<i><font color="Orange">oldSwapchain</font></i>设置为<i><font color="Red">VK_NULL_HANDLE</font></i>。</p><p>终于，我们完成了<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>结构体的填写！</p><hr><h2 id="创建交换链">创建交换链</h2><p>接下来我们终于可以创建交换链对象了。在类内新增一个<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainKHR.html"><code>VkSwapchainKHR</code></a>成员，构建过程我们已经非常熟悉：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateSwapchainKHR</span>(device, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;swapChain) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create swap chain!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，在后续章节涉及到渲染的时候我们还需要在代码中使用交换链中的图像，因此我们将这些图像也保存为类内成员<i><font color="Orange">std::vector<vkimage>swapChainImages</vkimage></font></i>，然后我们紧接着创建交换链之后来获取这些图像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkGetSwapchainImagesKHR</span>(device, swapChain, &amp;imageCount, <span class="hljs-literal">nullptr</span>);<br>swapChainImages.<span class="hljs-built_in">resize</span>(imageCount);<br><span class="hljs-built_in">vkGetSwapchainImagesKHR</span>(device, swapChain, &amp;imageCount, swapChainImages.<span class="hljs-built_in">data</span>());<br></code></pre></td></tr></table></figure><p>我们在后续章节还会用到这些图像的图像格式以及图像尺寸，因此在类内再新增两个成员<i><font color="Orange">VkFormat swapChainImageFormat</font></i>以及<i><font color="Orange">VkExtent2D swapChainExtent</font></i>分别保存这两者，并且在设置<i><font color="Orange">VkSwapchainCreateInfoKHR</font></i>的相应形参的时候顺便保存这两个成员就可以了。</p><p>大功告成！可喜可贺~</p><hr><p>--<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/">上一篇：窗口表面</a></p><p>--<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/">下一篇：图像视图</a></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/CG-api/" class="category-chain-item">CG_api</a> <span>></span> <a href="/categories/CG-api/vulkan/" class="category-chain-item">vulkan</a> <span>></span> <a href="/categories/CG-api/vulkan/vulkan-tutorial/" class="category-chain-item">vulkan_tutorial</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>交换链</div><div>http://example.com/2024/11/10/CG_api/vulkan/vulkan_tutorial/交换链/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>ZPC-dsg</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年11月10日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/" title="图像视图"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">图像视图</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/" title="窗口表面"><span class="hidden-mobile">窗口表面</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>