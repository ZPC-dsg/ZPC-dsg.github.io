<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/icon/mikuicon.jpg"><link rel="icon" href="/images/icon/mikuicon.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="ZPC-dsg"><meta name="keywords" content=""><meta name="description" content="概要 接下来的几个章节我们将开始纹理使用的学习。使用纹理可以给我们原本枯燥无味的程序添加大量有趣的细节。在Vulkan中使用纹理大致可以分为四步：  创建纹理对象并且为其分配内存 将图片数据上传并复制到纹理中 创建图像视图和采样器 创建相应的组合图像采样器描述符（combined image sampler descriptor）以便着色器采样纹理  本节我们将首先完成前两步的工"><meta property="og:type" content="article"><meta property="og:title" content="图像"><meta property="og:url" content="http://example.com/2024/12/12/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F/index.html"><meta property="og:site_name" content="ZPC の Blog"><meta property="og:description" content="概要 接下来的几个章节我们将开始纹理使用的学习。使用纹理可以给我们原本枯燥无味的程序添加大量有趣的细节。在Vulkan中使用纹理大致可以分为四步：  创建纹理对象并且为其分配内存 将图片数据上传并复制到纹理中 创建图像视图和采样器 创建相应的组合图像采样器描述符（combined image sampler descriptor）以便着色器采样纹理  本节我们将首先完成前两步的工"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/images/textbg/CG_api/vk_tuto_image.jpg"><meta property="article:published_time" content="2024-12-12T14:05:31.000Z"><meta property="article:modified_time" content="2024-12-20T01:06:34.111Z"><meta property="article:author" content="ZPC-dsg"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/images/textbg/CG_api/vk_tuto_image.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>图像 - ZPC の Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:"measurement_id:G-X8N3TZCB57",tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>ZPC の Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/images/textbg/CG_api/vk_tuto_image.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="图像"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> ZPC-dsg </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-12-12 22:05" pubdate>2024年12月12日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 5.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 46 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">图像</h1><div class="markdown-body"><h2 id="概要">概要</h2><p>接下来的几个章节我们将开始纹理使用的学习。使用纹理可以给我们原本枯燥无味的程序添加大量有趣的细节。在Vulkan中使用纹理大致可以分为四步：</p><ul><li>创建纹理对象并且为其分配内存</li><li>将图片数据上传并复制到纹理中</li><li>创建图像视图和采样器</li><li>创建相应的组合图像采样器描述符（<strong>combined image sampler descriptor</strong>）以便着色器采样纹理</li></ul><p>本节我们将首先完成前两步的工作。在之前的<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/">交换链</a>章节中我们提到过，在创建交换链对象的时候Vulkan会自动帮我们创建交换链使用的图像而无需我们自己创建，而在使用纹理的时候我们就需要自己完成创建图像的有关工作和细节了。创建纹理并且上传图片数据的过程主要可以细分为以下：</p><ul><li>将图片加载到程序中</li><li>将加载到程序中的图片数据复制给临时缓冲</li><li>创建纹理对象并且为其分配内存</li><li>在复制缓冲数据之前处理好图像布局的转换</li><li>将临时缓冲中的数据复制到纹理中</li></ul><p>可以看出构建并填充一个纹理对象的过程和构建并填充顶点缓冲的过程十分类似，不过最大的不同之处在于在将数据复制到纹理对象之前，我们需要处理好纹理布局。事实上，指定不同的图像布局会影响Vulkan对该图像执行操作的方式，一般在使用图像之前我们需要将图像布局转换为最适合接下来操作的那一个。在之前的<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/">渲染通道</a>章节中我们已经介绍过一些图像布局有关的知识，（这里有一个小疑点：<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/">渲染通道</a>章节中我们指定了帧缓冲的图像附件在渲染开始和结束后应该具备的布局，并且在之后的渲染过程中我们也并没有手动去进行布局的转换，但是GPT说即使在<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentDescription.html"><code>VkAttachmentDescription</code></a>中指定了附件的初始和最终布局，我们仍然需要在录制命令的时候手动进行布局转换以满足设置的布局要求，但是显然教程中没有这么做，我并不清楚是GPT说明有误还是教程漏写了。。。）。当我们需要自己处理布局转换有关的细节的时候，我们往往会采用管线屏障（<strong>pipeline barrier</strong>）来同步转换前后需要指定顺序的操作，这同样会在本文的主要内容中介绍。</p><p>本节对应Vulkan Tutorial的<a target="_blank" rel="noopener" href="https://vulkan-tutorial.com/Texture_mapping/Images#page_Preparing-the-texture-image">images</a>章节。</p><hr><h2 id="加载图片">加载图片</h2><p>有很多的库可以用于将图片加载至程序中，当然，自己写一个这样的库也并不困难。不过，为了性能和稳定性以及适用范围的考量，我们在这里还是选取一个十分通用的图像加载库：<a target="_blank" rel="noopener" href="https://github.com/nothings/stb">stb_image</a>。这个库最大的特点和方便之处在于所有的代码都集中在一个文件中，省去了很多构建依赖关系的麻烦。想要使用这个库，我们只需要在程序中包含<strong>stb_image.h</strong>头文件，然后在程序头定义宏<i><font color="Red">STB_IMAGE_IMPLEMENTATION</font></i>即可。关于这个库提供的API以及有关使用方式我们不做过多介绍，想要详细了解的读者可以参考<strong>stb_image.h</strong>头文件中的<strong>DOCUMENTATION</strong>注释部分。</p><p>假设我们使用一张名为<strong>texture.jpg</strong>的图像，并且将其放在程序根目录下的子文件夹<strong>textures</strong>中。我们添加一个构建纹理的成员函数<i><font color="Green">void createTextureImage()</font></i>，那么这个函数首先要做的就是加载图像到程序中来，加载图像的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createTextureImage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> texWidth, texHeight, texChannels;<br>    stbi_uc* pixels = <span class="hljs-built_in">stbi_load</span>(<span class="hljs-string">&quot;textures/texture.jpg&quot;</span>, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);<br>    VkDeviceSize imageSize = texWidth * texHeight * <span class="hljs-number">4</span>;<br><br>    <span class="hljs-keyword">if</span> (!pixels) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to load texture image!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里我们在<strong>stbi_load</strong>函数中使用了参数<i><font color="Red">STBI_rgb_alpha</font></i>，这意味着我们强制要求加载图片的透明通道，即使图片本身不具备该通道，这样加载的图片数据具有所有的四个通道。这么做可以使用统一的代码加载具有透明通道和不具有透明通道的图片。另外，加载后的图片数据大小<i><font color="Orange">imageSize</font></i>被定义为4倍的图像大小，因为加载后图片的每个像素都有4个通道，每个通道占一字节。</p><hr><h2 id="填充临时缓冲">填充临时缓冲</h2><p>填充临时缓冲的操作和<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/">临时缓冲区</a>章节所述的步骤没什么区别：首先创建一个CPU可见且一致的临时缓冲对象并且为它分配内存，然后将该缓冲映射到CPU端，再将程序中的数据复制到该缓冲中，最后解除映射。整个代码流程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createTextureImage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <br>    VkBuffer stagingBuffer;<br>	VkDeviceMemory stagingBufferMemory;<br>    <br>    <span class="hljs-built_in">createBuffer</span>(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);<br>    <br>    <span class="hljs-type">void</span>* data;<br>	<span class="hljs-built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="hljs-number">0</span>, imageSize, <span class="hljs-number">0</span>, &amp;data);<br>    <span class="hljs-built_in">memcpy</span>(data, pixels, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(imageSize));<br>	<span class="hljs-built_in">vkUnmapMemory</span>(device, stagingBufferMemory);<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然，不要忘了在图像数据复制到缓冲区后清理掉不再使用的<i><font color="Orange">pixels</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">stbi_image_free</span>(pixels);<br></code></pre></td></tr></table></figure><p>值得一提的是，实际上我们也可以使用临时图像来作为最终图像和CPU端数据的中介，不过在某些硬件上使用缓冲区作为中介的速度更快效果更好，所以我们还是使用临时缓冲区来传递数据。</p><hr><h2 id="创建纹理对象并分配内存">创建纹理对象并分配内存</h2><p>尽管在Vulkan中我们也可以使用缓冲区来存储并使用图像数据，但是Vulkan提供了专门用于使用图像的图像对象，通过图像对象我们就可以使用直观的坐标来获取像素颜色而无需通过字节来获取颜色信息，这显然是更方便的。并且Vulkan的图像对象还提供了各种布局以优化各种使用方式的效率。因此，使用图像对象来访问图片数据一般来讲是一个更好的选择。</p><p>现在我们已经将图片数据复制到了临时缓冲中，接下来我们需要创建GPU端真正用于存储数据的图像对象。为了创建这样一个图像对象，我们需要填写<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCreateInfo.html"><code>VkImageCreateInfo</code></a>结构体，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkImageCreateInfo</span> &#123;</span><br>    VkStructureType          sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*              pNext;<br>    VkImageCreateFlags       flags;<br>    VkImageType              imageType;<br>    VkFormat                 format;<br>    VkExtent3D               extent;<br>    <span class="hljs-type">uint32_t</span>                 mipLevels;<br>    <span class="hljs-type">uint32_t</span>                 arrayLayers;<br>    VkSampleCountFlagBits    samples;<br>    VkImageTiling            tiling;<br>    VkImageUsageFlags        usage;<br>    VkSharingMode            sharingMode;<br>    <span class="hljs-type">uint32_t</span>                 queueFamilyIndexCount;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*          pQueueFamilyIndices;<br>    VkImageLayout            initialLayout;<br>&#125; VkImageCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>指定了很多特性，详细可以参考<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCreateFlagBits.html">这个页面</a>，这里不做过多介绍。</p><p><i><font color="Orange">imageType</font></i>指定创建的图像对象类型，总共有三种类型：1D，2D和3D图像：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkImageType</span> &#123;</span><br>    VK_IMAGE_TYPE_1D = <span class="hljs-number">0</span>,<br>    VK_IMAGE_TYPE_2D = <span class="hljs-number">1</span>,<br>    VK_IMAGE_TYPE_3D = <span class="hljs-number">2</span>,<br>&#125; VkImageType;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">format</font></i>指定图像数据的格式，这个格式一般需要和临时缓冲区中存储图像的格式一致，不然的话在后续复制缓冲数据容易得到无法预知的错误结果。Vulkan支持的完整的图像格式可以参考<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkFormat.html">这个页面</a>。</p><p><i><font color="Orange">extent</font></i>是一个<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkExtent3D.html"><code>VkExtent3D</code></a>类型的成员，用于指定图像基础层级每个维度的像素数量，<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkExtent3D.html"><code>VkExtent3D</code></a>是一个包含三个维度像素数量成员的简单结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkExtent3D</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>    width;<br>    <span class="hljs-type">uint32_t</span>    height;<br>    <span class="hljs-type">uint32_t</span>    depth;<br>&#125; VkExtent3D;<br></code></pre></td></tr></table></figure><p>接下来的<i><font color="Orange">mipLevels</font></i>、<i><font color="Orange">arrayLayers</font></i>和<i><font color="Orange">samples</font></i>分别指定图像的多级渐远层级、图像层数以及多重采样采样数，我们暂时不需要使用多级渐远和多层图像，也暂时不会使用多重采样技术。</p><p><i><font color="Orange">tiling</font></i>指定了图像中的像素在内存中实际上的存储方式，它可以有以下取值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkImageTiling</span> &#123;</span><br>    VK_IMAGE_TILING_OPTIMAL = <span class="hljs-number">0</span>,<br>    VK_IMAGE_TILING_LINEAR = <span class="hljs-number">1</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_image_drm_format_modifier</span><br>    VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = <span class="hljs-number">1000158000</span>,<span class="hljs-comment">//主要用于支持 DRM（Direct Rendering Manager）格式修饰符的图像，这些修饰符允许驱动程序更好地利用硬件特性，以优化图像存储和访问。这个扩展使得 Vulkan 可以更好地与 Linux 的图形栈（如 Wayland 和 X11）集成</span><br>&#125; VkImageTiling;<br></code></pre></td></tr></table></figure><p>如果我们希望在后续的CPU端操作中获取图像中的内容，那么我们应该将<i><font color="Orange">tiling</font></i>设置为<i><font color="Red">VK_IMAGE_TILING_OPTIMAL</font></i>，但是如果我们希望在GPU端使用该图像，比如用于渲染采样等操作，那么应该将其设置为<i><font color="Red">VK_IMAGE_TILING_OPTIMAL</font></i>。注意铺砌方式和布局还是有所不同的：铺砌方式指定了图像数据在内存中的具体存储格式，而布局则是指定图像允许的使用方式。</p><p><i><font color="Orange">usage</font></i>指定图像的用途，关于Vulkan中图像允许的所有用途可以参考<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageUsageFlagBits.html">这个页面</a>。</p><p><i><font color="Orange">sharingMode</font></i>指定图像的共享模式，也就是是否能被多个队列家族所共享，下方的<i><font color="Orange">queueFamilyIndexCount</font></i>和<i><font color="Orange">pQueueFamilyIndices</font></i>就指定了可以共享该图像的队列家族索引。当然，如果共享模式不是<i><font color="Red">VK_SHARING_MODE_CONCURRENT</font></i>的话，这两个成员会被忽略，因此也就无需填写。</p><p><i><font color="Orange">initialLayout</font></i>指定图像的初始布局，也就是创建之初的布局。事实上，对于该变量我们的取值只有两种：</p><ul><li><i><font color="Red">VK_IMAGE_LAYOUT_UNDEFINED</font></i>：不可为GPU所用，并且在初次使用的布局转换之前会丢弃所有纹素内容。</li><li><i><font color="Red">VK_IMAGE_LAYOUT_PREINITIALIZED</font></i>：不可为GPU所用，但是在初次使用的布局转换之前会保存所有纹素内容。</li></ul><p>事实上，很少有情况需要我们在第一次布局转换之前保留纹素内容，不过也并没没有这种情况：比如我们使用临时图像传递图像数据，在将临时图像布局转换为适用于传递源的布局之前我们当然需要保留图像中复制而来的像素数据。不过在我们的应用程序中，我们将图像对象用作传输目的地，我们并不关心在接受临时缓冲里的图像数据之前该图像对象纹素中的内容是什么，因此我们应该将其初始布局设置为<i><font color="Red">VK_IMAGE_LAYOUT_UNDEFINED</font></i>。</p><p>于是创建我们所需要的纹理对象相应代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkImage textureImage;<br>VkDeviceMemory textureImageMemory;<br><br>VkImageCreateInfo imageInfo&#123;&#125;;<br>imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;<br>imageInfo.imageType = VK_IMAGE_TYPE_2D;<br>imageInfo.extent.width = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(texWidth);<br>imageInfo.extent.height = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(texHeight);<br>imageInfo.extent.depth = <span class="hljs-number">1</span>;<br>imageInfo.mipLevels = <span class="hljs-number">1</span>;<br>imageInfo.arrayLayers = <span class="hljs-number">1</span>;<br>imageInfo.format = VK_FORMAT_R8G8B8A8_SRGB;<br>imageInfo.tiling = VK_IMAGE_TILING_OPTIMAL;<br>imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;<br>imageInfo.usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;<br>imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;<br>imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateImage</span>(device, &amp;imageInfo, <span class="hljs-literal">nullptr</span>, &amp;textureImage) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create image!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们需要为创建好的图像分配内存，为图像分配内存的过程和为缓冲对象分配内存几乎一致，不熟悉的读者可以参考<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/">创建顶点缓冲</a>章节有关内容。我们这里直接给出分配纹理内存的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkMemoryRequirements memRequirements;<br><span class="hljs-built_in">vkGetImageMemoryRequirements</span>(device, textureImage, &amp;memRequirements);<br><br>VkMemoryAllocateInfo allocInfo&#123;&#125;;<br>allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;<br>allocInfo.allocationSize = memRequirements.size;<br>allocInfo.memoryTypeIndex = <span class="hljs-built_in">findMemoryType</span>(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkAllocateMemory</span>(device, &amp;allocInfo, <span class="hljs-literal">nullptr</span>, &amp;textureImageMemory) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to allocate image memory!&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">vkBindImageMemory</span>(device, textureImage, textureImageMemory, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>终于完成了对图像对象的创建和分配内存操作。不过此时<i><font color="Green">createTextureImage</font></i>函数已经变得比较臃肿了，我们可以将其中创建图像和分配内存的代码放到一个新的工具函数<i><font color="Green">void createImage(uint32_t width, uint32_t height, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage&amp; image, VkDeviceMemory&amp; imageMemory)</font></i>中来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createImage</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> width, <span class="hljs-type">uint32_t</span> height, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage&amp; image, VkDeviceMemory&amp; imageMemory)</span> </span>&#123;<br>    VkImageCreateInfo imageInfo&#123;&#125;;<br>    imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;<br>    imageInfo.imageType = VK_IMAGE_TYPE_2D;<br>    imageInfo.extent.width = width;<br>    imageInfo.extent.height = height;<br>    imageInfo.extent.depth = <span class="hljs-number">1</span>;<br>    imageInfo.mipLevels = <span class="hljs-number">1</span>;<br>    imageInfo.arrayLayers = <span class="hljs-number">1</span>;<br>    imageInfo.format = format;<br>    imageInfo.tiling = tiling;<br>    imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;<br>    imageInfo.usage = usage;<br>    imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;<br>    imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateImage</span>(device, &amp;imageInfo, <span class="hljs-literal">nullptr</span>, &amp;image) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create image!&quot;</span>);<br>    &#125;<br><br>    VkMemoryRequirements memRequirements;<br>    <span class="hljs-built_in">vkGetImageMemoryRequirements</span>(device, image, &amp;memRequirements);<br><br>    VkMemoryAllocateInfo allocInfo&#123;&#125;;<br>    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;<br>    allocInfo.allocationSize = memRequirements.size;<br>    allocInfo.memoryTypeIndex = <span class="hljs-built_in">findMemoryType</span>(memRequirements.memoryTypeBits, properties);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkAllocateMemory</span>(device, &amp;allocInfo, <span class="hljs-literal">nullptr</span>, &amp;imageMemory) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to allocate image memory!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">vkBindImageMemory</span>(device, image, imageMemory, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样<i><font color="Green">createTextureImage</font></i>函数就可以简化为以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createTextureImage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> texWidth, texHeight, texChannels;<br>    stbi_uc* pixels = <span class="hljs-built_in">stbi_load</span>(<span class="hljs-string">&quot;textures/texture.jpg&quot;</span>, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);<br>    VkDeviceSize imageSize = texWidth * texHeight * <span class="hljs-number">4</span>;<br><br>    <span class="hljs-keyword">if</span> (!pixels) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to load texture image!&quot;</span>);<br>    &#125;<br><br>    VkBuffer stagingBuffer;<br>    VkDeviceMemory stagingBufferMemory;<br>    <span class="hljs-built_in">createBuffer</span>(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);<br><br>    <span class="hljs-type">void</span>* data;<br>    <span class="hljs-built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="hljs-number">0</span>, imageSize, <span class="hljs-number">0</span>, &amp;data);<br>        <span class="hljs-built_in">memcpy</span>(data, pixels, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(imageSize));<br>    <span class="hljs-built_in">vkUnmapMemory</span>(device, stagingBufferMemory);<br><br>    <span class="hljs-built_in">stbi_image_free</span>(pixels);<br><br>    <span class="hljs-built_in">createImage</span>(texWidth, texHeight, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="布局转换">布局转换</h2><p>在创建好图像对象以及分配好相应的内存之后，我们接下来要做的就是将临时缓冲中的数据复制到图像对象中来。但是在复制之前，我们首先需要调整图像对象的布局以使其能够作为复制操作的目的地。</p><p>要实现布局的转换，我们同样需要将相应的命令提交到队列中执行。因此我们需要首先录制执行转换的命令。如今我们的程序中已经有多处需要用到命令缓冲了，因此不妨将相应代码提取出来重构成两个新的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkCommandBuffer <span class="hljs-title">beginSingleTimeCommands</span><span class="hljs-params">()</span> </span>&#123;<br>    VkCommandBufferAllocateInfo allocInfo&#123;&#125;;<br>    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;<br>    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;<br>    allocInfo.commandPool = commandPool;<br>    allocInfo.commandBufferCount = <span class="hljs-number">1</span>;<br><br>    VkCommandBuffer commandBuffer;<br>    <span class="hljs-built_in">vkAllocateCommandBuffers</span>(device, &amp;allocInfo, &amp;commandBuffer);<br><br>    VkCommandBufferBeginInfo beginInfo&#123;&#125;;<br>    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;<br>    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;<br><br>    <span class="hljs-built_in">vkBeginCommandBuffer</span>(commandBuffer, &amp;beginInfo);<br><br>    <span class="hljs-keyword">return</span> commandBuffer;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">endSingleTimeCommands</span><span class="hljs-params">(VkCommandBuffer commandBuffer)</span> </span>&#123;<br>    <span class="hljs-built_in">vkEndCommandBuffer</span>(commandBuffer);<br><br>    VkSubmitInfo submitInfo&#123;&#125;;<br>    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;<br>    submitInfo.commandBufferCount = <span class="hljs-number">1</span>;<br>    submitInfo.pCommandBuffers = &amp;commandBuffer;<br><br>    <span class="hljs-built_in">vkQueueSubmit</span>(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, VK_NULL_HANDLE);<br>    <span class="hljs-built_in">vkQueueWaitIdle</span>(graphicsQueue);<br><br>    <span class="hljs-built_in">vkFreeCommandBuffers</span>(device, commandPool, <span class="hljs-number">1</span>, &amp;commandBuffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>这些代码是从<i><font color="Green">copyBuffer</font></i>函数中提取出来的，这样<i><font color="Green">copyBuffer</font></i>函数就可以简化为以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copyBuffer</span><span class="hljs-params">(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size)</span> </span>&#123;<br>    VkCommandBuffer commandBuffer = <span class="hljs-built_in">beginSingleTimeCommands</span>();<br><br>    VkBufferCopy copyRegion&#123;&#125;;<br>    copyRegion.size = size;<br>    <span class="hljs-built_in">vkCmdCopyBuffer</span>(commandBuffer, srcBuffer, dstBuffer, <span class="hljs-number">1</span>, &amp;copyRegion);<br><br>    <span class="hljs-built_in">endSingleTimeCommands</span>(commandBuffer<br></code></pre></td></tr></table></figure><p>现在，我们创建一个<i><font color="Green">void transitionImageLayout(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout)</font></i>函数来完成布局转换相应的工作。我们将使用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageMemoryBarrier.html"><code>VkImageMemoryBarrier</code></a>（管线屏障的一种）来完成图像布局转换前后的同步操作。<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageMemoryBarrier.html"><code>VkImageMemoryBarrier</code></a>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkImageMemoryBarrier</span> &#123;</span><br>    VkStructureType            sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                pNext;<br>    VkAccessFlags              srcAccessMask;<br>    VkAccessFlags              dstAccessMask;<br>    VkImageLayout              oldLayout;<br>    VkImageLayout              newLayout;<br>    <span class="hljs-type">uint32_t</span>                   srcQueueFamilyIndex;<br>    <span class="hljs-type">uint32_t</span>                   dstQueueFamilyIndex;<br>    VkImage                    image;<br>    VkImageSubresourceRange    subresourceRange;<br>&#125; VkImageMemoryBarrier;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">srcAccessMask</font></i>和<i><font color="Orange">dstAccessMask</font></i>分别指定栅栏前需要完成的操作和栅栏后等待前述操作完成的操作，可能的取值可以参考<a target="_blank" rel="noopener" href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/VkAccessFlagBits.html">这个页面</a>。</p><p><i><font color="Orange">srcQueueFamilyIndex</font></i>和<i><font color="Orange">dstQueueFamilyIndex</font></i>分别指定图像归属权转移操作中的源队列和目标队列。在这里我们并不会将该管线屏障用于图像归属权转移操作，但是这两个成员的默认值并不是屏蔽该用法，因此我们仍然需要赋予这两个成员<i><font color="Red">VK_QUEUE_FAMILY_IGNORED</font></i>以显式指定我们不进行队列间归属转移。</p><p><i><font color="Orange">subresourceRange</font></i>用于指定图像中被该屏障影响的部分。<a target="_blank" rel="noopener" href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/VkImageSubresourceRange.html"><code>VkImageSubresourceRange</code></a>结构体的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkImageSubresourceRange</span> &#123;</span><br>    VkImageAspectFlags    aspectMask;<span class="hljs-comment">//图像的哪个方面（颜色、深度、模板等）会被影响</span><br>    <span class="hljs-type">uint32_t</span>              baseMipLevel;<span class="hljs-comment">//从哪个渐远层级开始被影响</span><br>    <span class="hljs-type">uint32_t</span>              levelCount;<span class="hljs-comment">//被影响的层级数</span><br>    <span class="hljs-type">uint32_t</span>              baseArrayLayer;<span class="hljs-comment">//从哪个图层开始被影响</span><br>    <span class="hljs-type">uint32_t</span>              layerCount;<span class="hljs-comment">//被影响的图像层数</span><br>&#125; VkImageSubresourceRange;<br></code></pre></td></tr></table></figure><p>随着我们程序的复杂化，我们可能需要处理多种不同类型的布局转换。就目前而言，我们需要处理的转换有两个：</p><ul><li>由最初的布局转换为数据传输目标布局</li><li>由传输目标布局转化为适合着色器读写布局</li></ul><p>于是在这两种转换中，填写<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageMemoryBarrier.html"><code>VkImageMemoryBarrier</code></a>结构体过程中唯一的不同就是对<i><font color="Orange">srcAccessMask</font></i>和<i><font color="Orange">dstAccessMask</font></i>的指定。对于从最初的布局到数据传输目标布局的转换，我们并不需要在复制数据到图像对象之前等待什么特别的操作先完成，于是<i><font color="Orange">srcAccessMask</font></i>直接填写为0即可。而<i><font color="Orange">dstAccessMask</font></i>显然应该指定为我们的复制写入操作，因此将其设置为<i><font color="Red">VK_ACCESS_TRANSFER_WRITE_BIT</font></i>比较合理。在成功复制数据之后，图像将供后续着色器读取纹理用，此时我们应该对其进行第二次的转换，即将其布局转换为适合着色器读取的布局。在进行这个转换时我们应该在转换前等待完成的操作是数据的写入操作，因为我们不希望在数据还未完全写入的时候就开始对图像进行转换操作，因此此时<i><font color="Orange">srcAccessMask</font></i>应该为<i><font color="Red">VK_ACCESS_TRANSFER_WRITE_BIT</font></i>，而<i><font color="Orange">dstAccessMask</font></i>应该为<i><font color="Red">VK_ACCESS_SHADER_READ_BIT</font></i>，因为后续着色器读取数据需要等待数据的填充完成之后才能进行。</p><p>在填写好这个信息结构体之后，我们需要使用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPipelineBarrier.html"><code>vkCmdPipelineBarrier</code></a>函数来完成管线屏障的提交工作，提交后队列会处理屏障所保障的布局转换操作。该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdPipelineBarrier</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    VkPipelineStageFlags                        srcStageMask,</span><br><span class="hljs-params">    VkPipelineStageFlags                        dstStageMask,</span><br><span class="hljs-params">    VkDependencyFlags                           dependencyFlags,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    memoryBarrierCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkMemoryBarrier*                      pMemoryBarriers,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    bufferMemoryBarrierCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkBufferMemoryBarrier*                pBufferMemoryBarriers,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    imageMemoryBarrierCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkImageMemoryBarrier*                 pImageMemoryBarriers)</span>;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">srcStageMask</font></i>和<i><font color="Orange">dstStageMask</font></i>分别指定屏障前需要完成的管线阶段和屏障后需要等待的管线阶段，这和之前在填写<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageMemoryBarrier.html"><code>VkImageMemoryBarrier</code></a>结构体中设置的<i><font color="Orange">srcAccessMask</font></i>和<i><font color="Orange">dstAccessMask</font></i>是相互对应的。在第一次转换中，我们无需等待任何操作，因此<i><font color="Orange">srcStageMask</font></i>可以直接设置为<i><font color="Red">VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</font></i>，而处于等待状态的操作是写入操作，因此<i><font color="Orange">dstStageMask</font></i>应该指定为<i><font color="Red">VK_PIPELINE_STAGE_TRANSFER_BIT</font></i>。不过这里注意，<i><font color="Red">VK_PIPELINE_STAGE_TRANSFER_BIT</font></i>实际上并不是一个真正存在的管线阶段，我们称其为一个<strong>伪阶段</strong>，它们是一种逻辑上存在的阶段，用于描述一些逻辑上的操作，阶段发生时间并不是固定的。<a target="_blank" rel="noopener" href="https://docs.vulkan.org/spec/latest/chapters/synchronization.html#VkPipelineStageFlagBits">这个页面</a>有更多关于Vulkan中的伪阶段的信息。</p><p>接下来的<i><font color="Orange">dependencyFlags</font></i>用于指定执行和内存上的一些依赖关系。它可能的取值如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDependencyFlagBits</span> &#123;</span><br>    VK_DEPENDENCY_BY_REGION_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//当一个命令依赖于另一个命令的执行时，如果使用该标志，表示只需在依赖的区域内进行同步，而不是整个资源。这可以提高性能，因为只需同步必要的部分</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_DEPENDENCY_DEVICE_GROUP_BIT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//在多视图渲染中，该标志指示依赖关系仅适用于特定的视图。这意味着资源的访问和修改仅限于特定的视图，其他视图不受影响</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_DEPENDENCY_VIEW_LOCAL_BIT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//在使用多个 GPU 的情况下，该标志指示依赖关系涉及设备组中的多个设备。这有助于在多个设备之间管理资源的访问和同步，确保数据一致性</span><br>  <span class="hljs-comment">// Provided by VK_EXT_attachment_feedback_loop_layout</span><br>    VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//在某些渲染场景中，可能存在反馈循环（如图像处理），该标志指示依赖关系与这种反馈循环相关。使用该标志可以确保在处理反馈循环时适当地管理资源的依赖关系</span><br>  <span class="hljs-comment">// Provided by VK_KHR_multiview</span><br>    VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = VK_DEPENDENCY_VIEW_LOCAL_BIT,<br>  <span class="hljs-comment">// Provided by VK_KHR_device_group</span><br>    VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = VK_DEPENDENCY_DEVICE_GROUP_BIT,<br>&#125; VkDependencyFlagBits;<br></code></pre></td></tr></table></figure><p>接下来的六个成员分别对应三种不同的管线屏障。我们需要使用的是图像内存屏障，因此只需填写最后两个成员即可。</p><p>于是当前我们的<i><font color="Green">transitionImageLayout</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transitionImageLayout</span><span class="hljs-params">(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout)</span> </span>&#123;<br>    VkCommandBuffer commandBuffer = <span class="hljs-built_in">beginSingleTimeCommands</span>();<br><br>    VkImageMemoryBarrier barrier&#123;&#125;;<br>    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;<br>    barrier.oldLayout = oldLayout;<br>    barrier.newLayout = newLayout;<br>    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;<br>    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;<br>    barrier.image = image;<br>    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br>    barrier.subresourceRange.baseMipLevel = <span class="hljs-number">0</span>;<br>    barrier.subresourceRange.levelCount = <span class="hljs-number">1</span>;<br>    barrier.subresourceRange.baseArrayLayer = <span class="hljs-number">0</span>;<br>    barrier.subresourceRange.layerCount = <span class="hljs-number">1</span>;<br><br>    VkPipelineStageFlags sourceStage;<br>    VkPipelineStageFlags destinationStage;<br><br>    <span class="hljs-keyword">if</span> (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) &#123;<br>        barrier.srcAccessMask = <span class="hljs-number">0</span>;<br>        barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;<br><br>        sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;<br>        destinationStage = VK_PIPELINE_STAGE_TRANSFER_BIT;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL &amp;&amp; newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) &#123;<br>        barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;<br>        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;<br><br>        sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT;<br>        destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;unsupported layout transition!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">vkCmdPipelineBarrier</span>(<br>        commandBuffer,<br>        sourceStage, destinationStage,<br>        <span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>        <span class="hljs-number">1</span>, &amp;barrier<br>    );<br><br>    <span class="hljs-built_in">endSingleTimeCommands</span>(commandBuffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就完成了图像布局转换有关的工作。</p><hr><h2 id="复制数据到纹理">复制数据到纹理</h2><p>图像完成第一次布局转换后，我们就可以将临时缓冲中的数据复制到图像对象中来了。同样创建一个<i><font color="Green">void copyBufferToImage(VkBuffer buffer, VkImage image, uint32_t width, uint32_t height)</font></i>函数来完成相应的工作。</p><p>如同<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/">临时缓冲区</a>章节中复制缓冲区到缓冲区时需要填写<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferCopy.html"><code>VkBufferCopy</code></a>结构体以指定复制区域，从缓冲区复制到图像同样需要指定复制区域和接收复制数据的图像区域，这是通过结构体<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferImageCopy.html"><code>VkBufferImageCopy</code></a>来指定的，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkBufferImageCopy</span> &#123;</span><br>    VkDeviceSize                bufferOffset;<br>    <span class="hljs-type">uint32_t</span>                    bufferRowLength;<br>    <span class="hljs-type">uint32_t</span>                    bufferImageHeight;<br>    VkImageSubresourceLayers    imageSubresource;<br>    VkOffset3D                  imageOffset;<br>    VkExtent3D                  imageExtent;<br>&#125; VkBufferImageCopy;<br></code></pre></td></tr></table></figure><p>大多数的成员含义是显而易见的，这里需要解释一下的是<i><font color="Orange">bufferRowLength</font></i>和<i><font color="Orange">bufferImageHeight</font></i>，这两个成员如果设置为非0值，则分别代表缓冲区的图像数据行宽度、列高度超过了实际图像每一行、每一列的像素数，这在处理图像填充或多层次图像时会比较有用。如果二者均设置为0，则代表不会有多余的填充，图像像素是紧密排列的。</p><p>于是我们填写该结构体的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkBufferImageCopy region&#123;&#125;;<br>region.bufferOffset = <span class="hljs-number">0</span>;<br>region.bufferRowLength = <span class="hljs-number">0</span>;<br>region.bufferImageHeight = <span class="hljs-number">0</span>;<br><br>region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br>region.imageSubresource.mipLevel = <span class="hljs-number">0</span>;<br>region.imageSubresource.baseArrayLayer = <span class="hljs-number">0</span>;<br>region.imageSubresource.layerCount = <span class="hljs-number">1</span>;<br><br>region.imageOffset = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>region.imageExtent = &#123;<br>    width,<br>    height,<br>    <span class="hljs-number">1</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>接下来就可以使用<a target="_blank" rel="noopener" href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/vkCmdCopyBufferToImage.html"><code>vkCmdCopyBufferToImage</code></a>来录制图像数据的复制命令了，该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdCopyBufferToImage</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    VkBuffer                                    srcBuffer,</span><br><span class="hljs-params">    VkImage                                     dstImage,</span><br><span class="hljs-params">    VkImageLayout                               dstImageLayout,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    regionCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkBufferImageCopy*                    pRegions)</span>;<br></code></pre></td></tr></table></figure><p>这些参数的含义都是显而易见的。需要注意一下的是该函数原型的最后两个参数提示我们实际上可以同时将一个缓冲区的数据复制到图像的多个子区域上，不过这里我们并不需要，只需要复制完整的图像数据即可。</p><p>于是我们的<i><font color="Green">copyBufferToImage</font></i>函数代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">copyBufferToImage</span><span class="hljs-params">(VkBuffer buffer, VkImage image, <span class="hljs-type">uint32_t</span> width, <span class="hljs-type">uint32_t</span> height)</span> &#123;<br>    VkCommandBuffer commandBuffer = beginSingleTimeCommands();<br><br>    VkBufferImageCopy region&#123;&#125;;<br>    region.bufferOffset = <span class="hljs-number">0</span>;<br>    region.bufferRowLength = <span class="hljs-number">0</span>;<br>    region.bufferImageHeight = <span class="hljs-number">0</span>;<br>    region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br>    region.imageSubresource.mipLevel = <span class="hljs-number">0</span>;<br>    region.imageSubresource.baseArrayLayer = <span class="hljs-number">0</span>;<br>    region.imageSubresource.layerCount = <span class="hljs-number">1</span>;<br>    region.imageOffset = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    region.imageExtent = &#123;<br>        width,<br>        height,<br>        <span class="hljs-number">1</span><br>    &#125;;<br><br>    vkCmdCopyBufferToImage(commandBuffer, buffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, <span class="hljs-number">1</span>, &amp;region);<br><br>    endSingleTimeCommands(commandBuffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就准备好了构建着色器所需纹理的所有准备工作，利用这些工具函数我们终于可以完成<i><font color="Green">createTextureImage</font></i>函数了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createTextureImage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> texWidth, texHeight, texChannels;<br>    stbi_uc* pixels = <span class="hljs-built_in">stbi_load</span>(<span class="hljs-string">&quot;textures/texture.jpg&quot;</span>, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);<br>    VkDeviceSize imageSize = texWidth * texHeight * <span class="hljs-number">4</span>;<br><br>    <span class="hljs-keyword">if</span> (!pixels) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to load texture image!&quot;</span>);<br>    &#125;<br><br>    VkBuffer stagingBuffer;<br>    VkDeviceMemory stagingBufferMemory;<br>    <span class="hljs-built_in">createBuffer</span>(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);<br><br>    <span class="hljs-type">void</span>* data;<br>    <span class="hljs-built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="hljs-number">0</span>, imageSize, <span class="hljs-number">0</span>, &amp;data);<br>    <span class="hljs-built_in">memcpy</span>(data, pixels, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(imageSize));<br>    <span class="hljs-built_in">vkUnmapMemory</span>(device, stagingBufferMemory);<br><br>    <span class="hljs-built_in">stbi_image_free</span>(pixels);<br><br>    <span class="hljs-built_in">createImage</span>(texWidth, texHeight, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);<br><br>    <span class="hljs-built_in">transitionImageLayout</span>(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);<br>    <span class="hljs-built_in">copyBufferToImage</span>(stagingBuffer, textureImage, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(texWidth), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(texHeight));<br>    <span class="hljs-built_in">transitionImageLayout</span>(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);<br><br>    <span class="hljs-built_in">vkDestroyBuffer</span>(device, stagingBuffer, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">vkFreeMemory</span>(device, stagingBufferMemory, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>大功告成！</p><hr><p>--<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/12/06/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B1%A0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86/">上一篇：描述符池和描述符集</a></p><p>--<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/">下一篇：图像视图和采样器</a></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/CG-api/" class="category-chain-item">CG_api</a> <span>></span> <a href="/categories/CG-api/vulkan/" class="category-chain-item">vulkan</a> <span>></span> <a href="/categories/CG-api/vulkan/vulkan-tutorial/" class="category-chain-item">vulkan_tutorial</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>图像</div><div>http://example.com/2024/12/12/CG_api/vulkan/vulkan_tutorial/图像/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>ZPC-dsg</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年12月12日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/" title="图像视图和采样器"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">图像视图和采样器</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/12/06/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B1%A0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86/" title="描述符池和描述符集"><span class="hidden-mobile">描述符池和描述符集</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>