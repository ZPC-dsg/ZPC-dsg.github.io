<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/icon/mikuicon.jpg"><link rel="icon" href="/images/icon/mikuicon.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="ZPC-dsg"><meta name="keywords" content=""><meta name="description" content="前言 FSR（Fragment shading rate）是一种控制着色器着色频率的技术。简单地讲，它会控制多少个像素共用一次片段着色器计算的结果。由于人眼一般会聚焦在看向的位置，所以如果能够在看向的位置处执行更多次的像素着色器（也就是增大着色频率），而在人眼视野的边缘处适当降低着色频率（也就是适当指定多个像素上只运行一次片段着色器），那既可以保证得到的效果，又可以节省性能开销。因此FSR常用"><meta property="og:type" content="article"><meta property="og:title" content="Fragment shading rate"><meta property="og:url" content="http://example.com/2025/03/14/CG_api/vulkan/vulkan_samples/fragment_shading_rate/index.html"><meta property="og:site_name" content="ZPC の Blog"><meta property="og:description" content="前言 FSR（Fragment shading rate）是一种控制着色器着色频率的技术。简单地讲，它会控制多少个像素共用一次片段着色器计算的结果。由于人眼一般会聚焦在看向的位置，所以如果能够在看向的位置处执行更多次的像素着色器（也就是增大着色频率），而在人眼视野的边缘处适当降低着色频率（也就是适当指定多个像素上只运行一次片段着色器），那既可以保证得到的效果，又可以节省性能开销。因此FSR常用"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/images/textbg/CG_api/vk_sample_rate.jpg"><meta property="article:published_time" content="2025-03-14T07:25:19.000Z"><meta property="article:modified_time" content="2025-03-15T07:18:44.364Z"><meta property="article:author" content="ZPC-dsg"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/images/textbg/CG_api/vk_sample_rate.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>Fragment shading rate - ZPC の Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:"measurement_id:G-X8N3TZCB57",tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 7.3.0"><script src="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.css"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>ZPC の Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/images/textbg/CG_api/vk_sample_rate.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Fragment shading rate"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> ZPC-dsg </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-03-14 15:25" pubdate>2025年3月14日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 7.2k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 60 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">Fragment shading rate</h1><div class="markdown-body"><h2 id="前言">前言</h2><p><strong>FSR（Fragment shading rate）</strong>是一种控制着色器着色频率的技术。简单地讲，它会控制多少个像素共用一次片段着色器计算的结果。由于人眼一般会聚焦在看向的位置，所以如果能够在看向的位置处执行更多次的像素着色器（也就是增大着色频率），而在人眼视野的边缘处适当降低着色频率（也就是适当指定多个像素上只运行一次片段着色器），那既可以保证得到的效果，又可以节省性能开销。因此FSR常用于VR等技术领域中。</p><p>本文将对Vulkan官方示例集中关于FSR的示例进行解读。和以往不同的是，本示例所构建的渲染流程和之前的准备除了在FSR有关的方面需要介绍，其它都是十分常规的流程，因此不会成段地将那些代码给出并加以分析。仍然希望阅读源码的读者可以自行参考<a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/Vulkan-Samples"><code>官方示例集的代码仓库</code></a>。本文会将注意力集中于FSR相关逻辑的分析，并且在分析之前根据官方文档的说明对Vulkan中的FSR做一个简要的介绍。</p><hr><h2 id="效果">效果</h2><p>还是先放上程序运行的效果：</p><div id="dplayer4" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom:20px"></div><script>!function(){var e=new DPlayer({container:document.getElementById("dplayer4"),loop:"yes",screenshot:"yes",video:{url:"/2025/03/14/CG_api/vulkan/vulkan_samples/fragment_shading_rate/shading_rate.mp4"},danmaku:{api:"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]),window.dplayers.push(e)}()</script><p>可以看到该程序提供了三个选项，其中第一个用于控制是否启用<strong>attachment fragment shading rate</strong>，第二个用于控制是否使用灰度图展示FSR效果，第三个选项用于控制是否显示天空盒。前两个选项开启与否的效果变化会在后文对代码进行分析的时候进行解读。</p><hr><h2 id="vulkan-fsr简介">Vulkan FSR简介</h2><p>本部分将对Vulkan中的FSR的使用流程、逻辑等进行简要的说明。如果读者希望了解更加详细的介绍，可以直接参考<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#VK_KHR_fragment_shading_rate"><code>官方文档</code></a>。</p><p>在Vulkan中，为了获取硬件支持的FSR种类，可以通过<code>vkGetPhysicalDeviceFragmentShadingRatesKHR</code>函数查询结构体<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentShadingRateKHR.html"><code>VkPhysicalDeviceFragmentShadingRateKHR</code></a>来得到支持的FSR数组。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_fragment_shading_rate</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPhysicalDeviceFragmentShadingRateKHR</span> &#123;</span><br>    VkStructureType       sType;<br>    <span class="hljs-type">void</span>*                 pNext;<br>    VkSampleCountFlags    sampleCounts;<span class="hljs-comment">//支持的采样数</span><br>    VkExtent2D            fragmentSize;<span class="hljs-comment">//支持的shading rate大小（以像素为单位）</span><br>&#125; VkPhysicalDeviceFragmentShadingRateKHR;<br></code></pre></td></tr></table></figure><p>所有支持的FSR大小会在该数组中按照从大到小排列，具体而言，排列顺序是FSR对应的fragment size指定的宽越大越靠前，宽相同时，高越大越靠前。另外，每种FRS的fragment size还对应有各自支持的采样数目。在支持FRS的硬件上一定会保证支持下图中的fragment size以及对应的多重采样采样数：</p><figure><img src="/2025/03/14/CG_api/vulkan/vulkan_samples/fragment_shading_rate/support.png" srcset="/img/loading.gif" lazyload alt="一定支持的FRS"><figcaption aria-hidden="true">一定支持的FRS</figcaption></figure><p>不过要注意表里的{1,1}代表的fragment size实际上并不具有FSR效果，放在表中只是为了完整性起见，{1,1}支持一切硬件支持的采样数。</p><p>Vulkan提供了三种指定FSR的方式，这三种方式最后的结果经过指定的运算组合成最后使用的FSR。</p><h3 id="方式一pipeline-fragment-shading-rate">方式一：Pipeline Fragment Shading Rate</h3><p>顾名思义，该方式就是在管线构建中指定FSR。有两种方式可以指定，一是通过将<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineFragmentShadingRateStateCreateInfoKHR.html"><code>VkPipelineFragmentShadingRateStateCreateInfoKHR</code></a>结构体传入<code>VkGraphicsPipelineCreateInfo</code>结构体的<i><font color="Orange">pNext</font></i>成员，二是将FSR构建为动态阶段并在录制渲染命令的时候使用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetFragmentShadingRateKHR.html"><code>vkCmdSetFragmentShadingRateKHR</code></a>动态设置FSR。先看第一种方法中的<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineFragmentShadingRateStateCreateInfoKHR.html"><code>VkPipelineFragmentShadingRateStateCreateInfoKHR</code></a>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_fragment_shading_rate</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineFragmentShadingRateStateCreateInfoKHR</span> &#123;</span><br>    VkStructureType                       sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                           pNext;<br>    VkExtent2D                            fragmentSize;<span class="hljs-comment">//指定该管线的draw命令使用的FSR</span><br>    VkFragmentShadingRateCombinerOpKHR    combinerOps[<span class="hljs-number">2</span>];<span class="hljs-comment">//组合模式</span><br>&#125; VkPipelineFragmentShadingRateStateCreateInfoKHR;<br></code></pre></td></tr></table></figure><p>最后的组合模式成员会在介绍完三种指定FSR的方式之后再来介绍。</p><p>动态设置FSR函数<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetFragmentShadingRateKHR.html"><code>vkCmdSetFragmentShadingRateKHR</code></a>原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_fragment_shading_rate</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdSetFragmentShadingRateKHR</span><span class="hljs-params">(</span><br><span class="hljs-params">  VkCommandBuffer commandBuffer,</span><br><span class="hljs-params">  <span class="hljs-type">const</span> VkExtent2D* pFragmentSize,</span><br><span class="hljs-params">  <span class="hljs-type">const</span> VkFragmentShadingRateCombinerOpKHR combinerOps[<span class="hljs-number">2</span>])</span>;<br></code></pre></td></tr></table></figure><p>指定的参数是基本一致的。当当前管线的绘制命令使用shader object或者在创建管线的动态阶段指定了<i><font color="Red">VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR</font></i>时，就可以使用该函数录制动态设置FSR的命令。</p><h3 id="方式二primitive-fragment-shading-rate">方式二：Primitive Fragment Shading Rate</h3><p>该FSR可以在最后一个使用了着色器的光栅化前着色器阶段的着色器中通过内置<strong>PrimitiveShadingRateKHR</strong>拓展来设置。如果该着色器阶段使用的是Mesh shader，那么每个图元都可以单独设置自己的<strong>PrimitiveShadingRateKHR</strong>，否则每个图元的<strong>PrimitiveShadingRateKHR</strong>是由每个图元的<strong>触发顶点（Provoking Vertex）</strong>来指定的（所谓<strong>触发顶点</strong>，指的是整个图元的属性由该顶点一个点决定而非在光栅化阶段插值得到，想要使用触发顶点，需要启用<i><font color="Red">VK_EXT_provoking_vertex</font></i>拓展，并且在光栅化阶段的信息结构体的pNext指针中传入<code>VkPipelineRasterizationProvokingVertexStateCreateInfoEXT</code>结构体指定触发顶点位置）。</p><h3 id="方式三attachment-fragment-shading-rate">方式三：Attachment Fragment Shading Rate</h3><p>这种方式的FSR需要在渲染子通道的信息结构体的pNext指针中指定<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkFragmentShadingRateAttachmentInfoKHR.html"><code>VkFragmentShadingRateAttachmentInfoKHR</code></a>结构体。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_fragment_shading_rate</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkFragmentShadingRateAttachmentInfoKHR</span> &#123;</span><br>    VkStructureType                  sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                      pNext;<br>    <span class="hljs-type">const</span> VkAttachmentReference2*    pFragmentShadingRateAttachment;<br>    VkExtent2D                       shadingRateAttachmentTexelSize;<br>&#125; VkFragmentShadingRateAttachmentInfoKHR;<br></code></pre></td></tr></table></figure><p>可以看到该结构体需要指定一个FSR附件以及该FSR附件中纹素的大小（FSR附件的大小和其它附件的大小可能不相同），每个纹素中都需要存储一个FSR值。帧缓冲中颜色附件上坐标为（x，y）的点对应在FSR附件上的坐标为（floor(x/shadingRateAttachmentTexelSize.width)，floor(y/shadingRateAttachmentTexelSize.height)）。</p><p>FSR附件的每个纹素中存储的实际上是一个编码后的FSR值，子通道在读取它的时候会将其自动解码，解码规则如下：假设纹素中存储的值为<strong>value</strong>，那么它所代表的FSR的宽度值为<strong>2<sup>((value)/4)&amp;3)<strong>，高度值为</strong>2</sup>(value&amp;3)</strong>。举个栗子：比如说某个纹素中存储的值为<strong>0x12</strong>，那么它对应的二进制数为<strong>10010</strong>，那么<strong>(value)/4&amp;3</strong>为0，因此宽度值解码后为1，而<strong>value&amp;3</strong>为2，那么对应的高度解码后就是4。</p><h3 id="如何组合这三种指定方式">如何组合这三种指定方式</h3><p>还记得<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineFragmentShadingRateStateCreateInfoKHR.html"><code>VkPipelineFragmentShadingRateStateCreateInfoKHR</code></a>中的<i><font color="Orange">combinerOps</font></i>成员吗？现在就可以来解释它的含义了。该二元数组的第一个元素代表方式一指定的FSR和方式二指定的FSR进行组合所使用的运算，第二个元素则代表方式一和方式二的FSR组合后的结果和方式三指定的FSR进行组合使用的运算。可以采用的运算符有以下几种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_fragment_shading_rate</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkFragmentShadingRateCombinerOpKHR</span> &#123;</span><br>  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR = <span class="hljs-number">0</span>,<span class="hljs-comment">//A op B = A</span><br>  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR = <span class="hljs-number">1</span>,<span class="hljs-comment">//A op B = B</span><br>  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR = <span class="hljs-number">2</span>,<span class="hljs-comment">//A op B = min(A, B)</span><br>  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR = <span class="hljs-number">3</span>,<span class="hljs-comment">//A op B = max(A, B)</span><br>  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR = <span class="hljs-number">4</span>,<span class="hljs-comment">//A op B = A * B</span><br>&#125; VkFragmentShadingRateCombinerOpKHR;<br></code></pre></td></tr></table></figure><p>这些运算都是逐位进行的。</p><p>因此三种指定方式的组合过程可以表示为<strong>(方式一 op1 方式二) op2 方式三</strong>，最终的组合结果fragment size在片段着色器中可以通过内置<strong>ShadingRateKHR</strong>来获取。</p><p>另外，硬件会保证组合的输入以及结果一定是<code>vkGetPhysicalDeviceFragmentShadingRatesKHR</code>函数获取的硬件支持的FSR中的一员。如果组合过程中出现了非硬件支持的大小的话，那硬件会根据一定的规则将其钳制。具体而言可以参考下图官方文档中的规范：</p><figure><img src="/2025/03/14/CG_api/vulkan/vulkan_samples/fragment_shading_rate/clamp.png" srcset="/img/loading.gif" lazyload alt="钳制规范"><figcaption aria-hidden="true">钳制规范</figcaption></figure><p>其中(Rx,Ry)是钳制前的FSR，(Rx',Ry')是钳制后的FSR。</p><p>好的，现在我们对Vulkan中的FSR已经有了一个大致的概要性的了解，接下来就来分析官方示例是如何实现这个效果的吧~</p><hr><h2 id="特性拓展支持">特性拓展支持</h2><p>首先来看为了在Vulkan中使用FSR需要启用哪些拓展：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">FragmentShadingRate::<span class="hljs-built_in">FragmentShadingRate</span>()<br>&#123;<br>	title = <span class="hljs-string">&quot;Fragment shading rate&quot;</span>;<br>	<span class="hljs-comment">// Enable instance and device extensions required to use VK_KHR_fragment_shading_rate</span><br>	<span class="hljs-built_in">add_instance_extension</span>(VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);<br>	<span class="hljs-built_in">add_device_extension</span>(VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME);<br>	<span class="hljs-built_in">add_device_extension</span>(VK_KHR_MULTIVIEW_EXTENSION_NAME);<br>	<span class="hljs-built_in">add_device_extension</span>(VK_KHR_MAINTENANCE2_EXTENSION_NAME);<br>	<span class="hljs-built_in">add_device_extension</span>(VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME);<br>&#125;<br></code></pre></td></tr></table></figure><p><i><font color="Red">VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME</font></i>拓展可以支持<code>VkPhysicalDeviceFeatures2</code>和<code>VkPhysicalDeviceProperties2</code>结构体的查询以获取更为丰富的硬件信息。<i><font color="Red">VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME</font></i>可以允许在创建render pass时指定更多的附件，比如本示例中需要的FSR附件。接下来的<i><font color="Red">VK_KHR_MULTIVIEW_EXTENSION_NAME</font></i>和多视口有关，示例中其实并未用到。<i><font color="Red">VK_KHR_MAINTENANCE2_EXTENSION_NAME</font></i>为Vulkan提供了一些额外的维护和资源管理功能。最后的<i><font color="Red">VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME</font></i>就是使用FSR的核心拓展了，开启了它才能在Vulkan中使用FSR。</p><p>接下来看看程序都查询了哪些设备特性支持：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FragmentShadingRate::request_gpu_features</span><span class="hljs-params">(vkb::PhysicalDevice &amp;gpu)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// Enable the shading rate attachment feature required by this sample</span><br>	<span class="hljs-comment">// These are passed to device creation via a pNext structure chain</span><br>	<span class="hljs-built_in">REQUEST_REQUIRED_FEATURE</span>(gpu,<br>	                         VkPhysicalDeviceFragmentShadingRateFeaturesKHR,<br>	                         VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR,<br>	                         attachmentFragmentShadingRate);<br><br>	<span class="hljs-comment">// Enable anisotropic filtering if supported</span><br>	<span class="hljs-keyword">if</span> (gpu.<span class="hljs-built_in">get_features</span>().samplerAnisotropy)<br>	&#123;<br>		gpu.<span class="hljs-built_in">get_mutable_requested_features</span>().samplerAnisotropy = VK_TRUE;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到本示例是查询了硬件是否支持<strong>Attachment shading rate</strong>，也就是简介部分提到的指定FSR的方式三，如果支持的话就可以创建FSR附件了。然后示例还是一如既往地开启了各向异性支持。（虽说也是一如既往地没有使用，只能说你可以不用，但不能没有。。。）</p><hr><h2 id="setup_render_pass">setup_render_pass</h2><p>与以往分析的示例不同的是，以往示例都是直接使用应用程序类的统一基类<code>ApiVulkanSample</code>在准备阶段创建好的默认渲染到后台缓冲的render pass来进行最后的屏幕渲染的，但是本示例不能继续这么做了，因为程序需要为该render pass额外添加一个FSR附件。所以在应用程序类中覆写了基类中的<i><font color="Green">setup_render_pass</font></i>方法。但事实上一开始我有点迷惑的是，<i><font color="Green">setup_render_pass</font></i>方法<i><font color="Green">setup_render_pass</font></i>方法是在基类的<i><font color="Green">prepare</font></i>函数中被调用的，基类的<i><font color="Green">prepare</font></i>函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ApiVulkanSample::prepare</span><span class="hljs-params">(<span class="hljs-type">const</span> vkb::ApplicationOptions &amp;options)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (!VulkanSample::<span class="hljs-built_in">prepare</span>(options))<br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	depth_format = vkb::<span class="hljs-built_in">get_suitable_depth_format</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_handle</span>());<br><br>	<span class="hljs-comment">// Create synchronization objects</span><br>	VkSemaphoreCreateInfo semaphore_create_info = vkb::initializers::<span class="hljs-built_in">semaphore_create_info</span>();<br>	<span class="hljs-comment">// Create a semaphore used to synchronize image presentation</span><br>	<span class="hljs-comment">// Ensures that the current swapchain render target has completed presentation and has been released by the presentation engine, ready for rendering</span><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateSemaphore</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;semaphore_create_info, <span class="hljs-literal">nullptr</span>, &amp;semaphores.acquired_image_ready));<br>	<span class="hljs-comment">// Create a semaphore used to synchronize command submission</span><br>	<span class="hljs-comment">// Ensures that the image is not presented until all commands have been sumbitted and executed</span><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateSemaphore</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;semaphore_create_info, <span class="hljs-literal">nullptr</span>, &amp;semaphores.render_complete));<br><br>	<span class="hljs-comment">// Set up submit info structure</span><br>	<span class="hljs-comment">// Semaphores will stay the same during application lifetime</span><br>	<span class="hljs-comment">// Command buffer submission info is set by each example</span><br>	submit_info                   = vkb::initializers::<span class="hljs-built_in">submit_info</span>();<br>	submit_info.pWaitDstStageMask = &amp;submit_pipeline_stages;<br><br>	<span class="hljs-keyword">if</span> (window-&gt;<span class="hljs-built_in">get_window_mode</span>() != vkb::Window::Mode::Headless)<br>	&#123;<br>		submit_info.waitSemaphoreCount   = <span class="hljs-number">1</span>;<br>		submit_info.pWaitSemaphores      = &amp;semaphores.acquired_image_ready;<br>		submit_info.signalSemaphoreCount = <span class="hljs-number">1</span>;<br>		submit_info.pSignalSemaphores    = &amp;semaphores.render_complete;<br>	&#125;<br><br>	queue = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_suitable_graphics_queue</span>().<span class="hljs-built_in">get_handle</span>();<br><br>	<span class="hljs-built_in">create_swapchain_buffers</span>();<br>	<span class="hljs-built_in">create_command_pool</span>();<br>	<span class="hljs-built_in">create_command_buffers</span>();<br>	<span class="hljs-built_in">create_synchronization_primitives</span>();<br>	<span class="hljs-built_in">setup_depth_stencil</span>();<br>	<span class="hljs-built_in">setup_render_pass</span>();<br>	<span class="hljs-built_in">create_pipeline_cache</span>();<br>	<span class="hljs-built_in">setup_framebuffer</span>();<br><br>	width  = <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_surface_extent</span>().width;<br>	height = <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_surface_extent</span>().height;<br><br>	<span class="hljs-built_in">prepare_gui</span>();<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而基类的<i><font color="Green">prepare</font></i>函数又会在应用程序类的<i><font color="Green">prepare</font></i>函数的开头被调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FragmentShadingRate::prepare</span><span class="hljs-params">(<span class="hljs-type">const</span> vkb::ApplicationOptions &amp;options)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (!ApiVulkanSample::<span class="hljs-built_in">prepare</span>(options))<br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	camera.type = vkb::CameraType::FirstPerson;<br>	camera.<span class="hljs-built_in">set_position</span>(glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-4.0f</span>));<br><br>	<span class="hljs-comment">// Note: Using reversed depth-buffer for increased precision, so Znear and Zfar are flipped</span><br>	camera.<span class="hljs-built_in">set_perspective</span>(<span class="hljs-number">60.0f</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(width) / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(height), <span class="hljs-number">256.0f</span>, <span class="hljs-number">0.1f</span>);<br><br>	<span class="hljs-built_in">load_assets</span>();<br>	<span class="hljs-built_in">prepare_uniform_buffers</span>();<br>	<span class="hljs-built_in">setup_descriptor_set_layout</span>();<br>	<span class="hljs-built_in">prepare_pipelines</span>();<br>	<span class="hljs-built_in">setup_descriptor_pool</span>();<br>	<span class="hljs-built_in">setup_descriptor_sets</span>();<br>	<span class="hljs-built_in">build_command_buffers</span>();<br>	prepared = <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么问题就是在子类开头强制调用基类中的<i><font color="Green">prepare</font></i>函数，此时调用的基类<i><font color="Green">prepare</font></i>函数会调用子类中覆写过的<i><font color="Green">setup_render_pass</font></i>方法吗？结论是肯定的，实际上只要没有如同子类调用基类<i><font color="Green">prepare</font></i>函数那样明确指定，在子类中调用的虚函数一定优先考虑被子类覆写的那个。（其实也就是将子类的this指针传递给了一个基类指针并对该基类指针调用虚函数，那这其实就是简单的多态，当时真的犯蠢了一时半会没想明白。。。）</p><p>接下来就来看看具有FSR的render pass是如何创建的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This sample uses a custom render pass setup, as the shading rate image needs to be passed to the sample&#x27;s render / sub pass</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FragmentShadingRate::setup_render_pass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// Query the fragment shading rate properties of the current implementation, we will need them later on</span><br>	physical_device_fragment_shading_rate_properties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR;<br>	VkPhysicalDeviceProperties2KHR device_properties&#123;&#125;;<br>	device_properties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;<br>	device_properties.pNext = &amp;physical_device_fragment_shading_rate_properties;<br>	<span class="hljs-built_in">vkGetPhysicalDeviceProperties2KHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_handle</span>(), &amp;device_properties);<br><br>	std::array&lt;VkAttachmentDescription2KHR, 3&gt; attachments = &#123;&#125;;<br>	<span class="hljs-comment">// Color attachment</span><br>	attachments[<span class="hljs-number">0</span>].sType          = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2;<br>	attachments[<span class="hljs-number">0</span>].format         = <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_format</span>();<br>	attachments[<span class="hljs-number">0</span>].samples        = VK_SAMPLE_COUNT_1_BIT;<br>	attachments[<span class="hljs-number">0</span>].loadOp         = VK_ATTACHMENT_LOAD_OP_CLEAR;<br>	attachments[<span class="hljs-number">0</span>].storeOp        = VK_ATTACHMENT_STORE_OP_STORE;<br>	attachments[<span class="hljs-number">0</span>].stencilLoadOp  = VK_ATTACHMENT_LOAD_OP_DONT_CARE;<br>	attachments[<span class="hljs-number">0</span>].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>	attachments[<span class="hljs-number">0</span>].initialLayout  = VK_IMAGE_LAYOUT_UNDEFINED;<br>	attachments[<span class="hljs-number">0</span>].finalLayout    = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;<br>	<span class="hljs-comment">// Depth attachment</span><br>	attachments[<span class="hljs-number">1</span>].sType          = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2;<br>	attachments[<span class="hljs-number">1</span>].format         = depth_format;<br>	attachments[<span class="hljs-number">1</span>].samples        = VK_SAMPLE_COUNT_1_BIT;<br>	attachments[<span class="hljs-number">1</span>].loadOp         = VK_ATTACHMENT_LOAD_OP_CLEAR;<br>	attachments[<span class="hljs-number">1</span>].storeOp        = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>	attachments[<span class="hljs-number">1</span>].stencilLoadOp  = VK_ATTACHMENT_LOAD_OP_CLEAR;<br>	attachments[<span class="hljs-number">1</span>].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>	attachments[<span class="hljs-number">1</span>].initialLayout  = VK_IMAGE_LAYOUT_UNDEFINED;<br>	attachments[<span class="hljs-number">1</span>].finalLayout    = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;<br>	<span class="hljs-comment">// Fragment shading rate attachment</span><br>	attachments[<span class="hljs-number">2</span>].sType          = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2;<br>	attachments[<span class="hljs-number">2</span>].format         = VK_FORMAT_R8_UINT;<br>	attachments[<span class="hljs-number">2</span>].samples        = VK_SAMPLE_COUNT_1_BIT;<br>	attachments[<span class="hljs-number">2</span>].loadOp         = VK_ATTACHMENT_LOAD_OP_LOAD;<br>	attachments[<span class="hljs-number">2</span>].storeOp        = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>	attachments[<span class="hljs-number">2</span>].stencilLoadOp  = VK_ATTACHMENT_LOAD_OP_CLEAR;<br>	attachments[<span class="hljs-number">2</span>].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>	attachments[<span class="hljs-number">2</span>].initialLayout  = VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR;<br>	attachments[<span class="hljs-number">2</span>].finalLayout    = VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR;<br><br>	VkAttachmentReference2KHR color_reference = &#123;&#125;;<br>	color_reference.sType                     = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2;<br>	color_reference.attachment                = <span class="hljs-number">0</span>;<br>	color_reference.layout                    = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;<br>	color_reference.aspectMask                = VK_IMAGE_ASPECT_COLOR_BIT;<br><br>	VkAttachmentReference2KHR depth_reference = &#123;&#125;;<br>	depth_reference.sType                     = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2;<br>	depth_reference.attachment                = <span class="hljs-number">1</span>;<br>	depth_reference.layout                    = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;<br>	depth_reference.aspectMask                = VK_IMAGE_ASPECT_DEPTH_BIT;<br><br>	<span class="hljs-comment">// Setup the attachment reference for the shading rate image attachment in slot 2</span><br>	VkAttachmentReference2 fragment_shading_rate_reference = &#123;&#125;;<br>	fragment_shading_rate_reference.sType                  = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2;<br>	fragment_shading_rate_reference.attachment             = <span class="hljs-number">2</span>;<br>	fragment_shading_rate_reference.layout                 = VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR;<br><br>	<span class="hljs-comment">// Setup the attachment info for the shading rate image, which will be added to the sub pass via structure chaining (in pNext)</span><br>	VkFragmentShadingRateAttachmentInfoKHR fragment_shading_rate_attachment_info = &#123;&#125;;<br>	fragment_shading_rate_attachment_info.sType                                  = VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR;<br>	fragment_shading_rate_attachment_info.pFragmentShadingRateAttachment         = &amp;fragment_shading_rate_reference;<br>	fragment_shading_rate_attachment_info.shadingRateAttachmentTexelSize.width   = physical_device_fragment_shading_rate_properties.maxFragmentShadingRateAttachmentTexelSize.width;<br>	fragment_shading_rate_attachment_info.shadingRateAttachmentTexelSize.height  = physical_device_fragment_shading_rate_properties.maxFragmentShadingRateAttachmentTexelSize.height;<br><br>	VkSubpassDescription2KHR subpass_description = &#123;&#125;;<br>	subpass_description.sType                    = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2;<br>	subpass_description.pipelineBindPoint        = VK_PIPELINE_BIND_POINT_GRAPHICS;<br>	subpass_description.colorAttachmentCount     = <span class="hljs-number">1</span>;<br>	subpass_description.pColorAttachments        = &amp;color_reference;<br>	subpass_description.pDepthStencilAttachment  = &amp;depth_reference;<br>	subpass_description.inputAttachmentCount     = <span class="hljs-number">0</span>;<br>	subpass_description.pInputAttachments        = <span class="hljs-literal">nullptr</span>;<br>	subpass_description.preserveAttachmentCount  = <span class="hljs-number">0</span>;<br>	subpass_description.pPreserveAttachments     = <span class="hljs-literal">nullptr</span>;<br>	subpass_description.pResolveAttachments      = <span class="hljs-literal">nullptr</span>;<br>	subpass_description.pNext                    = &amp;fragment_shading_rate_attachment_info;<br><br>	<span class="hljs-comment">// Subpass dependencies for layout transitions</span><br>	std::array&lt;VkSubpassDependency2KHR, 2&gt; dependencies = &#123;&#125;;<br><br>	dependencies[<span class="hljs-number">0</span>].sType           = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2;<br>	dependencies[<span class="hljs-number">0</span>].srcSubpass      = VK_SUBPASS_EXTERNAL;<br>	dependencies[<span class="hljs-number">0</span>].dstSubpass      = <span class="hljs-number">0</span>;<br>	dependencies[<span class="hljs-number">0</span>].srcStageMask    = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;<br>	dependencies[<span class="hljs-number">0</span>].dstStageMask    = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT;<br>	dependencies[<span class="hljs-number">0</span>].srcAccessMask   = VK_ACCESS_MEMORY_READ_BIT;<br>	dependencies[<span class="hljs-number">0</span>].dstAccessMask   = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;<br>	dependencies[<span class="hljs-number">0</span>].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;<br><br>	dependencies[<span class="hljs-number">1</span>].sType           = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2;<br>	dependencies[<span class="hljs-number">1</span>].srcSubpass      = <span class="hljs-number">0</span>;<br>	dependencies[<span class="hljs-number">1</span>].dstSubpass      = VK_SUBPASS_EXTERNAL;<br>	dependencies[<span class="hljs-number">1</span>].srcStageMask    = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT;<br>	dependencies[<span class="hljs-number">1</span>].dstStageMask    = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;<br>	dependencies[<span class="hljs-number">1</span>].srcAccessMask   = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;<br>	dependencies[<span class="hljs-number">1</span>].dstAccessMask   = VK_ACCESS_MEMORY_READ_BIT;<br>	dependencies[<span class="hljs-number">1</span>].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;<br><br>	VkRenderPassCreateInfo2KHR render_pass_create_info = &#123;&#125;;<br>	render_pass_create_info.sType                      = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2;<br>	render_pass_create_info.attachmentCount            = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attachments.<span class="hljs-built_in">size</span>());<br>	render_pass_create_info.pAttachments               = attachments.<span class="hljs-built_in">data</span>();<br>	render_pass_create_info.subpassCount               = <span class="hljs-number">1</span>;<br>	render_pass_create_info.pSubpasses                 = &amp;subpass_description;<br>	render_pass_create_info.dependencyCount            = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(dependencies.<span class="hljs-built_in">size</span>());<br>	render_pass_create_info.pDependencies              = dependencies.<span class="hljs-built_in">data</span>();<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateRenderPass2KHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;render_pass_create_info, <span class="hljs-literal">nullptr</span>, &amp;render_pass));<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我将只梳理FSR相关的逻辑，其它附件的创建都是常规操作，读者可自行阅读源码。</p><p>首先程序通过<code>vkGetPhysicalDeviceProperties2KHR</code>查询<code>VkPhysicalDeviceProperties2KHR</code>结构体以获取对FSR的fragment size等的支持类型，将查询结果存储在<i><font color="Orange">physical_device_fragment_shading_rate_properties</font></i>成员中。然后为了在创建subpass时指定FSR附件，首先需要填写附件相关的信息结构体<code>VkAttachmentDescription2KHR</code>（也就是<code>VkAttachmentDescription</code>的相应拓展结构体，后续使用的信息结构体都是拓展结构体，这样才能保证对FSR附件的支持），由于FSR附件中只需要存储一个数值，因此格式设置为<i><font color="Red">VK_FORMAT_R8_UINT</font></i>就好了。本示例不使用多重采样，因此采样数仍设为1。然后FSR附件的加载操作设为<i><font color="Red">VK_ATTACHMENT_LOAD_OP_LOAD</font></i>，而存储操作设置为<i><font color="Red">VK_ATTACHMENT_STORE_OP_DONT_CARE</font></i>，因为该附件中的值是不会被写入的，只会被读取。最后将附件的初始和最终布局均设置为<i><font color="Red">VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR</font></i>即可，该附件的内容用途都不需要改变，自然也就无需改变布局。</p><p>然后为了在子通道中指定该附件，需要填写附件引用信息<code>VkAttachmentReference2</code>，FSR附件引用信息的布局同样指定为<i><font color="Red">VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR</font></i>就可以了。</p><p>然后就是在子通道描述中指定该附件了。但是和一般的附件指定方式不同，FSR附件的指定需要将附件引用等信息填写至<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkFragmentShadingRateAttachmentInfoKHR.html"><code>VkFragmentShadingRateAttachmentInfoKHR</code></a>然后将这个结构体传递给<code>VkSubpassDescription2KHR</code>的<i><font color="Orange">pNext</font></i>成员。</p><p>在设置好子通道信息结构体后，依赖关系仍然是常规的依赖，后续按流程在render pass中指定好subpass并创建render pass就可以了。</p><hr><h2 id="setup_framebuffer">setup_framebuffer</h2><p>不单单是render pass，原本默认的帧缓冲也需要重新创建以包含新的FSR附件。该函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This sample uses a custom frame buffer setup, that includes the fragment shading rate image attachment</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FragmentShadingRate::setup_framebuffer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// Create ths shading rate image attachment if not defined (first run and resize)</span><br>	<span class="hljs-keyword">if</span> (shading_rate_image.image == VK_NULL_HANDLE)<br>	&#123;<br>		<span class="hljs-built_in">create_shading_rate_attachment</span>();<br>	&#125;<br><br>	VkImageView attachments[<span class="hljs-number">3</span>];<br>	<span class="hljs-comment">// Depth/Stencil attachment is the same for all frame buffers</span><br>	attachments[<span class="hljs-number">1</span>] = depth_stencil.view;<br>	<span class="hljs-comment">// Fragment shading rate attachment</span><br>	attachments[<span class="hljs-number">2</span>] = shading_rate_image.view;<br><br>	VkFramebufferCreateInfo framebuffer_create_info = &#123;&#125;;<br>	framebuffer_create_info.sType                   = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;<br>	framebuffer_create_info.renderPass              = render_pass;<br>	framebuffer_create_info.attachmentCount         = <span class="hljs-number">3</span>;<br>	framebuffer_create_info.pAttachments            = attachments;<br>	framebuffer_create_info.width                   = <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_surface_extent</span>().width;<br>	framebuffer_create_info.height                  = <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_surface_extent</span>().height;<br>	framebuffer_create_info.layers                  = <span class="hljs-number">1</span>;<br><br>	<span class="hljs-comment">// Delete existing frame buffers</span><br>	<span class="hljs-keyword">if</span> (!framebuffers.<span class="hljs-built_in">empty</span>())<br>	&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;framebuffer : framebuffers)<br>		&#123;<br>			<span class="hljs-keyword">if</span> (framebuffer != VK_NULL_HANDLE)<br>			&#123;<br>				<span class="hljs-built_in">vkDestroyFramebuffer</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), framebuffer, <span class="hljs-literal">nullptr</span>);<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// Create frame buffers for every swap chain image</span><br>	framebuffers.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_render_frames</span>().<span class="hljs-built_in">size</span>());<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; framebuffers.<span class="hljs-built_in">size</span>(); i++)<br>	&#123;<br>		attachments[<span class="hljs-number">0</span>] = swapchain_buffers[i].view;<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateFramebuffer</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;framebuffer_create_info, <span class="hljs-literal">nullptr</span>, &amp;framebuffers[i]));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样我们将只关注FSR附件部分的代码。</p><p>首先函数调用<i><font color="Green">create_shading_rate_attachment</font></i>函数创建真正的FSR纹理及视图资源。该函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Create an image that contains the values used to determine the shading rates to apply during scene rendering</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FragmentShadingRate::create_shading_rate_attachment</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// Check if the requested format for the shading rate attachment supports the required flag</span><br>	VkFormat           requested_format = VK_FORMAT_R8_UINT;<br>	VkFormatProperties format_properties;<br>	<span class="hljs-built_in">vkGetPhysicalDeviceFormatProperties</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_handle</span>(), requested_format, &amp;format_properties);<br>	<span class="hljs-keyword">if</span> (!(format_properties.optimalTilingFeatures &amp; VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR))<br>	&#123;<br>		<span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Selected shading rate attachment image format does not support required formate featureflag&quot;</span>);<br>	&#125;<br><br>	<span class="hljs-comment">// Shading rate image size depends on shading rate texel size</span><br>	<span class="hljs-comment">// For each texel in the target image, there is a corresponding shading texel size width x height block in the shading rate image</span><br>	VkExtent3D image_extent&#123;&#125;;<br>	image_extent.width  = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(<span class="hljs-built_in">ceil</span>(width / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(physical_device_fragment_shading_rate_properties.maxFragmentShadingRateAttachmentTexelSize.width)));<br>	image_extent.height = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(<span class="hljs-built_in">ceil</span>(height / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(physical_device_fragment_shading_rate_properties.maxFragmentShadingRateAttachmentTexelSize.height)));<br>	image_extent.depth  = <span class="hljs-number">1</span>;<br><br>	VkImageCreateInfo image_create_info&#123;&#125;;<br>	image_create_info.sType         = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;<br>	image_create_info.imageType     = VK_IMAGE_TYPE_2D;<br>	image_create_info.format        = VK_FORMAT_R8_UINT;<br>	image_create_info.extent        = image_extent;<br>	image_create_info.mipLevels     = <span class="hljs-number">1</span>;<br>	image_create_info.arrayLayers   = <span class="hljs-number">1</span>;<br>	image_create_info.samples       = VK_SAMPLE_COUNT_1_BIT;<br>	image_create_info.tiling        = VK_IMAGE_TILING_OPTIMAL;<br>	image_create_info.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;<br>	image_create_info.sharingMode   = VK_SHARING_MODE_EXCLUSIVE;<br>	image_create_info.usage         = VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR | VK_IMAGE_USAGE_TRANSFER_DST_BIT;<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateImage</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;image_create_info, <span class="hljs-literal">nullptr</span>, &amp;shading_rate_image.image));<br>	VkMemoryRequirements memory_requirements&#123;&#125;;<br>	<span class="hljs-built_in">vkGetImageMemoryRequirements</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), shading_rate_image.image, &amp;memory_requirements);<br><br>	VkMemoryAllocateInfo memory_allocate_info&#123;&#125;;<br>	memory_allocate_info.sType           = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;<br>	memory_allocate_info.allocationSize  = memory_requirements.size;<br>	memory_allocate_info.memoryTypeIndex = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_memory_type</span>(memory_requirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateMemory</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;memory_allocate_info, <span class="hljs-literal">nullptr</span>, &amp;shading_rate_image.memory));<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBindImageMemory</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), shading_rate_image.image, shading_rate_image.memory, <span class="hljs-number">0</span>));<br><br>	VkImageViewCreateInfo image_view_create_info&#123;&#125;;<br>	image_view_create_info.sType                           = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;<br>	image_view_create_info.viewType                        = VK_IMAGE_VIEW_TYPE_2D;<br>	image_view_create_info.image                           = shading_rate_image.image;<br>	image_view_create_info.format                          = VK_FORMAT_R8_UINT;<br>	image_view_create_info.subresourceRange.baseMipLevel   = <span class="hljs-number">0</span>;<br>	image_view_create_info.subresourceRange.levelCount     = <span class="hljs-number">1</span>;<br>	image_view_create_info.subresourceRange.baseArrayLayer = <span class="hljs-number">0</span>;<br>	image_view_create_info.subresourceRange.layerCount     = <span class="hljs-number">1</span>;<br>	image_view_create_info.subresourceRange.aspectMask     = VK_IMAGE_ASPECT_COLOR_BIT;<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateImageView</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;image_view_create_info, <span class="hljs-literal">nullptr</span>, &amp;shading_rate_image.view));<br><br>	<span class="hljs-comment">// Allocate a buffer that stores the shading rates</span><br>	VkDeviceSize buffer_size = image_extent.width * image_extent.height * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint8_t</span>);<br><br>	<span class="hljs-comment">// Fragment sizes are encoded in a single texel as follows:</span><br>	<span class="hljs-comment">// size(w) = 2^((texel/4) &amp; 3)</span><br>	<span class="hljs-comment">// size(h)h = 2^(texel &amp; 3)</span><br><br>	<span class="hljs-comment">// Populate the buffer with lowest possible shading rate pattern (4x4)</span><br>	<span class="hljs-type">uint8_t</span>  val                       = (<span class="hljs-number">4</span> &gt;&gt; <span class="hljs-number">1</span>) | (<span class="hljs-number">4</span> &lt;&lt; <span class="hljs-number">1</span>);<br>	<span class="hljs-type">uint8_t</span> *shading_rate_pattern_data = <span class="hljs-keyword">new</span> <span class="hljs-type">uint8_t</span>[buffer_size];<br>	<span class="hljs-built_in">memset</span>(shading_rate_pattern_data, val, buffer_size);<br><br>	<span class="hljs-comment">// Create a circular pattern from the available list of fragment shading rates with decreasing sampling rates outwards (max. range, pattern)</span><br>	std::vector&lt;VkPhysicalDeviceFragmentShadingRateKHR&gt; fragment_shading_rates&#123;&#125;;<br>	<span class="hljs-type">uint32_t</span>                                            fragment_shading_rate_count = <span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">vkGetPhysicalDeviceFragmentShadingRatesKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_handle</span>(), &amp;fragment_shading_rate_count, <span class="hljs-literal">nullptr</span>);<br>	<span class="hljs-keyword">if</span> (fragment_shading_rate_count &gt; <span class="hljs-number">0</span>)<br>	&#123;<br>		fragment_shading_rates.<span class="hljs-built_in">resize</span>(fragment_shading_rate_count);<br>		<span class="hljs-keyword">for</span> (VkPhysicalDeviceFragmentShadingRateKHR &amp;fragment_shading_rate : fragment_shading_rates)<br>		&#123;<br>			<span class="hljs-comment">// As per spec, the sType member of each shading rate array entry must be set</span><br>			fragment_shading_rate.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR;<br>		&#125;<br>		<span class="hljs-built_in">vkGetPhysicalDeviceFragmentShadingRatesKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_handle</span>(), &amp;fragment_shading_rate_count, fragment_shading_rates.<span class="hljs-built_in">data</span>());<br>	&#125;<br>	<span class="hljs-comment">// Shading rates returned by vkGetPhysicalDeviceFragmentShadingRatesKHR are ordered from largest to smallest</span><br>	std::map&lt;<span class="hljs-type">float</span>, <span class="hljs-type">uint8_t</span>&gt; pattern_lookup = &#123;&#125;;<br>	<span class="hljs-type">float</span>                    range          = <span class="hljs-number">25.0f</span> / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(fragment_shading_rates.<span class="hljs-built_in">size</span>());<br>	<span class="hljs-type">float</span>                    current_range  = <span class="hljs-number">8.0f</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = fragment_shading_rates.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>	&#123;<br>		<span class="hljs-type">uint32_t</span> rate_v               = fragment_shading_rates[i].fragmentSize.width == <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : (fragment_shading_rates[i].fragmentSize.width &gt;&gt; <span class="hljs-number">1</span>);<br>		<span class="hljs-type">uint32_t</span> rate_h               = fragment_shading_rates[i].fragmentSize.height == <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : (fragment_shading_rates[i].fragmentSize.height &lt;&lt; <span class="hljs-number">1</span>);<br>		pattern_lookup[current_range] = rate_v | rate_h;<br>		current_range += range;<br>	&#125;<br><br>	<span class="hljs-type">uint8_t</span> *ptrData = shading_rate_pattern_data;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> y = <span class="hljs-number">0</span>; y &lt; image_extent.height; y++)<br>	&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> x = <span class="hljs-number">0</span>; x &lt; image_extent.width; x++)<br>		&#123;<br>			<span class="hljs-type">const</span> <span class="hljs-type">float</span> deltaX = (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(image_extent.width) / <span class="hljs-number">2.0f</span> - <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(x)) / image_extent.width * <span class="hljs-number">100.0f</span>;<br>			<span class="hljs-type">const</span> <span class="hljs-type">float</span> deltaY = (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(image_extent.height) / <span class="hljs-number">2.0f</span> - <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(y)) / image_extent.height * <span class="hljs-number">100.0f</span>;<br>			<span class="hljs-type">const</span> <span class="hljs-type">float</span> dist   = std::<span class="hljs-built_in">sqrt</span>(deltaX * deltaX + deltaY * deltaY);<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pattern : pattern_lookup)<br>			&#123;<br>				<span class="hljs-keyword">if</span> (dist &lt; pattern.first)<br>				&#123;<br>					*ptrData = pattern.second;<br>					<span class="hljs-keyword">break</span>;<br>				&#125;<br>			&#125;<br>			ptrData++;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// Move shading rate pattern data to staging buffer</span><br>	vkb::core::BufferC staging_buffer = vkb::core::BufferC::<span class="hljs-built_in">create_staging_buffer</span>(<span class="hljs-built_in">get_device</span>(), buffer_size, shading_rate_pattern_data);<br>	<span class="hljs-keyword">delete</span>[] shading_rate_pattern_data;<br><br>	<span class="hljs-comment">// Upload the buffer containing the shading rates to the image that&#x27;ll be used as the shading rate attachment inside our renderpass</span><br>	VkCommandBuffer copy_cmd = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">create_command_buffer</span>(VK_COMMAND_BUFFER_LEVEL_PRIMARY, <span class="hljs-literal">true</span>);<br><br>	vkb::<span class="hljs-built_in">image_layout_transition</span>(copy_cmd, shading_rate_image.image, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);<br><br>	VkBufferImageCopy buffer_copy_region           = &#123;&#125;;<br>	buffer_copy_region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br>	buffer_copy_region.imageSubresource.layerCount = <span class="hljs-number">1</span>;<br>	buffer_copy_region.imageExtent.width           = image_extent.width;<br>	buffer_copy_region.imageExtent.height          = image_extent.height;<br>	buffer_copy_region.imageExtent.depth           = <span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">vkCmdCopyBufferToImage</span>(copy_cmd, staging_buffer.<span class="hljs-built_in">get_handle</span>(), shading_rate_image.image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, <span class="hljs-number">1</span>, &amp;buffer_copy_region);<br><br>	<span class="hljs-comment">// Transfer image layout to fragment shading rate attachment layout required to access this in the renderpass</span><br>	vkb::<span class="hljs-built_in">image_layout_transition</span>(<br>	    copy_cmd, shading_rate_image.image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR);<br><br>	<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">flush_command_buffer</span>(copy_cmd, queue, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先该函数检测指定的FSR附件格式<i><font color="Red">VK_FORMAT_R8_UINT</font></i>是否支持FSR（可能并非所有的格式都会支持FSR）。然后创建FSR图像资源，这里需要注意该图像宽高的指定，由于之前指定<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkFragmentShadingRateAttachmentInfoKHR.html"><code>VkFragmentShadingRateAttachmentInfoKHR</code></a>结构体的时候指定了FSR附件中一个纹素的大小，而纹理的总大小要和颜色附件的大小保持一致，因此该纹理的宽和高就应该设置为总大小除以纹素大小了。然后还需要注意的是图像的用途需要指定为<i><font color="Red">VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR | VK_IMAGE_USAGE_TRANSFER_DST_BIT</font></i>，因为该纹理会被创建为一个device local的资源，需要使用一个staging buffer将纹理初始数据从CPU上传到它中。</p><p>之后的图像内存创建以及图像视图创建都是常规操作，直接来看CPU端缓冲区数据的准备。</p><p>首先，硬件一般支持的最低着色率，或者说最大的FSR的fragment size为4x4，程序使用一个<strong>uint_8</strong>数组来存储FSR附件中每个纹素的值，其中高四位始终为0，低四位的高两位存储fragment size的宽，低两位存储fragment size的高，并且将这个数组内所有元素的默认值设置为<strong>00001010</strong>，也就是默认值设置为最大的FSR（可以根据之前在介绍attachment shading rate的解码公式的时候给出的公式计算得到<strong>00001010</strong>对应的宽高均分别为4）。接下来程序查询并得到所有硬件支持的FSR，在之后生成用于FSR附件内纹素的数据时会用到。</p><p>然后代码开始设置每一个纹素内储存的shading rate值，计算的逻辑基本上基于与中心点的距离，离中心点越远，fragment size就越大。代码首先是生成一个距离——shading rate对照表，然后循环处理每一个FSR附件中的纹素，根据它离中心点的距离查询表中距离大于它的所有项中最小的那一项距离对应的shading rate，然后将该纹素的值就设定为这个shading rate。当然如果某纹素距离中心的距离超过了表中所有项的距离值，那该纹素上也会存储原来的默认值。还有一点需要注意的是，这些纹素数据首先是要上传到一个buffer中的，它是一个一维的数据，而纹理是二维的。由于<code>vkCmdCopyBufferToImage</code>是按行copy的，因此buffer中的数据也应该一行一行存储，这就是生成数组数据的双重循环的外层循环对行，内层循环对列的原因。</p><p>最后将staging buffer中的数据复制到FSR附件中即可。</p><p>回到<i><font color="Green">setup_framebuffer</font></i>函数，在创建好FSR附件资源后，剩余的创建帧缓冲的操作都十分常规，无非就是指定好这些附件以及之前生成的render pass，这里不再赘述。</p><hr><h2 id="prepare_pipeline">prepare_pipeline</h2><p>准备阶段的代码已经在前文给出，其中不涉及到FSR的代码这里不再分析，希望阅读源码的读者可以参考<a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/Vulkan-Samples"><code>官方代码仓库</code></a>。本文仅挑选涉及FSR的代码逻辑进行分析。首先就是准备阶段中的<i><font color="Green">prepare_pipeline</font></i>函数，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FragmentShadingRate::prepare_pipelines</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	VkPipelineInputAssemblyStateCreateInfo input_assembly_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_input_assembly_state_create_info</span>(<br>	        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,<br>	        <span class="hljs-number">0</span>,<br>	        VK_FALSE);<br><br>	VkPipelineRasterizationStateCreateInfo rasterization_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_rasterization_state_create_info</span>(<br>	        VK_POLYGON_MODE_FILL,<br>	        VK_CULL_MODE_BACK_BIT,<br>	        VK_FRONT_FACE_COUNTER_CLOCKWISE,<br>	        <span class="hljs-number">0</span>);<br><br>	VkPipelineColorBlendAttachmentState blend_attachment_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_color_blend_attachment_state</span>(<br>	        <span class="hljs-number">0xf</span>,<br>	        VK_FALSE);<br><br>	VkPipelineColorBlendStateCreateInfo color_blend_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_color_blend_state_create_info</span>(<br>	        <span class="hljs-number">1</span>,<br>	        &amp;blend_attachment_state);<br><br>	<span class="hljs-comment">// Note: Using reversed depth-buffer for increased precision, so Greater depth values are kept</span><br>	VkPipelineDepthStencilStateCreateInfo depth_stencil_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_depth_stencil_state_create_info</span>(<br>	        VK_FALSE,<br>	        VK_FALSE,<br>	        VK_COMPARE_OP_GREATER);<br><br>	VkPipelineViewportStateCreateInfo viewport_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_viewport_state_create_info</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><br>	VkPipelineMultisampleStateCreateInfo multisample_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_multisample_state_create_info</span>(<br>	        VK_SAMPLE_COUNT_1_BIT,<br>	        <span class="hljs-number">0</span>);<br><br>	std::vector&lt;VkDynamicState&gt; dynamic_state_enables = &#123;<br>	    VK_DYNAMIC_STATE_VIEWPORT,<br>	    VK_DYNAMIC_STATE_SCISSOR,<br>	    <span class="hljs-comment">// Add fragment shading rate dynamic state, so we can easily toggle this at runtime</span><br>	    VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR&#125;;<br>	VkPipelineDynamicStateCreateInfo dynamic_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_dynamic_state_create_info</span>(<br>	        dynamic_state_enables.<span class="hljs-built_in">data</span>(),<br>	        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(dynamic_state_enables.<span class="hljs-built_in">size</span>()),<br>	        <span class="hljs-number">0</span>);<br><br>	VkGraphicsPipelineCreateInfo pipeline_create_info =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_create_info</span>(<br>	        pipeline_layout,<br>	        render_pass,<br>	        <span class="hljs-number">0</span>);<br><br>	std::vector&lt;VkPipelineColorBlendAttachmentState&gt; blend_attachment_states = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_color_blend_attachment_state</span>(<span class="hljs-number">0xf</span>, VK_FALSE),<br>	&#125;;<br><br>	pipeline_create_info.pInputAssemblyState = &amp;input_assembly_state;<br>	pipeline_create_info.pRasterizationState = &amp;rasterization_state;<br>	pipeline_create_info.pColorBlendState    = &amp;color_blend_state;<br>	pipeline_create_info.pMultisampleState   = &amp;multisample_state;<br>	pipeline_create_info.pViewportState      = &amp;viewport_state;<br>	pipeline_create_info.pDepthStencilState  = &amp;depth_stencil_state;<br>	pipeline_create_info.pDynamicState       = &amp;dynamic_state;<br><br>	std::array&lt;VkPipelineShaderStageCreateInfo, 2&gt; shader_stages;<br>	pipeline_create_info.stageCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(shader_stages.<span class="hljs-built_in">size</span>());<br>	pipeline_create_info.pStages    = shader_stages.<span class="hljs-built_in">data</span>();<br><br>	<span class="hljs-comment">// Vertex bindings an attributes for model rendering</span><br>	std::vector&lt;VkVertexInputBindingDescription&gt; vertex_input_bindings = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_binding_description</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Vertex), VK_VERTEX_INPUT_RATE_VERTEX),<br>	&#125;;<br>	std::vector&lt;VkVertexInputAttributeDescription&gt; vertex_input_attributes = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, VK_FORMAT_R32G32B32_SFLOAT, <span class="hljs-number">0</span>),                        <span class="hljs-comment">// Position</span><br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, VK_FORMAT_R32G32B32_SFLOAT, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>) * <span class="hljs-number">3</span>),        <span class="hljs-comment">// Normal</span><br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, VK_FORMAT_R32G32_SFLOAT, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>) * <span class="hljs-number">6</span>),           <span class="hljs-comment">// UV</span><br>	&#125;;<br><br>	VkPipelineVertexInputStateCreateInfo vertex_input_state = vkb::initializers::<span class="hljs-built_in">pipeline_vertex_input_state_create_info</span>();<br>	vertex_input_state.vertexBindingDescriptionCount        = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertex_input_bindings.<span class="hljs-built_in">size</span>());<br>	vertex_input_state.pVertexBindingDescriptions           = vertex_input_bindings.<span class="hljs-built_in">data</span>();<br>	vertex_input_state.vertexAttributeDescriptionCount      = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertex_input_attributes.<span class="hljs-built_in">size</span>());<br>	vertex_input_state.pVertexAttributeDescriptions         = vertex_input_attributes.<span class="hljs-built_in">data</span>();<br><br>	pipeline_create_info.pVertexInputState = &amp;vertex_input_state;<br><br>	pipeline_create_info.layout     = pipeline_layout;<br>	pipeline_create_info.renderPass = render_pass;<br><br>	<span class="hljs-comment">// Skysphere</span><br>	shader_stages[<span class="hljs-number">0</span>] = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;fragment_shading_rate&quot;</span>, <span class="hljs-string">&quot;scene.vert&quot;</span>, VK_SHADER_STAGE_VERTEX_BIT);<br>	shader_stages[<span class="hljs-number">1</span>] = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;fragment_shading_rate&quot;</span>, <span class="hljs-string">&quot;scene.frag&quot;</span>, VK_SHADER_STAGE_FRAGMENT_BIT);<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateGraphicsPipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;pipelines.skysphere));<br><br>	<span class="hljs-comment">// Objects</span><br>	<span class="hljs-comment">// Enable depth test and write</span><br>	depth_stencil_state.depthWriteEnable = VK_TRUE;<br>	depth_stencil_state.depthTestEnable  = VK_TRUE;<br>	<span class="hljs-comment">// Flip cull mode</span><br>	rasterization_state.cullMode = VK_CULL_MODE_FRONT_BIT;<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateGraphicsPipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;pipelines.sphere));<br>&#125;<br></code></pre></td></tr></table></figure><p>首先需要注意的就是管线动态阶段的设置，可以看到创建的两个管线的动态阶段不但指定了视口和裁剪矩形阶段，还设置了FSR阶段<i><font color="Red">VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR</font></i>，这样就可以在后续录制命令的时候通过<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetFragmentShadingRateKHR.html"><code>vkCmdSetFragmentShadingRateKHR</code></a>来动态设置该阶段的状态了。</p><p>然后就是这两个管线使用的着色器代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//vertex</span><br><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inNormal;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inUV;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> UBO &#123;<br>	<span class="hljs-type">mat4</span> projection;<br>	<span class="hljs-type">mat4</span> modelview;<br>	<span class="hljs-type">mat4</span> skybox_modelview;<br>	<span class="hljs-type">int</span> color_shading_rates;<br>&#125; ubo;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> outUV;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> outPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> outNormal;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> outViewVec;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">4</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> outLightVec;<br><br><span class="hljs-keyword">layout</span>(push_constant) <span class="hljs-keyword">uniform</span> Push_Constants &#123;<br>	<span class="hljs-type">vec4</span> <span class="hljs-keyword">offset</span>;<br>	<span class="hljs-type">int</span> object_type;<br>&#125; push_constants;<br><br><span class="hljs-type">void</span> main() <br>&#123;<br>	<span class="hljs-keyword">switch</span>(push_constants.object_type) &#123;<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">// Skysphere</span><br>			outPos = <span class="hljs-type">vec3</span>(<span class="hljs-type">mat3</span>(ubo.skybox_modelview) * inPos);<br>			<span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(ubo.projection * <span class="hljs-type">vec4</span>(outPos, <span class="hljs-number">1.0</span>));<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// Object</span><br>			<span class="hljs-type">vec3</span> localPos = inPos + push_constants.<span class="hljs-keyword">offset</span>.xyz;<br>			outPos = <span class="hljs-type">vec3</span>(ubo.modelview * <span class="hljs-type">vec4</span>(localPos, <span class="hljs-number">1.0</span>));<br>			<span class="hljs-built_in">gl_Position</span> = ubo.projection * ubo.modelview * <span class="hljs-type">vec4</span>(localPos, <span class="hljs-number">1.0</span>);<br>			<span class="hljs-keyword">break</span>;<br>	&#125;<br>	outUV = inUV;<br>	outNormal = <span class="hljs-type">mat3</span>(ubo.modelview) * inNormal;	<br>	<span class="hljs-type">vec3</span> lightPos = <span class="hljs-type">mat3</span>(ubo.modelview) * <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">-10.0</span>, <span class="hljs-number">-10.0</span>);<br>	outLightVec = lightPos.xyz - outPos.xyz;<br>	outViewVec = -outPos.xyz;		<br>&#125;<br><br><span class="hljs-comment">//fragment</span><br><span class="hljs-meta">#version 450</span><br><br><span class="hljs-meta">#extension GL_EXT_fragment_shading_rate : require</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> samplerEnvMap;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> samplerSphere;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inUV;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inNormal;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inViewVec;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">4</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inLightVec;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> UBO &#123;<br>	<span class="hljs-type">mat4</span> projection;<br>	<span class="hljs-type">mat4</span> modelview;<br>	<span class="hljs-type">mat4</span> skybox_modelview;<br>	<span class="hljs-type">int</span> color_shading_rates;<br>&#125; ubo;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outColor;<br><br><span class="hljs-keyword">layout</span>(push_constant) <span class="hljs-keyword">uniform</span> Push_Constants &#123;<br>	<span class="hljs-type">vec4</span> <span class="hljs-keyword">offset</span>;<br>	<span class="hljs-type">int</span> object_type;<br>&#125; push_constants;<br><br><span class="hljs-type">void</span> main() <br>&#123;<br>	<span class="hljs-type">vec4</span> color;<br><br>	<span class="hljs-keyword">switch</span> (push_constants.object_type) &#123;<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">// Skysphere			</span><br>			&#123;<br>				color = <span class="hljs-built_in">texture</span>(samplerEnvMap, <span class="hljs-type">vec2</span>(inUV.s, <span class="hljs-number">1.0</span> - inUV.t));<br>			&#125;<br>			<span class="hljs-keyword">break</span>;<br>		<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// Phong shading</span><br>			&#123;<br>				<span class="hljs-type">vec3</span> ambient = <span class="hljs-built_in">texture</span>(samplerSphere, inUV).rgb;<br>				<span class="hljs-type">vec3</span> N = <span class="hljs-built_in">normalize</span>(inNormal);<br>				<span class="hljs-type">vec3</span> L = <span class="hljs-built_in">normalize</span>(inLightVec);<br>				<span class="hljs-type">vec3</span> V = <span class="hljs-built_in">normalize</span>(inViewVec);<br>				<span class="hljs-type">vec3</span> R = <span class="hljs-built_in">reflect</span>(-L, N);<br>				<span class="hljs-type">vec3</span> diffuse = <span class="hljs-type">vec3</span>(<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N, L), <span class="hljs-number">0.0</span>));<br>				<span class="hljs-type">vec3</span> specular = <span class="hljs-type">vec3</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(R, V), <span class="hljs-number">0.0</span>), <span class="hljs-number">8.0</span>));<br>				color = <span class="hljs-type">vec4</span>(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);	<br>			&#125;<br>			<span class="hljs-keyword">break</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (ubo.color_shading_rates == <span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-comment">// Visualize fragment shading rates</span><br><br>		<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>;<br>		<span class="hljs-type">int</span> h = <span class="hljs-number">1</span>;<br>	<br>		<span class="hljs-keyword">if</span> ((gl_ShadingRateEXT &amp; gl_ShadingRateFlag2VerticalPixelsEXT) == gl_ShadingRateFlag2VerticalPixelsEXT) &#123;<br>			v = <span class="hljs-number">2</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span> ((gl_ShadingRateEXT &amp; gl_ShadingRateFlag4VerticalPixelsEXT) == gl_ShadingRateFlag4VerticalPixelsEXT) &#123;<br>			v = <span class="hljs-number">4</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span> ((gl_ShadingRateEXT &amp; gl_ShadingRateFlag2HorizontalPixelsEXT) == gl_ShadingRateFlag2HorizontalPixelsEXT) &#123;<br>			h = <span class="hljs-number">2</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span> ((gl_ShadingRateEXT &amp; gl_ShadingRateFlag4HorizontalPixelsEXT) == gl_ShadingRateFlag4HorizontalPixelsEXT) &#123;<br>			h = <span class="hljs-number">4</span>;<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> (v == <span class="hljs-number">1</span> &amp;&amp; h == <span class="hljs-number">1</span>) &#123;<br>			outColor = <span class="hljs-type">vec4</span>(color.rrr * <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br> 			outColor = <span class="hljs-type">vec4</span>(color.rrr * <span class="hljs-number">1.0</span> - ((v+h) * <span class="hljs-number">0.05</span>), <span class="hljs-number">1.0</span>);<br>		&#125;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		outColor = <span class="hljs-type">vec4</span>(color.rgb, <span class="hljs-number">1.0</span>);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>顶点着色器并没有什么好说明的，主要来看片段着色器中和FSR有关的部分。通过启用glsl拓展<code>GL_EXT_fragment_shading_rate</code>，可以在程序中通过<code>gl_ShadingRateEXT</code>来查询当前像素所使用的组合而成的最终fragment size。该像素着色器允许将这个值通过灰度图的方式显示到屏幕上：只要将UBO中的<strong>color_shading_rate</strong>设置为true，就可以在通过灰度图屏幕上大致显示每个像素的着色率的大小关系，着色率越大，颜色越暗。因此在前文效果视频中可以看到一旦开启FSR效果展示（第二个选项），越是远离屏幕中心颜色就越暗，因为之前在设置FSR附件中纹素数值的时候就是设置为距离越远fragment size越大的。如果第二个选项没有开启，就正常显示渲染后的颜色图。可以从效果视频中看到开启FSR后（也就是第一个选项），渲染结果越靠近中心是越清晰的，而如果关闭这个选项，那么整张图片是一样清晰的，这就是因为在图片的边缘着色率更大，多个像素上只执行了一次着色器，因此会使得画面变糊。</p><p>hlsl的对应代码也放在下面，可以看看hlsl中该拓展是怎么使用的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//vertex</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VSInput</span></span><br><span class="hljs-class">&#123;</span><br>[[vk::location(<span class="hljs-number">0</span>)]] float3 Pos : POSITION0;<br>[[vk::location(<span class="hljs-number">1</span>)]] float3 Normal : NORMAL0;<br>[[vk::location(<span class="hljs-number">2</span>)]] float2 UV : TEXCOORD0;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UBO</span></span><br><span class="hljs-class">&#123;</span><br>	float4x4 projection;<br>	float4x4 modelview;<br>	float4x4 skybox_modelview;<br>	<span class="hljs-type">int</span> color_shading_rates;<br>&#125;;<br>[[vk::binding(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)]]<br>ConstantBuffer&lt;UBO&gt; ubo : <span class="hljs-keyword">register</span>(b0);<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PushConstants</span></span><br><span class="hljs-class">&#123;</span><br>	float4 offset;<br>	<span class="hljs-type">int</span> object_type;<br>&#125;;<br>[[vk::push_constant]] PushConstants push_constants;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VSOutput</span></span><br><span class="hljs-class">&#123;</span><br>	float4 Pos : SV_POSITION;<br>[[vk::location(<span class="hljs-number">0</span>)]] float3 Normal : NORMAL0;<br>[[vk::location(<span class="hljs-number">1</span>)]] float2 UV : TEXCOORD0;<br>[[vk::location(<span class="hljs-number">2</span>)]] float3 ViewVec : VECTOR0;<br>[[vk::location(<span class="hljs-number">3</span>)]] float3 LightVec : VECTOR1;<br>&#125;;<br><br>VSOutput <span class="hljs-title function_">main</span><span class="hljs-params">(VSInput input)</span><br>&#123;<br>	VSOutput output = (VSOutput)<span class="hljs-number">0</span>;<br>	float3 outPos;<br><br>	<span class="hljs-keyword">switch</span>(push_constants.object_type) &#123;<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">// Skysphere</span><br>			outPos = mul((float3x3)ubo.skybox_modelview, input.Pos);<br>			output.Pos = float4(mul(ubo.projection, float4(outPos, <span class="hljs-number">1.0</span>)));<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// Object</span><br>			float3 localPos = input.Pos + push_constants.offset.xyz;<br>			outPos = mul((float3x3)ubo.modelview, localPos);<br>			output.Pos = mul(ubo.projection, mul(ubo.modelview, float4(localPos, <span class="hljs-number">1.0</span>)));<br>			<span class="hljs-keyword">break</span>;<br>	&#125;<br>	output.UV = input.UV;<br>	output.Normal = mul((float3x3)ubo.modelview, input.Normal);<br>	float3 lightPos = mul((float3x3)ubo.modelview, float3(<span class="hljs-number">0.0</span>, <span class="hljs-number">-10.0</span>, <span class="hljs-number">-10.0</span>));<br>	output.LightVec = lightPos.xyz - outPos.xyz;<br>	output.ViewVec = -outPos.xyz;		<br>	<span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">//fragment</span><br>[[vk::binding(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)]]<br>Texture2D textureEnvMap : <span class="hljs-keyword">register</span>(t1);<br>[[vk::binding(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)]]<br>SamplerState samplerEnvMap : <span class="hljs-keyword">register</span>(s1);<br>[[vk::binding(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)]]<br>Texture2D textureSphere : <span class="hljs-keyword">register</span>(t2);<br>[[vk::binding(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)]]<br>SamplerState samplerSphere : <span class="hljs-keyword">register</span>(s2);<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UBO</span></span><br><span class="hljs-class">&#123;</span><br>	float4x4 projection;<br>	float4x4 modelview;<br>	float4x4 skybox_modelview;<br>	<span class="hljs-type">int</span> color_shading_rates;<br>&#125;;<br>[[vk::binding(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)]]<br>ConstantBuffer&lt;UBO&gt; ubo : <span class="hljs-keyword">register</span>(b0);<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PushConstants</span></span><br><span class="hljs-class">&#123;</span><br>	float4 offset;<br>	<span class="hljs-type">int</span> object_type;<br>&#125;;<br>[[vk::push_constant]] PushConstants push_constants;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VSOutput</span></span><br><span class="hljs-class">&#123;</span><br>	float4 Pos : SV_POSITION;<br>[[vk::location(<span class="hljs-number">0</span>)]] float3 Normal : NORMAL0;<br>[[vk::location(<span class="hljs-number">1</span>)]] float2 UV : TEXCOORD0;<br>[[vk::location(<span class="hljs-number">2</span>)]] float3 ViewVec : VECTOR0;<br>[[vk::location(<span class="hljs-number">3</span>)]] float3 LightVec : VECTOR1;<br>&#125;;<br><br>float4 <span class="hljs-title function_">main</span><span class="hljs-params">(VSOutput input, uint shadingRate : SV_ShadingRate)</span> : SV_TARGET<br>&#123;<br>	float4 color;<br><br>	<span class="hljs-keyword">switch</span> (push_constants.object_type) &#123;<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">// Skysphere			</span><br>			&#123;<br>				color = textureEnvMap.Sample(samplerEnvMap, float2(input.UV.x, <span class="hljs-number">1.0</span> - input.UV.y));<br>			&#125;<br>			<span class="hljs-keyword">break</span>;<br>		<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// Phong shading</span><br>			&#123;<br>				float3 ambient = textureSphere.Sample(samplerSphere, input.UV).rgb;<br>				float3 N = normalize(input.Normal);<br>				float3 L = normalize(input.LightVec);<br>				float3 V = normalize(input.ViewVec);<br>				float3 R = reflect(-L, N);<br>				float3 diffuse = float3(max(dot(N, L), (<span class="hljs-number">0.0</span>).xxx));<br>				float3 specular = float3(<span class="hljs-built_in">pow</span>(max(dot(R, V), (<span class="hljs-number">0.0</span>).xxx), <span class="hljs-number">8.0</span>));<br>				color = float4(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);	<br>			&#125;<br>			<span class="hljs-keyword">break</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (ubo.color_shading_rates == <span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-comment">// Visualize fragment shading rates</span><br><br>		<span class="hljs-type">const</span> uint SHADING_RATE_1X1 = <span class="hljs-number">0</span>;<br>		<span class="hljs-type">const</span> uint SHADING_RATE_1X2 = <span class="hljs-number">0x1</span>;<br>		<span class="hljs-type">const</span> uint SHADING_RATE_2X1 = <span class="hljs-number">0x4</span>;<br>		<span class="hljs-type">const</span> uint SHADING_RATE_2X2 = <span class="hljs-number">0x5</span>;<br>		<span class="hljs-type">const</span> uint SHADING_RATE_2X4 = <span class="hljs-number">0x6</span>;<br>		<span class="hljs-type">const</span> uint SHADING_RATE_4X2 = <span class="hljs-number">0x9</span>;<br>		<span class="hljs-type">const</span> uint SHADING_RATE_4X4 = <span class="hljs-number">0xa</span>;<br><br>		<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>;<br>		<span class="hljs-type">int</span> h = <span class="hljs-number">1</span>;<br>	<br>		<span class="hljs-keyword">if</span> ((shadingRate == SHADING_RATE_1X2) || (shadingRate == SHADING_RATE_2X2) || (shadingRate == SHADING_RATE_4X2)) &#123;<br>			v = <span class="hljs-number">2</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span> ((shadingRate == SHADING_RATE_2X4) || (shadingRate == SHADING_RATE_4X4)) &#123;<br>			v = <span class="hljs-number">4</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span> ((shadingRate == SHADING_RATE_2X1) || (shadingRate == SHADING_RATE_2X2) || (shadingRate == SHADING_RATE_2X4)) &#123;<br>			h = <span class="hljs-number">2</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span> ((shadingRate == SHADING_RATE_4X2) || (shadingRate == SHADING_RATE_4X4)) &#123;<br>			h = <span class="hljs-number">4</span>;<br>		&#125;			<br><br>		<span class="hljs-keyword">if</span> (v == <span class="hljs-number">1</span> &amp;&amp; h == <span class="hljs-number">1</span>) &#123;<br>			<span class="hljs-keyword">return</span> float4(color.rrr * <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br> 			<span class="hljs-keyword">return</span> float4(color.rrr * <span class="hljs-number">1.0</span> - ((v+h) * <span class="hljs-number">0.05</span>), <span class="hljs-number">1.0</span>);<br>		&#125;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">return</span> float4(color.rgb, <span class="hljs-number">1.0</span>);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到hlsl中shading_rate通过<strong>SV_ShadingRate</strong>系统值给定。</p><hr><h2 id="build_command_buffers">build_command_buffers</h2><p>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FragmentShadingRate::build_command_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	VkCommandBufferBeginInfo command_buffer_begin_info = vkb::initializers::<span class="hljs-built_in">command_buffer_begin_info</span>();<br><br>	VkClearValue clear_values[<span class="hljs-number">3</span>];<br>	clear_values[<span class="hljs-number">0</span>].color        = &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;;<br>	clear_values[<span class="hljs-number">1</span>].depthStencil = &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0</span>&#125;;<br>	clear_values[<span class="hljs-number">2</span>].color        = &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;;<br><br>	VkRenderPassBeginInfo render_pass_begin_info = vkb::initializers::<span class="hljs-built_in">render_pass_begin_info</span>();<br>	render_pass_begin_info.renderPass            = render_pass;<br>	render_pass_begin_info.renderArea.offset.x   = <span class="hljs-number">0</span>;<br>	render_pass_begin_info.renderArea.offset.y   = <span class="hljs-number">0</span>;<br>	render_pass_begin_info.clearValueCount       = <span class="hljs-number">3</span>;<br>	render_pass_begin_info.pClearValues          = clear_values;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; draw_cmd_buffers.<span class="hljs-built_in">size</span>(); ++i)<br>	&#123;<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBeginCommandBuffer</span>(draw_cmd_buffers[i], &amp;command_buffer_begin_info));<br><br>		VkClearValue clear_values[<span class="hljs-number">3</span>];<br>		clear_values[<span class="hljs-number">0</span>].color        = &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;;<br>		clear_values[<span class="hljs-number">1</span>].depthStencil = &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0</span>&#125;;<br>		clear_values[<span class="hljs-number">2</span>].color        = &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;;<br><br>		<span class="hljs-comment">// Final composition</span><br>		VkRenderPassBeginInfo render_pass_begin_info    = vkb::initializers::<span class="hljs-built_in">render_pass_begin_info</span>();<br>		render_pass_begin_info.framebuffer              = framebuffers[i];<br>		render_pass_begin_info.renderPass               = render_pass;<br>		render_pass_begin_info.clearValueCount          = <span class="hljs-number">3</span>;<br>		render_pass_begin_info.renderArea.extent.width  = width;<br>		render_pass_begin_info.renderArea.extent.height = height;<br>		render_pass_begin_info.pClearValues             = clear_values;<br><br>		<span class="hljs-built_in">vkCmdBeginRenderPass</span>(draw_cmd_buffers[i], &amp;render_pass_begin_info, VK_SUBPASS_CONTENTS_INLINE);<br><br>		VkViewport viewport = vkb::initializers::<span class="hljs-built_in">viewport</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(height), <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br>		<span class="hljs-built_in">vkCmdSetViewport</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;viewport);<br><br>		VkRect2D scissor = vkb::initializers::<span class="hljs-built_in">rect2D</span>(width, height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>		<span class="hljs-built_in">vkCmdSetScissor</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;scissor);<br><br>		<span class="hljs-built_in">vkCmdBindDescriptorSets</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline_layout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;descriptor_set, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br><br>		<span class="hljs-comment">// Set the fragment shading rate state for the current pipeline</span><br>		VkExtent2D                         fragment_size = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>		VkFragmentShadingRateCombinerOpKHR combiner_ops[<span class="hljs-number">2</span>];<br>		<span class="hljs-comment">// The combiners determine how the different shading rate values for the pipeline, primitives and attachment are combined</span><br>		<span class="hljs-keyword">if</span> (enable_attachment_shading_rate)<br>		&#123;<br>			<span class="hljs-comment">// If shading rate from attachment is enabled, we set the combiner, so that the values from the attachment are used</span><br>			<span class="hljs-comment">// Combiner for pipeline (A) and primitive (B) - Not used in this sample</span><br>			combiner_ops[<span class="hljs-number">0</span>] = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR;<br>			<span class="hljs-comment">// Combiner for pipeline (A) and attachment (B), replace the pipeline default value (fragment_size) with the fragment sizes stored in the attachment</span><br>			combiner_ops[<span class="hljs-number">1</span>] = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR;<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			<span class="hljs-comment">// If shading rate from attachment is disabled, we keep the value set via the dynamic state</span><br>			combiner_ops[<span class="hljs-number">0</span>] = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR;<br>			combiner_ops[<span class="hljs-number">1</span>] = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR;<br>		&#125;<br>		<span class="hljs-built_in">vkCmdSetFragmentShadingRateKHR</span>(draw_cmd_buffers[i], &amp;fragment_size, combiner_ops);<br><br>		<span class="hljs-keyword">if</span> (display_skysphere)<br>		&#123;<br>			<span class="hljs-built_in">vkCmdBindPipeline</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipelines.skysphere);<br>			push_const_block.object_type = <span class="hljs-number">0</span>;<br>			<span class="hljs-built_in">vkCmdPushConstants</span>(draw_cmd_buffers[i], pipeline_layout, VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(push_const_block), &amp;push_const_block);<br>			<span class="hljs-built_in">vkCmdBindDescriptorSets</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline_layout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;descriptor_set, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>			<span class="hljs-built_in">draw_model</span>(models.skysphere, draw_cmd_buffers[i]);<br>		&#125;<br><br>		<span class="hljs-built_in">vkCmdBindPipeline</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipelines.sphere);<br>		<span class="hljs-built_in">vkCmdBindDescriptorSets</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline_layout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;descriptor_set, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>		std::vector&lt;glm::vec3&gt; mesh_offsets = &#123;<br>		    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">-2.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>),<br>		    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>),<br>		    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">2.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>),<br>		&#125;;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)<br>		&#123;<br>			push_const_block.object_type = <span class="hljs-number">1</span>;<br>			push_const_block.offset      = glm::<span class="hljs-built_in">vec4</span>(mesh_offsets[j], <span class="hljs-number">0.0f</span>);<br>			<span class="hljs-built_in">vkCmdPushConstants</span>(draw_cmd_buffers[i], pipeline_layout, VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(push_const_block), &amp;push_const_block);<br>			<span class="hljs-built_in">draw_model</span>(models.scene, draw_cmd_buffers[i]);<br>		&#125;<br><br>		<span class="hljs-built_in">draw_ui</span>(draw_cmd_buffers[i]);<br><br>		<span class="hljs-built_in">vkCmdEndRenderPass</span>(draw_cmd_buffers[i]);<br><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkEndCommandBuffer</span>(draw_cmd_buffers[i]));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样只关注FSR相关逻辑。前文在介绍Pipeline shading rate的时候也说明过动态指定shading rate可以通过<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetFragmentShadingRateKHR.html"><code>vkCmdSetFragmentShadingRateKHR</code></a>来实现。Pipeline shading rate通过<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetFragmentShadingRateKHR.html"><code>vkCmdSetFragmentShadingRateKHR</code></a>的<i><font color="Orange">pFragmentSize</font></i>来指定，这里程序是直接指定为了{1，1}，也就相当于不使用方式一指定shading rate。如果开启了FSR，那么Pipeline shading rate和Primitive shading rate的合并函数设置为<i><font color="Red">VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR</font></i>，因为程序本身也没有指定Primitive shading rate；然后再将这个合并的结果（其实也就是Pipeline shading rate指定的{1，1}）和Attachment shading rate合并，合并函数为<i><font color="Red">VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR</font></i>，这也就意味着最后shading rate的合并结果完全由FSR附件指定的shading rate决定。当然，如果不开启FSR，那么这两个合并函数都设置为默认（也就是<i><font color="Red">VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR</font></i><i><font color="Red">VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR</font></i>）就可以了。</p><p>该函数其它部分都是常规的绘制流程了，后面的<i><font color="Green">render</font></i>函数也仅仅就是提交录制的命令并更新UBO，这里不再分析。</p><p>本示例的学习到此结束！</p><hr></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/CG-api/" class="category-chain-item">CG_api</a> <span>></span> <a href="/categories/CG-api/vulkan/" class="category-chain-item">vulkan</a> <span>></span> <a href="/categories/CG-api/vulkan/vulkan-samples/" class="category-chain-item">vulkan_samples</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>Fragment shading rate</div><div>http://example.com/2025/03/14/CG_api/vulkan/vulkan_samples/fragment_shading_rate/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>ZPC-dsg</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年3月14日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/2025/03/14/CG_api/vulkan/vulkan_samples/calibrated_timestamps/" title="Calibrated timestamps"><span class="hidden-mobile">Calibrated timestamps</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>