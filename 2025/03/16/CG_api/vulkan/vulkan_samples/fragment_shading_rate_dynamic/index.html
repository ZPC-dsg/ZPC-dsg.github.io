<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/icon/mikuicon.jpg"><link rel="icon" href="/images/icon/mikuicon.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="ZPC-dsg"><meta name="keywords" content=""><meta name="description" content="前言 在之前的FSR示例中，代码直接通过硬编码的方式决定FSR附件的数据内容，并且在之后的渲染过程中始终保持不变（始终是图像中间着色率高，周围着色率低的状态），但这样得到的效果往往并不真实。本示例将通过颜色频率变化的剧烈程度来决定当前像素的FSR大小，变化越剧烈，理应使用更高的着色率以得到更精细的着色效果，反之变化不剧烈的地方完全可以适当降低着色率以获得画面效果和性能之间的平衡。 本文对该示例"><meta property="og:type" content="article"><meta property="og:title" content="Fragment shading rate dynamic"><meta property="og:url" content="http://example.com/2025/03/16/CG_api/vulkan/vulkan_samples/fragment_shading_rate_dynamic/index.html"><meta property="og:site_name" content="ZPC の Blog"><meta property="og:description" content="前言 在之前的FSR示例中，代码直接通过硬编码的方式决定FSR附件的数据内容，并且在之后的渲染过程中始终保持不变（始终是图像中间着色率高，周围着色率低的状态），但这样得到的效果往往并不真实。本示例将通过颜色频率变化的剧烈程度来决定当前像素的FSR大小，变化越剧烈，理应使用更高的着色率以得到更精细的着色效果，反之变化不剧烈的地方完全可以适当降低着色率以获得画面效果和性能之间的平衡。 本文对该示例"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/images/textbg/CG_api/vk_sample_rate_dy.jpg"><meta property="article:published_time" content="2025-03-16T13:26:03.000Z"><meta property="article:modified_time" content="2025-03-17T12:37:05.803Z"><meta property="article:author" content="ZPC-dsg"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/images/textbg/CG_api/vk_sample_rate_dy.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>Fragment shading rate dynamic - ZPC の Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:"measurement_id:G-X8N3TZCB57",tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 7.3.0"><script src="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.css"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>ZPC の Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/images/textbg/CG_api/vk_sample_rate_dy.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Fragment shading rate dynamic"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> ZPC-dsg </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-03-16 21:26" pubdate>2025年3月16日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 10k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 84 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">Fragment shading rate dynamic</h1><div class="markdown-body"><h2 id="前言">前言</h2><p>在之前的FSR示例中，代码直接通过硬编码的方式决定FSR附件的数据内容，并且在之后的渲染过程中始终保持不变（始终是图像中间着色率高，周围着色率低的状态），但这样得到的效果往往并不真实。本示例将通过颜色频率变化的剧烈程度来决定当前像素的FSR大小，变化越剧烈，理应使用更高的着色率以得到更精细的着色效果，反之变化不剧烈的地方完全可以适当降低着色率以获得画面效果和性能之间的平衡。</p><p>本文对该示例的分析同样会将注意力主要集中于FSR有关的代码逻辑。本示例的渲染逻辑并没有什么特殊之处，因此只会在有需要时进行粗浅的分析，希望仔细阅读有关部分源码的读者可以自行参考<a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/Vulkan-Samples"><code>官方代码仓库</code></a>。</p><hr><h2 id="效果">效果</h2><p>首先还是来看看效果：</p><div id="dplayer5" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom:20px"></div><script>!function(){var a=new DPlayer({container:document.getElementById("dplayer5"),loop:"yes",screenshot:"yes",video:{url:"/2025/03/16/CG_api/vulkan/vulkan_samples/fragment_shading_rate_dynamic/dynamic.mp4"},danmaku:{api:"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]),window.dplayers.push(a)}()</script><p>后文在分析示例的时候会解释视频中每个选项的含义。另外，第二个选项框的第四个选项实际上时我自己添加的，用于进行FSR附件内容的展示，后续我也会对添加的这一部分加以说明。</p><hr><h2 id="主要逻辑分析">主要逻辑分析</h2><p>本示例的逻辑并不简单。事实上光是搞懂示例整体的逻辑流程细节就花了我大半天的时间（一方面也是因为自己对Vulkan中的很多概念还是理解不深，还是太菜了wwwww）不过完全理解之后还是让我受益良多。因此在深入到代码具体实现细节之间，让我先来将整个程序的执行逻辑梳理一遍，有了这个基本的逻辑流程框架之后，在深入阅读源码的时候就不会感到云里雾里。</p><p>本示例一帧流程可以分为的三部分：第一部分是整个场景的渲染和展示，这一部分程序的渲染会使用上一帧由计算着色器得到的FSR附件（准确来讲实际上是计算着色器计算得到FSR数据，然后将这个数据复制到FSR附件中）进行full resolution的渲染，并且会使用到两个render pass：首先使用一个fragment render pass进行FSR渲染，然后使用基类自带的普通的render pass对UI进行渲染（一般UI渲染并不会使用FSR，我们当然希望UI界面始终是一样清晰的）。渲染使用的着色器会输出到两个渲染目标：一个普通的颜色附件以及一个用于存储颜色变化频率信息的附件；第二部分是一个smaller resolution的渲染，该部分将不会使用FSR附件进行整个场景的渲染，渲染过程和第一部分非UI部分的渲染基本一致，区别仅在于不使用FSR附件以及渲染到更低的分辨率上。第二部分渲染得到的频率附件将被后续第三阶段的计算着色器使用；第三阶段将使用计算着色器根据第二部分得到的场景频率信息来计算相应的FSR值，计算完成后将该数据复制到FSR附件中供下一帧第一部分的渲染使用。</p><p>之所以需要使用一个额外的渲染流程来输出供计算着色器使用的频率信息，是因为如果直接使用由FSR附件辅助生成的频率信息的话，那么上一帧低频的图像部分着色器的调用频率会很低，导致即使当前帧该部分的频率变化很高，也只能多个像素共享一次着色器调用的结果，导致该部分的频率信息不正确，从而影响下一帧的FSR附件内容，导致画面效果的滞后以及画面闪烁等现象。因此程序使用了一个额外的不使用FSR附件的渲染流程来渲染得到本帧真实的频率信息，不过为了达到画面和性能的平衡会适当地降低这次渲染的分辨率。</p><p>好的，大致流程梳理完毕，那么事不宜迟，开始整个代码框架的分析吧！</p><hr><h2 id="setup_render_pass">setup_render_pass</h2><p>首先来看render pass的构建函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FragmentShadingRateDynamic::setup_render_pass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::array&lt;VkRenderPass *, 2&gt; render_passes&#123;&amp;render_pass, &amp;fragment_render_pass&#125;;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> use_fragment_shading_rate : &#123;<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>&#125;)<br>	&#123;<br>		<span class="hljs-comment">// Query the fragment shading rate properties of the current implementation, we will need them later on</span><br>		physical_device_fragment_shading_rate_properties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR;<br>		VkPhysicalDeviceProperties2KHR device_properties&#123;&#125;;<br>		device_properties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;<br>		device_properties.pNext = &amp;physical_device_fragment_shading_rate_properties;<br>		<span class="hljs-built_in">vkGetPhysicalDeviceProperties2KHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_handle</span>(), &amp;device_properties);<br><br>		<span class="hljs-comment">// In contrast to the static fragment shading rate example, include</span><br>		<span class="hljs-comment">// an attachment for the output of the frequency content of the rendered image</span><br>		<span class="hljs-function">std::vector&lt;VkAttachmentDescription2KHR&gt; <span class="hljs-title">attachments</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br>		<span class="hljs-comment">// Color attachment</span><br>		attachments[<span class="hljs-number">0</span>].sType          = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2;<br>		attachments[<span class="hljs-number">0</span>].format         = <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_format</span>();<br>		attachments[<span class="hljs-number">0</span>].samples        = VK_SAMPLE_COUNT_1_BIT;<br>		attachments[<span class="hljs-number">0</span>].loadOp         = use_fragment_shading_rate ? VK_ATTACHMENT_LOAD_OP_CLEAR : VK_ATTACHMENT_LOAD_OP_LOAD;<br>		attachments[<span class="hljs-number">0</span>].storeOp        = VK_ATTACHMENT_STORE_OP_STORE;<br>		attachments[<span class="hljs-number">0</span>].stencilLoadOp  = VK_ATTACHMENT_LOAD_OP_DONT_CARE;<br>		attachments[<span class="hljs-number">0</span>].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>		attachments[<span class="hljs-number">0</span>].initialLayout  = use_fragment_shading_rate ? VK_IMAGE_LAYOUT_UNDEFINED : VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;<br>		attachments[<span class="hljs-number">0</span>].finalLayout    = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;<br>		<span class="hljs-comment">// Depth attachment</span><br>		attachments[<span class="hljs-number">1</span>].sType          = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2;<br>		attachments[<span class="hljs-number">1</span>].format         = depth_format;<br>		attachments[<span class="hljs-number">1</span>].samples        = VK_SAMPLE_COUNT_1_BIT;<br>		attachments[<span class="hljs-number">1</span>].loadOp         = use_fragment_shading_rate ? VK_ATTACHMENT_LOAD_OP_CLEAR : VK_ATTACHMENT_LOAD_OP_LOAD;<br>		attachments[<span class="hljs-number">1</span>].storeOp        = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>		attachments[<span class="hljs-number">1</span>].stencilLoadOp  = use_fragment_shading_rate ? VK_ATTACHMENT_LOAD_OP_CLEAR : VK_ATTACHMENT_LOAD_OP_LOAD;<br>		attachments[<span class="hljs-number">1</span>].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>		attachments[<span class="hljs-number">1</span>].initialLayout  = use_fragment_shading_rate ? VK_IMAGE_LAYOUT_UNDEFINED : VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;<br>		attachments[<span class="hljs-number">1</span>].finalLayout    = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;<br>		<span class="hljs-comment">// Fragment shading rate attachment</span><br>		attachments[<span class="hljs-number">2</span>].sType          = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2;<br>		attachments[<span class="hljs-number">2</span>].format         = VK_FORMAT_R8_UINT;<br>		attachments[<span class="hljs-number">2</span>].samples        = VK_SAMPLE_COUNT_1_BIT;<br>		attachments[<span class="hljs-number">2</span>].loadOp         = VK_ATTACHMENT_LOAD_OP_LOAD;<br>		attachments[<span class="hljs-number">2</span>].storeOp        = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>		attachments[<span class="hljs-number">2</span>].stencilLoadOp  = use_fragment_shading_rate ? VK_ATTACHMENT_LOAD_OP_CLEAR : VK_ATTACHMENT_LOAD_OP_LOAD;<br>		attachments[<span class="hljs-number">2</span>].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>		attachments[<span class="hljs-number">2</span>].initialLayout  = VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR;<br>		attachments[<span class="hljs-number">2</span>].finalLayout    = VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR;<br>		<span class="hljs-comment">// Frequency content attachment</span><br>		<span class="hljs-keyword">if</span> (use_fragment_shading_rate)<br>		&#123;<br>			attachments.<span class="hljs-built_in">emplace_back</span>(VkAttachmentDescription2KHR&#123;&#125;);<br>			attachments[<span class="hljs-number">3</span>].sType          = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2;<br>			attachments[<span class="hljs-number">3</span>].format         = VK_FORMAT_R8G8_UINT;<br>			attachments[<span class="hljs-number">3</span>].samples        = VK_SAMPLE_COUNT_1_BIT;<br>			attachments[<span class="hljs-number">3</span>].loadOp         = VK_ATTACHMENT_LOAD_OP_CLEAR;<br>			attachments[<span class="hljs-number">3</span>].storeOp        = VK_ATTACHMENT_STORE_OP_STORE;<br>			attachments[<span class="hljs-number">3</span>].stencilLoadOp  = VK_ATTACHMENT_LOAD_OP_DONT_CARE;<br>			attachments[<span class="hljs-number">3</span>].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>			attachments[<span class="hljs-number">3</span>].initialLayout  = VK_IMAGE_LAYOUT_UNDEFINED;<br>			attachments[<span class="hljs-number">3</span>].finalLayout    = VK_IMAGE_LAYOUT_GENERAL;        <span class="hljs-comment">// will be used by compute shader</span><br>		&#125;<br><br>		VkAttachmentReference2KHR depth_reference = &#123;VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2&#125;;<br>		depth_reference.attachment                = <span class="hljs-number">1</span>;<br>		depth_reference.layout                    = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;<br>		depth_reference.aspectMask                = VK_IMAGE_ASPECT_DEPTH_BIT;<br><br>		<span class="hljs-comment">// Set up the attachment reference for the shading rate image attachment in slot 2</span><br>		VkAttachmentReference2 fragment_shading_rate_reference = &#123;VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2&#125;;<br>		fragment_shading_rate_reference.attachment             = <span class="hljs-number">2</span>;<br>		fragment_shading_rate_reference.layout                 = VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR;<br><br>		<span class="hljs-comment">// Set up the attachment info for the shading rate image, which will be added to the sub pass via structure chaining (in pNext)</span><br>		VkFragmentShadingRateAttachmentInfoKHR fragment_shading_rate_attachment_info = &#123;<br>		    VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR&#125;;<br>		fragment_shading_rate_attachment_info.pFragmentShadingRateAttachment        = &amp;fragment_shading_rate_reference;<br>		fragment_shading_rate_attachment_info.shadingRateAttachmentTexelSize.width  = physical_device_fragment_shading_rate_properties.maxFragmentShadingRateAttachmentTexelSize.width;<br>		fragment_shading_rate_attachment_info.shadingRateAttachmentTexelSize.height = physical_device_fragment_shading_rate_properties.maxFragmentShadingRateAttachmentTexelSize.height;<br><br>		VkAttachmentReference2KHR color_reference = &#123;VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2&#125;;<br>		color_reference.attachment                = <span class="hljs-number">0</span>;<br>		color_reference.layout                    = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;<br>		color_reference.aspectMask                = VK_IMAGE_ASPECT_COLOR_BIT;<br><br>		<span class="hljs-comment">// Setup attachment for frequency information</span><br>		VkAttachmentReference2 frequency_reference = &#123;VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2&#125;;<br>		frequency_reference.attachment             = <span class="hljs-number">3</span>;<br>		frequency_reference.layout                 = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;<br>		frequency_reference.aspectMask             = VK_IMAGE_ASPECT_COLOR_BIT;<br><br>		std::vector&lt;VkAttachmentReference2&gt; color_references = &#123;color_reference&#125;;<br>		<span class="hljs-keyword">if</span> (use_fragment_shading_rate)<br>		&#123;<br>			color_references.<span class="hljs-built_in">emplace_back</span>(frequency_reference);<br>		&#125;<br><br>		VkSubpassDescription2KHR sub_pass = &#123;VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2&#125;;<br>		<span class="hljs-keyword">if</span> (use_fragment_shading_rate)<br>		&#123;<br>			<span class="hljs-comment">// This sub pass will draw the 3D scene and generate the fragment shading rate</span><br>			<span class="hljs-comment">// The color attachments includes both the (RGB) color output and the fragment shading rate image</span><br>			sub_pass.sType                   = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2;<br>			sub_pass.pipelineBindPoint       = VK_PIPELINE_BIND_POINT_GRAPHICS;<br>			sub_pass.colorAttachmentCount    = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(color_references.<span class="hljs-built_in">size</span>());<br>			sub_pass.pColorAttachments       = color_references.<span class="hljs-built_in">data</span>();<br>			sub_pass.pDepthStencilAttachment = &amp;depth_reference;<br>			sub_pass.inputAttachmentCount    = <span class="hljs-number">0</span>;<br>			sub_pass.pInputAttachments       = <span class="hljs-literal">nullptr</span>;<br>			sub_pass.preserveAttachmentCount = <span class="hljs-number">0</span>;<br>			sub_pass.pPreserveAttachments    = <span class="hljs-literal">nullptr</span>;<br>			sub_pass.pResolveAttachments     = <span class="hljs-literal">nullptr</span>;<br>			sub_pass.pNext                   = &amp;fragment_shading_rate_attachment_info;<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			sub_pass.sType                   = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2;<br>			sub_pass.pipelineBindPoint       = VK_PIPELINE_BIND_POINT_GRAPHICS;<br>			sub_pass.colorAttachmentCount    = <span class="hljs-number">1</span>;<br>			sub_pass.pColorAttachments       = &amp;color_reference;<br>			sub_pass.pDepthStencilAttachment = &amp;depth_reference;<br>			sub_pass.inputAttachmentCount    = <span class="hljs-number">0</span>;<br>			sub_pass.pInputAttachments       = <span class="hljs-literal">nullptr</span>;<br>			sub_pass.preserveAttachmentCount = <span class="hljs-number">0</span>;<br>			sub_pass.pPreserveAttachments    = <span class="hljs-literal">nullptr</span>;<br>			sub_pass.pResolveAttachments     = <span class="hljs-literal">nullptr</span>;<br>			sub_pass.pNext                   = <span class="hljs-literal">nullptr</span>;<br>		&#125;<br><br>		<span class="hljs-comment">// Sub-pass dependencies for layout transitions</span><br>		std::vector&lt;VkSubpassDependency2KHR&gt; dependencies = &#123;&#125;;<br><br>		<span class="hljs-keyword">if</span> (use_fragment_shading_rate)<br>		&#123;<br>			dependencies.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span>, &#123;VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2&#125;);<br>			dependencies[<span class="hljs-number">0</span>].sType           = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2;<br>			dependencies[<span class="hljs-number">0</span>].srcSubpass      = VK_SUBPASS_EXTERNAL;<br>			dependencies[<span class="hljs-number">0</span>].dstSubpass      = <span class="hljs-number">0</span>;<br>			dependencies[<span class="hljs-number">0</span>].srcStageMask    = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;<br>			dependencies[<span class="hljs-number">0</span>].dstStageMask    = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;<br>			dependencies[<span class="hljs-number">0</span>].srcAccessMask   = VK_ACCESS_MEMORY_READ_BIT;<br>			dependencies[<span class="hljs-number">0</span>].dstAccessMask   = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;<br>			dependencies[<span class="hljs-number">0</span>].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;<br><br>			dependencies[<span class="hljs-number">1</span>].sType           = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2;<br>			dependencies[<span class="hljs-number">1</span>].srcSubpass      = <span class="hljs-number">0</span>;<br>			dependencies[<span class="hljs-number">1</span>].dstSubpass      = VK_SUBPASS_EXTERNAL;<br>			dependencies[<span class="hljs-number">1</span>].srcStageMask    = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;<br>			dependencies[<span class="hljs-number">1</span>].dstStageMask    = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;<br>			dependencies[<span class="hljs-number">1</span>].srcAccessMask   = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;<br>			dependencies[<span class="hljs-number">1</span>].dstAccessMask   = VK_ACCESS_MEMORY_READ_BIT;<br>			dependencies[<span class="hljs-number">1</span>].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;<br>		&#125;<br>		VkRenderPassCreateInfo2KHR render_pass_create_info = &#123;&#125;;<br>		render_pass_create_info.sType                      = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2;<br>		render_pass_create_info.attachmentCount            = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attachments.<span class="hljs-built_in">size</span>());<br>		render_pass_create_info.pAttachments               = attachments.<span class="hljs-built_in">data</span>();<br>		render_pass_create_info.subpassCount               = <span class="hljs-number">1</span>;<br>		render_pass_create_info.pSubpasses                 = &amp;sub_pass;<br>		render_pass_create_info.dependencyCount            = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(dependencies.<span class="hljs-built_in">size</span>());<br>		render_pass_create_info.pDependencies              = !dependencies.<span class="hljs-built_in">empty</span>() ? dependencies.<span class="hljs-built_in">data</span>() : VK_NULL_HANDLE;<br><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateRenderPass2KHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;render_pass_create_info, <span class="hljs-literal">nullptr</span>,<br>		                                render_passes[<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(use_fragment_shading_rate)]));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到程序构建了两个render pass，分别用于一般场景的绘制（<i><font color="Orange">fragment_render_pass</font></i>）和GUI的绘制（<i><font color="Orange">render_pass</font></i>）。</p><p>接下来来看render pass附件描述的指定。可以看到两个render pass都指定了三个附件——颜色附件、深度附件以及FSR附件（不过事实上<i><font color="Orange">render_pass</font></i>并不会使用到这个FSR附件），它们实际上会共用这些附件资源。<i><font color="Orange">fragment_render_pass</font></i>还额外指定了一个用于存储颜色频率输出的附件。另外还需要注意的是这些附件的加载存储方式以及布局：可以看到<i><font color="Orange">fragment_render_pass</font></i>的颜色附件的<i><font color="Orange">loadOp</font></i>指定为<i><font color="Red">VK_ATTACHMENT_LOAD_OP_CLEAR</font></i>，因为该render pass负责最后输出到屏幕上的画面的渲染，并不需要上一帧画面的内容，但是<i><font color="Orange">render_pass</font></i>的<i><font color="Orange">loadOp</font></i>则指定为<i><font color="Red">VK_ATTACHMENT_LOAD_OP_LOAD</font></i>，这是因为<i><font color="Orange">render_pass</font></i>负责在绘制完场景之后进行UI界面的绘制，UI界面需要在原先渲染画面的基础上绘制，因此需要将之前<i><font color="Orange">fragment_render_pass</font></i>渲染的场景图像加载进来而不是清除掉。另外，二者的<i><font color="Orange">storeOp</font></i>均指定为<i><font color="Red">VK_ATTACHMENT_STORE_OP_STORE</font></i>，对于<i><font color="Orange">fragment_render_pass</font></i>，它需要将渲染结果存储起来供<i><font color="Orange">render_pass</font></i>加载，对于<i><font color="Orange">render_pass</font></i>而言，则是因为渲染的图像后续需要被显示到屏幕上，当然需要保存下来。另外，<i><font color="Orange">fragment_render_pass</font></i>的初始布局设置为<i><font color="Red">VK_IMAGE_LAYOUT_UNDEFINED</font></i>，而<i><font color="Orange">render_pass</font></i>的初始布局以及二者的最终布局均设置为<i><font color="Red">VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</font></i>，这是因为对于<i><font color="Orange">fragment_render_pass</font></i>而言，它显然无需在意渲染开始前图像的内容，因此直接设置为<i><font color="Red">VK_IMAGE_LAYOUT_UNDEFINED</font></i>代表此时附件内的内容是无效的，在后续需要使用该附件的时候还需要转化为合理的布局（在subpass中进行布局转换），而对于<i><font color="Orange">render_pass</font></i>而言，它紧接着<i><font color="Orange">fragment_render_pass</font></i>执行，由于<i><font color="Orange">fragment_render_pass</font></i>的最终布局是<i><font color="Red">VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</font></i>，为了匹配这个最终布局，它的初始布局就必须设置为和<i><font color="Orange">fragment_render_pass</font></i>最终布局一样的布局（<i><font color="Red">VK_IMAGE_LAYOUT_UNDEFINED</font></i>这个特殊布局作为初始布局的话则不需要和之前使用该附件的render pass的最终布局相匹配）。之后的深度附件的布局和加载存储操作指定逻辑和颜色附件基本相同。再来看FSR附件，注意到无论是哪个render pass，它的加载操作均指定为<i><font color="Red">VK_ATTACHMENT_LOAD_OP_LOAD</font></i>，因为对于<i><font color="Orange">fragment_render_pass</font></i>而言，它的FSR附件内容是在开启render pass之前被计算着色器填写好的，因此直接在渲染通道中将其加载进来就可以了。而<i><font color="Orange">render_pass</font></i>实际上并不会使用这个附件，因此怎么设置都行。另外，这两个render pass对FSR附件的存储操作均设置为<i><font color="Red">VK_ATTACHMENT_STORE_OP_DONT_CARE</font></i>，这是因为FSR附件内容是由计算着色器生成的，因此并不需要保存这个附件的内容。最后注意FSR附件的布局始终设置为<i><font color="Red">VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR</font></i>，毕竟它至始至终都只用于被着色器读取内容。</p><p>对于<i><font color="Orange">fragment_render_pass</font></i>独有的频率附件，它的加载操作同样设置为清除，因为上一帧的频率附件会通过描述符的形式传递给当前帧的着色器，当前帧的频率附件则会清除内容以渲染当前帧的频率结果。它的存储操作设为<i><font color="Red">VK_ATTACHMENT_STORE_OP_STORE</font></i>，因为这个频率附件的内容后续需要被计算着色器使用以计算下一帧使用的FSR附件内容，所以它的内容需要被保留。最后注意到频率附件的最终布局指定为<i><font color="Red">VK_IMAGE_LAYOUT_GENERAL</font></i>，因为后续它会作为storage image供计算着色器使用，其布局必须设置为这个。</p><p>然后就是指定subpass使用的各个附件的引用，这部分无需赘述，关于FSR附件引用的指定在<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2025/03/14/CG_api/vulkan/vulkan_samples/fragment_shading_rate/"><code>我的上一篇博客</code></a>中也有详细说明。这里只需注意不管是哪个render pass中的subpass，颜色附件都需要将布局指定为<i><font color="Red">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</font></i>，因为在子通道中它需要作为着色器的渲染目标。</p><p>最后是子通道依赖关系的指定。这里我并不是很理解为什么<i><font color="Orange">fragment_render_pass</font></i>的子通道和外部通道的依赖关系中没有带上深度测试有关的同步，理论上来讲应该要添加上深度测试有关的阶段和操作以确保深度缓冲的布局正确性和内容可见性（可以参考<strong>fragment_shading_rate</strong>示例的有关代码）。另外，将<i><font color="Orange">render_pass</font></i>的子通道依赖设置为<i><font color="Red">VK_NULL_HANDLE</font></i>（实际也就是nullptr）并不意味着该通道就不包含任何依赖关系了，事实上根据官方文档，这种情况下Vulkan会隐式地为该通道的子通道和头尾外部通道之间各添加一个依赖关系，该关系等价的子通道依赖分别如下图：</p><figure><img src="/2025/03/16/CG_api/vulkan/vulkan_samples/fragment_shading_rate_dynamic/dependency_before.png" srcset="/img/loading.gif" lazyload alt="外部通道和子通道依赖"><figcaption aria-hidden="true">外部通道和子通道依赖</figcaption></figure><figure><img src="/2025/03/16/CG_api/vulkan/vulkan_samples/fragment_shading_rate_dynamic/dependency_after.png" srcset="/img/loading.gif" lazyload alt="子通道和外部通道依赖"><figcaption aria-hidden="true">子通道和外部通道依赖</figcaption></figure><p>这个默认的依赖关系对于UI界面的绘制足够了。</p><hr><h2 id="setup_framebuffer">setup_framebuffer</h2><p>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FragmentShadingRateDynamic::setup_framebuffer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// Create ths shading rate image attachment if not defined (first run and resize)</span><br>	<span class="hljs-keyword">auto</span> check_dimension = [<span class="hljs-keyword">this</span>](<span class="hljs-type">const</span> vkb::core::ImageView *view) &#123;<br>		<span class="hljs-keyword">if</span> (!view)<br>		&#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		&#125;<br>		<span class="hljs-keyword">auto</span> extent = view-&gt;<span class="hljs-built_in">get_image</span>().<span class="hljs-built_in">get_extent</span>();<br>		<span class="hljs-keyword">return</span> extent.width == <span class="hljs-keyword">this</span>-&gt;width &amp;&amp; extent.height == <span class="hljs-keyword">this</span>-&gt;height;<br>	&#125;;<br>	<span class="hljs-keyword">if</span> (compute_buffers.<span class="hljs-built_in">empty</span>() || !<span class="hljs-built_in">check_dimension</span>(compute_buffers[<span class="hljs-number">0</span>].frequency_content_image_view.<span class="hljs-built_in">get</span>()))<br>	&#123;<br>		<span class="hljs-built_in">create_shading_rate_attachment</span>();<br>	&#125;<br><br>	<span class="hljs-built_in">assert</span>(render_pass &amp;&amp; fragment_render_pass);<br>	std::array&lt;VkRenderPass *, 2&gt;                                     render_passes&#123;&amp;render_pass, &amp;fragment_render_pass&#125;;<br>	std::array&lt;std::reference_wrapper&lt;std::vector&lt;VkFramebuffer&gt;&gt;, <span class="hljs-number">2</span>&gt; framebuffer_refs&#123;framebuffers,<br>	                                                                                   fragment_framebuffers&#125;;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> use_fragment_shading_rate : &#123;<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>&#125;)<br>	&#123;<br>		<span class="hljs-comment">// Delete existing frame buffers</span><br>		std::vector&lt;VkFramebuffer&gt; &amp;_framebuffers = framebuffer_refs[use_fragment_shading_rate];<br>		<span class="hljs-keyword">if</span> (!_framebuffers.<span class="hljs-built_in">empty</span>())<br>		&#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;framebuffer : _framebuffers)<br>			&#123;<br>				<span class="hljs-keyword">if</span> (framebuffer != VK_NULL_HANDLE)<br>				&#123;<br>					<span class="hljs-built_in">vkDestroyFramebuffer</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), framebuffer, <span class="hljs-literal">nullptr</span>);<br>				&#125;<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">// Create frame buffers for every swap chain image</span><br>		_framebuffers.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_render_frames</span>().<span class="hljs-built_in">size</span>());<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; _framebuffers.<span class="hljs-built_in">size</span>(); i++)<br>		&#123;<br>			<span class="hljs-function">std::vector&lt;VkImageView&gt; <span class="hljs-title">attachments</span><span class="hljs-params">(<span class="hljs-number">3</span>, &#123;&#125;)</span></span>;<br>			<span class="hljs-comment">// Depth/Stencil attachment is the same for all frame buffers</span><br>			attachments[<span class="hljs-number">1</span>] = depth_stencil.view;<br>			<span class="hljs-comment">// Fragment shading rate attachment</span><br>			attachments[<span class="hljs-number">2</span>] = compute_buffers[i].shading_rate_image_view-&gt;<span class="hljs-built_in">get_handle</span>();<br>			<span class="hljs-keyword">if</span> (use_fragment_shading_rate)<br>			&#123;<br>				attachments.<span class="hljs-built_in">emplace_back</span>(compute_buffers[i].frequency_content_image_view-&gt;<span class="hljs-built_in">get_handle</span>());<br>			&#125;<br><br>			VkFramebufferCreateInfo framebuffer_create_info = &#123;&#125;;<br>			framebuffer_create_info.sType                   = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;<br>			framebuffer_create_info.pNext                   = <span class="hljs-literal">nullptr</span>;<br>			framebuffer_create_info.renderPass              = *render_passes[use_fragment_shading_rate];<br>			framebuffer_create_info.attachmentCount         = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attachments.<span class="hljs-built_in">size</span>());<br>			framebuffer_create_info.pAttachments            = attachments.<span class="hljs-built_in">data</span>();<br>			framebuffer_create_info.width                   = <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_surface_extent</span>().width;<br>			framebuffer_create_info.height                  = <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_surface_extent</span>().height;<br>			framebuffer_create_info.layers                  = <span class="hljs-number">1</span>;<br><br>			attachments[<span class="hljs-number">0</span>] = swapchain_buffers[i].view;<br>			<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateFramebuffer</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;framebuffer_create_info, <span class="hljs-literal">nullptr</span>, &amp;_framebuffers[i]));<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先为了创建所需的帧缓冲，需要创建好所有实际的附件资源。程序通过<i><font color="Green">create_shading_rate_attachment</font></i>函数来创建FSR附件、用于存储计算着色器计算的FSR结果的storage image以及频率图像。该函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FragmentShadingRateDynamic::create_shading_rate_attachment</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// Deallocate any existing memory so that it can be reused</span><br>	compute_buffers.<span class="hljs-built_in">clear</span>();<br>	compute_buffers.<span class="hljs-built_in">resize</span>(draw_cmd_buffers.<span class="hljs-built_in">size</span>());<br><br>	subpass_extent = VkExtent2D&#123;<br>	    <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(<span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(width) / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(subpass_extent_ratio))),<br>	    <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(<span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(height) / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(subpass_extent_ratio)))&#125;;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;compute_buffer : compute_buffers)<br>	&#123;<br>		<span class="hljs-keyword">auto</span> &amp;shading_rate_image              = compute_buffer.shading_rate_image;<br>		<span class="hljs-keyword">auto</span> &amp;shading_rate_image_view         = compute_buffer.shading_rate_image_view;<br>		<span class="hljs-keyword">auto</span> &amp;frequency_content_image         = compute_buffer.frequency_content_image;<br>		<span class="hljs-keyword">auto</span> &amp;frequency_content_image_view    = compute_buffer.frequency_content_image_view;<br>		<span class="hljs-keyword">auto</span> &amp;shading_rate_image_compute      = compute_buffer.shading_rate_image_compute;<br>		<span class="hljs-keyword">auto</span> &amp;shading_rate_image_compute_view = compute_buffer.shading_rate_image_compute_view;<br><br>		<span class="hljs-type">const</span> VkFormat     requested_format = VK_FORMAT_R8_UINT;<br>		VkFormatProperties format_properties;<br>		<span class="hljs-built_in">vkGetPhysicalDeviceFormatProperties</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_handle</span>(), requested_format, &amp;format_properties);<br>		<span class="hljs-keyword">if</span> (!(format_properties.optimalTilingFeatures &amp; VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR))<br>		&#123;<br>			<span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Shading rate attachment image does not support required format feature flag.&quot;</span>);<br>		&#125;<br><br>		<span class="hljs-comment">// The shading rate image will be smaller than the frame width and height,</span><br>		<span class="hljs-comment">// which we label here for clarity</span><br>		<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> frame_width = width, frame_height = height;<br>		VkExtent3D     image_extent&#123;&#125;;<br>		image_extent.width  = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(<span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(frame_width) /<br>		                                                 <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(physical_device_fragment_shading_rate_properties.maxFragmentShadingRateAttachmentTexelSize.width)));<br>		image_extent.height = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(<span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(frame_height) /<br>		                                                 <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(physical_device_fragment_shading_rate_properties.maxFragmentShadingRateAttachmentTexelSize.height)));<br>		image_extent.depth  = <span class="hljs-number">1</span>;<br><br>		<span class="hljs-keyword">auto</span> create_shading_rate = [&amp;](VkImageUsageFlags image_usage, VkFormat format) &#123;<br>			<span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::Image&gt;(<span class="hljs-built_in">get_device</span>(),<br>			                                          image_extent,<br>			                                          format,<br>			                                          image_usage,<br>			                                          VMA_MEMORY_USAGE_GPU_ONLY,<br>			                                          VK_SAMPLE_COUNT_1_BIT);<br>		&#125;;<br><br>		shading_rate_image = <span class="hljs-built_in">create_shading_rate</span>(<br>		    VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR | VK_IMAGE_USAGE_TRANSFER_DST_BIT,<br>		    VK_FORMAT_R8_UINT);<br>		shading_rate_image_compute = <span class="hljs-built_in">create_shading_rate</span>(<br>		    VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT,<br>		    VK_FORMAT_R8_UINT);<br><br>		<span class="hljs-type">uint32_t</span> fragment_shading_rate_count = <span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">vkGetPhysicalDeviceFragmentShadingRatesKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_handle</span>(), &amp;fragment_shading_rate_count,<br>		                                           <span class="hljs-literal">nullptr</span>);<br>		<span class="hljs-keyword">if</span> (fragment_shading_rate_count &gt; <span class="hljs-number">0</span>)<br>		&#123;<br>			fragment_shading_rates.<span class="hljs-built_in">resize</span>(fragment_shading_rate_count);<br>			<span class="hljs-keyword">for</span> (VkPhysicalDeviceFragmentShadingRateKHR &amp;fragment_shading_rate : fragment_shading_rates)<br>			&#123;<br>				fragment_shading_rate.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR;<br>			&#125;<br>			<span class="hljs-built_in">vkGetPhysicalDeviceFragmentShadingRatesKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_handle</span>(),<br>			                                           &amp;fragment_shading_rate_count, fragment_shading_rates.<span class="hljs-built_in">data</span>());<br>		&#125;<br><br>		<span class="hljs-comment">// initialize to the lowest shading rate, equal to (min_shading_rate &gt;&gt; 1) | (min_shading_rate &lt;&lt; 1));</span><br>		<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>           min_shading_rate = fragment_shading_rates.<span class="hljs-built_in">front</span>().fragmentSize;<br>		<span class="hljs-function">std::vector&lt;<span class="hljs-type">uint8_t</span>&gt; <span class="hljs-title">temp_buffer</span><span class="hljs-params">(frame_height * frame_width,</span></span><br><span class="hljs-params"><span class="hljs-function">		                                 (min_shading_rate.height &gt;&gt; <span class="hljs-number">1</span>) | ((min_shading_rate.width &lt;&lt; <span class="hljs-number">1</span>) &amp; <span class="hljs-number">12</span>))</span></span>;<br>		<span class="hljs-keyword">auto</span>                 staging_buffer = vkb::core::BufferC::<span class="hljs-built_in">create_staging_buffer</span>(<span class="hljs-built_in">get_device</span>(), temp_buffer);<br><br>		<span class="hljs-keyword">auto</span> cmd = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">create_command_buffer</span>(VK_COMMAND_BUFFER_LEVEL_PRIMARY, <span class="hljs-literal">true</span>);<br><br>		vkb::<span class="hljs-built_in">image_layout_transition</span>(cmd, shading_rate_image-&gt;<span class="hljs-built_in">get_handle</span>(), VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);<br><br>		VkBufferImageCopy buffer_copy_region           = &#123;&#125;;<br>		buffer_copy_region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br>		buffer_copy_region.imageSubresource.layerCount = <span class="hljs-number">1</span>;<br>		buffer_copy_region.imageExtent                 = image_extent;<br>		<span class="hljs-built_in">vkCmdCopyBufferToImage</span>(cmd, staging_buffer.<span class="hljs-built_in">get_handle</span>(), shading_rate_image-&gt;<span class="hljs-built_in">get_handle</span>(),<br>		                       VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, <span class="hljs-number">1</span>, &amp;buffer_copy_region);<br><br>		vkb::<span class="hljs-built_in">image_layout_transition</span>(<br>		    cmd, shading_rate_image-&gt;<span class="hljs-built_in">get_handle</span>(), VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR);<br><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkEndCommandBuffer</span>(cmd));<br><br>		<span class="hljs-keyword">auto</span> submit               = vkb::initializers::<span class="hljs-built_in">submit_info</span>();<br>		submit.commandBufferCount = <span class="hljs-number">1</span>;<br>		submit.pCommandBuffers    = &amp;cmd;<br><br>		<span class="hljs-keyword">auto</span> fence = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">request_fence</span>();<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkQueueSubmit</span>(queue, <span class="hljs-number">1</span>, &amp;submit, fence));<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkWaitForFences</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-number">1</span>, &amp;fence, VK_TRUE, UINT64_MAX));<br><br>		shading_rate_image_view         = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::ImageView&gt;(*shading_rate_image, VK_IMAGE_VIEW_TYPE_2D,<br>                                                                         VK_FORMAT_R8_UINT);<br>		shading_rate_image_compute_view = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::ImageView&gt;(*shading_rate_image_compute,<br>		                                                                         VK_IMAGE_VIEW_TYPE_2D,<br>		                                                                         VK_FORMAT_R8_UINT);<br><br>		<span class="hljs-comment">// Create an attachment to store the frequency content of the rendered image during the render pass</span><br>		VkExtent3D frequency_image_extent&#123;&#125;;<br>		frequency_image_extent.width  = <span class="hljs-keyword">this</span>-&gt;width;<br>		frequency_image_extent.height = <span class="hljs-keyword">this</span>-&gt;height;<br>		frequency_image_extent.depth  = <span class="hljs-number">1</span>;<br>		frequency_content_image       = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::Image&gt;(<span class="hljs-built_in">get_device</span>(),<br>                                                                     frequency_image_extent,<br>                                                                     VK_FORMAT_R8G8_UINT,<br>                                                                     VK_IMAGE_USAGE_STORAGE_BIT |<br>                                                                         VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT |<br>                                                                         VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,<br>                                                                     VMA_MEMORY_USAGE_GPU_ONLY);<br>		frequency_content_image_view  = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::ImageView&gt;(*frequency_content_image,<br>                                                                              VK_IMAGE_VIEW_TYPE_2D,<br>                                                                              VK_FORMAT_R8G8_UINT);<br><br>		&#123;<br>			<span class="hljs-keyword">auto</span> &amp;_cmd = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">request_command_buffer</span>();<br>			_cmd.<span class="hljs-built_in">begin</span>(VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT);<br>			<span class="hljs-keyword">auto</span> _memory_barrier            = vkb::<span class="hljs-built_in">ImageMemoryBarrier</span>();<br>			_memory_barrier.dst_access_mask = <span class="hljs-number">0</span>;<br>			_memory_barrier.src_access_mask = <span class="hljs-number">0</span>;<br>			_memory_barrier.old_layout      = VK_IMAGE_LAYOUT_UNDEFINED;<br>			_memory_barrier.new_layout      = VK_IMAGE_LAYOUT_GENERAL;<br>			_cmd.<span class="hljs-built_in">image_memory_barrier</span>(*shading_rate_image_compute_view, _memory_barrier);<br>			_cmd.<span class="hljs-built_in">image_memory_barrier</span>(*frequency_content_image_view, _memory_barrier);<br>			_cmd.<span class="hljs-built_in">end</span>();<br><br>			<span class="hljs-keyword">auto</span> &amp;queue  = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_by_flags</span>(VK_QUEUE_GRAPHICS_BIT, <span class="hljs-number">0</span>);<br>			<span class="hljs-keyword">auto</span>  _fence = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">request_fence</span>();<br>			queue.<span class="hljs-built_in">submit</span>(_cmd, _fence);<br>			<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkWaitForFences</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-number">1</span>, &amp;_fence, VK_TRUE, UINT64_MAX));<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">compute_buffers</font></i>是一个存储了每一帧各自的FSR资源以及频率图像资源的应用程序类成员，它是一个自定义结构体<code>ComputeBuffers</code>类型的向量，其中<code>ComputeBuffers</code>类定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Shading rate image is an input to the graphics pipeline</span><br><span class="hljs-comment">// and is produced by the &quot;compute shader.&quot;</span><br><span class="hljs-comment">// It has a lower resolution than the framebuffer</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ComputeBuffers</span><br>&#123;<br>	std::unique_ptr&lt;vkb::core::Image&gt;     shading_rate_image;<br>	std::unique_ptr&lt;vkb::core::ImageView&gt; shading_rate_image_view;<br><br>	<span class="hljs-comment">// Frequency content image is an output of the graphics pipeline</span><br>	<span class="hljs-comment">// and is consumed by the &quot;compute shader&quot; to produce the shading rate image.</span><br>	<span class="hljs-comment">// It has the same resolution as the framebuffer</span><br>	std::unique_ptr&lt;vkb::core::Image&gt;     frequency_content_image;<br>	std::unique_ptr&lt;vkb::core::ImageView&gt; frequency_content_image_view;<br><br>	std::unique_ptr&lt;vkb::core::Image&gt;     shading_rate_image_compute;<br>	std::unique_ptr&lt;vkb::core::ImageView&gt; shading_rate_image_compute_view;<br><br>	VkCommandBuffer command_buffer = VK_NULL_HANDLE;<br>	VkDescriptorSet descriptor_set = VK_NULL_HANDLE;<br>&#125;;<br></code></pre></td></tr></table></figure><p><i><font color="Green">create_shading_rate_attachment</font></i>函数用于生成该结构体的所有图像和视图。</p><p>首先注意函数开头处计算得到的<i><font color="Orange">subpass_extent</font></i>，它决定了第二次渲染场景的时候渲染区域的大小，后续计算着色器中使用的频率数据实际上就会是这个分辨率更低的渲染结果。</p><p>之后的FSR图像的创建过程和<strong>fragment_shading_rate</strong>示例中的过程基本一致，这里不再赘述。只需要注意一点，就是程序实际上使用最低的FSR填充了用作FSR附件的图像作为初值，但并没有填充用于计算着色器计算的FSR storage image的初值，这是因为每帧的第一次渲染都会使用上一帧计算得到的FSR附件数据，但第一帧是没有上一帧的，因此需要一个初始数据。</p><p>最后程序创建好了频率图像。注意该图像的大小和后台缓冲大小是一致的。后续我们会看到第二次渲染频率图实际上并不是渲染到一个更小的图像上，只是渲染到该频率图像的一个子区域上。另外还需要注意程序并没有给频率图像数据提供初值。理论上当前帧第一次渲染时使用的频率图像（通过描述符指定）也是上一帧的频率附件呀？我觉得这是因为程序默认的渲染模式是正常渲染颜色，虽然程序可以切换渲染模式到渲染频率图，但是用户的手速不可能极限到在第一帧的时候就将渲染模式切换为渲染频率图吧。。。只要第一帧是正常渲染，那之后的每一帧都会具有上一帧，也就具有上一帧的频率图，即使之后切换了渲染模式着色器也可以正常采样频率图像数据了，因此没有问题。</p><p>回到<i><font color="Green">setup_framebuffer</font></i>函数，在创建好帧缓冲所需的附件资源之后，就可以开始创建实际的帧缓冲对象了。程序创建了两个帧缓冲（严格来说应该是两种帧缓冲，每种帧缓冲为每帧都需要创建一个），<i><font color="Orange">framebuffers</font></i>用于进行UI界面的渲染，而<i><font color="Orange">fragment_framebuffers</font></i>用于实际场景的渲染。可以看到这两种帧缓冲都指定了颜色、深度和FSR附件，并且<i><font color="Orange">fragment_framebuffers</font></i>还额外指定了频率附件。另外，它们兼容的render pass分别指定为<i><font color="Orange">render_pass</font></i>和<i><font color="Orange">fragment_render_pass</font></i>。</p><hr><h2 id="prepare_pipelines">prepare_pipelines</h2><p>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FragmentShadingRateDynamic::prepare_pipelines</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	VkPipelineInputAssemblyStateCreateInfo input_assembly_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_input_assembly_state_create_info</span>(<br>	        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,<br>	        <span class="hljs-number">0</span>,<br>	        VK_FALSE);<br><br>	VkPipelineRasterizationStateCreateInfo rasterization_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_rasterization_state_create_info</span>(<br>	        VK_POLYGON_MODE_FILL,<br>	        VK_CULL_MODE_BACK_BIT,<br>	        VK_FRONT_FACE_COUNTER_CLOCKWISE,<br>	        <span class="hljs-number">0</span>);<br><br>	<span class="hljs-function">std::vector&lt;VkPipelineColorBlendAttachmentState&gt; <span class="hljs-title">blend_attachment_state</span><span class="hljs-params">(<span class="hljs-number">2</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">	                                                                        vkb::initializers::pipeline_color_blend_attachment_state(</span></span><br><span class="hljs-params"><span class="hljs-function">	                                                                            <span class="hljs-number">0xf</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">	                                                                            VK_FALSE))</span></span>;<br><br>	VkPipelineColorBlendStateCreateInfo color_blend_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_color_blend_state_create_info</span>(<br>	        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(blend_attachment_state.<span class="hljs-built_in">size</span>()),<br>	        blend_attachment_state.<span class="hljs-built_in">data</span>());<br><br>	<span class="hljs-comment">// Note: Using reversed depth-buffer for increased precision, so Greater depth values are kept</span><br>	VkPipelineDepthStencilStateCreateInfo depth_stencil_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_depth_stencil_state_create_info</span>(<br>	        VK_FALSE,<br>	        VK_FALSE,<br>	        VK_COMPARE_OP_GREATER);<br><br>	VkPipelineViewportStateCreateInfo viewport_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_viewport_state_create_info</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><br>	VkPipelineMultisampleStateCreateInfo multisample_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_multisample_state_create_info</span>(<br>	        VK_SAMPLE_COUNT_1_BIT,<br>	        <span class="hljs-number">0</span>);<br><br>	std::vector&lt;VkDynamicState&gt; dynamic_state_enables = &#123;<br>	    VK_DYNAMIC_STATE_VIEWPORT,<br>	    VK_DYNAMIC_STATE_SCISSOR,<br>	    <span class="hljs-comment">// Add fragment shading rate dynamic state, so we can easily toggle this at runtime</span><br>	    VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR&#125;;<br>	VkPipelineDynamicStateCreateInfo dynamic_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_dynamic_state_create_info</span>(<br>	        dynamic_state_enables.<span class="hljs-built_in">data</span>(),<br>	        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(dynamic_state_enables.<span class="hljs-built_in">size</span>()),<br>	        <span class="hljs-number">0</span>);<br><br>	VkGraphicsPipelineCreateInfo pipeline_create_info =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_create_info</span>(<br>	        pipeline_layout,<br>	        fragment_render_pass,<br>	        <span class="hljs-number">0</span>);<br><br>	std::vector&lt;VkPipelineColorBlendAttachmentState&gt; blend_attachment_states = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_color_blend_attachment_state</span>(<span class="hljs-number">0xf</span>, VK_FALSE),<br>	&#125;;<br><br>	pipeline_create_info.pInputAssemblyState = &amp;input_assembly_state;<br>	pipeline_create_info.pRasterizationState = &amp;rasterization_state;<br>	pipeline_create_info.pColorBlendState    = &amp;color_blend_state;<br>	pipeline_create_info.pMultisampleState   = &amp;multisample_state;<br>	pipeline_create_info.pViewportState      = &amp;viewport_state;<br>	pipeline_create_info.pDepthStencilState  = &amp;depth_stencil_state;<br>	pipeline_create_info.pDynamicState       = &amp;dynamic_state;<br><br>	std::array&lt;VkPipelineShaderStageCreateInfo, 2&gt; shader_stages&#123;&#125;;<br>	pipeline_create_info.stageCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(shader_stages.<span class="hljs-built_in">size</span>());<br>	pipeline_create_info.pStages    = shader_stages.<span class="hljs-built_in">data</span>();<br><br>	<span class="hljs-comment">// Vertex bindings an attributes for model rendering</span><br>	std::vector&lt;VkVertexInputBindingDescription&gt; vertex_input_bindings = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_binding_description</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Vertex), VK_VERTEX_INPUT_RATE_VERTEX),<br>	&#125;;<br>	std::vector&lt;VkVertexInputAttributeDescription&gt; vertex_input_attributes = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, VK_FORMAT_R32G32B32_SFLOAT,<br>	                                                          <span class="hljs-number">0</span>),        <span class="hljs-comment">// Position</span><br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, VK_FORMAT_R32G32B32_SFLOAT,<br>	                                                          <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>) * <span class="hljs-number">3</span>),        <span class="hljs-comment">// Normal</span><br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, VK_FORMAT_R32G32_SFLOAT,<br>	                                                          <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>) * <span class="hljs-number">6</span>),        <span class="hljs-comment">// UV</span><br>	&#125;;<br><br>	VkPipelineVertexInputStateCreateInfo vertex_input_state = vkb::initializers::<span class="hljs-built_in">pipeline_vertex_input_state_create_info</span>();<br>	vertex_input_state.vertexBindingDescriptionCount        = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertex_input_bindings.<span class="hljs-built_in">size</span>());<br>	vertex_input_state.pVertexBindingDescriptions           = vertex_input_bindings.<span class="hljs-built_in">data</span>();<br>	vertex_input_state.vertexAttributeDescriptionCount      = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertex_input_attributes.<span class="hljs-built_in">size</span>());<br>	vertex_input_state.pVertexAttributeDescriptions         = vertex_input_attributes.<span class="hljs-built_in">data</span>();<br><br>	pipeline_create_info.pVertexInputState = &amp;vertex_input_state;<br>	pipeline_create_info.layout            = pipeline_layout;<br>	pipeline_create_info.subpass           = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">// Sky-sphere</span><br>	shader_stages[<span class="hljs-number">0</span>] = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;fragment_shading_rate_dynamic/scene.vert&quot;</span>, VK_SHADER_STAGE_VERTEX_BIT);<br>	shader_stages[<span class="hljs-number">1</span>] = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;fragment_shading_rate_dynamic/scene.frag&quot;</span>, VK_SHADER_STAGE_FRAGMENT_BIT);<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateGraphicsPipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;pipeline_create_info, <span class="hljs-literal">nullptr</span>,<br>	                                   &amp;pipelines.skysphere));<br><br>	<span class="hljs-comment">// Objects</span><br>	<span class="hljs-comment">// Enable depth test and write</span><br>	depth_stencil_state.depthWriteEnable = VK_TRUE;<br>	depth_stencil_state.depthTestEnable  = VK_TRUE;<br>	<span class="hljs-comment">// Flip cull mode</span><br>	rasterization_state.cullMode = VK_CULL_MODE_FRONT_BIT;<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateGraphicsPipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;pipeline_create_info, <span class="hljs-literal">nullptr</span>,<br>	                                   &amp;pipelines.sphere));<br>&#125;<br></code></pre></td></tr></table></figure><p>关于该函数中动态阶段的设定在<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2025/03/14/CG_api/vulkan/vulkan_samples/fragment_shading_rate/"><code>之前的博客</code></a>中已经详细阐明了。这里只需要说明创建的两个渲染管线所使用的render pass都是<i><font color="Orange">fragment_render_pass</font></i>而不是默认的<i><font color="Orange">render_pass</font></i>，默认的<i><font color="Orange">render_pass</font></i>只用于UI界面的渲染。</p><p>然后来看管线使用到的着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//vertex shader</span><br><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inPos;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inNormal;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inUV;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> UBO<br>&#123;<br>	<span class="hljs-type">mat4</span> projection;<br>	<span class="hljs-type">mat4</span> modelview;<br>	<span class="hljs-type">mat4</span> skybox_modelview;<br>	<span class="hljs-type">int</span>  color_shading_rates;<br>&#125;<br>ubo;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> outUV;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> outPos;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> outNormal;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> outViewVec;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">4</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> outLightVec;<br><br><span class="hljs-keyword">layout</span>(push_constant) <span class="hljs-keyword">uniform</span> Push_Constants<br>&#123;<br>	<span class="hljs-type">vec4</span> <span class="hljs-keyword">offset</span>;<br>	<span class="hljs-type">int</span>  object_type;<br>&#125;<br>push_constants;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>	<span class="hljs-keyword">switch</span> (push_constants.object_type)<br>	&#123;<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:        <span class="hljs-comment">// Skysphere</span><br>			outPos      = <span class="hljs-type">vec3</span>(<span class="hljs-type">mat3</span>(ubo.skybox_modelview) * inPos);<br>			<span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(ubo.projection * <span class="hljs-type">vec4</span>(outPos, <span class="hljs-number">1.0</span>));<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:        <span class="hljs-comment">// Object</span><br>			<span class="hljs-type">vec3</span> localPos = inPos + push_constants.<span class="hljs-keyword">offset</span>.xyz;<br>			outPos        = <span class="hljs-type">vec3</span>(ubo.modelview * <span class="hljs-type">vec4</span>(localPos, <span class="hljs-number">1.0</span>));<br>			<span class="hljs-built_in">gl_Position</span>   = ubo.projection * ubo.modelview * <span class="hljs-type">vec4</span>(localPos, <span class="hljs-number">1.0</span>);<br>			<span class="hljs-keyword">break</span>;<br>	&#125;<br>	outUV         = inUV;<br>	outNormal     = <span class="hljs-type">mat3</span>(ubo.modelview) * inNormal;<br>	<span class="hljs-type">vec3</span> lightPos = <span class="hljs-type">mat3</span>(ubo.modelview) * <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">-10.0</span>, <span class="hljs-number">-10.0</span>);<br>	outLightVec   = lightPos.xyz - outPos.xyz;<br>	outViewVec    = -outPos.xyz;<br>&#125;<br><br><span class="hljs-comment">//fragment shader</span><br><span class="hljs-meta">#version 450</span><br><br><span class="hljs-meta">#extension GL_EXT_fragment_shading_rate : require</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> samplerEnvMap;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> samplerSphere;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">3</span>, <span class="hljs-keyword">rg8ui</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-keyword">readonly</span> <span class="hljs-type">uimage2D</span> input_frequency;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">4</span>, <span class="hljs-keyword">r8ui</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-keyword">readonly</span> <span class="hljs-type">uimage2D</span> output_sampling_rate;<br><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inUV;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inPos;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inNormal;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inViewVec;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">4</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inLightVec;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> UBO<br>&#123;<br>	<span class="hljs-type">mat4</span> projection;<br>	<span class="hljs-type">mat4</span> modelview;<br>	<span class="hljs-type">mat4</span> skybox_modelview;<br>	<span class="hljs-type">int</span>  color_shading_rates;<br>&#125;<br>ubo;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outColor;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">uvec2</span> outFrequency;<br><br><span class="hljs-keyword">layout</span>(push_constant) <span class="hljs-keyword">uniform</span> Push_Constants<br>&#123;<br>	<span class="hljs-type">vec4</span> <span class="hljs-keyword">offset</span>;<br>	<span class="hljs-type">int</span>  object_type;<br>&#125;<br>push_constants;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>	<span class="hljs-type">vec4</span>  color;<br>	<span class="hljs-type">float</span> freq_x = <span class="hljs-number">0</span>, freq_y = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-keyword">switch</span> (push_constants.object_type)<br>	&#123;<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:        <span class="hljs-comment">// Skysphere</span><br>		&#123;<br>			color   = <span class="hljs-built_in">texture</span>(samplerEnvMap, <span class="hljs-type">vec2</span>(inUV.s, <span class="hljs-number">1.0</span> - inUV.t));<br>			<span class="hljs-type">vec3</span> dx = <span class="hljs-built_in">dFdx</span>(color.xyz);<br>			<span class="hljs-type">vec3</span> dy = <span class="hljs-built_in">dFdx</span>(color.xyz);<br>			freq_x  = <span class="hljs-built_in">dot</span>(dx, dx);<br>			freq_y  = <span class="hljs-built_in">dot</span>(dy, dy);<br>		&#125;<br>		<span class="hljs-keyword">break</span>;<br><br>		<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:        <span class="hljs-comment">// Phong shading</span><br>		&#123;<br>			<span class="hljs-type">vec4</span> tex_value = <span class="hljs-built_in">texture</span>(samplerSphere, <span class="hljs-type">vec2</span>(inUV.s, <span class="hljs-number">1.0</span> - inUV.t));<br>			<span class="hljs-type">vec3</span> ambient   = tex_value.rgb;<br>			<span class="hljs-type">vec3</span> N         = <span class="hljs-built_in">normalize</span>(inNormal);<br>			<span class="hljs-type">vec3</span> L         = <span class="hljs-built_in">normalize</span>(inLightVec);<br>			<span class="hljs-type">vec3</span> V         = <span class="hljs-built_in">normalize</span>(inViewVec);<br>			<span class="hljs-type">vec3</span> R         = <span class="hljs-built_in">reflect</span>(-L, N);<br>			<span class="hljs-type">vec3</span> diffuse   = <span class="hljs-type">vec3</span>(<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N, L), <span class="hljs-number">0.0</span>));<br>			<span class="hljs-type">vec3</span> specular  = <span class="hljs-type">vec3</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(R, V), <span class="hljs-number">0.0</span>), <span class="hljs-number">8.0</span>));<br>			color          = <span class="hljs-type">vec4</span>(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);<br>			<span class="hljs-type">vec3</span> dx        = <span class="hljs-built_in">dFdx</span>(color.xyz);<br>			<span class="hljs-type">vec3</span> dy        = <span class="hljs-built_in">dFdy</span>(color.xyz);<br>			freq_x         = <span class="hljs-built_in">dot</span>(dx, dx);<br>			freq_y         = <span class="hljs-built_in">dot</span>(dy, dy);<br>		&#125;<br>		<span class="hljs-keyword">break</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (ubo.color_shading_rates == <span class="hljs-number">1</span>)<br>	&#123;<br>		<span class="hljs-comment">// Visualize fragment shading rates</span><br><br>		<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>;<br>		<span class="hljs-type">int</span> h = <span class="hljs-number">1</span>;<br><br>		<span class="hljs-keyword">if</span> ((gl_ShadingRateEXT &amp; gl_ShadingRateFlag2VerticalPixelsEXT) == gl_ShadingRateFlag2VerticalPixelsEXT)<br>		&#123;<br>			v = <span class="hljs-number">2</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span> ((gl_ShadingRateEXT &amp; gl_ShadingRateFlag4VerticalPixelsEXT) == gl_ShadingRateFlag4VerticalPixelsEXT)<br>		&#123;<br>			v = <span class="hljs-number">4</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span> ((gl_ShadingRateEXT &amp; gl_ShadingRateFlag2HorizontalPixelsEXT) == gl_ShadingRateFlag2HorizontalPixelsEXT)<br>		&#123;<br>			h = <span class="hljs-number">2</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span> ((gl_ShadingRateEXT &amp; gl_ShadingRateFlag4HorizontalPixelsEXT) == gl_ShadingRateFlag4HorizontalPixelsEXT)<br>		&#123;<br>			h = <span class="hljs-number">4</span>;<br>		&#125;<br><br>		outColor = <span class="hljs-type">vec4</span>(<span class="hljs-type">vec3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> - h * v / <span class="hljs-number">16.0</span>), <span class="hljs-number">1</span>);<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ubo.color_shading_rates == <span class="hljs-number">2</span>)<br>	&#123;<br>		<span class="hljs-type">ivec2</span> coord = <span class="hljs-type">ivec2</span>(<span class="hljs-built_in">gl_FragCoord</span>);<br>		outColor = <span class="hljs-built_in">imageLoad</span>(input_frequency, coord);<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ubo.color_shading_rates == <span class="hljs-number">3</span>)<br>	&#123;<br>		<span class="hljs-type">ivec2</span> coord = <span class="hljs-type">ivec2</span>(<span class="hljs-built_in">gl_FragCoord</span>);<br>		<span class="hljs-type">ivec2</span> rate_size = <span class="hljs-built_in">imageSize</span>(output_sampling_rate).xy;<br>		<span class="hljs-type">ivec2</span> freq_size = <span class="hljs-built_in">imageSize</span>(input_frequency).xy;<br>		<span class="hljs-type">ivec2</span> rate_coord = <span class="hljs-type">ivec2</span>(<span class="hljs-built_in">floor</span>(<span class="hljs-type">vec2</span>(coord) / <span class="hljs-type">vec2</span>(freq_size / rate_size)));<br>		<span class="hljs-type">uint</span> texel = <span class="hljs-built_in">imageLoad</span>(output_sampling_rate, rate_coord).r;<br>		<span class="hljs-type">uint</span> width = <span class="hljs-built_in">min</span>(<span class="hljs-type">uint</span>(<span class="hljs-built_in">floor</span>((<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, texel &amp; <span class="hljs-number">12</span>)))), <span class="hljs-number">4</span>);<br>		<span class="hljs-type">uint</span> height = <span class="hljs-built_in">min</span>(<span class="hljs-type">uint</span>(<span class="hljs-built_in">floor</span>((<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, texel &amp; <span class="hljs-number">3</span>)))), <span class="hljs-number">4</span>);<br>		outColor = <span class="hljs-type">vec4</span>(<span class="hljs-type">vec3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> - width * height / <span class="hljs-number">16.0</span>), <span class="hljs-number">1</span>);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		outColor = <span class="hljs-type">vec4</span>(color.rgb, <span class="hljs-number">1.0</span>);<br>	&#125;<br>	outFrequency = <span class="hljs-type">uvec2</span>(<span class="hljs-number">255</span> * freq_x, <span class="hljs-number">255</span> * freq_y);<br>&#125;<br></code></pre></td></tr></table></figure><p>顶点着色器得的代码逻辑十分常规，不再具体分析，下面来简单看下片段着色器的代码。</p><p>可以看到，片段着色器会根据传入的uniform变量<i><font color="Orange">color_shading_rates</font></i>来决定之后的渲染模式，0代表渲染正常颜色，1代表渲染频率图，2代表渲染当前像素的FSR值（这部分的有关说明在<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2025/03/14/CG_api/vulkan/vulkan_samples/fragment_shading_rate/"><code>上一篇博客</code></a>中也已经有说明），3是我自己添加上去的逻辑，后续在文章的结尾我会解释3的逻辑以及2、3之间的区别。</p><p>另外，注意到该着色器渲染频率图的方法就是直接对频率图进行采样（使用的直接是整张图像的坐标而不是缩小版图像的坐标），而频率图在上一帧实际上进行了两次渲染，第一次渲染了一个完整的频率图，第二次将这个图像渲染到了整个窗口的一部分（后面看录制命令函数的时候会看到）。而由于频率附件的存储操作为store，也就意味着这两次渲染得到的图像都会保留下来，并且后一次渲染的图像会覆盖前一次渲染图像的一部分（另外一部分仍然会显示原来的图像，因为尽管指定了频率附件的加载操作是clear，但第二次渲染只是在整个图像的一个子区域上渲染，因此加载时只会清除这一部分的图像，其余部分仍然保留）。这就是为什么上面视频中当渲染模式设置为显示频率图时我们可以看到左上角有一个缩小版的图像的原因。</p><hr><h2 id="create_compute_pipeline">create_compute_pipeline</h2><p>该函数用于构建计算管线并且录制计算有关的命令。函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FragmentShadingRateDynamic::create_compute_pipeline</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// Descriptor set layout</span><br>	std::vector&lt;VkDescriptorSetLayoutBinding&gt; set_layout_bindings = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,<br>	                                                     VK_SHADER_STAGE_COMPUTE_BIT, <span class="hljs-number">0</span>),<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,<br>	                                                     VK_SHADER_STAGE_COMPUTE_BIT, <span class="hljs-number">1</span>),<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,<br>	                                                     VK_SHADER_STAGE_COMPUTE_BIT, <span class="hljs-number">2</span>),<br>	&#125;;<br><br>	VkDescriptorSetLayoutCreateInfo descriptor_layout_create_info = vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_create_info</span>(<br>	    set_layout_bindings);<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorSetLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_layout_create_info, VK_NULL_HANDLE,<br>	                                     &amp;compute.descriptor_set_layout));<br><br>	VkPipelineLayoutCreateInfo pipeline_layout_create_info = vkb::initializers::<span class="hljs-built_in">pipeline_layout_create_info</span>(<br>	    &amp;compute.descriptor_set_layout, <span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreatePipelineLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;pipeline_layout_create_info, VK_NULL_HANDLE,<br>	                                &amp;compute.pipeline_layout));<br><br>	<span class="hljs-comment">// Descriptor pool</span><br>	<span class="hljs-keyword">if</span> (compute.descriptor_pool)<br>	&#123;<br>		<span class="hljs-built_in">vkDestroyDescriptorPool</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), compute.descriptor_pool, VK_NULL_HANDLE);<br>		compute.descriptor_pool = VK_NULL_HANDLE;<br>	&#125;<br><br>	<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>                        N     = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(draw_cmd_buffers.<span class="hljs-built_in">size</span>());<br>	std::vector&lt;VkDescriptorPoolSize&gt; sizes = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_pool_size</span>(VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, <span class="hljs-number">4</span> * N),<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_pool_size</span>(VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, <span class="hljs-number">4</span> * N)&#125;;<br>	<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> pool_create = vkb::initializers::<span class="hljs-built_in">descriptor_pool_create_info</span>(sizes, N);<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorPool</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;pool_create, VK_NULL_HANDLE, &amp;compute.descriptor_pool));<br><br>	<span class="hljs-comment">// Descriptor sets</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;compute_buffer : compute_buffers)<br>	&#123;<br>		VkDescriptorSetAllocateInfo alloc_info = vkb::initializers::<span class="hljs-built_in">descriptor_set_allocate_info</span>(<br>		    compute.descriptor_pool, &amp;compute.descriptor_set_layout, <span class="hljs-number">1</span>);<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;alloc_info, &amp;compute_buffer.descriptor_set));<br>	&#125;<br><br>	<span class="hljs-comment">// Pipeline</span><br>	VkComputePipelineCreateInfo pipeline_create_info = vkb::initializers::<span class="hljs-built_in">compute_pipeline_create_info</span>(<br>	    compute.pipeline_layout);<br>	pipeline_create_info.stage = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;fragment_shading_rate_dynamic/generate_shading_rate.comp&quot;</span>,<br>	                                         VK_SHADER_STAGE_COMPUTE_BIT);<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateComputePipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;pipeline_create_info, VK_NULL_HANDLE,<br>	                                  &amp;compute.pipeline));<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;compute_buffer : compute_buffers)<br>	&#123;<br>		<span class="hljs-keyword">auto</span> create = vkb::initializers::<span class="hljs-built_in">command_buffer_allocate_info</span>(command_pool, VK_COMMAND_BUFFER_LEVEL_PRIMARY, <span class="hljs-number">1</span>);<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateCommandBuffers</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;create, &amp;compute_buffer.command_buffer));<br>	&#125;<br>	<span class="hljs-built_in">update_compute_pipeline</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p></p><p>首先创建管线布局，为此需要创建描述符布局。计算着色器会使用到一个频率图作为输入，一个FSR图作为输出，以及一个传递一些图像大小、FSR种类信息的常量缓冲。然后函数分配好每个<code>ComputeBuffer</code>中使用到的描述符集以及命令缓冲，最后在<i><font color="Green">update_compute_pipeline</font></i>函数中会是用该命令缓冲录制计算命令。该函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FragmentShadingRateDynamic::update_compute_pipeline</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// Update array</span><br>	<span class="hljs-built_in">assert</span>(!fragment_shading_rates.<span class="hljs-built_in">empty</span>());<br><br>	<span class="hljs-type">uint32_t</span>                max_rate_x = <span class="hljs-number">0</span>, max_rate_y = <span class="hljs-number">0</span>;<br>	std::vector&lt;glm::uvec2&gt; shading_rates_u_vec_2;<br>	shading_rates_u_vec_<span class="hljs-number">2.</span><span class="hljs-built_in">reserve</span>(fragment_shading_rates.<span class="hljs-built_in">size</span>());<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;rate : fragment_shading_rates)<br>	&#123;<br>		max_rate_x = std::<span class="hljs-built_in">max</span>(max_rate_x, rate.fragmentSize.width);<br>		max_rate_y = std::<span class="hljs-built_in">max</span>(max_rate_y, rate.fragmentSize.height);<br>		shading_rates_u_vec_<span class="hljs-number">2.</span><span class="hljs-built_in">emplace_back</span>(glm::<span class="hljs-built_in">uvec2</span>(rate.fragmentSize.width, rate.fragmentSize.height));<br>	&#125;<br><br>	<span class="hljs-built_in">assert</span>(max_rate_x &amp;&amp; max_rate_y);<br>	FrequencyInformation params&#123;<br>	    glm::<span class="hljs-built_in">uvec2</span>(subpass_extent.width, subpass_extent.height),<br>	    glm::<span class="hljs-built_in">uvec2</span>(compute_buffers[<span class="hljs-number">0</span>].shading_rate_image-&gt;<span class="hljs-built_in">get_extent</span>().width,<br>	               compute_buffers[<span class="hljs-number">0</span>].shading_rate_image-&gt;<span class="hljs-built_in">get_extent</span>().height),<br>	    glm::<span class="hljs-built_in">uvec2</span>(max_rate_x, max_rate_y),<br>	    <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(fragment_shading_rates.<span class="hljs-built_in">size</span>()),<br>	    <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(<span class="hljs-number">0</span>)&#125;;<br><br>	<span class="hljs-comment">// Transfer frequency information to buffer</span><br>	<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> buffer_size =<br>	    <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(<span class="hljs-built_in">sizeof</span>(FrequencyInformation) + shading_rates_u_vec_<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(shading_rates_u_vec_2[<span class="hljs-number">0</span>]));<br>	frequency_information_params = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), buffer_size,<br>	                                                                    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,<br>	                                                                    VMA_MEMORY_USAGE_CPU_TO_GPU);<br>	frequency_information_params-&gt;<span class="hljs-built_in">update</span>(&amp;params, <span class="hljs-built_in">sizeof</span>(FrequencyInformation), <span class="hljs-number">0</span>);<br>	frequency_information_params-&gt;<span class="hljs-built_in">update</span>(shading_rates_u_vec_<span class="hljs-number">2.</span><span class="hljs-built_in">data</span>(),<br>	                                     shading_rates_u_vec_<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(shading_rates_u_vec_2[<span class="hljs-number">0</span>]),<br>	                                     <span class="hljs-built_in">sizeof</span>(FrequencyInformation));<br><br>	<span class="hljs-comment">// Update descriptor sets</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;compute_buffer : compute_buffers)<br>	&#123;<br>		<span class="hljs-keyword">auto</span> &amp;shading_rate_image              = compute_buffer.shading_rate_image;<br>		<span class="hljs-keyword">auto</span> &amp;shading_rate_image_view         = compute_buffer.shading_rate_image_view;<br>		<span class="hljs-keyword">auto</span> &amp;frequency_content_image         = compute_buffer.frequency_content_image;<br>		<span class="hljs-keyword">auto</span> &amp;frequency_content_image_view    = compute_buffer.frequency_content_image_view;<br>		<span class="hljs-keyword">auto</span> &amp;shading_rate_image_compute      = compute_buffer.shading_rate_image_compute;<br>		<span class="hljs-keyword">auto</span> &amp;shading_rate_image_compute_view = compute_buffer.shading_rate_image_compute_view;<br><br>		VkDescriptorImageInfo               frequency_image       = vkb::initializers::<span class="hljs-built_in">descriptor_image_info</span>(VK_NULL_HANDLE,<br>		                                                                                                     frequency_content_image_view-&gt;<span class="hljs-built_in">get_handle</span>(),<br>		                                                                                                     VK_IMAGE_LAYOUT_GENERAL);<br>		VkDescriptorImageInfo               shading_image         = vkb::initializers::<span class="hljs-built_in">descriptor_image_info</span>(VK_NULL_HANDLE,<br>		                                                                                                     shading_rate_image_compute_view-&gt;<span class="hljs-built_in">get_handle</span>(),<br>		                                                                                                     VK_IMAGE_LAYOUT_GENERAL);<br>		VkDescriptorBufferInfo              buffer_info           = <span class="hljs-built_in">create_descriptor</span>(*frequency_information_params);<br>		std::array&lt;VkWriteDescriptorSet, 3&gt; write_descriptor_sets = &#123;<br>		    vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(compute_buffer.descriptor_set, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,<br>		                                            <span class="hljs-number">0</span>, &amp;frequency_image),<br>		    vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(compute_buffer.descriptor_set, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,<br>		                                            <span class="hljs-number">1</span>, &amp;shading_image),<br>		    vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(compute_buffer.descriptor_set,<br>		                                            VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, <span class="hljs-number">2</span>, &amp;buffer_info)&#125;;<br>		<span class="hljs-built_in">vkUpdateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(write_descriptor_sets.<span class="hljs-built_in">size</span>()),<br>		                       write_descriptor_sets.<span class="hljs-built_in">data</span>(), <span class="hljs-number">0</span>, VK_NULL_HANDLE);<br><br>		<span class="hljs-comment">// Command Buffer</span><br>		<span class="hljs-built_in">assert</span>(compute_buffer.command_buffer);<br>		<span class="hljs-keyword">auto</span> &amp;command_buffer = compute_buffer.command_buffer;<br><br>		<span class="hljs-keyword">auto</span> begin = vkb::initializers::<span class="hljs-built_in">command_buffer_begin_info</span>();<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBeginCommandBuffer</span>(command_buffer, &amp;begin));<br><br>		<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>     fragment_extent = compute_buffer.shading_rate_image-&gt;<span class="hljs-built_in">get_extent</span>();<br>		<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> fragment_width = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(<span class="hljs-number">1</span>), fragment_extent.width), fragment_height = std::<span class="hljs-built_in">max</span>(<br>		                                                                                               <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(<span class="hljs-number">1</span>), fragment_extent.height);<br><br>		<span class="hljs-built_in">vkCmdBindPipeline</span>(command_buffer, VK_PIPELINE_BIND_POINT_COMPUTE, compute.pipeline);<br>		<span class="hljs-built_in">vkCmdBindDescriptorSets</span>(command_buffer, VK_PIPELINE_BIND_POINT_COMPUTE, compute.pipeline_layout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<br>		                        &amp;compute_buffer.descriptor_set, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>		<span class="hljs-built_in">vkCmdDispatch</span>(command_buffer, <span class="hljs-number">1</span> + (fragment_width - <span class="hljs-number">1</span>) / <span class="hljs-number">8</span>, <span class="hljs-number">1</span> + (fragment_height - <span class="hljs-number">1</span>) / <span class="hljs-number">8</span>, <span class="hljs-number">1</span>);<br><br>		VkImageCopy image_copy;<br>		image_copy.srcSubresource = &#123;VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>		image_copy.dstOffset      = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>		image_copy.dstSubresource = &#123;VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>		image_copy.extent         = shading_rate_image-&gt;<span class="hljs-built_in">get_extent</span>();<br>		image_copy.srcOffset      = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><br>		vkb::<span class="hljs-built_in">image_layout_transition</span>(<br>		    command_buffer, shading_rate_image-&gt;<span class="hljs-built_in">get_handle</span>(), VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);<br><br>		VkImageSubresourceRange subresource_range = &#123;VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>		vkb::<span class="hljs-built_in">image_layout_transition</span>(command_buffer,<br>		                             shading_rate_image_compute-&gt;<span class="hljs-built_in">get_handle</span>(),<br>		                             VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,<br>		                             VK_PIPELINE_STAGE_TRANSFER_BIT,<br>		                             VK_ACCESS_SHADER_WRITE_BIT,<br>		                             VK_ACCESS_TRANSFER_READ_BIT,<br>		                             VK_IMAGE_LAYOUT_GENERAL,<br>		                             VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,<br>		                             subresource_range);<br><br>		<span class="hljs-built_in">vkCmdCopyImage</span>(command_buffer, shading_rate_image_compute-&gt;<span class="hljs-built_in">get_handle</span>(), VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,<br>		               shading_rate_image-&gt;<span class="hljs-built_in">get_handle</span>(), VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, <span class="hljs-number">1</span>, &amp;image_copy);<br><br>		vkb::<span class="hljs-built_in">image_layout_transition</span>(<br>		    command_buffer, shading_rate_image-&gt;<span class="hljs-built_in">get_handle</span>(), VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR);<br><br>		vkb::<span class="hljs-built_in">image_layout_transition</span>(command_buffer,<br>		                             shading_rate_image_compute-&gt;<span class="hljs-built_in">get_handle</span>(),<br>		                             VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,<br>		                             VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,<br>		                             &#123;&#125;,<br>		                             &#123;&#125;,<br>		                             VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,<br>		                             VK_IMAGE_LAYOUT_GENERAL,<br>		                             subresource_range);<br><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkEndCommandBuffer</span>(compute_buffer.command_buffer));<br><br>		<span class="hljs-keyword">if</span> (debug_utils_supported)<br>		&#123;<br>			<span class="hljs-keyword">auto</span> set_name = [device&#123;<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>()&#125;](VkObjectType object_type, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,<br>			                                                    <span class="hljs-type">const</span> <span class="hljs-type">void</span> *handle) &#123;<br>				VkDebugUtilsObjectNameInfoEXT name_info = &#123;VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT&#125;;<br>				name_info.objectType                    = object_type;<br>				name_info.objectHandle                  = (<span class="hljs-type">uint64_t</span>) handle;<br>				name_info.pObjectName                   = name;<br>				<span class="hljs-built_in">vkSetDebugUtilsObjectNameEXT</span>(device, &amp;name_info);<br>			&#125;;<br>			<span class="hljs-built_in">set_name</span>(VK_OBJECT_TYPE_IMAGE_VIEW, <span class="hljs-string">&quot;shading_rate_image_compute_view&quot;</span>,<br>			         <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span> *&gt;(shading_rate_image_compute_view-&gt;<span class="hljs-built_in">get_handle</span>()));<br>			<span class="hljs-built_in">set_name</span>(VK_OBJECT_TYPE_IMAGE_VIEW, <span class="hljs-string">&quot;shading_rate_image_view&quot;</span>, <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span> *&gt;(shading_rate_image_view-&gt;<span class="hljs-built_in">get_handle</span>()));<br>			<span class="hljs-built_in">set_name</span>(VK_OBJECT_TYPE_IMAGE_VIEW, <span class="hljs-string">&quot;frequency_content_image_view&quot;</span>,<br>			         <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span> *&gt;(frequency_content_image_view-&gt;<span class="hljs-built_in">get_handle</span>()));<br>			<span class="hljs-built_in">set_name</span>(VK_OBJECT_TYPE_IMAGE, <span class="hljs-string">&quot;shading_rate_image_compute&quot;</span>, <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span> *&gt;(shading_rate_image_compute-&gt;<span class="hljs-built_in">get_handle</span>()));<br>			<span class="hljs-built_in">set_name</span>(VK_OBJECT_TYPE_IMAGE, <span class="hljs-string">&quot;shading_rate_image&quot;</span>, <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span> *&gt;(shading_rate_image-&gt;<span class="hljs-built_in">get_handle</span>()));<br>			<span class="hljs-built_in">set_name</span>(VK_OBJECT_TYPE_IMAGE, <span class="hljs-string">&quot;frequency_content_image&quot;</span>, <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span> *&gt;(frequency_content_image-&gt;<span class="hljs-built_in">get_handle</span>()));<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数首先是将所有硬件支持的FSR大小存储在一个向量中，之后该向量内的数据会上传到计算着色器使用的GPU常量缓冲中，同时程序也记录下了最大支持的FSR大小。程序将需要上传给常量缓冲区的数据打包在了一个自定义类<code>FrequencyInformation</code>中，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FrequencyInformation</span><br>&#123;<br>	glm::uvec2 frame_dimensions;<br>	glm::uvec2 shading_rate_dimensions;<br>	glm::uvec2 max_rates;<br>	<span class="hljs-type">uint32_t</span>   n_rates;<br>	<span class="hljs-type">uint32_t</span>   _pad;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里的<i><font color="Orange">frame_dimensions</font></i>记录的是第二次渲染的区域大小，毕竟计算着色器使用的频率图会是第二次渲染得到的频率图。</p><p>在CPU端准备好这些数据之后，就可以创建常量缓冲区<i><font color="Orange">frequency_information_params</font></i>并且将所有的数据上传了。然后，程序指定了每一帧描述符的绑定和更新方式（每一帧都具有自己的频率图和输出FSR图，但共用一个constant buffer）。最后代码开始录制计算阶段的命令。命令逻辑十分简答，就是让一个线程负责一个FSR图像素的计算（本示例是定义一个线程组的x,y维度分别指定8个线程），在计算结束之后，需要将输出FSR图的内容复制到同一帧对应的FSR附件中供下一帧使用，其中需要进行一系列的布局转换，这里不再具体分析。</p><p>最后来看计算着色器的代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">local_size_x</span> = <span class="hljs-number">8</span>, <span class="hljs-keyword">local_size_y</span> = <span class="hljs-number">8</span>) <span class="hljs-keyword">in</span>;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">rg8ui</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-keyword">readonly</span> <span class="hljs-type">uimage2D</span> input_frequency;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>, <span class="hljs-keyword">r8ui</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-keyword">writeonly</span> <span class="hljs-type">uimage2D</span> output_sampling_rate;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">buffer</span> FrequencyInformation<br>&#123;<br>	<span class="hljs-type">uvec4</span> settings;                     <span class="hljs-comment">// &#123;frame_width, frame_height, output_width, output_height&#125;</span><br>	<span class="hljs-type">uvec4</span> frequency_information;        <span class="hljs-comment">// &#123; max_rate_x, max_rate_y, n_rates, ...&#125;</span><br>	<span class="hljs-type">uvec2</span> rates[];<br>&#125;<br>params;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>	<span class="hljs-keyword">const</span> <span class="hljs-type">uint</span> x0            = <span class="hljs-built_in">gl_GlobalInvocationID</span>.x,<br>	           y0            = <span class="hljs-built_in">gl_GlobalInvocationID</span>.y,<br>	           frame_width   = params.settings[<span class="hljs-number">0</span>],<br>	           frame_height  = params.settings[<span class="hljs-number">1</span>],<br>	           output_width  = params.settings[<span class="hljs-number">2</span>],<br>	           output_height = params.settings[<span class="hljs-number">3</span>];<br><br>	<span class="hljs-keyword">const</span> <span class="hljs-type">uint</span> delta_x = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-type">uint</span>(<span class="hljs-built_in">round</span>(<span class="hljs-type">float</span>(frame_width) / <span class="hljs-type">float</span>(output_width)))),<br>	           delta_y = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-type">uint</span>(<span class="hljs-built_in">round</span>(<span class="hljs-type">float</span>(frame_height) / <span class="hljs-type">float</span>(output_height))));<br>	<span class="hljs-keyword">if</span> (x0 &gt;= output_width || y0 &gt;= output_height)<br>	&#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-type">vec2</span> max_freqs = <span class="hljs-type">vec2</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">uint</span> i = <span class="hljs-number">0</span>; i &lt; delta_x; ++i)<br>	&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">uint</span> j = <span class="hljs-number">0</span>; j &lt; delta_y; ++j)<br>		&#123;<br>			<span class="hljs-type">ivec2</span> coord = <span class="hljs-type">ivec2</span>(delta_x * x0 + i, delta_y * y0 + j);<br>			<span class="hljs-type">vec2</span>  freq  = <span class="hljs-type">vec2</span>(<span class="hljs-built_in">imageLoad</span>(input_frequency, coord)) / <span class="hljs-number">255.</span>f;<br>			max_freqs   = <span class="hljs-built_in">max</span>(max_freqs, freq);<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-type">vec2</span> freqs = <span class="hljs-built_in">min</span>(<span class="hljs-number">1.25</span> * <span class="hljs-built_in">sqrt</span>(max_freqs), <span class="hljs-type">vec2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br><br>	<span class="hljs-keyword">const</span> <span class="hljs-type">float</span> min_rate = <span class="hljs-number">1</span>,<br>	            max_rate = <span class="hljs-built_in">max</span>(params.frequency_information.x, params.frequency_information.y);<br><br>	<span class="hljs-keyword">const</span> <span class="hljs-type">vec2</span> optimal_rate = freqs * <span class="hljs-type">vec2</span>(min_rate, min_rate) + (<span class="hljs-number">1</span> - freqs) * <span class="hljs-type">vec2</span>(max_rate, max_rate);        <span class="hljs-comment">//round(frequency * min_rate + (1 - frequency) * max_rate);</span><br><br>	<span class="hljs-keyword">const</span> <span class="hljs-type">uint</span> n_rates            = params.frequency_information.z;<br>	<span class="hljs-type">uint</span>       optimal_rate_index = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">float</span>      current_cost       = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> * max_rate * max_rate;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">uint</span> i = <span class="hljs-number">0</span>; i &lt; n_rates; ++i)<br>	&#123;<br>		<span class="hljs-type">uvec2</span> rate = params.rates[i];<br>		<span class="hljs-type">float</span> cost = (rate.x - optimal_rate.x) * (rate.x - optimal_rate.x) + (rate.y - optimal_rate.y) * (rate.y - optimal_rate.y);<br>		<span class="hljs-keyword">if</span> (cost &lt; current_cost)<br>		&#123;<br>			current_cost       = cost;<br>			optimal_rate_index = i;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-type">uint</span> optimal_rate_x = params.rates[optimal_rate_index].x, optimal_rate_y = params.rates[optimal_rate_index].y;<br>	<span class="hljs-type">uint</span> rate_code = <span class="hljs-type">uint</span>(optimal_rate_y &gt;&gt; <span class="hljs-number">1</span>) | ((optimal_rate_x &lt;&lt; <span class="hljs-number">1</span>) &amp; <span class="hljs-number">12</span>);<br>	<span class="hljs-built_in">imageStore</span>(output_sampling_rate, <span class="hljs-type">ivec2</span>(x0, y0), <span class="hljs-type">uvec4</span>(rate_code));<br>&#125;<br></code></pre></td></tr></table></figure><p>首先可以看到计算着色器中的常量缓冲区内成员的命名相较于CPU端的常量缓冲区结构体<code>FrequencyInformation</code>的定义进行了一个重新分组，不过这也只是数据分组的问题，并不影响传入数据的正确对应。</p><p>主函数开始处，代码通过<code>gl_GlobalInvocationID</code>获取当前处理的像素索引。然后计算出输入频率图和输出FSR图的大小比例，这个比例会用于后续决定FSR图中的某个像素值会被哪些频率图中的像素所影响。接下来代码就获取到当前FSR图像素对应包含的所有频率图中的像素，并且获取到这些像素中的最大频率值用于后续计算FSR图上该像素处的shading rate。代码对该最大频率值做了一个适当的变换得到一个0、1之间的权值，然后用该权值插值常量缓冲区中传入的最大fragment size和最小fragment size（必然是{1，1}），并且指定该值就是当前像素的最佳fragment size。不过这还没有结束，因为这样计算出来的fragment size未必被硬件所支持，所以需要在硬件支持的所有fragment size中，挑选最接近该值的一个大小。这是通过遍历常量缓冲区中传入的所有硬件支持大小数组，然后寻找与最佳大小之间的平面距离最短的硬件支持大小来决定的。最后对选择的大小进行对应的编码（这在<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2025/03/14/CG_api/vulkan/vulkan_samples/fragment_shading_rate/"><code>上一篇博客</code></a>中也已经有详细分析）并存入输出FSR图中即可。</p><hr><h2 id="setup_descriptor_sets">setup_descriptor_sets</h2><p>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FragmentShadingRateDynamic::setup_descriptor_sets</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// Shared model object descriptor set</span><br>	VkDescriptorSetAllocateInfo alloc_info =<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_allocate_info</span>(descriptor_pool, &amp;descriptor_set_layout, <span class="hljs-number">1</span>);<br><br>	render_descriptor_sets.<span class="hljs-built_in">resize</span>(draw_cmd_buffers.<span class="hljs-built_in">size</span>(), VK_NULL_HANDLE);<br>	<span class="hljs-built_in">assert</span>(!compute_buffers.<span class="hljs-built_in">empty</span>());<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; render_descriptor_sets.<span class="hljs-built_in">size</span>(); ++i)<br>	&#123;<br>		<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> prev_frame     = (i + compute_buffers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) % compute_buffers.<span class="hljs-built_in">size</span>();<br>		<span class="hljs-keyword">auto</span>        &amp;descriptor_set = render_descriptor_sets[i];<br>		<span class="hljs-keyword">if</span> (!descriptor_set)<br>		&#123;<br>			<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;alloc_info, &amp;descriptor_set));<br>		&#125;<br><br>		VkDescriptorBufferInfo scene_buffer_descriptor      = <span class="hljs-built_in">create_descriptor</span>(*uniform_buffers.scene);<br>		VkDescriptorImageInfo  environment_image_descriptor = <span class="hljs-built_in">create_descriptor</span>(textures.skysphere);<br>		VkDescriptorImageInfo  sphere_image_descriptor      = <span class="hljs-built_in">create_descriptor</span>(textures.scene);<br><br>		<span class="hljs-comment">// We want to visualize the previous frame&#x27;s frequency and shading rate image</span><br>		VkDescriptorImageInfo frequency_descriptor = vkb::initializers::<span class="hljs-built_in">descriptor_image_info</span>(VK_NULL_HANDLE,<br>		                                                                                      compute_buffers[prev_frame].frequency_content_image_view-&gt;<span class="hljs-built_in">get_handle</span>(),<br>		                                                                                      VK_IMAGE_LAYOUT_GENERAL);<br>		VkDescriptorImageInfo shading_image        = vkb::initializers::<span class="hljs-built_in">descriptor_image_info</span>(VK_NULL_HANDLE,<br>		                                                                                      compute_buffers[prev_frame].shading_rate_image_compute_view-&gt;<span class="hljs-built_in">get_handle</span>(),<br>		                                                                                      VK_IMAGE_LAYOUT_GENERAL);<br><br>		std::vector&lt;VkWriteDescriptorSet&gt;<br>		    write_descriptor_sets = &#123;<br>		        vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_set, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">0</span>,<br>		                                                &amp;scene_buffer_descriptor),<br>		        vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_set, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="hljs-number">1</span>,<br>		                                                &amp;environment_image_descriptor),<br>		        vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_set, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="hljs-number">2</span>,<br>		                                                &amp;sphere_image_descriptor),<br>		        vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_set, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, <span class="hljs-number">3</span>,<br>		                                                &amp;frequency_descriptor),<br>		        vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_set, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, <span class="hljs-number">4</span>,<br>		                                                &amp;shading_image),<br>		    &#125;;<br>		<span class="hljs-built_in">vkUpdateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(write_descriptor_sets.<span class="hljs-built_in">size</span>()),<br>		                       write_descriptor_sets.<span class="hljs-built_in">data</span>(), <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数代码中只需要注意到频率图描述符和FSR图描述符使用的都是上一帧第一次渲染绑定的频率附件和计算着色器计算得到的FSR图。为什么不是绑定上一帧使用的FSR附件呢？这是因为如果一个图像要用作FSR附件，那么它的<i><font color="Orange">usage</font></i>一定要包含<i><font color="Red">VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR</font></i>，但同时它又需要绑定为当前帧片段着色器的storage image，因此又需要指定用途包括<i><font color="Red">VK_IMAGE_USAGE_STORAGE_BIT</font></i>，但事实上这两个标志是不能兼容的。</p><hr><h2 id="build_command_buffers">build_command_buffers</h2><p>接下来来看渲染命令录制代码（计算命令已经在前文<i><font color="Green">update_compute_pipeline</font></i>函数中给出）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FragmentShadingRateDynamic::build_command_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">setup_descriptor_sets</span>();<br>	<span class="hljs-keyword">if</span> (small_command_buffers.<span class="hljs-built_in">size</span>() &lt; draw_cmd_buffers.<span class="hljs-built_in">size</span>())<br>	&#123;<br>		<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> old_size = small_command_buffers.<span class="hljs-built_in">size</span>();<br>		small_command_buffers.<span class="hljs-built_in">resize</span>(draw_cmd_buffers.<span class="hljs-built_in">size</span>(), VK_NULL_HANDLE);<br>		<span class="hljs-keyword">auto</span> allocate = vkb::initializers::<span class="hljs-built_in">command_buffer_allocate_info</span>(command_pool, VK_COMMAND_BUFFER_LEVEL_PRIMARY,<br>		                                                                <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(draw_cmd_buffers.<span class="hljs-built_in">size</span>() - old_size));<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateCommandBuffers</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;allocate, &amp;small_command_buffers[old_size]));<br>	&#125;<br><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">RenderTarget</span><br>	&#123;<br>		VkCommandBuffer _command_buffer;<br>		VkFramebuffer   _fragment_framebuffer;<br>		VkFramebuffer   _framebuffer;<br>		VkDescriptorSet _descriptor_set;<br>		VkRenderPass    _render_pass;<br>		VkExtent2D      image_extent;<br>		<span class="hljs-type">bool</span>            enable_ui;<br>		<span class="hljs-type">bool</span>            enable_fragment_shading_rate;<br>	&#125;;<br><br>	<span class="hljs-keyword">auto</span> build_command_buffer = [&amp;](RenderTarget render_target) &#123;<br>		VkCommandBufferBeginInfo command_buffer_begin_info = vkb::initializers::<span class="hljs-built_in">command_buffer_begin_info</span>();<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBeginCommandBuffer</span>(render_target._command_buffer, &amp;command_buffer_begin_info));<br><br>		std::array&lt;VkClearValue, 4&gt; clear_values&#123;&#125;;<br>		clear_values[<span class="hljs-number">0</span>].color        = &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;;<br>		clear_values[<span class="hljs-number">1</span>].depthStencil = &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0</span>&#125;;<br>		clear_values[<span class="hljs-number">2</span>].color        = &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;;<br>		clear_values[<span class="hljs-number">3</span>].color        = &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;;<br><br>		<span class="hljs-comment">// Final composition</span><br>		VkRenderPassBeginInfo render_pass_begin_info = vkb::initializers::<span class="hljs-built_in">render_pass_begin_info</span>();<br>		render_pass_begin_info.framebuffer           = render_target._fragment_framebuffer;<br>		render_pass_begin_info.renderPass            = render_target._render_pass;<br>		render_pass_begin_info.clearValueCount       = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(clear_values.<span class="hljs-built_in">size</span>());<br>		render_pass_begin_info.pClearValues          = clear_values.<span class="hljs-built_in">data</span>();<br>		render_pass_begin_info.renderArea.extent     = render_target.image_extent;<br><br>		<span class="hljs-built_in">vkCmdBeginRenderPass</span>(render_target._command_buffer, &amp;render_pass_begin_info, VK_SUBPASS_CONTENTS_INLINE);<br><br>		<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> _width = render_target.image_extent.width, _height = render_target.image_extent.height;<br>		VkViewport     viewport = vkb::initializers::<span class="hljs-built_in">viewport</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(_width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(_height), <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br>		<span class="hljs-built_in">vkCmdSetViewport</span>(render_target._command_buffer, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;viewport);<br><br>		VkRect2D scissor = vkb::initializers::<span class="hljs-built_in">rect2D</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int32_t</span>&gt;(_width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int32_t</span>&gt;(_height), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>		<span class="hljs-built_in">vkCmdSetScissor</span>(render_target._command_buffer, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;scissor);<br><br>		VkDescriptorSet descriptor_set = render_target._descriptor_set;<br>		<span class="hljs-built_in">vkCmdBindDescriptorSets</span>(render_target._command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline_layout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<br>		                        &amp;descriptor_set, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br><br>		<span class="hljs-comment">// Set the fragment shading rate state for the current pipeline</span><br>		VkExtent2D                         fragment_size = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>		VkFragmentShadingRateCombinerOpKHR combiner_ops[<span class="hljs-number">2</span>];<br>		<span class="hljs-comment">// The combiners determine how the different shading rate values for the pipeline, primitives and attachment are combined</span><br>		<span class="hljs-keyword">if</span> (enable_attachment_shading_rate &amp;&amp; render_target.enable_fragment_shading_rate)<br>		&#123;<br>			<span class="hljs-comment">// If shading rate from attachment is enabled, we set the combiner, so that the values from the attachment are used</span><br>			<span class="hljs-comment">// Combiner for pipeline (A) and primitive (B) - Not used in this sample</span><br>			combiner_ops[<span class="hljs-number">0</span>] = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR;<br>			<span class="hljs-comment">// Combiner for pipeline (A) and attachment (B), replace the pipeline default value (fragment_size) with the fragment sizes stored in the attachment</span><br>			combiner_ops[<span class="hljs-number">1</span>] = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR;<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			<span class="hljs-comment">// If shading rate from attachment is disabled, we keep the value set via the dynamic state</span><br>			combiner_ops[<span class="hljs-number">0</span>] = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR;<br>			combiner_ops[<span class="hljs-number">1</span>] = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR;<br>		&#125;<br>		<span class="hljs-built_in">vkCmdSetFragmentShadingRateKHR</span>(render_target._command_buffer, &amp;fragment_size, combiner_ops);<br><br>		<span class="hljs-keyword">if</span> (display_sky_sphere)<br>		&#123;<br>			<span class="hljs-built_in">vkCmdBindPipeline</span>(render_target._command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelines.skysphere);<br>			push_const_block.object_type = <span class="hljs-number">0</span>;<br>			<span class="hljs-built_in">vkCmdPushConstants</span>(render_target._command_buffer, pipeline_layout,<br>			                   VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(push_const_block),<br>			                   &amp;push_const_block);<br>			<span class="hljs-built_in">vkCmdBindDescriptorSets</span>(render_target._command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline_layout, <span class="hljs-number">0</span>,<br>			                        <span class="hljs-number">1</span>, &amp;descriptor_set, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>			<span class="hljs-built_in">draw_model</span>(models.skysphere, render_target._command_buffer);<br>		&#125;<br><br>		<span class="hljs-built_in">vkCmdBindPipeline</span>(render_target._command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelines.sphere);<br>		<span class="hljs-built_in">vkCmdBindDescriptorSets</span>(render_target._command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline_layout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<br>		                        &amp;descriptor_set, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>		std::vector&lt;glm::vec3&gt; mesh_offsets = &#123;<br>		    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">-2.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>),<br>		    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>),<br>		    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">2.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>),<br>		&#125;;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)<br>		&#123;<br>			push_const_block.object_type = <span class="hljs-number">1</span>;<br>			push_const_block.offset      = glm::<span class="hljs-built_in">vec4</span>(mesh_offsets[j], <span class="hljs-number">0.0f</span>);<br>			<span class="hljs-built_in">vkCmdPushConstants</span>(render_target._command_buffer, pipeline_layout,<br>			                   VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(push_const_block),<br>			                   &amp;push_const_block);<br>			<span class="hljs-built_in">draw_model</span>(models.scene, render_target._command_buffer);<br>		&#125;<br><br>		<span class="hljs-built_in">vkCmdEndRenderPass</span>(render_target._command_buffer);<br><br>		<span class="hljs-keyword">if</span> (render_target.enable_ui)<br>		&#123;<br>			render_pass_begin_info.clearValueCount = <span class="hljs-number">0</span>;<br>			render_pass_begin_info.pClearValues    = VK_NULL_HANDLE;<br>			render_pass_begin_info.renderPass      = render_pass;<br>			render_pass_begin_info.framebuffer     = render_target._framebuffer;<br>			<span class="hljs-built_in">vkCmdBeginRenderPass</span>(render_target._command_buffer, &amp;render_pass_begin_info, VK_SUBPASS_CONTENTS_INLINE);<br><br>			<span class="hljs-built_in">draw_ui</span>(render_target._command_buffer);<br><br>			<span class="hljs-built_in">vkCmdEndRenderPass</span>(render_target._command_buffer);<br>		&#125;<br><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkEndCommandBuffer</span>(render_target._command_buffer));<br>	&#125;;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; draw_cmd_buffers.<span class="hljs-built_in">size</span>(); ++i)<br>	&#123;<br>		<span class="hljs-comment">// small_command_buffers are not controlled by ApiVulkanSample, that is we need to explicitly reset them here!</span><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkResetCommandBuffer</span>(small_command_buffers[i], <span class="hljs-number">0</span>));<br><br>		<span class="hljs-built_in">assert</span>(subpass_extent.width &gt; <span class="hljs-number">0</span> &amp;&amp; subpass_extent.width &lt;= width &amp;&amp; subpass_extent.height &gt; <span class="hljs-number">0</span> &amp;&amp;<br>		       subpass_extent.height &lt;= height);<br>		RenderTarget small_target&#123;<br>		    small_command_buffers[i], fragment_framebuffers[i], framebuffers[i], render_descriptor_sets[i],<br>		    fragment_render_pass, subpass_extent, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>&#125;;<br>		RenderTarget full_target&#123;<br>		    draw_cmd_buffers[i], fragment_framebuffers[i], framebuffers[i], render_descriptor_sets[i], fragment_render_pass, &#123;width, height&#125;, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>&#125;;<br>		<span class="hljs-built_in">build_command_buffer</span>(small_target);<br>		<span class="hljs-built_in">build_command_buffer</span>(full_target);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">small_command_buffers</font></i>就是用来录制第二次渲染命令的命令缓冲。本函数中定义了一个lambda表达式<i><font color="Green">build_command_buffer</font></i>来统一两次渲染命令的录制过程。两者共有的过程就是渲染场景，而第一次渲染需要额外渲染UI界面以及动态设置FSR状态，因为我们可以看到使用应用程序类基类提供的默认渲染命令缓冲<i><font color="Orange">draw_cmd_buffers</font></i>录制渲染命令时（也就是第一次渲染）将<i><font color="Orange">enable_ui</font></i>和<i><font color="Orange">enable_fragment_shading_rate</font></i>都设置为true，而后一次渲染则将这两个布尔成员都设置为false（后一次渲染指定了FSR的两个<strong>combineOp</strong>均为keep，而最初的<strong>Pipeline shading rate</strong>的fragment size又设置为{1，1}，其实也就相当于没有用到FSR附件了）。另外，后一次渲染的renderArea、viewport大小、scissor大小均设置为根据<i><font color="Orange">subpass_extent</font></i>指定的大小，其中renderArea指定为该大小实际上意味着该render pass的加载和存储操作都只会在这个子区域上进行，viewport大小和scissor大小指定为该大小则意味着整个图像只会完整地渲染到这个子区域上。</p><hr><h2 id="draw">draw</h2><p>最后来看渲染主函数<i><font color="Green">draw</font></i>，其代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FragmentShadingRateDynamic::draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	VkSemaphore        semaphore&#123;VK_NULL_HANDLE&#125;;<br>	<span class="hljs-type">const</span> VkSemaphore *old_semaphore&#123;VK_NULL_HANDLE&#125;;<br>	<span class="hljs-type">const</span> VkSemaphore *wait_semaphore&#123;VK_NULL_HANDLE&#125;;<br>	<span class="hljs-keyword">auto</span>               semaphore_create = vkb::initializers::<span class="hljs-built_in">semaphore_create_info</span>();<br>	<span class="hljs-built_in">vkCreateSemaphore</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;semaphore_create, VK_NULL_HANDLE, &amp;semaphore);<br><br>	ApiVulkanSample::<span class="hljs-built_in">prepare_frame</span>();<br>	<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> start_submit = submit_info;<br>	<span class="hljs-built_in">assert</span>(submit_info.signalSemaphoreCount == <span class="hljs-number">1</span>);<br>	old_semaphore  = submit_info.pSignalSemaphores;<br>	wait_semaphore = submit_info.pWaitSemaphores;<br>	std::vector&lt;VkSemaphore&gt; semaphores&#123;submit_info.pSignalSemaphores[<span class="hljs-number">0</span>], semaphore&#125;;<br><br>	submit_info.commandBufferCount   = <span class="hljs-number">1</span>;<br>	submit_info.pCommandBuffers      = &amp;draw_cmd_buffers[current_buffer];<br>	submit_info.signalSemaphoreCount = <span class="hljs-number">2</span>;<br>	submit_info.pSignalSemaphores    = semaphores.<span class="hljs-built_in">data</span>();<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkQueueSubmit</span>(queue, <span class="hljs-number">1</span>, &amp;submit_info, VK_NULL_HANDLE));<br>	ApiVulkanSample::<span class="hljs-built_in">submit_frame</span>();<br><br>	<span class="hljs-type">const</span> std::array&lt;VkPipelineStageFlags, 2&gt; small_wait_mask = &#123;VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,<br>	                                                             VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT&#125;;<br>	VkSemaphore                               small_semaphore&#123;VK_NULL_HANDLE&#125;;<br>	<span class="hljs-built_in">vkCreateSemaphore</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;semaphore_create, VK_NULL_HANDLE, &amp;small_semaphore);<br>	submit_info.pCommandBuffers      = &amp;small_command_buffers[current_buffer];<br>	submit_info.signalSemaphoreCount = <span class="hljs-number">1</span>;<br>	submit_info.pSignalSemaphores    = &amp;small_semaphore;<br>	submit_info.waitSemaphoreCount   = <span class="hljs-number">1</span>;<br>	submit_info.pWaitDstStageMask    = small_wait_mask.<span class="hljs-built_in">data</span>();<br>	submit_info.pWaitSemaphores      = &amp;semaphore;<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkQueueSubmit</span>(queue, <span class="hljs-number">1</span>, &amp;submit_info, VK_NULL_HANDLE));<br><br>	<span class="hljs-type">const</span> VkPipelineStageFlags wait_mask           = VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT;<br>	<span class="hljs-keyword">auto</span>                       compute_submit_info = vkb::initializers::<span class="hljs-built_in">submit_info</span>();<br>	compute_submit_info.commandBufferCount         = <span class="hljs-number">1</span>;<br>	compute_submit_info.pCommandBuffers            = &amp;compute_buffers[current_buffer].command_buffer;<br>	compute_submit_info.pWaitDstStageMask          = &amp;wait_mask;<br>	compute_submit_info.pWaitSemaphores            = &amp;small_semaphore;<br>	compute_submit_info.waitSemaphoreCount         = <span class="hljs-number">1</span>;<br>	compute_submit_info.signalSemaphoreCount       = <span class="hljs-number">0</span>;<br>	compute_submit_info.pSignalSemaphores          = VK_NULL_HANDLE;<br><br>	<span class="hljs-keyword">if</span> (!compute_fence)<br>	&#123;<br>		<span class="hljs-keyword">auto</span> fence_create = vkb::initializers::<span class="hljs-built_in">fence_create_info</span>();<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateFence</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;fence_create, VK_NULL_HANDLE, &amp;compute_fence));<br>	&#125;<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkQueueSubmit</span>(queue, <span class="hljs-number">1</span>, &amp;compute_submit_info, compute_fence));<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkWaitForFences</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-number">1</span>, &amp;compute_fence, VK_TRUE, UINT64_MAX));<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkResetFences</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-number">1</span>, &amp;compute_fence));<br><br>	<span class="hljs-built_in">vkDestroySemaphore</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), semaphore, VK_NULL_HANDLE);<br>	<span class="hljs-built_in">vkDestroySemaphore</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), small_semaphore, VK_NULL_HANDLE);<br>	submit_info.signalSemaphoreCount = <span class="hljs-number">1</span>;<br>	submit_info.pSignalSemaphores    = old_semaphore;<br>	submit_info.waitSemaphoreCount   = <span class="hljs-number">1</span>;<br>	submit_info.pWaitSemaphores      = wait_semaphore;<br>	submit_info.pWaitDstStageMask    = start_submit.pWaitDstStageMask;<br>&#125;<br></code></pre></td></tr></table></figure><p></p><p>主要需要捋清该函数的同步逻辑。首先该函数开始处额外创建了一个信号量，该信号量将用于第一次渲染和第二次渲染的同步。将该信号量连同原本基类成员<i><font color="Orange">submit_info</font></i>（基类创建的用于提交<i><font color="Orange">draw_cmd_buffers</font></i>的提交信息）中设置的用于同步渲染和显示的信号量一起设置为该次提交的点亮信号。然后将第二次渲染的等待信号设置为该额外创建的信号（等待阶段设置为<i><font color="Red">VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</font></i>，也就是说整个管线都会等待该信号被点亮），就可以在第一次渲染结束后通过该信号通知第二次渲染可以开始了。然后再额外创建一个用于第二次渲染和计算管线同步的信号量，并设置为第二次渲染提交信息的点亮信号以及计算命令提交信息的等待信号即可。最后为计算管线的提交函数传递一个栅栏参数以在CPU端等待计算结果完成（下一帧使用的图像的布局转换也已经完成了，参见计算命令录制函数最后录制的那些图像布局转换命令）。最后恢复基类的<i><font color="Orange">submit_info</font></i>初始设置即可（不恢复的话那下一帧再次调用<i><font color="Green">draw</font></i>的时候<code>assert(submit_info.signalSemaphoreCount == 1)</code>这行代码会终止程序）。</p><hr><h2 id="显示fsr附件内容">显示FSR附件内容</h2><p>阅读前文给出的片段着色器代码可以发现，事实上该着色器中并没有使用到绑定的<i><font color="Orange">output_sampling_rate</font></i>图像，究其原因是因为示例选择的显示FSR图像的方式是通过glsl内置拓展<strong>GL_EXT_fragment_shading_rate</strong>为每个像素提供的FSR值（这个值在光栅化阶段通过三种指定FSR方式指定的值组合而成）来显示，这个值是最终的shading rate结果，当然是准确的，但如果直接采样计算着色器计算得到的FSR图像，结果会不会有差异呢？秉着一探究竟的想法，我在着色器中另外实现了展示计算着色器得到的FSR图的逻辑，并且在UI界面渲染模式选择栏新添了展示该FSR图的选项（就是第四个选项）。显示FSR图的逻辑就是计算出当前像素对应在FSR图中的坐标（通过两张图大小的比例关系），然后使用该坐标采样得到shading rate，然后对该数值解码分别得到对应的fragment size宽和高（解码方式已经在<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2025/03/14/CG_api/vulkan/vulkan_samples/fragment_shading_rate/"><code>上一篇博客</code></a>中说明过），最后按照和直接使用拓展显示FSR值一样的逻辑显示最终的灰度结果。然后通过上面的视频对比也可以发现，这两者呈现的效果还真的是略有区别。按道理来讲这两种方式最后得到某个像素的shading rate应该是一致的（毕竟我的做法只是将硬件解码FSR附件的方式搬到了着色器代码中来），我并不清楚具体原因，只能猜测可能是因为在着色器使用浮点计算时不完全准确的计算结果造成了一定误差，还望大佬指教~</p><p>本示例的分析到此结束！</p><hr></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/CG-api/" class="category-chain-item">CG_api</a> <span>></span> <a href="/categories/CG-api/vulkan/" class="category-chain-item">vulkan</a> <span>></span> <a href="/categories/CG-api/vulkan/vulkan-samples/" class="category-chain-item">vulkan_samples</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>Fragment shading rate dynamic</div><div>http://example.com/2025/03/16/CG_api/vulkan/vulkan_samples/fragment_shading_rate_dynamic/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>ZPC-dsg</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年3月16日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2025/03/20/CG_api/vulkan/vulkan_samples/gshader_to_mshader/" title="Gshader to Mshader"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Gshader to Mshader</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2025/03/14/CG_api/vulkan/vulkan_samples/fragment_shading_rate/" title="Fragment shading rate"><span class="hidden-mobile">Fragment shading rate</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>