<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/icon/mikuicon.jpg"><link rel="icon" href="/images/icon/mikuicon.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="ZPC-dsg"><meta name="keywords" content=""><meta name="description" content="前言 GPU计时对于程序的性能分析等至关重要。如果使用一般的高精度时钟（如std::chrono::high_resolution_clock）是没有办法衡量GPU上命令执行的用时的。不过万幸Vulkan提供了一套工具用于进行GPU上的时间戳查询，本示例的目的就是展示Vulkan中GPU时间戳查询的基本过程。关于该示例的一些细节说明可以参考官方示例文档。  效果 首先还是来看一下程序运行的"><meta property="og:type" content="article"><meta property="og:title" content="Timestamp queries"><meta property="og:url" content="http://example.com/2025/03/13/CG_api/vulkan/vulkan_samples/timestamp_queries/index.html"><meta property="og:site_name" content="ZPC の Blog"><meta property="og:description" content="前言 GPU计时对于程序的性能分析等至关重要。如果使用一般的高精度时钟（如std::chrono::high_resolution_clock）是没有办法衡量GPU上命令执行的用时的。不过万幸Vulkan提供了一套工具用于进行GPU上的时间戳查询，本示例的目的就是展示Vulkan中GPU时间戳查询的基本过程。关于该示例的一些细节说明可以参考官方示例文档。  效果 首先还是来看一下程序运行的"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/images/textbg/CG_api/vk_sample_stamp.jpg"><meta property="article:published_time" content="2025-03-13T01:21:31.000Z"><meta property="article:modified_time" content="2025-03-14T00:58:28.254Z"><meta property="article:author" content="ZPC-dsg"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/images/textbg/CG_api/vk_sample_stamp.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>Timestamp queries - ZPC の Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:"measurement_id:G-X8N3TZCB57",tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>ZPC の Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/images/textbg/CG_api/vk_sample_stamp.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Timestamp queries"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> ZPC-dsg </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-03-13 09:21" pubdate>2025年3月13日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 11k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 95 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">Timestamp queries</h1><div class="markdown-body"><h2 id="前言">前言</h2><p>GPU计时对于程序的性能分析等至关重要。如果使用一般的高精度时钟（如<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/chrono/high_resolution_clock"><code>std::chrono::high_resolution_clock</code></a>）是没有办法衡量GPU上命令执行的用时的。不过万幸Vulkan提供了一套工具用于进行GPU上的时间戳查询，本示例的目的就是展示Vulkan中GPU时间戳查询的基本过程。关于该示例的一些细节说明可以参考<a target="_blank" rel="noopener" href="https://docs.vulkan.org/samples/latest/samples/api/timestamp_queries/README.html"><code>官方示例文档</code></a>。</p><hr><h2 id="效果">效果</h2><p>首先还是来看一下程序运行的效果：</p><figure><img src="/2025/03/13/CG_api/vulkan/vulkan_samples/timestamp_queries/time.png" srcset="/img/loading.gif" lazyload alt="时间戳查询"><figcaption aria-hidden="true">时间戳查询</figcaption></figure><p>可以看到GUI最下方的timing栏显示了该渲染流程中使用到的三个pass分别耗用的GPU时长。</p><hr><h2 id="特性拓展要求">特性拓展要求</h2><p>首先还是来看一下想要进行GPU时间戳查询需要查询哪些GPU拓展特性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++">TimestampQueries::<span class="hljs-built_in">TimestampQueries</span>()<br>&#123;<br>	title = <span class="hljs-string">&quot;Timestamp queries&quot;</span>;<br>	<span class="hljs-comment">// This sample uses vkCmdResetQueryPool to reset the timestamp query pool on the host, which requires VK_EXT_host_query_reset or Vulkan 1.2</span><br>	<span class="hljs-built_in">add_device_extension</span>(VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME);<br>	<span class="hljs-comment">// This also requires us to enable the feature in the appropriate feature struct, see request_gpu_features()</span><br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimestampQueries::request_gpu_features</span><span class="hljs-params">(vkb::PhysicalDevice &amp;gpu)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// We need to enable the command pool reset feature in the extension struct</span><br>	<span class="hljs-built_in">REQUEST_REQUIRED_FEATURE</span>(gpu, VkPhysicalDeviceHostQueryResetFeaturesEXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT, hostQueryReset);<br><br>	<span class="hljs-comment">// Enable anisotropic filtering if supported</span><br>	<span class="hljs-keyword">if</span> (gpu.<span class="hljs-built_in">get_features</span>().samplerAnisotropy)<br>	&#123;<br>		gpu.<span class="hljs-built_in">get_mutable_requested_features</span>().samplerAnisotropy = VK_TRUE;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，首先程序开启了拓展<i><font color="Red">VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME</font></i>，这个拓展用于支持查询池的重置。每次将数据写入到查询池之前，我们都需要通过<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResetQueryPool.html"><code>vkCmdResetQueryPool</code></a>重置查询池，因此需要启用该拓展。</p><p>在开启拓展后，就可以在使用的物理设备上启用重置特性<strong>hostQueryReset</strong>。最后程序在这里还开启了各向异性过滤支持。</p><hr><h2 id="准备阶段">准备阶段</h2><p>接下来开始准备阶段代码的分析。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TimestampQueries::prepare</span><span class="hljs-params">(<span class="hljs-type">const</span> vkb::ApplicationOptions &amp;options)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (!ApiVulkanSample::<span class="hljs-built_in">prepare</span>(options))<br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// Check if the selected device supports timestamps. A value of zero means no support.</span><br>	VkPhysicalDeviceLimits device_limits = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_properties</span>().limits;<br>	<span class="hljs-keyword">if</span> (device_limits.timestampPeriod == <span class="hljs-number">0</span>)<br>	&#123;<br>		<span class="hljs-keyword">throw</span> std::runtime_error&#123;<span class="hljs-string">&quot;The selected device does not support timestamp queries!&quot;</span>&#125;;<br>	&#125;<br><br>	<span class="hljs-comment">// Check if all queues support timestamp queries, if not we need to check on a per-queue basis</span><br>	<span class="hljs-keyword">if</span> (!device_limits.timestampComputeAndGraphics)<br>	&#123;<br>		<span class="hljs-comment">// Check if the graphics queue used in this sample supports time stamps</span><br>		VkQueueFamilyProperties graphics_queue_family_properties = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_suitable_graphics_queue</span>().<span class="hljs-built_in">get_properties</span>();<br>		<span class="hljs-keyword">if</span> (graphics_queue_family_properties.timestampValidBits == <span class="hljs-number">0</span>)<br>		&#123;<br>			<span class="hljs-keyword">throw</span> std::runtime_error&#123;<span class="hljs-string">&quot;The selected graphics queue family does not support timestamp queries!&quot;</span>&#125;;<br>		&#125;<br>	&#125;<br><br>	camera.type = vkb::CameraType::LookAt;<br>	camera.<span class="hljs-built_in">set_position</span>(glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-4.0f</span>));<br>	camera.<span class="hljs-built_in">set_rotation</span>(glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">180.0f</span>, <span class="hljs-number">0.0f</span>));<br><br>	<span class="hljs-comment">// Note: Using reversed depth-buffer for increased precision, so Znear and Zfar are flipped</span><br>	camera.<span class="hljs-built_in">set_perspective</span>(<span class="hljs-number">60.0f</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(width) / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(height), <span class="hljs-number">256.0f</span>, <span class="hljs-number">0.1f</span>);<br><br>	<span class="hljs-built_in">load_assets</span>();<br>	<span class="hljs-built_in">prepare_uniform_buffers</span>();<br>	<span class="hljs-built_in">prepare_offscreen_buffer</span>();<br>	<span class="hljs-built_in">setup_descriptor_set_layout</span>();<br>	<span class="hljs-built_in">prepare_pipelines</span>();<br>	<span class="hljs-built_in">setup_descriptor_pool</span>();<br>	<span class="hljs-built_in">setup_descriptor_sets</span>();<br>	<span class="hljs-built_in">prepare_time_stamp_queries</span>();<br>	<span class="hljs-built_in">build_command_buffers</span>();<br>	prepared = <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意准备阶段的开头，代码查询了当前设备的<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLimits.html"><code>VkPhysicalDeviceLimits</code></a>结构体的<i><font color="Orange">timestampPeriod</font></i>成员。只有该成员不为0才代表GPU时间戳查询是可用的。另外，还需要查询<i><font color="Orange">timestampComputeAndGraphics</font></i>是否为<i><font color="Red">VK_TRUE</font></i>，如果是的话，这表明所有的图形和计算管线都支持GPU时间戳查询，否则我们就必须查询当前使用的队列是否支持该查询。这可以通过查询当前队列的<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueueFamilyProperties.html"><code>VkQueueFamilyProperties</code></a>结构体的<i><font color="Orange">timestampValidBits</font></i>成员是否为0来判断。</p><p>接下来就是一系列工具函数的调用。老规矩，还是逐个击破~</p><h3 id="load_assets">load_assets</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimestampQueries::load_assets</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// Models</span><br>	models.skybox                      = <span class="hljs-built_in">load_model</span>(<span class="hljs-string">&quot;scenes/cube.gltf&quot;</span>);<br>	std::vector&lt;std::string&gt; filenames = &#123;<span class="hljs-string">&quot;geosphere.gltf&quot;</span>, <span class="hljs-string">&quot;teapot.gltf&quot;</span>, <span class="hljs-string">&quot;torusknot.gltf&quot;</span>&#125;;<br>	object_names                       = &#123;<span class="hljs-string">&quot;Sphere&quot;</span>, <span class="hljs-string">&quot;Teapot&quot;</span>, <span class="hljs-string">&quot;Torusknot&quot;</span>&#125;;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> file : filenames)<br>	&#123;<br>		<span class="hljs-keyword">auto</span> object = <span class="hljs-built_in">load_model</span>(<span class="hljs-string">&quot;scenes/&quot;</span> + file);<br>		models.objects.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">move</span>(object));<br>	&#125;<br><br>	<span class="hljs-comment">// Transforms</span><br>	<span class="hljs-keyword">auto</span> geosphere_matrix = glm::<span class="hljs-built_in">mat4</span>(<span class="hljs-number">1.0f</span>);<br>	<span class="hljs-keyword">auto</span> teapot_matrix    = glm::<span class="hljs-built_in">mat4</span>(<span class="hljs-number">1.0f</span>);<br>	teapot_matrix         = glm::<span class="hljs-built_in">scale</span>(teapot_matrix, glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">10.0f</span>, <span class="hljs-number">10.0f</span>, <span class="hljs-number">10.0f</span>));<br>	teapot_matrix         = glm::<span class="hljs-built_in">rotate</span>(teapot_matrix, glm::<span class="hljs-built_in">radians</span>(<span class="hljs-number">180.0f</span>), glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>));<br>	<span class="hljs-keyword">auto</span> torus_matrix     = glm::<span class="hljs-built_in">mat4</span>(<span class="hljs-number">1.0f</span>);<br>	models.transforms.<span class="hljs-built_in">push_back</span>(geosphere_matrix);<br>	models.transforms.<span class="hljs-built_in">push_back</span>(teapot_matrix);<br>	models.transforms.<span class="hljs-built_in">push_back</span>(torus_matrix);<br><br>	<span class="hljs-comment">// Load HDR cube map</span><br>	textures.envmap = <span class="hljs-built_in">load_texture_cubemap</span>(<span class="hljs-string">&quot;textures/uffizi_rgba16f_cube.ktx&quot;</span>, vkb::sg::Image::Color);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数就是将场景需要用到的模型加载到程序中来，并且设置好每个模型的模型变换矩阵，没什么好说的，继续继续~</p><h3 id="prepare_uniform_buffers">prepare_uniform_buffers</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Prepare and initialize uniform buffer containing shader uniforms</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimestampQueries::prepare_uniform_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// Matrices vertex shader uniform buffer</span><br>	uniform_buffers.matrices = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(),<br>	                                                                <span class="hljs-built_in">sizeof</span>(ubo_vs),<br>	                                                                VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,<br>	                                                                VMA_MEMORY_USAGE_CPU_TO_GPU);<br><br>	<span class="hljs-comment">// Params</span><br>	uniform_buffers.params = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(),<br>	                                                              <span class="hljs-built_in">sizeof</span>(ubo_params),<br>	                                                              VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,<br>	                                                              VMA_MEMORY_USAGE_CPU_TO_GPU);<br><br>	<span class="hljs-built_in">update_uniform_buffers</span>();<br>	<span class="hljs-built_in">update_params</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>离屏渲染pass会用到两个UBO，一个存储了场景中物体的变换矩阵信息，另一个存储了一个控制曝光度的uniform变量。这里首先创建好这两个uniform buffer，然后初始化两个缓冲区中的数据。缓冲区数据结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UBOVS</span><br>&#123;<br>	glm::mat4 projection;<br>	glm::mat4 modelview;<br>	glm::mat4 skybox_modelview;<br>	glm::mat4 inverse_modelview;<br>	<span class="hljs-type">float</span>     modelscale = <span class="hljs-number">0.05f</span>;<br>&#125; ubo_vs;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UBOParams</span><br>&#123;<br>	<span class="hljs-type">float</span> exposure = <span class="hljs-number">1.0f</span>;<br>&#125; ubo_params;<br></code></pre></td></tr></table></figure><p>缓冲区更新函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimestampQueries::update_uniform_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	ubo_vs.projection        = camera.matrices.perspective;<br>	ubo_vs.modelview         = camera.matrices.view * models.transforms[models.object_index];<br>	ubo_vs.skybox_modelview  = camera.matrices.view;<br>	ubo_vs.inverse_modelview = glm::<span class="hljs-built_in">inverse</span>(camera.matrices.view);<br>	uniform_buffers.matrices-&gt;<span class="hljs-built_in">convert_and_update</span>(ubo_vs);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimestampQueries::update_params</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	uniform_buffers.params-&gt;<span class="hljs-built_in">convert_and_update</span>(ubo_params);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里的<i><font color="Orange">inverse_modelview</font></i>成员，实际上该成员存储的是摄像机观察矩阵的逆矩阵而不是模型矩阵和观察矩阵乘积的逆矩阵，这个变量名实在是有点误导性了。。。</p><h3 id="prepare_offscreen_buffer">prepare_offscreen_buffer</h3><p>该函数用于准备好离屏渲染所需的帧缓冲。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Prepare a new framebuffer and attachments for offscreen rendering (G-Buffer)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimestampQueries::prepare_offscreen_buffer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	&#123;<br>		offscreen.width  = width;<br>		offscreen.height = height;<br><br>		<span class="hljs-comment">// Color attachments</span><br><br>		<span class="hljs-comment">// We are using two 128-Bit RGBA floating point color buffers for this sample</span><br>		<span class="hljs-comment">// In a performance or bandwidth-limited scenario you should consider using a format with lower precision</span><br>		<span class="hljs-built_in">create_attachment</span>(VK_FORMAT_R32G32B32A32_SFLOAT, VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, &amp;offscreen.color[<span class="hljs-number">0</span>]);<br>		<span class="hljs-built_in">create_attachment</span>(VK_FORMAT_R32G32B32A32_SFLOAT, VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, &amp;offscreen.color[<span class="hljs-number">1</span>]);<br>		<span class="hljs-comment">// Depth attachment</span><br>		<span class="hljs-built_in">create_attachment</span>(depth_format, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, &amp;offscreen.depth);<br><br>		<span class="hljs-comment">// Set up separate renderpass with references to the color and depth attachments</span><br>		std::array&lt;VkAttachmentDescription, 3&gt; attachment_descriptions = &#123;&#125;;<br><br>		<span class="hljs-comment">// Init attachment properties</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i)<br>		&#123;<br>			attachment_descriptions[i].samples        = VK_SAMPLE_COUNT_1_BIT;<br>			attachment_descriptions[i].loadOp         = VK_ATTACHMENT_LOAD_OP_CLEAR;<br>			attachment_descriptions[i].storeOp        = VK_ATTACHMENT_STORE_OP_STORE;<br>			attachment_descriptions[i].stencilLoadOp  = VK_ATTACHMENT_LOAD_OP_DONT_CARE;<br>			attachment_descriptions[i].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>			<span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>)<br>			&#123;<br>				attachment_descriptions[i].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;<br>				attachment_descriptions[i].finalLayout   = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;<br>			&#125;<br>			<span class="hljs-keyword">else</span><br>			&#123;<br>				attachment_descriptions[i].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;<br>				attachment_descriptions[i].finalLayout   = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">// Formats</span><br>		attachment_descriptions[<span class="hljs-number">0</span>].format = offscreen.color[<span class="hljs-number">0</span>].format;<br>		attachment_descriptions[<span class="hljs-number">1</span>].format = offscreen.color[<span class="hljs-number">1</span>].format;<br>		attachment_descriptions[<span class="hljs-number">2</span>].format = offscreen.depth.format;<br><br>		std::vector&lt;VkAttachmentReference&gt; color_references;<br>		color_references.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">0</span>, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL&#125;);<br>		color_references.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">1</span>, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL&#125;);<br><br>		VkAttachmentReference depth_reference = &#123;&#125;;<br>		depth_reference.attachment            = <span class="hljs-number">2</span>;<br>		depth_reference.layout                = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;<br><br>		VkSubpassDescription subpass    = &#123;&#125;;<br>		subpass.pipelineBindPoint       = VK_PIPELINE_BIND_POINT_GRAPHICS;<br>		subpass.pColorAttachments       = color_references.<span class="hljs-built_in">data</span>();<br>		subpass.colorAttachmentCount    = <span class="hljs-number">2</span>;<br>		subpass.pDepthStencilAttachment = &amp;depth_reference;<br><br>		<span class="hljs-comment">// Use subpass dependencies for attachment layout transitions</span><br>		std::array&lt;VkSubpassDependency, 2&gt; dependencies;<br><br>		dependencies[<span class="hljs-number">0</span>].srcSubpass      = VK_SUBPASS_EXTERNAL;<br>		dependencies[<span class="hljs-number">0</span>].dstSubpass      = <span class="hljs-number">0</span>;<br>		dependencies[<span class="hljs-number">0</span>].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;<br>		<span class="hljs-comment">// End of previous commands</span><br>		dependencies[<span class="hljs-number">0</span>].srcStageMask  = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;<br>		dependencies[<span class="hljs-number">0</span>].srcAccessMask = <span class="hljs-number">0</span>;<br>		<span class="hljs-comment">// Read/write from/to depth</span><br>		dependencies[<span class="hljs-number">0</span>].dstStageMask  = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;<br>		dependencies[<span class="hljs-number">0</span>].dstAccessMask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;<br>		<span class="hljs-comment">// Write to attachment</span><br>		dependencies[<span class="hljs-number">0</span>].dstStageMask |= VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;<br>		dependencies[<span class="hljs-number">0</span>].dstAccessMask |= VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;<br><br>		dependencies[<span class="hljs-number">1</span>].srcSubpass      = <span class="hljs-number">0</span>;<br>		dependencies[<span class="hljs-number">1</span>].dstSubpass      = VK_SUBPASS_EXTERNAL;<br>		dependencies[<span class="hljs-number">1</span>].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;<br>		<span class="hljs-comment">// End of write to attachment</span><br>		dependencies[<span class="hljs-number">1</span>].srcStageMask  = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;<br>		dependencies[<span class="hljs-number">1</span>].srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;<br>		<span class="hljs-comment">// Attachment later read using sampler in &#x27;composition&#x27; pipeline</span><br>		dependencies[<span class="hljs-number">1</span>].dstStageMask  = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;<br>		dependencies[<span class="hljs-number">1</span>].dstAccessMask = VK_ACCESS_SHADER_READ_BIT;<br><br>		VkRenderPassCreateInfo render_pass_create_info = &#123;&#125;;<br>		render_pass_create_info.sType                  = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;<br>		render_pass_create_info.pAttachments           = attachment_descriptions.<span class="hljs-built_in">data</span>();<br>		render_pass_create_info.attachmentCount        = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attachment_descriptions.<span class="hljs-built_in">size</span>());<br>		render_pass_create_info.subpassCount           = <span class="hljs-number">1</span>;<br>		render_pass_create_info.pSubpasses             = &amp;subpass;<br>		render_pass_create_info.dependencyCount        = <span class="hljs-number">2</span>;<br>		render_pass_create_info.pDependencies          = dependencies.<span class="hljs-built_in">data</span>();<br><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateRenderPass</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;render_pass_create_info, <span class="hljs-literal">nullptr</span>, &amp;offscreen.render_pass));<br><br>		std::array&lt;VkImageView, 3&gt; attachments;<br>		attachments[<span class="hljs-number">0</span>] = offscreen.color[<span class="hljs-number">0</span>].view;<br>		attachments[<span class="hljs-number">1</span>] = offscreen.color[<span class="hljs-number">1</span>].view;<br>		attachments[<span class="hljs-number">2</span>] = offscreen.depth.view;<br><br>		VkFramebufferCreateInfo framebuffer_create_info = &#123;&#125;;<br>		framebuffer_create_info.sType                   = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;<br>		framebuffer_create_info.pNext                   = <span class="hljs-literal">NULL</span>;<br>		framebuffer_create_info.renderPass              = offscreen.render_pass;<br>		framebuffer_create_info.pAttachments            = attachments.<span class="hljs-built_in">data</span>();<br>		framebuffer_create_info.attachmentCount         = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attachments.<span class="hljs-built_in">size</span>());<br>		framebuffer_create_info.width                   = offscreen.width;<br>		framebuffer_create_info.height                  = offscreen.height;<br>		framebuffer_create_info.layers                  = <span class="hljs-number">1</span>;<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateFramebuffer</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;framebuffer_create_info, <span class="hljs-literal">nullptr</span>, &amp;offscreen.framebuffer));<br><br>		<span class="hljs-comment">// Calculate valid filter and mipmap modes</span><br>		VkFilter            filter      = VK_FILTER_NEAREST;<br>		VkSamplerMipmapMode mipmap_mode = VK_SAMPLER_MIPMAP_MODE_LINEAR;<br>		vkb::<span class="hljs-built_in">make_filters_valid</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_handle</span>(), offscreen.color[<span class="hljs-number">0</span>].format, &amp;filter, &amp;mipmap_mode);<br><br>		<span class="hljs-comment">// Create sampler to sample from the color attachments</span><br>		VkSamplerCreateInfo sampler = vkb::initializers::<span class="hljs-built_in">sampler_create_info</span>();<br>		sampler.magFilter           = filter;<br>		sampler.minFilter           = filter;<br>		sampler.mipmapMode          = mipmap_mode;<br>		sampler.addressModeU        = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;<br>		sampler.addressModeV        = sampler.addressModeU;<br>		sampler.addressModeW        = sampler.addressModeU;<br>		sampler.mipLodBias          = <span class="hljs-number">0.0f</span>;<br>		sampler.maxAnisotropy       = <span class="hljs-number">1.0f</span>;<br>		sampler.minLod              = <span class="hljs-number">0.0f</span>;<br>		sampler.maxLod              = <span class="hljs-number">1.0f</span>;<br>		sampler.borderColor         = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE;<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateSampler</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;sampler, <span class="hljs-literal">nullptr</span>, &amp;offscreen.sampler));<br>	&#125;<br><br>	<span class="hljs-comment">// Bloom separable filter pass</span><br>	&#123;<br>		filter_pass.width  = width;<br>		filter_pass.height = height;<br><br>		<span class="hljs-comment">// Color attachments - needs to be a blendable format, so choose from a priority ordered list</span><br>		<span class="hljs-type">const</span> std::vector&lt;VkFormat&gt; float_format_priority_list = &#123;<br>		    VK_FORMAT_R32G32B32A32_SFLOAT,<br>		    VK_FORMAT_R16G16B16A16_SFLOAT        <span class="hljs-comment">// Guaranteed blend support for this</span><br>		&#125;;<br><br>		VkFormat color_format = vkb::<span class="hljs-built_in">choose_blendable_format</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_handle</span>(), float_format_priority_list);<br><br>		<span class="hljs-comment">// Two floating point color buffers</span><br>		<span class="hljs-built_in">create_attachment</span>(color_format, VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, &amp;filter_pass.color[<span class="hljs-number">0</span>]);<br><br>		<span class="hljs-comment">// Set up separate renderpass with references to the color and depth attachments</span><br>		std::array&lt;VkAttachmentDescription, 1&gt; attachment_descriptions = &#123;&#125;;<br><br>		<span class="hljs-comment">// Init attachment properties</span><br>		attachment_descriptions[<span class="hljs-number">0</span>].samples        = VK_SAMPLE_COUNT_1_BIT;<br>		attachment_descriptions[<span class="hljs-number">0</span>].loadOp         = VK_ATTACHMENT_LOAD_OP_CLEAR;<br>		attachment_descriptions[<span class="hljs-number">0</span>].storeOp        = VK_ATTACHMENT_STORE_OP_STORE;<br>		attachment_descriptions[<span class="hljs-number">0</span>].stencilLoadOp  = VK_ATTACHMENT_LOAD_OP_DONT_CARE;<br>		attachment_descriptions[<span class="hljs-number">0</span>].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>		attachment_descriptions[<span class="hljs-number">0</span>].initialLayout  = VK_IMAGE_LAYOUT_UNDEFINED;<br>		attachment_descriptions[<span class="hljs-number">0</span>].finalLayout    = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;<br>		attachment_descriptions[<span class="hljs-number">0</span>].format         = filter_pass.color[<span class="hljs-number">0</span>].format;<br><br>		std::vector&lt;VkAttachmentReference&gt; color_references;<br>		color_references.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">0</span>, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL&#125;);<br><br>		VkSubpassDescription subpass = &#123;&#125;;<br>		subpass.pipelineBindPoint    = VK_PIPELINE_BIND_POINT_GRAPHICS;<br>		subpass.pColorAttachments    = color_references.<span class="hljs-built_in">data</span>();<br>		subpass.colorAttachmentCount = <span class="hljs-number">1</span>;<br><br>		<span class="hljs-comment">// Use subpass dependencies for attachment layout transitions</span><br>		std::array&lt;VkSubpassDependency, 2&gt; dependencies;<br><br>		dependencies[<span class="hljs-number">0</span>].srcSubpass      = VK_SUBPASS_EXTERNAL;<br>		dependencies[<span class="hljs-number">0</span>].dstSubpass      = <span class="hljs-number">0</span>;<br>		dependencies[<span class="hljs-number">0</span>].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;<br>		<span class="hljs-comment">// End of previous commands</span><br>		dependencies[<span class="hljs-number">0</span>].srcStageMask  = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;<br>		dependencies[<span class="hljs-number">0</span>].srcAccessMask = <span class="hljs-number">0</span>;<br>		<span class="hljs-comment">// Read from image in fragment shader</span><br>		dependencies[<span class="hljs-number">0</span>].dstStageMask  = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;<br>		dependencies[<span class="hljs-number">0</span>].dstAccessMask = VK_ACCESS_SHADER_READ_BIT;<br>		<span class="hljs-comment">// Write to attachment</span><br>		dependencies[<span class="hljs-number">0</span>].dstStageMask |= VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;<br>		dependencies[<span class="hljs-number">0</span>].dstAccessMask |= VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;<br><br>		dependencies[<span class="hljs-number">1</span>].srcSubpass      = <span class="hljs-number">0</span>;<br>		dependencies[<span class="hljs-number">1</span>].dstSubpass      = VK_SUBPASS_EXTERNAL;<br>		dependencies[<span class="hljs-number">1</span>].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;<br>		<span class="hljs-comment">// End of write to attachment</span><br>		dependencies[<span class="hljs-number">1</span>].srcStageMask  = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;<br>		dependencies[<span class="hljs-number">1</span>].srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;<br>		<span class="hljs-comment">// Attachment later read using sampler in &#x27;bloom[0]&#x27; pipeline</span><br>		dependencies[<span class="hljs-number">1</span>].dstStageMask  = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;<br>		dependencies[<span class="hljs-number">1</span>].dstAccessMask = VK_ACCESS_SHADER_READ_BIT;<br><br>		VkRenderPassCreateInfo render_pass_create_info = &#123;&#125;;<br>		render_pass_create_info.sType                  = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;<br>		render_pass_create_info.pAttachments           = attachment_descriptions.<span class="hljs-built_in">data</span>();<br>		render_pass_create_info.attachmentCount        = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attachment_descriptions.<span class="hljs-built_in">size</span>());<br>		render_pass_create_info.subpassCount           = <span class="hljs-number">1</span>;<br>		render_pass_create_info.pSubpasses             = &amp;subpass;<br>		render_pass_create_info.dependencyCount        = <span class="hljs-number">2</span>;<br>		render_pass_create_info.pDependencies          = dependencies.<span class="hljs-built_in">data</span>();<br><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateRenderPass</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;render_pass_create_info, <span class="hljs-literal">nullptr</span>, &amp;filter_pass.render_pass));<br><br>		std::array&lt;VkImageView, 1&gt; attachments;<br>		attachments[<span class="hljs-number">0</span>] = filter_pass.color[<span class="hljs-number">0</span>].view;<br><br>		VkFramebufferCreateInfo framebuffer_create_info = &#123;&#125;;<br>		framebuffer_create_info.sType                   = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;<br>		framebuffer_create_info.pNext                   = <span class="hljs-literal">NULL</span>;<br>		framebuffer_create_info.renderPass              = filter_pass.render_pass;<br>		framebuffer_create_info.pAttachments            = attachments.<span class="hljs-built_in">data</span>();<br>		framebuffer_create_info.attachmentCount         = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attachments.<span class="hljs-built_in">size</span>());<br>		framebuffer_create_info.width                   = filter_pass.width;<br>		framebuffer_create_info.height                  = filter_pass.height;<br>		framebuffer_create_info.layers                  = <span class="hljs-number">1</span>;<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateFramebuffer</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;framebuffer_create_info, <span class="hljs-literal">nullptr</span>, &amp;filter_pass.framebuffer));<br><br>		<span class="hljs-comment">// Calculate valid filter and mipmap modes</span><br>		VkFilter            filter      = VK_FILTER_NEAREST;<br>		VkSamplerMipmapMode mipmap_mode = VK_SAMPLER_MIPMAP_MODE_LINEAR;<br>		vkb::<span class="hljs-built_in">make_filters_valid</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_handle</span>(), filter_pass.color[<span class="hljs-number">0</span>].format, &amp;filter, &amp;mipmap_mode);<br><br>		<span class="hljs-comment">// Create sampler to sample from the color attachments</span><br>		VkSamplerCreateInfo sampler = vkb::initializers::<span class="hljs-built_in">sampler_create_info</span>();<br>		sampler.magFilter           = filter;<br>		sampler.minFilter           = filter;<br>		sampler.mipmapMode          = mipmap_mode;<br>		sampler.addressModeU        = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;<br>		sampler.addressModeV        = sampler.addressModeU;<br>		sampler.addressModeW        = sampler.addressModeU;<br>		sampler.mipLodBias          = <span class="hljs-number">0.0f</span>;<br>		sampler.maxAnisotropy       = <span class="hljs-number">1.0f</span>;<br>		sampler.minLod              = <span class="hljs-number">0.0f</span>;<br>		sampler.maxLod              = <span class="hljs-number">1.0f</span>;<br>		sampler.borderColor         = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE;<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateSampler</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;sampler, <span class="hljs-literal">nullptr</span>, &amp;filter_pass.sampler));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先创建离屏渲染所需的颜色附件。后续阅读着色器代码的时候会看到该离屏pass会输出到两个渲染目标，一个存储实际颜色，另一个存储亮部区域，所以这里会创建两个颜色附件。创建附件函数<i><font color="Orange">create_attachment</font></i>如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimestampQueries::create_attachment</span><span class="hljs-params">(VkFormat format, VkImageUsageFlagBits usage, FrameBufferAttachment *attachment)</span></span><br><span class="hljs-function"></span>&#123;<br>	VkImageAspectFlags aspect_mask = <span class="hljs-number">0</span>;<br>	VkImageLayout      image_layout;<br><br>	attachment-&gt;format = format;<br><br>	<span class="hljs-keyword">if</span> (usage &amp; VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)<br>	&#123;<br>		aspect_mask  = VK_IMAGE_ASPECT_COLOR_BIT;<br>		image_layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (usage &amp; VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)<br>	&#123;<br>		aspect_mask = VK_IMAGE_ASPECT_DEPTH_BIT;<br>		<span class="hljs-comment">// Stencil aspect should only be set on depth + stencil formats (VK_FORMAT_D16_UNORM_S8_UINT..VK_FORMAT_D32_SFLOAT_S8_UINT</span><br>		<span class="hljs-keyword">if</span> (format &gt;= VK_FORMAT_D16_UNORM_S8_UINT)<br>		&#123;<br>			aspect_mask |= VK_IMAGE_ASPECT_STENCIL_BIT;<br>		&#125;<br>		image_layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;<br>	&#125;<br><br>	<span class="hljs-built_in">assert</span>(aspect_mask &gt; <span class="hljs-number">0</span>);<br><br>	VkImageCreateInfo image = vkb::initializers::<span class="hljs-built_in">image_create_info</span>();<br>	image.imageType         = VK_IMAGE_TYPE_2D;<br>	image.format            = format;<br>	image.extent.width      = offscreen.width;<br>	image.extent.height     = offscreen.height;<br>	image.extent.depth      = <span class="hljs-number">1</span>;<br>	image.mipLevels         = <span class="hljs-number">1</span>;<br>	image.arrayLayers       = <span class="hljs-number">1</span>;<br>	image.samples           = VK_SAMPLE_COUNT_1_BIT;<br>	image.tiling            = VK_IMAGE_TILING_OPTIMAL;<br>	image.usage             = usage | VK_IMAGE_USAGE_SAMPLED_BIT;<br><br>	VkMemoryAllocateInfo memory_allocate_info = vkb::initializers::<span class="hljs-built_in">memory_allocate_info</span>();<br>	VkMemoryRequirements memory_requirements;<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateImage</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;image, <span class="hljs-literal">nullptr</span>, &amp;attachment-&gt;image));<br>	<span class="hljs-built_in">vkGetImageMemoryRequirements</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), attachment-&gt;image, &amp;memory_requirements);<br>	memory_allocate_info.allocationSize  = memory_requirements.size;<br>	memory_allocate_info.memoryTypeIndex = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_memory_type</span>(memory_requirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateMemory</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;memory_allocate_info, <span class="hljs-literal">nullptr</span>, &amp;attachment-&gt;mem));<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBindImageMemory</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), attachment-&gt;image, attachment-&gt;mem, <span class="hljs-number">0</span>));<br><br>	VkImageViewCreateInfo image_view_create_info           = vkb::initializers::<span class="hljs-built_in">image_view_create_info</span>();<br>	image_view_create_info.viewType                        = VK_IMAGE_VIEW_TYPE_2D;<br>	image_view_create_info.format                          = format;<br>	image_view_create_info.subresourceRange                = &#123;&#125;;<br>	image_view_create_info.subresourceRange.aspectMask     = aspect_mask;<br>	image_view_create_info.subresourceRange.baseMipLevel   = <span class="hljs-number">0</span>;<br>	image_view_create_info.subresourceRange.levelCount     = <span class="hljs-number">1</span>;<br>	image_view_create_info.subresourceRange.baseArrayLayer = <span class="hljs-number">0</span>;<br>	image_view_create_info.subresourceRange.layerCount     = <span class="hljs-number">1</span>;<br>	image_view_create_info.image                           = attachment-&gt;image;<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateImageView</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;image_view_create_info, <span class="hljs-literal">nullptr</span>, &amp;attachment-&gt;view));<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用是创建附件对应的图像、图像内存以及图像视图资源，这些资源全部被封装在了应用程序类内嵌套的一个结构体<code>FrameBufferAttachment</code>中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Framebuffer for offscreen rendering</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FrameBufferAttachment</span><br>&#123;<br>	VkImage        image;<br>	VkDeviceMemory mem;<br>	VkImageView    view;<br>	VkFormat       format;<br>	<span class="hljs-function"><span class="hljs-type">void</span>           <span class="hljs-title">destroy</span><span class="hljs-params">(VkDevice device)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-built_in">vkDestroyImageView</span>(device, view, <span class="hljs-literal">nullptr</span>);<br>		<span class="hljs-built_in">vkDestroyImage</span>(device, image, <span class="hljs-literal">nullptr</span>);<br>		<span class="hljs-built_in">vkFreeMemory</span>(device, mem, <span class="hljs-literal">nullptr</span>);<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>而离屏pass渲染到的帧缓冲使用到的这些附件以及render pass等信息封装在了<code>FrameBuffer</code>结构体中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FrameBuffer</span><br>&#123;<br>	<span class="hljs-type">int32_t</span>               width, height;<br>	VkFramebuffer         framebuffer;<br>	FrameBufferAttachment color[<span class="hljs-number">2</span>];<br>	FrameBufferAttachment depth;<br>	VkRenderPass          render_pass;<br>	VkSampler             sampler;<br>&#125; offscreen;<br></code></pre></td></tr></table></figure><p>另外可以看到代码为离屏pass创建的两个渲染目标附件都是SRGB格式的。</p><p>创建好颜色附件之后，同样需要创建一个深度附件，这些附件都需要绑定到离屏帧缓冲上。</p><p>然后为了将这三个附件绑定到帧缓冲上，还需要指定相应的附件描述。这部分内容在我<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/"><code>之前的博客</code></a>中已经有详细的描述，这里只需要注意颜色附件的<i><font color="Orange">finalLayout</font></i>被指定为<i><font color="Red">VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</font></i>，因为在离屏pass渲染完毕后这两个颜色附件将被用作纹理资源在后续pass中进行bloom和混合等后处理操作。</p><p>接下来需要指定渲染通道内的所有子通道，子通道用到的附件引用以及各个子通道之间的依赖关系。本示例不涉及到多子通道操作，每个render pass都只有一个子通道，该子通道需要的附件就是render pass指定的所有附件。</p><p>接下来详细说明一下子通道依赖的设置。首先，在仅有一个子通道的情况下，代码也可能需要指定两个通道依赖，因为Vulkan实际上在渲染通道开始前和渲染通道结束后还有两个外部定义好的通道，使用<i><font color="Red">VK_SUBPASS_EXTERNAL</font></i>指定，render pass内定义的子通道需要和这两个特殊的子通道之间指定依赖关系。首先注意到这两个子通道的依赖标志都设置为了<i><font color="Red">VK_DEPENDENCY_BY_REGION_BIT</font></i>，通过查阅<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#VkDependencyFlagBits"><code>官方文档</code></a>，可以知道这个标志的作用是指定与帧缓冲相关的管线阶段内的操作是局部同步的，大致意思就是说如果同步是全局的，那么帧缓冲上的一个同步区域（一般为一个像素）内的任何采样点在源阶段上指定的操作都需要和目标阶段上对应的同步区域（位置相同处的区域）像素内的所有采样点在目标阶段上指定的操作进行同步，而如果通过<i><font color="Red">VK_DEPENDENCY_BY_REGION_BIT</font></i>指定了局部同步的话，那么那么帧缓冲上的一个同步区域（一般为一个像素）内的任何采样点在源阶段上指定的操作都只需要和目标阶段上对应的同步区域（位置相同处的区域）像素内的对应采样点进行同步即可。一般来讲指定<i><font color="Red">VK_DEPENDENCY_BY_REGION_BIT</font></i>对于绝大多数的架构来讲都是更高效的（尤其是在基于瓦片的架构下，指定该标志可以保持帧缓冲区域始终处于GPU片上寄存器中，有效地缓解因为强制依赖关系而带来的带宽开销。如果指定的是全局的依赖关系，那么硬件实现会强制将数据flush到内存或缓存，导致任何局部性优化失效。）</p><p>然后代码首先指定开头外部通道和子通道的依赖关系。指定源阶段为<i><font color="Red">VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</font></i>，意味着在上一帧渲染中所有的管线命令都已经完成之后才能进行附件布局的自动转换（如颜色附件由<i><font color="Orange">initialLayout</font></i>中指定的<i><font color="Red">VK_IMAGE_LAYOUT_UNDEFINED</font></i>转变为<i><font color="Orange">color_references</font></i>变量中指定的<i><font color="Red">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</font></i>），<i><font color="Orange">srcAccessMask</font></i>指定为0代表无需特指任何特定操作，这是将源阶段指定为<i><font color="Red">VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</font></i>或者<i><font color="Red">VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</font></i>的固定搭配。然后代码将目标阶段指定为<i><font color="Red">VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>，并且将目标阶段的操作指定为深度读取写入以及颜色写入操作，这是因为在进行这些操作之前，附件的布局必须转换为相应的在附件引用中指定的布局以供着色器读取或写入。</p><p>然后代码指定子通道和结尾外部通道之间的依赖关系，这里将源阶段指定为了渲染目标输出阶段，操作指定为颜色附件写入操作，因为在颜色附件完成了着色器写入之后，它无需继续被当前render pass使用，它的布局就可以被安全地转换为<i><font color="Orange">finalLayout</font></i>中指定的布局了。另外，这里并没有在源阶段中指定和深度值读写有关的阶段，因为深度缓冲并不会在后续继续被别的pass使用，它的值在颜色输出完成之后是无所谓的。然后代码将目标阶段和操作分别指定为了片段着色器阶段以及着色器读取操作，这是因为后续该pass中的颜色附件会被用作后处理pass的纹理资源被着色器读取，因此在被下一个render pass读取之前颜色附件的布局必须转换为<i><font color="Orange">finalLayout</font></i>中指定的布局，即<i><font color="Red">VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</font></i>。</p><p>这样离屏pass所需的所有信息就齐全了，最后调用<code>vkCreateRenderPass</code>创建离屏render pass即可。</p><p>单单创建一个render pass还不够，为了使用这些附件，还需要为它们创建相应的帧缓冲并将render pass指定给该帧缓冲。这个过程在<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%B8%A7%E7%BC%93%E5%86%B2/"><code>我之前的的文章</code></a>中也有详细的介绍了，这里也只是常规操作。</p><p>关于离屏帧缓冲结构体成员<i><font color="Orange">offscreen</font></i>，代码最后还创建了之后的pass中读取其颜色缓冲内容所需的采样器。创建逻辑是先使用后<i><font color="Green">make_filters_valid</font></i>工具函数查询当前指定的过滤模式和多级渐远模式硬件是否支持，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">make_filters_valid</span><span class="hljs-params">(VkPhysicalDevice physical_device, VkFormat format, VkFilter *filter, VkSamplerMipmapMode *mipmapMode)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// Not all formats support linear filtering, so we need to adjust them if they don&#x27;t</span><br>	<span class="hljs-keyword">if</span> (*filter == VK_FILTER_NEAREST &amp;&amp; (mipmapMode == <span class="hljs-literal">nullptr</span> || *mipmapMode == VK_SAMPLER_MIPMAP_MODE_NEAREST))<br>	&#123;<br>		<span class="hljs-keyword">return</span>;        <span class="hljs-comment">// These must already be valid</span><br>	&#125;<br><br>	VkFormatProperties properties;<br>	<span class="hljs-built_in">vkGetPhysicalDeviceFormatProperties</span>(physical_device, format, &amp;properties);<br><br>	<span class="hljs-keyword">if</span> (!(properties.optimalTilingFeatures &amp; VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT))<br>	&#123;<br>		*filter = VK_FILTER_NEAREST;<br>		<span class="hljs-keyword">if</span> (mipmapMode)<br>		&#123;<br>			*mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在确定了这些过滤模式后就可以填写信息结构体<code>VkSamplerCreateInfo</code>并使用<code>vkCreateSampler</code>进行创建了，详细的流程梳理在<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/"><code>我之前的文章</code></a>中同样有说明。离屏pass的帧缓冲有关资源就创建完毕了。</p><p>接下来还需要再创建一个用于模拟首次泛光特效的离屏pass。后文会看到在构建该pass对应的渲染管线的时候会开启颜色混合，因此用于该pass的颜色附件需要是支持颜色混合的，因此代码在创建该帧缓冲代码开始处首先通过<i><font color="Green">choose_blendable_format</font></i>工具函数来判断希望的颜色附件格式是否支持颜色混合，该工具函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkFormat <span class="hljs-title">choose_blendable_format</span><span class="hljs-params">(VkPhysicalDevice physical_device, <span class="hljs-type">const</span> std::vector&lt;VkFormat&gt; &amp;format_priority_list)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;format : format_priority_list)<br>	&#123;<br>		VkFormatProperties properties;<br>		<span class="hljs-built_in">vkGetPhysicalDeviceFormatProperties</span>(physical_device, format, &amp;properties);<br>		<span class="hljs-keyword">if</span> (properties.optimalTilingFeatures &amp; VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT)<br>		&#123;<br>			<span class="hljs-keyword">return</span> format;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;No suitable blendable format could be determined&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>另外需要注意的是，该离屏pass只需要一个颜色附件就可以了。因为泛光实际上是一种后处理效果，全程在屏幕空间进行，并不需要深度缓冲的支持，所以也就没有必要为该pass创建一个深度模板附件。</p><p>然后就是指定该颜色附件的描述，由于该颜色附件会被后续render pass用作纹理资源渲染最终输出到屏幕上的结果，因此该颜色附件的<i><font color="Orange">finalLayout</font></i>同样需要指定为<i><font color="Red">VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</font></i>。</p><p>之后代码同样需要指定该render pass的subpass以及subpass之间的依赖关系。不过这里需要注意在开头外部通道和内部子通道的源阶段设置上，除了指定用于同步颜色附件布局转换的<i><font color="Red">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>，代码还指定了<i><font color="Red">VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</font></i>，设置这个阶段是为了保证bloom render pass在着色器读取前一个离屏render pass渲染得到的颜色附件前该附件已经准备好了（subpass dependency一般用于保证附件的同步，但也可以保证其它非附件着色器资源的同步，只要该资源是在该render pass中使用）。之后子通道和结尾外部通道的同步依赖设置和之前离屏render pass一致，因为该渲染附件后续也会用作真正渲染到屏幕上的render pass的纹理资源。</p><p>后续bloom pass同样生成相应的framebuffer和采样器，这里不再赘述。</p><h3 id="setup_descriptor_set_layout">setup_descriptor_set_layout</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimestampQueries::setup_descriptor_set_layout</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::vector&lt;VkDescriptorSetLayoutBinding&gt; set_layout_bindings = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, <span class="hljs-number">0</span>),<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT, <span class="hljs-number">1</span>),<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_SHADER_STAGE_FRAGMENT_BIT, <span class="hljs-number">2</span>),<br>	&#125;;<br><br>	VkDescriptorSetLayoutCreateInfo descriptor_layout_create_info =<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_create_info</span>(set_layout_bindings.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(set_layout_bindings.<span class="hljs-built_in">size</span>()));<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorSetLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_layout_create_info, <span class="hljs-literal">nullptr</span>, &amp;descriptor_set_layouts.models));<br><br>	VkPipelineLayoutCreateInfo pipeline_layout_create_info =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_layout_create_info</span>(<br>	        &amp;descriptor_set_layouts.models,<br>	        <span class="hljs-number">1</span>);<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreatePipelineLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;pipeline_layout_create_info, <span class="hljs-literal">nullptr</span>, &amp;pipeline_layouts.models));<br><br>	<span class="hljs-comment">// Bloom filter</span><br>	set_layout_bindings = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT, <span class="hljs-number">0</span>),<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT, <span class="hljs-number">1</span>),<br>	&#125;;<br><br>	descriptor_layout_create_info = vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_create_info</span>(set_layout_bindings.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(set_layout_bindings.<span class="hljs-built_in">size</span>()));<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorSetLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_layout_create_info, <span class="hljs-literal">nullptr</span>, &amp;descriptor_set_layouts.bloom_filter));<br><br>	pipeline_layout_create_info = vkb::initializers::<span class="hljs-built_in">pipeline_layout_create_info</span>(&amp;descriptor_set_layouts.bloom_filter, <span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreatePipelineLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;pipeline_layout_create_info, <span class="hljs-literal">nullptr</span>, &amp;pipeline_layouts.bloom_filter));<br><br>	<span class="hljs-comment">// G-Buffer composition</span><br>	set_layout_bindings = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT, <span class="hljs-number">0</span>),<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT, <span class="hljs-number">1</span>),<br>	&#125;;<br><br>	descriptor_layout_create_info = vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_create_info</span>(set_layout_bindings.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(set_layout_bindings.<span class="hljs-built_in">size</span>()));<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorSetLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_layout_create_info, <span class="hljs-literal">nullptr</span>, &amp;descriptor_set_layouts.composition));<br><br>	pipeline_layout_create_info = vkb::initializers::<span class="hljs-built_in">pipeline_layout_create_info</span>(&amp;descriptor_set_layouts.composition, <span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreatePipelineLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;pipeline_layout_create_info, <span class="hljs-literal">nullptr</span>, &amp;pipeline_layouts.composition));<br>&#125;<br></code></pre></td></tr></table></figure><p>本示例使用三个pass来得到最后的渲染结果，所以这里创建了相应的三个描述符布局和管线布局。第一个是离屏pass所需的描述符布局，渲染该离屏pass需要一个环境贴图以及两个uniform buffer。接下来是离屏bloom render pass，需要离屏pass渲染得到的两张图像作为纹理绑定到管线上。最后的合并pass同样需要两个纹理，这在后续的着色器代码中会看到。</p><h3 id="prepare_pipelines">prepare_pipelines</h3><p>同样先上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimestampQueries::prepare_pipelines</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	VkPipelineInputAssemblyStateCreateInfo input_assembly_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_input_assembly_state_create_info</span>(<br>	        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,<br>	        <span class="hljs-number">0</span>,<br>	        VK_FALSE);<br><br>	VkPipelineRasterizationStateCreateInfo rasterization_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_rasterization_state_create_info</span>(<br>	        VK_POLYGON_MODE_FILL,<br>	        VK_CULL_MODE_BACK_BIT,<br>	        VK_FRONT_FACE_COUNTER_CLOCKWISE,<br>	        <span class="hljs-number">0</span>);<br><br>	VkPipelineColorBlendAttachmentState blend_attachment_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_color_blend_attachment_state</span>(<br>	        <span class="hljs-number">0xf</span>,<br>	        VK_FALSE);<br><br>	VkPipelineColorBlendStateCreateInfo color_blend_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_color_blend_state_create_info</span>(<br>	        <span class="hljs-number">1</span>,<br>	        &amp;blend_attachment_state);<br><br>	<span class="hljs-comment">// Note: Using reversed depth-buffer for increased precision, so Greater depth values are kept</span><br>	VkPipelineDepthStencilStateCreateInfo depth_stencil_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_depth_stencil_state_create_info</span>(<br>	        VK_FALSE,<br>	        VK_FALSE,<br>	        VK_COMPARE_OP_GREATER);<br><br>	VkPipelineViewportStateCreateInfo viewport_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_viewport_state_create_info</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><br>	VkPipelineMultisampleStateCreateInfo multisample_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_multisample_state_create_info</span>(<br>	        VK_SAMPLE_COUNT_1_BIT,<br>	        <span class="hljs-number">0</span>);<br><br>	std::vector&lt;VkDynamicState&gt; dynamic_state_enables = &#123;<br>	    VK_DYNAMIC_STATE_VIEWPORT,<br>	    VK_DYNAMIC_STATE_SCISSOR&#125;;<br>	VkPipelineDynamicStateCreateInfo dynamic_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_dynamic_state_create_info</span>(<br>	        dynamic_state_enables.<span class="hljs-built_in">data</span>(),<br>	        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(dynamic_state_enables.<span class="hljs-built_in">size</span>()),<br>	        <span class="hljs-number">0</span>);<br><br>	VkGraphicsPipelineCreateInfo pipeline_create_info =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_create_info</span>(<br>	        pipeline_layouts.models,<br>	        render_pass,<br>	        <span class="hljs-number">0</span>);<br><br>	std::vector&lt;VkPipelineColorBlendAttachmentState&gt; blend_attachment_states = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_color_blend_attachment_state</span>(<span class="hljs-number">0xf</span>, VK_FALSE),<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_color_blend_attachment_state</span>(<span class="hljs-number">0xf</span>, VK_FALSE),<br>	&#125;;<br><br>	pipeline_create_info.pInputAssemblyState = &amp;input_assembly_state;<br>	pipeline_create_info.pRasterizationState = &amp;rasterization_state;<br>	pipeline_create_info.pColorBlendState    = &amp;color_blend_state;<br>	pipeline_create_info.pMultisampleState   = &amp;multisample_state;<br>	pipeline_create_info.pViewportState      = &amp;viewport_state;<br>	pipeline_create_info.pDepthStencilState  = &amp;depth_stencil_state;<br>	pipeline_create_info.pDynamicState       = &amp;dynamic_state;<br><br>	std::array&lt;VkPipelineShaderStageCreateInfo, 2&gt; shader_stages;<br>	pipeline_create_info.stageCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(shader_stages.<span class="hljs-built_in">size</span>());<br>	pipeline_create_info.pStages    = shader_stages.<span class="hljs-built_in">data</span>();<br><br>	VkSpecializationInfo                    specialization_info;<br>	std::array&lt;VkSpecializationMapEntry, 1&gt; specialization_map_entries;<br><br>	<span class="hljs-comment">// Full screen pipelines</span><br><br>	<span class="hljs-comment">// Empty vertex input state, full screen triangles are generated by the vertex shader</span><br>	VkPipelineVertexInputStateCreateInfo empty_input_state = vkb::initializers::<span class="hljs-built_in">pipeline_vertex_input_state_create_info</span>();<br>	pipeline_create_info.pVertexInputState                 = &amp;empty_input_state;<br><br>	<span class="hljs-comment">// Final fullscreen composition pass pipeline</span><br>	shader_stages[<span class="hljs-number">0</span>]                  = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;hdr&quot;</span>, <span class="hljs-string">&quot;composition.vert&quot;</span>, VK_SHADER_STAGE_VERTEX_BIT);<br>	shader_stages[<span class="hljs-number">1</span>]                  = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;hdr&quot;</span>, <span class="hljs-string">&quot;composition.frag&quot;</span>, VK_SHADER_STAGE_FRAGMENT_BIT);<br>	pipeline_create_info.layout       = pipeline_layouts.composition;<br>	pipeline_create_info.renderPass   = render_pass;<br>	rasterization_state.cullMode      = VK_CULL_MODE_FRONT_BIT;<br>	color_blend_state.attachmentCount = <span class="hljs-number">1</span>;<br>	color_blend_state.pAttachments    = blend_attachment_states.<span class="hljs-built_in">data</span>();<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateGraphicsPipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;pipelines.composition));<br><br>	<span class="hljs-comment">// Bloom pass</span><br>	shader_stages[<span class="hljs-number">0</span>]                           = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;hdr&quot;</span>, <span class="hljs-string">&quot;bloom.vert&quot;</span>, VK_SHADER_STAGE_VERTEX_BIT);<br>	shader_stages[<span class="hljs-number">1</span>]                           = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;hdr&quot;</span>, <span class="hljs-string">&quot;bloom.frag&quot;</span>, VK_SHADER_STAGE_FRAGMENT_BIT);<br>	color_blend_state.pAttachments             = &amp;blend_attachment_state;<br>	blend_attachment_state.colorWriteMask      = <span class="hljs-number">0xF</span>;<br>	blend_attachment_state.blendEnable         = VK_TRUE;<br>	blend_attachment_state.colorBlendOp        = VK_BLEND_OP_ADD;<br>	blend_attachment_state.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;<br>	blend_attachment_state.dstColorBlendFactor = VK_BLEND_FACTOR_ONE;<br>	blend_attachment_state.alphaBlendOp        = VK_BLEND_OP_ADD;<br>	blend_attachment_state.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;<br>	blend_attachment_state.dstAlphaBlendFactor = VK_BLEND_FACTOR_DST_ALPHA;<br><br>	<span class="hljs-comment">// Set constant parameters via specialization constants</span><br>	specialization_map_entries[<span class="hljs-number">0</span>]        = vkb::initializers::<span class="hljs-built_in">specialization_map_entry</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>));<br>	<span class="hljs-type">uint32_t</span> dir                         = <span class="hljs-number">1</span>;<br>	specialization_info                  = vkb::initializers::<span class="hljs-built_in">specialization_info</span>(<span class="hljs-number">1</span>, specialization_map_entries.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">sizeof</span>(dir), &amp;dir);<br>	shader_stages[<span class="hljs-number">1</span>].pSpecializationInfo = &amp;specialization_info;<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateGraphicsPipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;pipelines.bloom[<span class="hljs-number">0</span>]));<br><br>	<span class="hljs-comment">// Second blur pass (into separate framebuffer)</span><br>	pipeline_create_info.renderPass = filter_pass.render_pass;<br>	dir                             = <span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateGraphicsPipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;pipelines.bloom[<span class="hljs-number">1</span>]));<br><br>	<span class="hljs-comment">// Object rendering pipelines</span><br>	rasterization_state.cullMode = VK_CULL_MODE_BACK_BIT;<br><br>	<span class="hljs-comment">// Vertex bindings an attributes for model rendering</span><br>	<span class="hljs-comment">// Binding description</span><br>	std::vector&lt;VkVertexInputBindingDescription&gt; vertex_input_bindings = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_binding_description</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Vertex), VK_VERTEX_INPUT_RATE_VERTEX),<br>	&#125;;<br><br>	<span class="hljs-comment">// Attribute descriptions</span><br>	std::vector&lt;VkVertexInputAttributeDescription&gt; vertex_input_attributes = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, VK_FORMAT_R32G32B32_SFLOAT, <span class="hljs-number">0</span>),                       <span class="hljs-comment">// Position</span><br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, VK_FORMAT_R32G32B32_SFLOAT, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>) * <span class="hljs-number">3</span>)        <span class="hljs-comment">// Normal</span><br>	&#125;;<br><br>	VkPipelineVertexInputStateCreateInfo vertex_input_state = vkb::initializers::<span class="hljs-built_in">pipeline_vertex_input_state_create_info</span>();<br>	vertex_input_state.vertexBindingDescriptionCount        = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertex_input_bindings.<span class="hljs-built_in">size</span>());<br>	vertex_input_state.pVertexBindingDescriptions           = vertex_input_bindings.<span class="hljs-built_in">data</span>();<br>	vertex_input_state.vertexAttributeDescriptionCount      = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertex_input_attributes.<span class="hljs-built_in">size</span>());<br>	vertex_input_state.pVertexAttributeDescriptions         = vertex_input_attributes.<span class="hljs-built_in">data</span>();<br><br>	pipeline_create_info.pVertexInputState = &amp;vertex_input_state;<br><br>	<span class="hljs-comment">// Skybox pipeline (background cube)</span><br>	blend_attachment_state.blendEnable = VK_FALSE;<br>	pipeline_create_info.layout        = pipeline_layouts.models;<br>	pipeline_create_info.renderPass    = offscreen.render_pass;<br>	color_blend_state.attachmentCount  = <span class="hljs-number">2</span>;<br>	color_blend_state.pAttachments     = blend_attachment_states.<span class="hljs-built_in">data</span>();<br><br>	shader_stages[<span class="hljs-number">0</span>] = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;hdr&quot;</span>, <span class="hljs-string">&quot;gbuffer.vert&quot;</span>, VK_SHADER_STAGE_VERTEX_BIT);<br>	shader_stages[<span class="hljs-number">1</span>] = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;hdr&quot;</span>, <span class="hljs-string">&quot;gbuffer.frag&quot;</span>, VK_SHADER_STAGE_FRAGMENT_BIT);<br><br>	<span class="hljs-comment">// Set constant parameters via specialization constants</span><br>	specialization_map_entries[<span class="hljs-number">0</span>]        = vkb::initializers::<span class="hljs-built_in">specialization_map_entry</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>));<br>	<span class="hljs-type">uint32_t</span> shadertype                  = <span class="hljs-number">0</span>;<br>	specialization_info                  = vkb::initializers::<span class="hljs-built_in">specialization_info</span>(<span class="hljs-number">1</span>, specialization_map_entries.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">sizeof</span>(shadertype), &amp;shadertype);<br>	shader_stages[<span class="hljs-number">0</span>].pSpecializationInfo = &amp;specialization_info;<br>	shader_stages[<span class="hljs-number">1</span>].pSpecializationInfo = &amp;specialization_info;<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateGraphicsPipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;pipelines.skybox));<br><br>	<span class="hljs-comment">// Object rendering pipeline</span><br>	shadertype = <span class="hljs-number">1</span>;<br><br>	<span class="hljs-comment">// Enable depth test and write</span><br>	depth_stencil_state.depthWriteEnable = VK_TRUE;<br>	depth_stencil_state.depthTestEnable  = VK_TRUE;<br>	<span class="hljs-comment">// Flip cull mode</span><br>	rasterization_state.cullMode = VK_CULL_MODE_FRONT_BIT;<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateGraphicsPipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;pipelines.reflect));<br>&#125;<br></code></pre></td></tr></table></figure><p>首先创建的是最后的合并pass的管线，该管线无需深度测试，无需颜色混合，甚至无需绑定顶点缓冲，实际上该管线的顶点数据会直接在着色器中生成，这也是渲染一个全屏pass的常用优化手段，在后续的着色器代码中会看到。另外还需要注意绑定到该管线的render pass是应用程序类基类本就提供好的一个一般的用于渲染到后台缓冲的render pass。接下来就来看一下该渲染管线使用的着色器代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//vertex shader</span><br><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> outUV;<br><br><span class="hljs-keyword">out</span> gl_PerVertex<br>&#123;<br>	<span class="hljs-type">vec4</span> <span class="hljs-built_in">gl_Position</span>;<br>&#125;;<br><br><span class="hljs-type">void</span> main() <br>&#123;<br>	outUV = <span class="hljs-type">vec2</span>((gl_VertexIndex &lt;&lt; <span class="hljs-number">1</span>) &amp; <span class="hljs-number">2</span>, gl_VertexIndex &amp; <span class="hljs-number">2</span>);<br>	<span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(outUV * <span class="hljs-number">2.0</span>f - <span class="hljs-number">1.0</span>f, <span class="hljs-number">0.0</span>f, <span class="hljs-number">1.0</span>f);<br>&#125;<br><br><span class="hljs-comment">//fragment shader</span><br><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> samplerColor0;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> samplerColor1;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inUV;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outColor;<br><br><span class="hljs-type">void</span> main() <br>&#123;<br>	outColor = <span class="hljs-built_in">texture</span>(samplerColor0, inUV);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，顶点着色器生成的outUV其实就是屏幕上的点。具体而言，后续在录制命令函数中我们会看到，绘制命令会将顶点数设置为3，所以即使没有实际的顶点缓冲绑定，顶点着色器程序中的<strong>gl_VertexIndex</strong>还是会在三次调用中分别被指定为0，1，2，那么可以计算得到它们相应的outUV就分别为（0，0），（2，0），（0，2），这样可以得到相应的三个点的<strong>gl_Position</strong>，也就是代表的顶点在裁剪空间中的坐标分别为（-1，-1，0，1），（3，-1，0，1），（-1，3，0，1），可以发现这三个点构成的三角形实际上正好包含了NDC坐标空间（[-1，1] x [-1，1]），多余的部分事实上会在裁剪阶段被裁剪掉，因此最后也能正确地渲染出一个全屏四边形，相比于直接上传一个四边形的顶点数据，它的优势就在于无需绑定顶点缓冲和索引缓冲，效率更高。</p><p>关于该管线还有一点需要注意，就是cull mode的设置。可以看到该管线的cull mode被设置为正面剔除，结合前面三角形绕序设置为逆时针可知，顶点为逆时针绕序的三角形将被剔除，而上文顶点着色器代码中生成的三角形顶点绕序为顺时针，所以并不会被剔除。</p><p>接下来的片段着色器代码十分简单，就是一个单纯的对第一个纹理的采样操作。这里需要注意两点，首先是后面我们会看到，第一个绑定的纹理实际上就是第一个离屏pass渲染得到第一张图像，也就是正常的颜色图像，所以这个合并管线的作用也仅仅就是将颜色图像从离屏帧缓冲渲染到后台帧缓冲上去。第二点需要注意的是这里的<strong>inUV</strong>，由于进行光栅化的过程中会对顶点着色器中的顶点属性进行透视插值（这里没有透视效果那就是普通的线性插值），因此原来（3，-1）的点对应的<strong>outUV</strong>，也就是纹理坐标为（2，0），那么处于（-1，-1）和（3，-1）中点的四边形右上顶点对应的纹理坐标就应该是（1，0），全屏四边形的另外几个顶点的纹理坐标可以同样算出，可以发现这样计算得到的纹理坐标和在传入顶点数据的时候分别指定四个顶点的纹理坐标得到的插值结果是完全一致的。</p><p>接下来是第一个离屏bloom pass对应的管线的创建，可以看到在创建该管线的时候，代码开启了颜色混合，混合操作也就是简单的相加。并且这里还设置了一个specialization constant，后续在阅读着色器代码的时候可以看到这个常量只是为了区分当前是哪一个bloom pass，因为事实上该示例会使用两个bloom pass，第一个在离屏pass之后渲染，第二个在合并pass之后做最后的后处理渲染。</p><p>紧接着就是创建第二个bloom pass用到的管线，区别仅仅在于specialization constant以及render pass的设置，前一个bloom管线需要的是之前在创建离屏pass函数中创建的那个用于bloom的离屏pass，后一个则需要的是普通的渲染到后台缓冲区的render pass。这两个bloom管线使用的着色器是一样的，代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//vertex shader</span><br><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> outUV;<br><br><span class="hljs-keyword">out</span> gl_PerVertex<br>&#123;<br>	<span class="hljs-type">vec4</span> <span class="hljs-built_in">gl_Position</span>;<br>&#125;;<br><br><span class="hljs-type">void</span> main() <br>&#123;<br>	outUV = <span class="hljs-type">vec2</span>((gl_VertexIndex &lt;&lt; <span class="hljs-number">1</span>) &amp; <span class="hljs-number">2</span>, gl_VertexIndex &amp; <span class="hljs-number">2</span>);<br>	<span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(outUV * <span class="hljs-number">2.0</span>f - <span class="hljs-number">1.0</span>f, <span class="hljs-number">0.0</span>f, <span class="hljs-number">1.0</span>f);<br>&#125;<br><br><span class="hljs-comment">//fragment shader</span><br><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> samplerColor0;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> samplerColor1;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inUV;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outColor;<br><br><span class="hljs-keyword">layout</span> (constant_id = <span class="hljs-number">0</span>) <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> dir = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>)<br>&#123;<br>	<span class="hljs-comment">// From the OpenGL Super bible</span><br>	<span class="hljs-keyword">const</span> <span class="hljs-type">float</span> weights[] = <span class="hljs-type">float</span>[](<span class="hljs-number">0.0024499299678342</span>,<br>									<span class="hljs-number">0.0043538453346397</span>,<br>									<span class="hljs-number">0.0073599963704157</span>,<br>									<span class="hljs-number">0.0118349786570722</span>,<br>									<span class="hljs-number">0.0181026699707781</span>,<br>									<span class="hljs-number">0.0263392293891488</span>,<br>									<span class="hljs-number">0.0364543006660986</span>,<br>									<span class="hljs-number">0.0479932050577658</span>,<br>									<span class="hljs-number">0.0601029809166942</span>,<br>									<span class="hljs-number">0.0715974486241365</span>,<br>									<span class="hljs-number">0.0811305381519717</span>,<br>									<span class="hljs-number">0.0874493212267511</span>,<br>									<span class="hljs-number">0.0896631113333857</span>,<br>									<span class="hljs-number">0.0874493212267511</span>,<br>									<span class="hljs-number">0.0811305381519717</span>,<br>									<span class="hljs-number">0.0715974486241365</span>,<br>									<span class="hljs-number">0.0601029809166942</span>,<br>									<span class="hljs-number">0.0479932050577658</span>,<br>									<span class="hljs-number">0.0364543006660986</span>,<br>									<span class="hljs-number">0.0263392293891488</span>,<br>									<span class="hljs-number">0.0181026699707781</span>,<br>									<span class="hljs-number">0.0118349786570722</span>,<br>									<span class="hljs-number">0.0073599963704157</span>,<br>									<span class="hljs-number">0.0043538453346397</span>,<br>									<span class="hljs-number">0.0024499299678342</span>);<br><br><br>	<span class="hljs-keyword">const</span> <span class="hljs-type">float</span> blurScale = <span class="hljs-number">0.003</span>;<br>	<span class="hljs-keyword">const</span> <span class="hljs-type">float</span> blurStrength = <span class="hljs-number">1.0</span>;<br><br>	<span class="hljs-type">float</span> ar = <span class="hljs-number">1.0</span>;<br>	<span class="hljs-comment">// Aspect ratio for vertical blur pass</span><br>	<span class="hljs-keyword">if</span> (dir == <span class="hljs-number">1</span>)<br>	&#123;<br>		<span class="hljs-type">vec2</span> ts = <span class="hljs-built_in">textureSize</span>(samplerColor1, <span class="hljs-number">0</span>);<br>		ar = ts.y / ts.x;<br>	&#125;<br><br>	<span class="hljs-type">vec2</span> P = inUV.yx - <span class="hljs-type">vec2</span>(<span class="hljs-number">0</span>, (weights.<span class="hljs-built_in">length</span>() &gt;&gt; <span class="hljs-number">1</span>) * ar * blurScale);<br><br>	<span class="hljs-type">vec4</span> color = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weights.<span class="hljs-built_in">length</span>(); i++)<br>	&#123;<br>		<span class="hljs-type">vec2</span> dv = <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>, i * blurScale) * ar;<br>		color += <span class="hljs-built_in">texture</span>(samplerColor1, P + dv) * weights[i] * blurStrength;<br>	&#125;<br><br>	outColor = color;<br>&#125;<br></code></pre></td></tr></table></figure><p>顶点着色器和前面的合并pass使用的一致，都是生成一个全屏四边形，下面来看片段着色器。</p><p>这里不会仔细解释这一段代码了，主要逻辑就是使用一个高斯核对离屏pass生成的高光部分进行模糊处理，但是我认为这段代码实际上是有一些问题的，因为首先<code>dir=0</code>（水平模糊）时，<code>ar</code> 仍为 1.0，但 <code>dv</code> 的偏移方向为 y 轴（<code>vec2(0.0, i * blurScale)</code>），这与预期不符，另外此代码仅使用 <code>samplerColor1</code>，而 <code>samplerColor0</code> 未被使用。这些地方我暂时无法理解，个人认为比较逻辑清晰的bloom着色器代码可以参考<a target="_blank" rel="noopener" href="https://learnopengl.com/Advanced-Lighting/Bloom"><code>LearnOpenGL</code></a>网站上的教程。</p><p>最后来创建绘制物体和天空盒的管线。首先需要将cull mode改回来，然后需要指定正确的模型顶点和索引缓冲，还需要关闭颜色混合，并且设置好specialization constants，这里的specialization constants用于区分当前绘制的是天空盒还是普通物体（因为这两种物体的渲染使用的是同一个着色器）。这两个管线用到的render pass都是离屏pass创建函数中创建的第一个render pass，着色器使用的也是同一套，不过需要注意渲染物体的时候开启了深度测试以得到正确的渲染结果。着色器代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//vertex shader</span><br><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inNormal;<br><br><span class="hljs-keyword">layout</span> (constant_id = <span class="hljs-number">0</span>) <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> type = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> UBO &#123;<br>	<span class="hljs-type">mat4</span> projection;<br>	<span class="hljs-type">mat4</span> modelview;<br>	<span class="hljs-type">mat4</span> skybox_modelview;<br>	<span class="hljs-type">mat4</span> inverse_modelview;<br>	<span class="hljs-type">float</span> modelscale;<br>&#125; ubo;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> outUVW;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> outPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> outNormal;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> outViewVec;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">4</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> outLightVec;<br><br><span class="hljs-type">void</span> main() <br>&#123;<br>	outUVW = inPos;<br><br>	<span class="hljs-keyword">switch</span>(type) &#123;<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">// Skybox</span><br>			outPos = <span class="hljs-type">vec3</span>(<span class="hljs-type">mat3</span>(ubo.skybox_modelview) * inPos);<br>			<span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(ubo.projection * <span class="hljs-type">vec4</span>(outPos, <span class="hljs-number">1.0</span>));<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// Object</span><br>			outPos = <span class="hljs-type">vec3</span>(ubo.modelview * <span class="hljs-type">vec4</span>(inPos * ubo.modelscale, <span class="hljs-number">1.0</span>));<br>			<span class="hljs-built_in">gl_Position</span> = ubo.projection * ubo.modelview * <span class="hljs-type">vec4</span>(inPos.xyz * ubo.modelscale, <span class="hljs-number">1.0</span>);<br>			<span class="hljs-keyword">break</span>;<br>	&#125;<br>	outNormal = <span class="hljs-type">mat3</span>(ubo.modelview) * inNormal;	<br>	<br>	<span class="hljs-type">vec3</span> lightPos = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>f, <span class="hljs-number">-5.0</span>f, <span class="hljs-number">5.0</span>f);<br>	outLightVec = lightPos.xyz - outPos.xyz;<br>	outViewVec = -outPos.xyz;		<br>&#125;<br><br><span class="hljs-comment">//fragment shader</span><br><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">samplerCube</span> samplerEnvMap;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inUVW;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inNormal;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inViewVec;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">4</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inLightVec;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outColor0;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outColor1;<br><br><span class="hljs-keyword">layout</span> (constant_id = <span class="hljs-number">0</span>) <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> type = <span class="hljs-number">0</span>;<br><br><span class="hljs-meta">#define PI 3.1415926</span><br><span class="hljs-meta">#define TwoPI (2.0 * PI)</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> UBOCamera &#123;<br>	<span class="hljs-type">mat4</span> projection;<br>	<span class="hljs-type">mat4</span> modelview;<br>	<span class="hljs-type">mat4</span> skybox_modelview;<br>	<span class="hljs-type">mat4</span> inverse_modelview;<br>	<span class="hljs-type">float</span> modelscale;<br>&#125; uboCamera;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">uniform</span> UBO &#123;<br>	<span class="hljs-type">float</span> exposure;<br>&#125; ubo;<br><br><span class="hljs-type">void</span> main() <br>&#123;<br>	<span class="hljs-type">vec4</span> color;<br>	<span class="hljs-type">vec3</span> wcNormal;<br><br>	<span class="hljs-keyword">switch</span> (type) &#123;<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">// Skybox			</span><br>			&#123;<br>				<span class="hljs-type">vec3</span> normal = <span class="hljs-built_in">normalize</span>(inUVW);<br>				color = <span class="hljs-built_in">texture</span>(samplerEnvMap, normal);<br>			&#125;<br>			<span class="hljs-keyword">break</span>;<br>		<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// Reflect</span><br>			&#123;<br>				<span class="hljs-type">vec3</span> wViewVec = <span class="hljs-type">mat3</span>(uboCamera.inverse_modelview) * <span class="hljs-built_in">normalize</span>(inViewVec);<br>				<span class="hljs-type">vec3</span> normal = <span class="hljs-built_in">normalize</span>(inNormal);<br>				<span class="hljs-type">vec3</span> wNormal = <span class="hljs-type">mat3</span>(uboCamera.inverse_modelview) * normal;<br><br>				<span class="hljs-type">float</span> NdotL = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(normal, inLightVec), <span class="hljs-number">0.0</span>);<br><br>				<span class="hljs-type">vec3</span> eyeDir = <span class="hljs-built_in">normalize</span>(inViewVec);		<br>				<span class="hljs-type">vec3</span> halfVec = <span class="hljs-built_in">normalize</span>(inLightVec + eyeDir);<br>				<span class="hljs-type">float</span> NdotH = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(normal, halfVec), <span class="hljs-number">0.0</span>); <br>				<span class="hljs-type">float</span> NdotV = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(normal, eyeDir), <span class="hljs-number">0.0</span>); <br>				<span class="hljs-type">float</span> VdotH = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(eyeDir, halfVec), <span class="hljs-number">0.0</span>);<br>		<br>				<span class="hljs-comment">// Geometric attenuation</span><br>				<span class="hljs-type">float</span> NH2 = <span class="hljs-number">2.0</span> * NdotH;<br>				<span class="hljs-type">float</span> g1 = (NH2 * NdotV) / VdotH;<br>				<span class="hljs-type">float</span> g2 = (NH2 * NdotL) / VdotH;<br>				<span class="hljs-type">float</span> geoAtt = <span class="hljs-built_in">min</span>(<span class="hljs-number">1.0</span>, <span class="hljs-built_in">min</span>(g1, g2));<br><br>				<span class="hljs-keyword">const</span> <span class="hljs-type">float</span> F0 = <span class="hljs-number">0.6</span>;<br>				<span class="hljs-keyword">const</span> <span class="hljs-type">float</span> k = <span class="hljs-number">0.2</span>;<br><br>				<span class="hljs-comment">// Fresnel (schlick approximation)</span><br>				<span class="hljs-type">float</span> fresnel = <span class="hljs-built_in">pow</span>(<span class="hljs-number">1.0</span> - VdotH, <span class="hljs-number">5.0</span>);<br>				fresnel *= (<span class="hljs-number">1.0</span> - F0);<br>				fresnel += F0;<br>		<br>				<span class="hljs-comment">// Note: clamp to zero to mitigate any divide by zero</span><br>				<span class="hljs-type">float</span> spec = <span class="hljs-built_in">max</span>((fresnel * geoAtt) / (NdotV * NdotL * <span class="hljs-number">3.14</span>), <span class="hljs-number">0.0</span>);<br> <br>				color = <span class="hljs-built_in">texture</span>(samplerEnvMap, <span class="hljs-built_in">reflect</span>(-wViewVec, wNormal));	 	<br><br>				color = <span class="hljs-type">vec4</span>(color.rgb * NdotL * (k + spec * (<span class="hljs-number">1.0</span> - k)), <span class="hljs-number">1.0</span>);<br>			&#125;<br>			<span class="hljs-keyword">break</span>;<br><br>		<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">// Refract			</span><br>			&#123;<br>				<span class="hljs-type">vec3</span> wViewVec = <span class="hljs-type">mat3</span>(uboCamera.inverse_modelview) * <span class="hljs-built_in">normalize</span>(inViewVec);<br>				<span class="hljs-type">vec3</span> wNormal = <span class="hljs-type">mat3</span>(uboCamera.inverse_modelview) * inNormal;<br>				color = <span class="hljs-built_in">texture</span>(samplerEnvMap, <span class="hljs-built_in">refract</span>(-wViewVec, wNormal, <span class="hljs-number">1.0</span>/<span class="hljs-number">1.6</span>));		<br>			&#125;<br>			<span class="hljs-keyword">break</span>;<br>	&#125;<br><br><br>	<span class="hljs-comment">// Color with manual exposure into attachment 0</span><br>	outColor0.rgb = <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>) - <span class="hljs-built_in">exp</span>(-color.rgb * ubo.exposure);<br><br>	<span class="hljs-comment">// Bright parts for bloom into attachment 1</span><br>	<span class="hljs-type">float</span> l = <span class="hljs-built_in">dot</span>(outColor0.rgb, <span class="hljs-type">vec3</span>(<span class="hljs-number">0.2126</span>, <span class="hljs-number">0.7152</span>, <span class="hljs-number">0.0722</span>));<br>	<span class="hljs-type">float</span> threshold = <span class="hljs-number">0.75</span>;<br>	outColor1.rgb = (l &gt; threshold) ? outColor0.rgb : <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>);<br>	outColor1.a = <span class="hljs-number">1.0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先看顶点着色器，逻辑十分简单，就是根据当前物体的种类（一般物体还是天空盒）来计算位置、法线等向量。天空盒位置坐标的计算需要排除模型矩阵中平移的影响，这可以通过将<code>ubo.skybox_modelview</code>裁剪为左上角3x3的矩阵来实现（具体原理可以参考<a target="_blank" rel="noopener" href="https://learnopengl.com/Advanced-OpenGL/Cubemaps"><code>LearnOpenGL天空盒教程</code></a>）。另外，该代码中计算观察空间内的法线值我认为是不严谨的，因为它是直接使用模型观察矩阵乘积乘以模型空间中的法线向量了，但事实上法线的变换应该通过左乘模型观察矩阵的转置逆来实现。我认为这里之所以这么设置还能得出正确的结果，是因为回顾之前更新Uniform的函数可以发现，所有物体的模型矩阵要么是单位矩阵，要么是一个缩放乘上一个旋转，对于旋转矩阵和单位矩阵，其转置逆就是它自身，而对于缩放矩阵，其转置逆会是原来的矩阵的常数倍，但这实际上并不会影响之后对该法向量的使用，因为在使用该法向量的时候总是要把其化为单位向量的，多乘一个常数最后化出来的单位向量还是一致的；而对于观察矩阵，它是一个平移矩阵乘以一个旋转矩阵，平移分量并不会影响法向量的计算（用mat3强制转换符去掉了），而旋转的转置逆是它自身，所以同样无影响。当然，虽说最后结果是对的，但我仍然认为这种写法本身是不严谨且容易令人迷惑的。</p><p>接下来就是片段着色器，这部分代码不会具体分析了，主要逻辑其实也就是如果绘制的是天空盒就直接采样得到颜色，如果绘制的是一般物体就计算反射颜色（实际上程序代码中并没有设置过specialization constants为2，所以折射部分代码实际上并没有使用到。。。），然后反射部分使用的是一个部分的微表面brdf模型（之所以说是部分的，因为我怎么看这个公式和games202中的微表面模型公式都不太相同。。。），最后输出经过exposure处理后的颜色值到第一个颜色附件，输出高光值到第二个颜色附件。</p><h3 id="setup_descriptor_pool">setup_descriptor_pool</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimestampQueries::setup_descriptor_pool</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::vector&lt;VkDescriptorPoolSize&gt; pool_sizes = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_pool_size</span>(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">4</span>),<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_pool_size</span>(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="hljs-number">6</span>)&#125;;<br>	<span class="hljs-type">uint32_t</span>                   num_descriptor_sets = <span class="hljs-number">4</span>;<br>	VkDescriptorPoolCreateInfo descriptor_pool_create_info =<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_pool_create_info</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(pool_sizes.<span class="hljs-built_in">size</span>()), pool_sizes.<span class="hljs-built_in">data</span>(), num_descriptor_sets);<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorPool</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_pool_create_info, <span class="hljs-literal">nullptr</span>, &amp;descriptor_pool));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到代码是创建了一个包含四个描述符集的描述符池，其中可以分配四个uniform buffer和6个组合图像采样器。这是因为程序将为渲染天空盒、渲染物体、bloom和合成管线分别创建一个描述符集，根据渲染天空盒和渲染物体所使用的管线可知它们都需要两个uniform buffer和一个cubemap，而bloom管线和合成管线各需要两个2D纹理。</p><h3 id="setup_descriptor_sets">setup_descriptor_sets</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimestampQueries::setup_descriptor_sets</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	VkDescriptorSetAllocateInfo alloc_info =<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_allocate_info</span>(<br>	        descriptor_pool,<br>	        &amp;descriptor_set_layouts.models,<br>	        <span class="hljs-number">1</span>);<br><br>	<span class="hljs-comment">// 3D object descriptor set</span><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;alloc_info, &amp;descriptor_sets.object));<br><br>	VkDescriptorBufferInfo            matrix_buffer_descriptor     = <span class="hljs-built_in">create_descriptor</span>(*uniform_buffers.matrices);<br>	VkDescriptorImageInfo             environment_image_descriptor = <span class="hljs-built_in">create_descriptor</span>(textures.envmap);<br>	VkDescriptorBufferInfo            params_buffer_descriptor     = <span class="hljs-built_in">create_descriptor</span>(*uniform_buffers.params);<br>	std::vector&lt;VkWriteDescriptorSet&gt; write_descriptor_sets        = &#123;<br>        vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_sets.object, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">0</span>, &amp;matrix_buffer_descriptor),<br>        vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_sets.object, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="hljs-number">1</span>, &amp;environment_image_descriptor),<br>        vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_sets.object, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">2</span>, &amp;params_buffer_descriptor),<br>    &#125;;<br>	<span class="hljs-built_in">vkUpdateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(write_descriptor_sets.<span class="hljs-built_in">size</span>()), write_descriptor_sets.<span class="hljs-built_in">data</span>(), <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>	<span class="hljs-comment">// Sky box descriptor set</span><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;alloc_info, &amp;descriptor_sets.skybox));<br><br>	matrix_buffer_descriptor     = <span class="hljs-built_in">create_descriptor</span>(*uniform_buffers.matrices);<br>	environment_image_descriptor = <span class="hljs-built_in">create_descriptor</span>(textures.envmap);<br>	params_buffer_descriptor     = <span class="hljs-built_in">create_descriptor</span>(*uniform_buffers.params);<br>	write_descriptor_sets        = &#123;<br>        vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_sets.skybox, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">0</span>, &amp;matrix_buffer_descriptor),<br>        vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_sets.skybox, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="hljs-number">1</span>, &amp;environment_image_descriptor),<br>        vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_sets.skybox, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">2</span>, &amp;params_buffer_descriptor),<br>    &#125;;<br>	<span class="hljs-built_in">vkUpdateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(write_descriptor_sets.<span class="hljs-built_in">size</span>()), write_descriptor_sets.<span class="hljs-built_in">data</span>(), <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>	<span class="hljs-comment">// Bloom filter</span><br>	alloc_info = vkb::initializers::<span class="hljs-built_in">descriptor_set_allocate_info</span>(descriptor_pool, &amp;descriptor_set_layouts.bloom_filter, <span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;alloc_info, &amp;descriptor_sets.bloom_filter));<br><br>	std::vector&lt;VkDescriptorImageInfo&gt; color_descriptors = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_image_info</span>(offscreen.sampler, offscreen.color[<span class="hljs-number">0</span>].view, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL),<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_image_info</span>(offscreen.sampler, offscreen.color[<span class="hljs-number">1</span>].view, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL),<br>	&#125;;<br><br>	write_descriptor_sets = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_sets.bloom_filter, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="hljs-number">0</span>, &amp;color_descriptors[<span class="hljs-number">0</span>]),<br>	    vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_sets.bloom_filter, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="hljs-number">1</span>, &amp;color_descriptors[<span class="hljs-number">1</span>]),<br>	&#125;;<br>	<span class="hljs-built_in">vkUpdateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(write_descriptor_sets.<span class="hljs-built_in">size</span>()), write_descriptor_sets.<span class="hljs-built_in">data</span>(), <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>	<span class="hljs-comment">// Composition descriptor set</span><br>	alloc_info = vkb::initializers::<span class="hljs-built_in">descriptor_set_allocate_info</span>(descriptor_pool, &amp;descriptor_set_layouts.composition, <span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;alloc_info, &amp;descriptor_sets.composition));<br><br>	color_descriptors = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_image_info</span>(offscreen.sampler, offscreen.color[<span class="hljs-number">0</span>].view, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL),<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_image_info</span>(offscreen.sampler, filter_pass.color[<span class="hljs-number">0</span>].view, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL),<br>	&#125;;<br><br>	write_descriptor_sets = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_sets.composition, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="hljs-number">0</span>, &amp;color_descriptors[<span class="hljs-number">0</span>]),<br>	    vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_sets.composition, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="hljs-number">1</span>, &amp;color_descriptors[<span class="hljs-number">1</span>]),<br>	&#125;;<br>	<span class="hljs-built_in">vkUpdateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(write_descriptor_sets.<span class="hljs-built_in">size</span>()), write_descriptor_sets.<span class="hljs-built_in">data</span>(), <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这部分代码只是常规的指定描述符和绑定描述符，至于每个管线绑定的是哪一个描述符在前文其实也已经分析得差不多了，后文在构建命令缓冲函数中还会看到具体得描述符集绑定。</p><h3 id="prepare_time_stamp_queries">prepare_time_stamp_queries</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimestampQueries::prepare_time_stamp_queries</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// We will get timestamps for the beginning and end of each of the three render passes in this sample, so we resize accordingly</span><br>	time_stamps.<span class="hljs-built_in">resize</span>(<span class="hljs-number">6</span>);<br><br>	<span class="hljs-comment">// Create the query pool object used to get the GPU time tamps</span><br>	VkQueryPoolCreateInfo query_pool_info&#123;&#125;;<br>	query_pool_info.sType = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;<br>	<span class="hljs-comment">// We need to specify the query type for this pool, which in our case is for time stamps</span><br>	query_pool_info.queryType = VK_QUERY_TYPE_TIMESTAMP;<br>	<span class="hljs-comment">// Set the no. of queries in this pool</span><br>	query_pool_info.queryCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(time_stamps.<span class="hljs-built_in">size</span>());<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateQueryPool</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;query_pool_info, <span class="hljs-literal">nullptr</span>, &amp;query_pool_timestamps));<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数的作用就是构建好查询时间戳所需要的查询池，<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyQueryPoolResults.html"><code>VkQueryPoolCreateInfo</code></a>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkQueryPoolCreateInfo</span> &#123;</span><br>    VkStructureType                  sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                      pNext;<br>    VkQueryPoolCreateFlags           flags;<br>    VkQueryType                      queryType;<br>    <span class="hljs-type">uint32_t</span>                         queryCount;<br>    VkQueryPipelineStatisticFlags    pipelineStatistics;<br>&#125; VkQueryPoolCreateInfo;<br></code></pre></td></tr></table></figure><p>可以看到我们需要指定的基础信息为该查询池的查询种类以及可以容纳的最大查询结果数。这里我们会将最大查询数量指定为6，因为程序总共有三个pass，每个pass的头尾各需要一个时间戳。</p><h3 id="build_command_buffers">build_command_buffers</h3><p>构建命令缓冲的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimestampQueries::build_command_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	VkCommandBufferBeginInfo command_buffer_begin_info = vkb::initializers::<span class="hljs-built_in">command_buffer_begin_info</span>();<br><br>	VkClearValue clear_values[<span class="hljs-number">2</span>];<br>	clear_values[<span class="hljs-number">0</span>].color        = &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;;<br>	clear_values[<span class="hljs-number">1</span>].depthStencil = &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0</span>&#125;;<br><br>	VkRenderPassBeginInfo render_pass_begin_info = vkb::initializers::<span class="hljs-built_in">render_pass_begin_info</span>();<br>	render_pass_begin_info.renderPass            = render_pass;<br>	render_pass_begin_info.renderArea.offset.x   = <span class="hljs-number">0</span>;<br>	render_pass_begin_info.renderArea.offset.y   = <span class="hljs-number">0</span>;<br>	render_pass_begin_info.clearValueCount       = <span class="hljs-number">2</span>;<br>	render_pass_begin_info.pClearValues          = clear_values;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; draw_cmd_buffers.<span class="hljs-built_in">size</span>(); ++i)<br>	&#123;<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBeginCommandBuffer</span>(draw_cmd_buffers[i], &amp;command_buffer_begin_info));<br><br>		<span class="hljs-comment">// Reset the timestamp query pool, so we can start fetching new values into it</span><br>		<span class="hljs-built_in">vkCmdResetQueryPool</span>(draw_cmd_buffers[i], query_pool_timestamps, <span class="hljs-number">0</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(time_stamps.<span class="hljs-built_in">size</span>()));<br><br>		&#123;<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			    First pass: Render scene to offscreen framebuffer</span><br><span class="hljs-comment">			*/</span><br><br>			<span class="hljs-built_in">vkCmdWriteTimestamp</span>(draw_cmd_buffers[i], VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, query_pool_timestamps, <span class="hljs-number">0</span>);<br><br>			std::array&lt;VkClearValue, 3&gt; clear_values;<br>			clear_values[<span class="hljs-number">0</span>].color        = &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;;<br>			clear_values[<span class="hljs-number">1</span>].color        = &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;;<br>			clear_values[<span class="hljs-number">2</span>].depthStencil = &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0</span>&#125;;<br><br>			VkRenderPassBeginInfo render_pass_begin_info    = vkb::initializers::<span class="hljs-built_in">render_pass_begin_info</span>();<br>			render_pass_begin_info.renderPass               = offscreen.render_pass;<br>			render_pass_begin_info.framebuffer              = offscreen.framebuffer;<br>			render_pass_begin_info.renderArea.extent.width  = offscreen.width;<br>			render_pass_begin_info.renderArea.extent.height = offscreen.height;<br>			render_pass_begin_info.clearValueCount          = <span class="hljs-number">3</span>;<br>			render_pass_begin_info.pClearValues             = clear_values.<span class="hljs-built_in">data</span>();<br><br>			<span class="hljs-built_in">vkCmdBeginRenderPass</span>(draw_cmd_buffers[i], &amp;render_pass_begin_info, VK_SUBPASS_CONTENTS_INLINE);<br><br>			VkViewport viewport = vkb::initializers::<span class="hljs-built_in">viewport</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(offscreen.width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(offscreen.height), <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br>			<span class="hljs-built_in">vkCmdSetViewport</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;viewport);<br><br>			VkRect2D scissor = vkb::initializers::<span class="hljs-built_in">rect2D</span>(offscreen.width, offscreen.height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>			<span class="hljs-built_in">vkCmdSetScissor</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;scissor);<br><br>			VkDeviceSize offsets[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>			<span class="hljs-comment">// Skybox</span><br>			<span class="hljs-keyword">if</span> (display_skybox)<br>			&#123;<br>				<span class="hljs-built_in">vkCmdBindPipeline</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipelines.skybox);<br>				<span class="hljs-built_in">vkCmdBindDescriptorSets</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline_layouts.models, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;descriptor_sets.skybox, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>				<span class="hljs-built_in">draw_model</span>(models.skybox, draw_cmd_buffers[i]);<br>			&#125;<br><br>			<span class="hljs-comment">// 3D object</span><br>			<span class="hljs-built_in">vkCmdBindPipeline</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipelines.reflect);<br>			<span class="hljs-built_in">vkCmdBindDescriptorSets</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline_layouts.models, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;descriptor_sets.object, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>			<span class="hljs-built_in">draw_model</span>(models.objects[models.object_index], draw_cmd_buffers[i]);<br><br>			<span class="hljs-built_in">vkCmdEndRenderPass</span>(draw_cmd_buffers[i]);<br><br>			<span class="hljs-built_in">vkCmdWriteTimestamp</span>(draw_cmd_buffers[i], VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, query_pool_timestamps, <span class="hljs-number">1</span>);<br>		&#125;<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		    Second render pass: First bloom pass</span><br><span class="hljs-comment">		*/</span><br>		<span class="hljs-keyword">if</span> (bloom)<br>		&#123;<br>			VkClearValue clear_values[<span class="hljs-number">2</span>];<br>			clear_values[<span class="hljs-number">0</span>].color        = &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;;<br>			clear_values[<span class="hljs-number">1</span>].depthStencil = &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0</span>&#125;;<br><br>			<span class="hljs-comment">// Bloom filter</span><br>			VkRenderPassBeginInfo render_pass_begin_info    = vkb::initializers::<span class="hljs-built_in">render_pass_begin_info</span>();<br>			render_pass_begin_info.framebuffer              = filter_pass.framebuffer;<br>			render_pass_begin_info.renderPass               = filter_pass.render_pass;<br>			render_pass_begin_info.clearValueCount          = <span class="hljs-number">1</span>;<br>			render_pass_begin_info.renderArea.extent.width  = filter_pass.width;<br>			render_pass_begin_info.renderArea.extent.height = filter_pass.height;<br>			render_pass_begin_info.pClearValues             = clear_values;<br><br>			<span class="hljs-built_in">vkCmdWriteTimestamp</span>(draw_cmd_buffers[i], VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, query_pool_timestamps, <span class="hljs-number">2</span>);<br><br>			<span class="hljs-built_in">vkCmdBeginRenderPass</span>(draw_cmd_buffers[i], &amp;render_pass_begin_info, VK_SUBPASS_CONTENTS_INLINE);<br><br>			VkViewport viewport = vkb::initializers::<span class="hljs-built_in">viewport</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(filter_pass.width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(filter_pass.height), <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br>			<span class="hljs-built_in">vkCmdSetViewport</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;viewport);<br><br>			VkRect2D scissor = vkb::initializers::<span class="hljs-built_in">rect2D</span>(filter_pass.width, filter_pass.height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>			<span class="hljs-built_in">vkCmdSetScissor</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;scissor);<br><br>			<span class="hljs-built_in">vkCmdBindDescriptorSets</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline_layouts.bloom_filter, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;descriptor_sets.bloom_filter, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>			<span class="hljs-built_in">vkCmdBindPipeline</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipelines.bloom[<span class="hljs-number">1</span>]);<br>			<span class="hljs-built_in">vkCmdDraw</span>(draw_cmd_buffers[i], <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>			<span class="hljs-built_in">vkCmdEndRenderPass</span>(draw_cmd_buffers[i]);<br><br>			<span class="hljs-built_in">vkCmdWriteTimestamp</span>(draw_cmd_buffers[i], VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, query_pool_timestamps, <span class="hljs-number">3</span>);<br>		&#125;<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		    Note: Explicit synchronization is not required between the render pass, as this is done implicit via sub pass dependencies</span><br><span class="hljs-comment">		*/</span><br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		    Third render pass: Scene rendering with applied second bloom pass (when enabled)</span><br><span class="hljs-comment">		*/</span><br>		&#123;<br>			VkClearValue clear_values[<span class="hljs-number">2</span>];<br>			clear_values[<span class="hljs-number">0</span>].color        = &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;;<br>			clear_values[<span class="hljs-number">1</span>].depthStencil = &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0</span>&#125;;<br><br>			<span class="hljs-comment">// Final composition</span><br>			VkRenderPassBeginInfo render_pass_begin_info    = vkb::initializers::<span class="hljs-built_in">render_pass_begin_info</span>();<br>			render_pass_begin_info.framebuffer              = framebuffers[i];<br>			render_pass_begin_info.renderPass               = render_pass;<br>			render_pass_begin_info.clearValueCount          = <span class="hljs-number">2</span>;<br>			render_pass_begin_info.renderArea.extent.width  = width;<br>			render_pass_begin_info.renderArea.extent.height = height;<br>			render_pass_begin_info.pClearValues             = clear_values;<br><br>			<span class="hljs-built_in">vkCmdWriteTimestamp</span>(draw_cmd_buffers[i], VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, query_pool_timestamps, bloom ? <span class="hljs-number">4</span> : <span class="hljs-number">2</span>);<br><br>			<span class="hljs-built_in">vkCmdBeginRenderPass</span>(draw_cmd_buffers[i], &amp;render_pass_begin_info, VK_SUBPASS_CONTENTS_INLINE);<br><br>			VkViewport viewport = vkb::initializers::<span class="hljs-built_in">viewport</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(height), <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br>			<span class="hljs-built_in">vkCmdSetViewport</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;viewport);<br><br>			VkRect2D scissor = vkb::initializers::<span class="hljs-built_in">rect2D</span>(width, height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>			<span class="hljs-built_in">vkCmdSetScissor</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;scissor);<br><br>			<span class="hljs-built_in">vkCmdBindDescriptorSets</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline_layouts.composition, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;descriptor_sets.composition, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>			<span class="hljs-comment">// Scene</span><br>			<span class="hljs-built_in">vkCmdBindPipeline</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipelines.composition);<br>			<span class="hljs-built_in">vkCmdDraw</span>(draw_cmd_buffers[i], <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>			<span class="hljs-comment">// Bloom</span><br>			<span class="hljs-keyword">if</span> (bloom)<br>			&#123;<br>				<span class="hljs-built_in">vkCmdBindPipeline</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipelines.bloom[<span class="hljs-number">0</span>]);<br>				<span class="hljs-built_in">vkCmdDraw</span>(draw_cmd_buffers[i], <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>			&#125;<br><br>			<span class="hljs-built_in">draw_ui</span>(draw_cmd_buffers[i]);<br><br>			<span class="hljs-built_in">vkCmdEndRenderPass</span>(draw_cmd_buffers[i]);<br><br>			<span class="hljs-built_in">vkCmdWriteTimestamp</span>(draw_cmd_buffers[i], VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, query_pool_timestamps, bloom ? <span class="hljs-number">5</span> : <span class="hljs-number">3</span>);<br>		&#125;<br><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkEndCommandBuffer</span>(draw_cmd_buffers[i]));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在录制命令列表的最开始需要首先重置查询池，这样之后才能将写入查询结果。</p><p>紧接着在第一个pass开始前插入一个时间戳写入。需要注意的是，时间戳查询与在 CPU 上使用高精度计数器（如 <code>QueryPerformanceCounter</code>）进行计时的机制存在显著差异。这主要源于 GPU 的工作特性：它会以高度并行化的方式在不同管线阶段分派任务、重叠执行操作，并以异步形式完成工作。因此，尽管从技术上讲，您可以指定在管线的任意阶段写入时间戳，但许多阶段的组合和顺序可能无法得到有意义的结果。此外，不同队列（Queue）上获取的时间戳无法直接比较，因为不同队列（如图形队列、计算队列）可能由硬件独立调度，其时间戳计数器可能不同步。跨队列的时间戳差值无法反映真实的执行间隔。因此，一般来讲将起始时间戳查询放在render pass头，也就是<i><font color="Red">VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</font></i>代表的渲染阶段，然后将结尾时间戳查询放在render pass尾，也就是<i><font color="Red">VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</font></i>代表的渲染阶段，一般可以查询到正确的运行时间结果。</p><p>然后首先开启第一个pass，也就是将场景渲染到两张离屏缓冲的pass。这里的<i><font color="Green">draw_models</font></i>就是录制绑定顶点、索引缓冲区以及执行绘制相关的命令的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ApiVulkanSample::draw_model</span><span class="hljs-params">(std::unique_ptr&lt;vkb::sg::SubMesh&gt; &amp;model, VkCommandBuffer command_buffer, <span class="hljs-type">uint32_t</span> instance_count)</span></span><br><span class="hljs-function"></span>&#123;<br>	VkDeviceSize offsets[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>	<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;vertex_buffer = model-&gt;vertex_buffers.<span class="hljs-built_in">at</span>(<span class="hljs-string">&quot;vertex_buffer&quot;</span>);<br>	<span class="hljs-keyword">auto</span>       &amp;index_buffer  = model-&gt;index_buffer;<br><br>	<span class="hljs-built_in">vkCmdBindVertexBuffers</span>(command_buffer, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, vertex_buffer.<span class="hljs-built_in">get</span>(), offsets);<br>	<span class="hljs-built_in">vkCmdBindIndexBuffer</span>(command_buffer, index_buffer-&gt;<span class="hljs-built_in">get_handle</span>(), <span class="hljs-number">0</span>, model-&gt;index_type);<br>	<span class="hljs-built_in">vkCmdDrawIndexed</span>(command_buffer, model-&gt;vertex_indices, instance_count, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在第一个render pass执行结束后再插入一个时间戳查询，这样就可以通过这两个时间戳之间的差值计算该pass渲染所占用的时长。之后的每一个pass同样会在开头和结尾分别写入一个时间戳。</p><p>在完成第一个render pass后，接下来需要开启第二个pass，也就是第一个bloom pass，这个bloom pass会对第一个渲染物体的pass输出的高光图进行模糊，并将模糊结果输出到一张离屏图像上。在该pass结束后就会开始最后的合并pass，该pass会将第一个render pass输出的正常颜色图输出到后台缓冲上去。最后，程序还会再进行一次bloom pass，这次的bloom pass和合并pass绑定的是相同的描述符集，都是包括了第一个pass得到的正常颜色图以及第二个pass得到的bloom图，最终的效果会是将bloom得到的离屏纹理上的图像再一次模糊后输出到后台缓冲上与原来的正常颜色图混合。</p><p>这里需要注意这些管线之间都是怎么同步的：首先Vulkan会保证隐式的子通道内部同步，也就是说同一个子通道内录制的命令会严格按照录制的顺序依次执行，并且会保证前一个命令的写入结果对后一个命令一定可见。因此尽管天空盒和普通物体使用的是不同的pipeline，但它们的绘制命令是录制在同一个子通道内的，因此二者之间并不需要显示的同步，最后的合并管线和第二次bloom管线也是如此；其次，程序对于离屏pass和离屏bloom pass的子通道依赖设置保证了渲染物体和天空盒的pass（也就是离屏pass）和第一次bloom pass（也就是离屏bloom pass）之间的同步依赖以及第一次bloom pass和后续的合并pass之间的依赖。因此程序不会发生同步上的问题。</p><p>准备阶段就此告一段落。</p><hr><h2 id="绘制阶段">绘制阶段</h2><p>接下来就是绘制阶段的代码分析了。首先来看绘制部分的核心函数<i><font color="Green">draw</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimestampQueries::draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	ApiVulkanSample::<span class="hljs-built_in">prepare_frame</span>();<br>	submit_info.commandBufferCount = <span class="hljs-number">1</span>;<br>	submit_info.pCommandBuffers    = &amp;draw_cmd_buffers[current_buffer];<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkQueueSubmit</span>(queue, <span class="hljs-number">1</span>, &amp;submit_info, VK_NULL_HANDLE));<br>	ApiVulkanSample::<span class="hljs-built_in">submit_frame</span>();<br><br>	<span class="hljs-comment">// Read back the time stamp query results after the frame is finished</span><br>	<span class="hljs-built_in">get_time_stamp_results</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到<i><font color="Green">draw</font></i>的逻辑分为两部分：提交录制的命令以及查询时间戳记录的结果。这里我们直接看时间戳结果的查询：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimestampQueries::get_time_stamp_results</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// The number of timestamps changes if the bloom pass is disabled</span><br>	<span class="hljs-type">uint32_t</span> count = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(bloom ? time_stamps.<span class="hljs-built_in">size</span>() : time_stamps.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>);<br><br>	<span class="hljs-comment">// Fetch the time stamp results written in the command buffer submissions</span><br>	<span class="hljs-comment">// A note on the flags used:</span><br>	<span class="hljs-comment">//	VK_QUERY_RESULT_64_BIT: Results will have 64 bits. As time stamp values are on nano-seconds, this flag should always be used to avoid 32 bit overflows</span><br>	<span class="hljs-comment">//  VK_QUERY_RESULT_WAIT_BIT: Since we want to immediately display the results, we use this flag to have the CPU wait until the results are available</span><br>	<span class="hljs-built_in">vkGetQueryPoolResults</span>(<br>	    <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(),<br>	    query_pool_timestamps,<br>	    <span class="hljs-number">0</span>,<br>	    count,<br>	    time_stamps.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint64_t</span>),<br>	    time_stamps.<span class="hljs-built_in">data</span>(),<br>	    <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint64_t</span>),<br>	    VK_QUERY_RESULT_64_BIT | VK_QUERY_RESULT_WAIT_BIT);<br>&#125;<br></code></pre></td></tr></table></figure><p>事实上获取时间戳结果有两种方式：在命令缓冲中录制使用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyQueryPoolResults.html"><code>vkCmdCopyQueryPoolResults</code></a>将结果复制到一个缓冲区的命令，或者在命令缓冲执行结束后使用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetQueryPoolResults.html"><code>vkGetQueryPoolResults</code></a>将结果回读到指定内存。本示例使用的是第二种方法，其函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkGetQueryPoolResults</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDevice                                    device,</span><br><span class="hljs-params">    VkQueryPool                                 queryPool,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    firstQuery,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    queryCount,</span><br><span class="hljs-params">    <span class="hljs-type">size_t</span>                                      dataSize,</span><br><span class="hljs-params">    <span class="hljs-type">void</span>*                                       pData,<span class="hljs-comment">//写入结果的内存</span></span><br><span class="hljs-params">    VkDeviceSize                                stride,</span><br><span class="hljs-params">    VkQueryResultFlags                          flags)</span>;<br></code></pre></td></tr></table></figure><p>这里只需要解释一下示例中指定的标志位：<i><font color="Red">VK_QUERY_RESULT_64_BIT</font></i>表示API得到的查询结果使用64位表示，如果不显示指定这个标志位的话，那么最终得到的结果会是32位的。但是如果仅仅使用32位存储结果，那极有可能最后的结果超出了32位能表示的最大数据范围。因为事实上时间戳查询得到的结果是以<strong>tick</strong>为单位的，可以看成是一个时间段的度量，而一tick具体表示多长时间可以通过<code>VkPhysicalDeviceLimits</code>结构体的<i><font color="Orange">timestampPeriod</font></i>成员来查询，它的数值就代表了一tick是多少纳秒（10^-9秒），因此差不多0.43秒的时间就已经超出了32时间戳查询的最大结果。然后就是标志位<i><font color="Red">VK_QUERY_RESULT_WAIT_BIT</font></i>，该标志位代表API会等待所有指定的查询都已经在GPU上执行结束了才进行到内存的写入，这就保证了在使用写入结果的内存时该内存内的所有结果都是有效的，该命令使用结束之后所有的结果立即可用，但缺点就是可能会阻塞应用程序。作为替代，也可以换用标志位<i><font color="Red">VK_QUERY_RESULT_WITH_AVAILABILITY_BIT</font></i>，该标志位就不会统一等待所有的时间戳查询完成，而是会返回每个时间戳查询结果目前是否有效（根据返回的有效性数字是不是非零）以及如果有效的话值是多少，因此如果使用这个标志位，就应该在每次查询某个时间戳结果的时候首先查询它的有效性，有效再进行结果的查询。这种方法在实际应用中更受青睐，它显然可以获得更好的性能。该标志的一个使用范例大致如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// time_stamp_with_availibility[current_frame * 2] contains the queried timestamp</span><br><span class="hljs-comment">// time_stamp_with_availibility[current_frame * 2 + 1] contains availability of the timestamp</span><br>std::array&lt;<span class="hljs-type">uint64_t</span>, max_frames_in_flight * 2&gt; time_stamp_with_availibility&#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawFrame</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">vkBeginCommandBuffer</span>(command_buffer, &amp;command_buffer_begin_info);<br><br>	<span class="hljs-comment">// Only write new timestamp if previous result is available</span><br>	<span class="hljs-keyword">if</span> (time_stamp_with_availibility[current_frame * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] != <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-built_in">vkCmdWriteTimestamp</span>(command_buffer, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, query_pool_timestamps, <span class="hljs-number">0</span>);<br>	&#125;<br><br>	<span class="hljs-comment">// Issue draw commands</span><br><br>	<span class="hljs-built_in">vkEndCommandBuffer</span>(command_buffer);<br><br>	<span class="hljs-comment">// Get deferred time stamp query for the current frame</span><br>	<span class="hljs-built_in">vkGetQueryPoolResults</span>(<br>		device,<br>		query_pool_timestamps,<br>		<span class="hljs-number">0</span>,<br>		<span class="hljs-number">1</span>,<br>		<span class="hljs-number">2</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint64_t</span>),<br>		&amp;time_stamp_with_availibility[Current_frame * max_frames_in_flight],<br>		<span class="hljs-number">2</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint64_t</span>),<br>		VK_QUERY_RESULT_64_BIT | VK_QUERY_RESULT_WITH_AVAILABILITY_BIT);<br><br>	<span class="hljs-comment">// Display time stamp for the current frame if available</span><br>	<span class="hljs-keyword">if</span> (time_stamp_with_availibility[current_frame * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] != <span class="hljs-number">0</span>) &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;Timestamp = &quot;</span> &lt;&lt; time_stamp_with_availibility[current_frame * <span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终程序会显示出每两次查询之间的时间间隔，该逻辑在UI的更新逻辑中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimestampQueries::on_update_ui_overlay</span><span class="hljs-params">(vkb::Drawer &amp;drawer)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (drawer.<span class="hljs-built_in">header</span>(<span class="hljs-string">&quot;Settings&quot;</span>))<br>	&#123;<br>		<span class="hljs-keyword">if</span> (drawer.<span class="hljs-built_in">combo_box</span>(<span class="hljs-string">&quot;Object type&quot;</span>, &amp;models.object_index, object_names))<br>		&#123;<br>			<span class="hljs-built_in">update_uniform_buffers</span>();<br>			<span class="hljs-built_in">rebuild_command_buffers</span>();<br>		&#125;<br>		<span class="hljs-keyword">if</span> (drawer.<span class="hljs-built_in">input_float</span>(<span class="hljs-string">&quot;Exposure&quot;</span>, &amp;ubo_params.exposure, <span class="hljs-number">0.025f</span>, <span class="hljs-string">&quot;%.3f&quot;</span>))<br>		&#123;<br>			<span class="hljs-built_in">update_params</span>();<br>		&#125;<br>		<span class="hljs-keyword">if</span> (drawer.<span class="hljs-built_in">checkbox</span>(<span class="hljs-string">&quot;Bloom&quot;</span>, &amp;bloom))<br>		&#123;<br>			<span class="hljs-built_in">rebuild_command_buffers</span>();<br>		&#125;<br>		<span class="hljs-keyword">if</span> (drawer.<span class="hljs-built_in">checkbox</span>(<span class="hljs-string">&quot;Skybox&quot;</span>, &amp;display_skybox))<br>		&#123;<br>			<span class="hljs-built_in">rebuild_command_buffers</span>();<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (drawer.<span class="hljs-built_in">header</span>(<span class="hljs-string">&quot;timing&quot;</span>))<br>	&#123;<br>		<span class="hljs-comment">// Timestamps don&#x27;t have a time unit themselves, but are read as timesteps</span><br>		<span class="hljs-comment">// The timestampPeriod property of the device tells how many nanoseconds such a timestep translates to on the selected device</span><br>		<span class="hljs-type">float</span> timestampFrequency = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_properties</span>().limits.timestampPeriod;<br><br>		drawer.<span class="hljs-built_in">text</span>(<span class="hljs-string">&quot;Pass 1: Offscreen scene rendering: %.3f ms&quot;</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(time_stamps[<span class="hljs-number">1</span>] - time_stamps[<span class="hljs-number">0</span>]) * timestampFrequency / <span class="hljs-number">1000000.0f</span>);<br>		drawer.<span class="hljs-built_in">text</span>(<span class="hljs-string">&quot;Pass 2: %s %.3f ms&quot;</span>, (bloom ? <span class="hljs-string">&quot;First bloom pass&quot;</span> : <span class="hljs-string">&quot;Scene display&quot;</span>), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(time_stamps[<span class="hljs-number">3</span>] - time_stamps[<span class="hljs-number">2</span>]) * timestampFrequency / <span class="hljs-number">1000000.0f</span>);<br>		<span class="hljs-keyword">if</span> (bloom)<br>		&#123;<br>			drawer.<span class="hljs-built_in">text</span>(<span class="hljs-string">&quot;Pass 3: Second bloom pass %.3f ms&quot;</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(time_stamps[<span class="hljs-number">5</span>] - time_stamps[<span class="hljs-number">4</span>]) * timestampFrequency / <span class="hljs-number">1000000.0f</span>);<br>			drawer.<span class="hljs-built_in">set_dirty</span>(<span class="hljs-literal">true</span>);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本示例会使用毫秒（10^-3秒）作为计时单位。</p><p>本示例的分析到此结束。</p><hr></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/CG-api/" class="category-chain-item">CG_api</a> <span>></span> <a href="/categories/CG-api/vulkan/" class="category-chain-item">vulkan</a> <span>></span> <a href="/categories/CG-api/vulkan/vulkan-samples/" class="category-chain-item">vulkan_samples</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>Timestamp queries</div><div>http://example.com/2025/03/13/CG_api/vulkan/vulkan_samples/timestamp_queries/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>ZPC-dsg</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年3月13日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2025/03/14/CG_api/vulkan/vulkan_samples/calibrated_timestamps/" title="Calibrated timestamps"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Calibrated timestamps</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2025/03/07/CG_api/d3d12/directX_samples/D3D12Multithreading/" title="D3D12 Multithreading"><span class="hidden-mobile">D3D12 Multithreading</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>