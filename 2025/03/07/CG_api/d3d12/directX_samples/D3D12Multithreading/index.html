<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/icon/mikuicon.jpg"><link rel="icon" href="/images/icon/mikuicon.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="ZPC-dsg"><meta name="keywords" content=""><meta name="description" content="前言 从本篇文章开始，我将逐一梳理D3D12官方示例集中的示例，并且开始mini engine的分析。这是该系列的第一篇文章，主题是D3D12中的多线程渲染。 本示例以及其它示例的代码读者可以在微软的DirectX-Graphics-Samples中找到。 下面闲话少说，开始我们的探索！  效果 首先看一下程序的运行效果（不知道为啥录出来有黑框，将就着看看。。。）： (functi"><meta property="og:type" content="article"><meta property="og:title" content="post"><meta property="og:url" content="http://example.com/2025/03/07/CG_api/d3d12/directX_samples/D3D12Multithreading/index.html"><meta property="og:site_name" content="ZPC の Blog"><meta property="og:description" content="前言 从本篇文章开始，我将逐一梳理D3D12官方示例集中的示例，并且开始mini engine的分析。这是该系列的第一篇文章，主题是D3D12中的多线程渲染。 本示例以及其它示例的代码读者可以在微软的DirectX-Graphics-Samples中找到。 下面闲话少说，开始我们的探索！  效果 首先看一下程序的运行效果（不知道为啥录出来有黑框，将就着看看。。。）： (functi"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/images/textbg/CG_api/d12_sample_threads.jpg"><meta property="article:published_time" content="2025-03-07T00:58:41.000Z"><meta property="article:modified_time" content="2025-03-10T02:42:52.058Z"><meta property="article:author" content="ZPC-dsg"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/images/textbg/CG_api/d12_sample_threads.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>post - ZPC の Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:"measurement_id:G-X8N3TZCB57",tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 7.3.0"><script src="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.css"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>ZPC の Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/images/textbg/CG_api/d12_sample_threads.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="post"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> ZPC-dsg </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-03-07 08:58" pubdate>2025年3月7日 早上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 13k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 109 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">post</h1><div class="markdown-body"><h2 id="前言">前言</h2><p>从本篇文章开始，我将逐一梳理D3D12官方示例集中的示例，并且开始<strong>mini engine</strong>的分析。这是该系列的第一篇文章，主题是D3D12中的多线程渲染。</p><p>本示例以及其它示例的代码读者可以在微软的<a target="_blank" rel="noopener" href="https://github.com/microsoft/DirectX-Graphics-Samples"><code>DirectX-Graphics-Samples</code></a>中找到。</p><p>下面闲话少说，开始我们的探索！</p><hr><h2 id="效果">效果</h2><p>首先看一下程序的运行效果（不知道为啥录出来有黑框，将就着看看。。。）：</p><div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom:20px"></div><script>!function(){var e=new DPlayer({container:document.getElementById("dplayer2"),loop:"yes",screenshot:"yes",video:{url:"/2025/03/07/CG_api/d3d12/directX_samples/D3D12Multithreading/multithreading.mp4"},danmaku:{api:"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]),window.dplayers.push(e)}()</script><hr><h2 id="程序入口">程序入口</h2><p>程序入口点位于<strong>Main.cpp</strong>中，启动代码十分简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;D3D12Multithreading.h&quot;</span></span><br><br><span class="hljs-function">_Use_decl_annotations_</span><br><span class="hljs-function"><span class="hljs-type">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE, LPSTR, <span class="hljs-type">int</span> nCmdShow)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">D3D12Multithreading <span class="hljs-title">sample</span><span class="hljs-params">(<span class="hljs-number">1280</span>, <span class="hljs-number">720</span>, <span class="hljs-string">L&quot;D3D12 Multithreading Sample&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> Win32Application::<span class="hljs-built_in">Run</span>(&amp;sample, hInstance, nCmdShow);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>WinMain</strong>是Windows图形窗口程序的入口点，<i><font color="Red">WINAPI</font></i>是该函数调用必须使用的关键字，一般定义为**__stdcall<strong>，指定了函数参数在调用堆栈中的顺序，它指定参数传递顺序为从右到左，不过在ARM和x64处理器上，该关键字会被编译器忽略，这些架构上是统一采用</strong>__fastcall**约定的。有关这部分的细节可以参考微软的<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/stdcall?view=msvc-170"><code>官方文档</code></a>。</p><p>可以看到主函数的逻辑就是创建一个应用程序类对象，然后调用该程序类基类<strong>Win32Application</strong>的<i><font color="Green">Run</font></i>静态函数执行渲染主逻辑以及处理一切窗口信息。首先来看应用程序类<code>D3D12Multithreading</code>的构造函数做了什么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">D3D12Multithreading::<span class="hljs-built_in">D3D12Multithreading</span>(UINT width, UINT height, std::wstring name) :<br>    <span class="hljs-built_in">DXSample</span>(width, height, name),<br>    <span class="hljs-built_in">m_frameIndex</span>(<span class="hljs-number">0</span>),<br>    <span class="hljs-built_in">m_viewport</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(height)),<br>    <span class="hljs-built_in">m_scissorRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">static_cast</span>&lt;LONG&gt;(width), <span class="hljs-built_in">static_cast</span>&lt;LONG&gt;(height)),<br>    <span class="hljs-built_in">m_keyboardInput</span>(),<br>    <span class="hljs-built_in">m_titleCount</span>(<span class="hljs-number">0</span>),<br>    <span class="hljs-built_in">m_cpuTime</span>(<span class="hljs-number">0</span>),<br>    <span class="hljs-built_in">m_fenceValue</span>(<span class="hljs-number">0</span>),<br>    <span class="hljs-built_in">m_rtvDescriptorSize</span>(<span class="hljs-number">0</span>),<br>    <span class="hljs-built_in">m_currentFrameResourceIndex</span>(<span class="hljs-number">0</span>),<br>    <span class="hljs-built_in">m_pCurrentFrameResource</span>(<span class="hljs-literal">nullptr</span>)<br>&#123;<br>    s_app = <span class="hljs-keyword">this</span>;<br><br>    m_keyboardInput.animate = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">DXGIDeclareAdapterRemovalSupport</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">s_app</font></i>是一个指向该类的静态指针成员，将其初始化为指向当前创建的类实例。之后设置动画效果为开启状态，具体而言在该示例中开启动画效果会使得场景内灯光处于不断变化的状态，代码对应于<i><font color="Orange">OnUpdate</font></i>函数中的这一段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (m_keyboardInput.animate)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NumLights; i++)<br>    &#123;<br>        <span class="hljs-type">float</span> direction = frameChange * <span class="hljs-built_in">pow</span>(<span class="hljs-number">-1.0f</span>, i);<br>        <span class="hljs-built_in">XMStoreFloat4</span>(&amp;m_lights[i].position, <span class="hljs-built_in">XMVector4Transform</span>(<span class="hljs-built_in">XMLoadFloat4</span>(&amp;m_lights[i].position), <span class="hljs-built_in">XMMatrixRotationY</span>(direction)));<br><br>        XMVECTOR eye = <span class="hljs-built_in">XMLoadFloat4</span>(&amp;m_lights[i].position);<br>        XMVECTOR at = <span class="hljs-built_in">XMVectorSet</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">8.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>);<br>        <span class="hljs-built_in">XMStoreFloat4</span>(&amp;m_lights[i].direction, <span class="hljs-built_in">XMVector3Normalize</span>(<span class="hljs-built_in">XMVectorSubtract</span>(at, eye)));<br>        XMVECTOR up = <span class="hljs-built_in">XMVectorSet</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>);<br>        m_lightCameras[i].<span class="hljs-built_in">Set</span>(eye, at, up);<br><br>        m_lightCameras[i].<span class="hljs-built_in">Get3DViewProjMatrices</span>(&amp;m_lights[i].view, &amp;m_lights[i].projection, <span class="hljs-number">90.0f</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(m_width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(m_height));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后调用<strong>DXGIDeclareAdapterRemovalSupport</strong>函数，该函数一般用于应用程序初始化阶段，用于声明适配器的移除支持，该函数允许应用程序声明它支持适配器移除。这在使用<strong>可热插拔的图形硬件</strong>（热插拔的图形硬件是指能够在计算机运行时动态连接或断开，而无需重启系统或关闭应用程序的图形处理单元）时尤其重要，比如在某些笔记本电脑或外部 GPU 设备上。</p><p>那么接下来就开始探究主渲染函数<i><font color="Green">Run</font></i>的逻辑。首先上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Win32Application::Run</span><span class="hljs-params">(DXSample* pSample, HINSTANCE hInstance, <span class="hljs-type">int</span> nCmdShow)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Parse the command line parameters</span><br>    <span class="hljs-type">int</span> argc;<br>    LPWSTR* argv = <span class="hljs-built_in">CommandLineToArgvW</span>(<span class="hljs-built_in">GetCommandLineW</span>(), &amp;argc);<br>    pSample-&gt;<span class="hljs-built_in">ParseCommandLineArgs</span>(argv, argc);<br>    <span class="hljs-built_in">LocalFree</span>(argv);<br><br>    <span class="hljs-comment">// Initialize the window class.</span><br>    WNDCLASSEX windowClass = &#123; <span class="hljs-number">0</span> &#125;;<br>    windowClass.cbSize = <span class="hljs-built_in">sizeof</span>(WNDCLASSEX);<br>    windowClass.style = CS_HREDRAW | CS_VREDRAW;<br>    windowClass.lpfnWndProc = WindowProc;<br>    windowClass.hInstance = hInstance;<br>    windowClass.hCursor = <span class="hljs-built_in">LoadCursor</span>(<span class="hljs-literal">NULL</span>, IDC_ARROW);<br>    windowClass.lpszClassName = <span class="hljs-string">L&quot;DXSampleClass&quot;</span>;<br>    <span class="hljs-built_in">RegisterClassEx</span>(&amp;windowClass);<br><br>    RECT windowRect = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">static_cast</span>&lt;LONG&gt;(pSample-&gt;<span class="hljs-built_in">GetWidth</span>()), <span class="hljs-built_in">static_cast</span>&lt;LONG&gt;(pSample-&gt;<span class="hljs-built_in">GetHeight</span>()) &#125;;<br>    <span class="hljs-built_in">AdjustWindowRect</span>(&amp;windowRect, WS_OVERLAPPEDWINDOW, FALSE);<br><br>    <span class="hljs-comment">// Create the window and store a handle to it.</span><br>    m_hwnd = <span class="hljs-built_in">CreateWindow</span>(<br>        windowClass.lpszClassName,<br>        pSample-&gt;<span class="hljs-built_in">GetTitle</span>(),<br>        WS_OVERLAPPEDWINDOW,<br>        CW_USEDEFAULT,<br>        CW_USEDEFAULT,<br>        windowRect.right - windowRect.left,<br>        windowRect.bottom - windowRect.top,<br>        <span class="hljs-literal">nullptr</span>,        <span class="hljs-comment">// We have no parent window.</span><br>        <span class="hljs-literal">nullptr</span>,        <span class="hljs-comment">// We aren&#x27;t using menus.</span><br>        hInstance,<br>        pSample);<br><br>    <span class="hljs-comment">// Initialize the sample. OnInit is defined in each child-implementation of DXSample.</span><br>    pSample-&gt;<span class="hljs-built_in">OnInit</span>();<br><br>    <span class="hljs-built_in">ShowWindow</span>(m_hwnd, nCmdShow);<br><br>    <span class="hljs-comment">// Main sample loop.</span><br>    MSG msg = &#123;&#125;;<br>    <span class="hljs-keyword">while</span> (msg.message != WM_QUIT)<br>    &#123;<br>        <span class="hljs-comment">// Process any messages in the queue.</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">PeekMessage</span>(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, PM_REMOVE))<br>        &#123;<br>            <span class="hljs-built_in">TranslateMessage</span>(&amp;msg);<br>            <span class="hljs-built_in">DispatchMessage</span>(&amp;msg);<br>        &#125;<br>    &#125;<br><br>    pSample-&gt;<span class="hljs-built_in">OnDestroy</span>();<br><br>    <span class="hljs-comment">// Return this part of the WM_QUIT message to Windows.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(msg.wParam);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先调用WinAPI函数<code>GetCommandLineW</code>获取命令行字符串（返回结果为宽字符<strong>LPCWSTR</strong>，这里C代表只读，即constant），然后调用<code>CommandLineToArgvW</code>将命令行字符串解析为一个参数数组，并且填写参数数组中的元素个数<i><font color="Orange">argc</font></i>。接下来调用应用程序类基类<code>DXSample</code>的<i><font color="Green">ParseCommandLineArgs</font></i>方法解析命令行输入的字符串，解析部分代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Helper function for parsing any supplied command line args.</span><br><span class="hljs-function">_Use_decl_annotations_</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DXSample::ParseCommandLineArgs</span><span class="hljs-params">(WCHAR* argv[], <span class="hljs-type">int</span> argc)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (_wcsnicmp(argv[i], <span class="hljs-string">L&quot;-warp&quot;</span>, <span class="hljs-built_in">wcslen</span>(argv[i])) == <span class="hljs-number">0</span> || <br>            _wcsnicmp(argv[i], <span class="hljs-string">L&quot;/warp&quot;</span>, <span class="hljs-built_in">wcslen</span>(argv[i])) == <span class="hljs-number">0</span>)<br>        &#123;<br>            m_useWarpDevice = <span class="hljs-literal">true</span>;<br>            m_title = m_title + <span class="hljs-string">L&quot; (WARP)&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见解析函数会查询命令行是否输入了<strong>-warp</strong>或<strong>/warp</strong>参数，如果输入了该参数将意味着本示例的渲染将使用软件适配器。</p><p>解析命令行参数完毕后使用<code>LocalFree</code>释放分配给命令行参数数组的内存（<code>LocalAlloc</code>分配的内存需要使用<code>LocalFree</code>释放）。</p><p>接下来就是Windows应用程序窗口的创建逻辑，这里着重来看该窗口设置的回调函数<i><font color="Green">WindowProc</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Main message handler for the sample.</span><br><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">Win32Application::WindowProc</span><span class="hljs-params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span><br><span class="hljs-function"></span>&#123;<br>    DXSample* pSample = <span class="hljs-built_in">reinterpret_cast</span>&lt;DXSample*&gt;(<span class="hljs-built_in">GetWindowLongPtr</span>(hWnd, GWLP_USERDATA));<br><br>    <span class="hljs-keyword">switch</span> (message)<br>    &#123;<br>    <span class="hljs-keyword">case</span> WM_CREATE:<br>        &#123;<br>            <span class="hljs-comment">// Save the DXSample* passed in to CreateWindow.</span><br>            LPCREATESTRUCT pCreateStruct = <span class="hljs-built_in">reinterpret_cast</span>&lt;LPCREATESTRUCT&gt;(lParam);<br>            <span class="hljs-built_in">SetWindowLongPtr</span>(hWnd, GWLP_USERDATA, <span class="hljs-built_in">reinterpret_cast</span>&lt;LONG_PTR&gt;(pCreateStruct-&gt;lpCreateParams));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">case</span> WM_KEYDOWN:<br>        <span class="hljs-keyword">if</span> (pSample)<br>        &#123;<br>            pSample-&gt;<span class="hljs-built_in">OnKeyDown</span>(<span class="hljs-built_in">static_cast</span>&lt;UINT8&gt;(wParam));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">case</span> WM_KEYUP:<br>        <span class="hljs-keyword">if</span> (pSample)<br>        &#123;<br>            pSample-&gt;<span class="hljs-built_in">OnKeyUp</span>(<span class="hljs-built_in">static_cast</span>&lt;UINT8&gt;(wParam));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">case</span> WM_PAINT:<br>        <span class="hljs-keyword">if</span> (pSample)<br>        &#123;<br>            pSample-&gt;<span class="hljs-built_in">OnUpdate</span>();<br>            pSample-&gt;<span class="hljs-built_in">OnRender</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">case</span> WM_DESTROY:<br>        <span class="hljs-built_in">PostQuitMessage</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Handle any messages the switch statement didn&#x27;t.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">DefWindowProc</span>(hWnd, message, wParam, lParam);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数利用在Windows窗口创建的时候会发出<i><font color="Red">WM_CREATE</font></i>信号，在处理该信号的逻辑中将传递给窗口的<i><font color="Orange">lpParam</font></i>参数的应用程序类指针保存到用户数据中，这样该回调函数之后每次被调用的时候第一行代码都会从用户数据中获取该类的指针以执行后续处理逻辑。</p><p>之后函数处理用户按键逻辑。这里可以自行发挥，比如实现移动效果等，不过该示例为了简洁起见将<i><font color="Green">OnKeyDown</font></i>和<i><font color="Green">OnKeyUp</font></i>两个函数函数体均设置为空，不执行任何逻辑。</p><p>如果系统发送了<i><font color="Red">WM_PAINT</font></i>消息，那么回调函数就会调用应用程序类的<i><font color="Green">OnUpdate</font></i>和<i><font color="Green">OnRender</font></i>函数，这两个函数是整个渲染逻辑的核心部分，我们稍后分析。</p><p>回到<i><font color="Green">Run</font></i>函数，在初始化窗口结束后，首先调用应用程序类的<i><font color="Green">OnInit</font></i>函数进行资源的初始化，之后进入到渲染主循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Main sample loop.</span><br>MSG msg = &#123;&#125;;<br><span class="hljs-keyword">while</span> (msg.message != WM_QUIT)<br>&#123;<br>    <span class="hljs-comment">// Process any messages in the queue.</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">PeekMessage</span>(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, PM_REMOVE))<br>    &#123;<br>        <span class="hljs-built_in">TranslateMessage</span>(&amp;msg);<br>        <span class="hljs-built_in">DispatchMessage</span>(&amp;msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是一个不断处理消息循环的过程。</p><p>最后如果发送了退出信号（<i><font color="Red">WM_QUIT</font></i>），那么程序需要调用应用程序类的<i><font color="Green">OnDestroy</font></i>函数来进行资源的销毁释放。</p><p>下面开始渲染逻辑的分析。首先是<i><font color="Green">OnInit</font></i>函数。</p><hr><h2 id="oninit">OnInit</h2><p>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::OnInit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">LoadPipeline</span>();<br>    <span class="hljs-built_in">LoadAssets</span>();<br>    <span class="hljs-built_in">LoadContexts</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>先来看<i><font color="Green">LoadPipeline</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Load the rendering pipeline dependencies.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::LoadPipeline</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UINT dxgiFactoryFlags = <span class="hljs-number">0</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_DEBUG)</span><br>    <span class="hljs-comment">// Enable the debug layer (requires the Graphics Tools &quot;optional feature&quot;).</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Enabling the debug layer after device creation will invalidate the active device.</span><br>    &#123;<br>        ComPtr&lt;ID3D12Debug&gt; debugController;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SUCCEEDED</span>(<span class="hljs-built_in">D3D12GetDebugInterface</span>(<span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;debugController))))<br>        &#123;<br>            debugController-&gt;<span class="hljs-built_in">EnableDebugLayer</span>();<br><br>            <span class="hljs-comment">// Enable additional debug layers.</span><br>            dxgiFactoryFlags |= DXGI_CREATE_FACTORY_DEBUG;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    ComPtr&lt;IDXGIFactory4&gt; factory;<br>    <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">CreateDXGIFactory2</span>(dxgiFactoryFlags, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;factory)));<br><br>    <span class="hljs-keyword">if</span> (m_useWarpDevice)<br>    &#123;<br>        ComPtr&lt;IDXGIAdapter&gt; warpAdapter;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(factory-&gt;<span class="hljs-built_in">EnumWarpAdapter</span>(<span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;warpAdapter)));<br><br>        <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">D3D12CreateDevice</span>(<br>            warpAdapter.<span class="hljs-built_in">Get</span>(),<br>            D3D_FEATURE_LEVEL_11_0,<br>            <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_device)<br>            ));<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        ComPtr&lt;IDXGIAdapter1&gt; hardwareAdapter;<br>        <span class="hljs-built_in">GetHardwareAdapter</span>(factory.<span class="hljs-built_in">Get</span>(), &amp;hardwareAdapter, <span class="hljs-literal">true</span>);<br><br>        <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">D3D12CreateDevice</span>(<br>            hardwareAdapter.<span class="hljs-built_in">Get</span>(),<br>            D3D_FEATURE_LEVEL_11_0,<br>            <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_device)<br>            ));<br>    &#125;<br><br>    <span class="hljs-comment">// Describe and create the command queue.</span><br>    D3D12_COMMAND_QUEUE_DESC queueDesc = &#123;&#125;;<br>    queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;<br>    queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;<br><br>    <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommandQueue</span>(&amp;queueDesc, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_commandQueue)));<br>    <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_commandQueue);<br><br>    <span class="hljs-comment">// Describe and create the swap chain.</span><br>    DXGI_SWAP_CHAIN_DESC1 swapChainDesc = &#123;&#125;;<br>    swapChainDesc.BufferCount = FrameCount;<br>    swapChainDesc.Width = m_width;<br>    swapChainDesc.Height = m_height;<br>    swapChainDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;<br>    swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;<br>    swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;<br>    swapChainDesc.SampleDesc.Count = <span class="hljs-number">1</span>;<br><br>    ComPtr&lt;IDXGISwapChain1&gt; swapChain;<br>    <span class="hljs-built_in">ThrowIfFailed</span>(factory-&gt;<span class="hljs-built_in">CreateSwapChainForHwnd</span>(<br>        m_commandQueue.<span class="hljs-built_in">Get</span>(),        <span class="hljs-comment">// Swap chain needs the queue so that it can force a flush on it.</span><br>        Win32Application::<span class="hljs-built_in">GetHwnd</span>(),<br>        &amp;swapChainDesc,<br>        <span class="hljs-literal">nullptr</span>,<br>        <span class="hljs-literal">nullptr</span>,<br>        &amp;swapChain<br>        ));<br><br>    <span class="hljs-comment">// This sample does not support fullscreen transitions.</span><br>    <span class="hljs-built_in">ThrowIfFailed</span>(factory-&gt;<span class="hljs-built_in">MakeWindowAssociation</span>(Win32Application::<span class="hljs-built_in">GetHwnd</span>(), DXGI_MWA_NO_ALT_ENTER));<br><br>    <span class="hljs-built_in">ThrowIfFailed</span>(swapChain.<span class="hljs-built_in">As</span>(&amp;m_swapChain));<br>    m_frameIndex = m_swapChain-&gt;<span class="hljs-built_in">GetCurrentBackBufferIndex</span>();<br><br>    <span class="hljs-comment">// Create descriptor heaps.</span><br>    &#123;<br>        <span class="hljs-comment">// Describe and create a render target view (RTV) descriptor heap.</span><br>        D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc = &#123;&#125;;<br>        rtvHeapDesc.NumDescriptors = FrameCount;<br>        rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;<br>        rtvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateDescriptorHeap</span>(&amp;rtvHeapDesc, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_rtvHeap)));<br><br>        <span class="hljs-comment">// Describe and create a depth stencil view (DSV) descriptor heap.</span><br>        <span class="hljs-comment">// Each frame has its own depth stencils (to write shadows onto) </span><br>        <span class="hljs-comment">// and then there is one for the scene itself.</span><br>        D3D12_DESCRIPTOR_HEAP_DESC dsvHeapDesc = &#123;&#125;;<br>        dsvHeapDesc.NumDescriptors = <span class="hljs-number">1</span> + FrameCount * <span class="hljs-number">1</span>;<br>        dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;<br>        dsvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateDescriptorHeap</span>(&amp;dsvHeapDesc, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_dsvHeap)));<br><br>        <span class="hljs-comment">// Describe and create a shader resource view (SRV) and constant </span><br>        <span class="hljs-comment">// buffer view (CBV) descriptor heap.  Heap layout: null views, </span><br>        <span class="hljs-comment">// object diffuse + normal textures views, frame 1&#x27;s shadow buffer, </span><br>        <span class="hljs-comment">// frame 1&#x27;s 2x constant buffer, frame 2&#x27;s shadow buffer, frame 2&#x27;s </span><br>        <span class="hljs-comment">// 2x constant buffers, etc...</span><br>        <span class="hljs-type">const</span> UINT nullSrvCount = <span class="hljs-number">2</span>;        <span class="hljs-comment">// Null descriptors are needed for out of bounds behavior reads.</span><br>        <span class="hljs-type">const</span> UINT cbvCount = FrameCount * <span class="hljs-number">2</span>;<br>        <span class="hljs-type">const</span> UINT srvCount = _countof(SampleAssets::Textures) + (FrameCount * <span class="hljs-number">1</span>);<br>        D3D12_DESCRIPTOR_HEAP_DESC cbvSrvHeapDesc = &#123;&#125;;<br>        cbvSrvHeapDesc.NumDescriptors = nullSrvCount + cbvCount + srvCount;<br>        cbvSrvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;<br>        cbvSrvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateDescriptorHeap</span>(&amp;cbvSrvHeapDesc, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_cbvSrvHeap)));<br>        <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_cbvSrvHeap);<br><br>        <span class="hljs-comment">// Describe and create a sampler descriptor heap.</span><br>        D3D12_DESCRIPTOR_HEAP_DESC samplerHeapDesc = &#123;&#125;;<br>        samplerHeapDesc.NumDescriptors = <span class="hljs-number">2</span>;        <span class="hljs-comment">// One clamp and one wrap sampler.</span><br>        samplerHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER;<br>        samplerHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateDescriptorHeap</span>(&amp;samplerHeapDesc, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_samplerHeap)));<br>        <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_samplerHeap);<br><br>        m_rtvDescriptorSize = m_device-&gt;<span class="hljs-built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);<br>    &#125;<br><br>    <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommandAllocator</span>(D3D12_COMMAND_LIST_TYPE_DIRECT, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_commandAllocator)));<br>&#125;<br></code></pre></td></tr></table></figure><p>为了创建显示适配器以及交换链，需要首先创建<code>IDXGIFactory</code>对象。这里要注意的是如果是调试模式，需要添加<i><font color="Red">DXGI_CREATE_FACTORY_DEBUG</font></i>标志以帮助开发者在调试过程中获取更多的错误信息和诊断信息，并且可以开启调试层。这里注释中提到如果在创建好设备后再启用调试层会导致设备失效，这点需要注意。</p><p>创建好工厂后，开始枚举挑选显示适配器。前文提到如果用户在命令行传入<strong>-warp</strong>或<strong>/warp</strong>参数，那么<i><font color="Orange">m_useWarpDevice</font></i>就会被设置为true，于是代码就会枚举软件适配器（通过<code>EnumWarpAdapter</code>），然后使用该软件适配器进行设备的创建；反之代码就会枚举一般的硬件适配器然后创建设备。枚举硬件适配器函数<i><font color="Green">GetHardwareAdapter</font></i>实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Helper function for acquiring the first available hardware adapter that supports Direct3D 12.</span><br><span class="hljs-comment">// If no such adapter can be found, *ppAdapter will be set to nullptr.</span><br><span class="hljs-function">_Use_decl_annotations_</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DXSample::GetHardwareAdapter</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    IDXGIFactory1* pFactory,</span></span><br><span class="hljs-params"><span class="hljs-function">    IDXGIAdapter1** ppAdapter,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">bool</span> requestHighPerformanceAdapter)</span></span><br><span class="hljs-function"></span>&#123;<br>    *ppAdapter = <span class="hljs-literal">nullptr</span>;<br><br>    ComPtr&lt;IDXGIAdapter1&gt; adapter;<br><br>    ComPtr&lt;IDXGIFactory6&gt; factory6;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SUCCEEDED</span>(pFactory-&gt;<span class="hljs-built_in">QueryInterface</span>(<span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;factory6))))<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<br>            UINT adapterIndex = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">SUCCEEDED</span>(factory6-&gt;<span class="hljs-built_in">EnumAdapterByGpuPreference</span>(<br>                adapterIndex,<br>                requestHighPerformanceAdapter == <span class="hljs-literal">true</span> ? DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE : DXGI_GPU_PREFERENCE_UNSPECIFIED,<br>                <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;adapter)));<br>            ++adapterIndex)<br>        &#123;<br>            DXGI_ADAPTER_DESC1 desc;<br>            adapter-&gt;<span class="hljs-built_in">GetDesc1</span>(&amp;desc);<br><br>            <span class="hljs-keyword">if</span> (desc.Flags &amp; DXGI_ADAPTER_FLAG_SOFTWARE)<br>            &#123;<br>                <span class="hljs-comment">// Don&#x27;t select the Basic Render Driver adapter.</span><br>                <span class="hljs-comment">// If you want a software adapter, pass in &quot;/warp&quot; on the command line.</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// Check to see whether the adapter supports Direct3D 12, but don&#x27;t create the</span><br>            <span class="hljs-comment">// actual device yet.</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SUCCEEDED</span>(<span class="hljs-built_in">D3D12CreateDevice</span>(adapter.<span class="hljs-built_in">Get</span>(), D3D_FEATURE_LEVEL_11_0, _uuidof(ID3D12Device), <span class="hljs-literal">nullptr</span>)))<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(adapter.<span class="hljs-built_in">Get</span>() == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (UINT adapterIndex = <span class="hljs-number">0</span>; <span class="hljs-built_in">SUCCEEDED</span>(pFactory-&gt;<span class="hljs-built_in">EnumAdapters1</span>(adapterIndex, &amp;adapter)); ++adapterIndex)<br>        &#123;<br>            DXGI_ADAPTER_DESC1 desc;<br>            adapter-&gt;<span class="hljs-built_in">GetDesc1</span>(&amp;desc);<br><br>            <span class="hljs-keyword">if</span> (desc.Flags &amp; DXGI_ADAPTER_FLAG_SOFTWARE)<br>            &#123;<br>                <span class="hljs-comment">// Don&#x27;t select the Basic Render Driver adapter.</span><br>                <span class="hljs-comment">// If you want a software adapter, pass in &quot;/warp&quot; on the command line.</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// Check to see whether the adapter supports Direct3D 12, but don&#x27;t create the</span><br>            <span class="hljs-comment">// actual device yet.</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SUCCEEDED</span>(<span class="hljs-built_in">D3D12CreateDevice</span>(adapter.<span class="hljs-built_in">Get</span>(), D3D_FEATURE_LEVEL_11_0, _uuidof(ID3D12Device), <span class="hljs-literal">nullptr</span>)))<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    *ppAdapter = adapter.<span class="hljs-built_in">Detach</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总体逻辑就是逐一枚举适配器，然后查询它是否支持D3D12（通过使用<code>D3D12CreateDevice</code>函数并且将最后需要创建的设备项设置为空来实现仅查询能否创建而不具体创建设备的效果）。</p><p>接下来代码创建一个全局的命令队列用于执行各线程提交的命令，并且创建一个三缓冲的交换链（这里<i><font color="Orange">FrameCount</font></i>定义为常量3。），并且将当前后备缓冲区的索引存储到程序中。然后代码创建了整个场景需要使用到的描述符堆：首先需要一个至少具有三个描述符的渲染目标视图描述符堆以及具有四个深度模板视图的描述符堆，这里之所以需要四个深度模板视图，是因为本示例是一个两趟的渲染，第一趟是渲染阴影的shadow pass，第二趟是渲染场景的scene pass，因此除了需要一个用于scene pass的深度图外，还需要每帧一个用作shadow pass深度缓冲的资源（该资源在shadow pass用作深度缓冲，在scene pass用作着色器纹理资源，所以需要为该资源分别创建两个视图）；然后本示例每帧会使用两个常量缓冲区存储两趟pass中各自的场景信息如MVP矩阵、灯光信息等，用于存储常量缓冲区数据的结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LightState</span><br>&#123;<br>    XMFLOAT4 position;<br>    XMFLOAT4 direction;<br>    XMFLOAT4 color;<br>    XMFLOAT4 falloff;<br><br>    XMFLOAT4X4 view;<br>    XMFLOAT4X4 projection;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SceneConstantBuffer</span><br>&#123;<br>    XMFLOAT4X4 model;<br>    XMFLOAT4X4 view;<br>    XMFLOAT4X4 projection;<br>    XMFLOAT4 ambientColor;<br>    BOOL sampleShadowMap;<br>    BOOL padding[<span class="hljs-number">3</span>];        <span class="hljs-comment">// Must be aligned to be made up of N float4s.</span><br>    LightState lights[NumLights];<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里需要注意两点：首先结构体中<i><font color="Orange">sampleShadowMap</font></i>成员用于决定着色器在进行场景光照计算的时候是否需要计算阴影；齐次该成员后加入了三个padding，其目的是使得该结构体在c++中的内存布局和hlsl中相应常量缓冲区布局保持一致，因为hlsl常量缓冲区中任意一个数据成员必须按4字节对齐，也就是说如果一个数据没有4字节，而紧随其后的数据成员与该数据成员大小之和又超过了4字节，那么hlsl不会拆分后一个数据成员使它的一部分和前一个数据成员一同构成4字节，而是会在前一个数据成员后插入padding来补齐4字节。更多有关hlsl打包原则的细节可以参考[<code>这篇文章</code>]。</p><p>回到<i><font color="Green">LoadPipeline</font></i>函数。除了每帧需要两个常量缓冲区描述符，由于每帧scene pass可能会渲染阴影，所以还需要一个ShadowMap的着色器资源视图。此外，当然需要为场景中使用的模型的所有纹理各创建一个着色器资源视图，这里纹理就包括了diffuse map和normal map，它们事实上会被打包在一个描述符表中。另外，事实上代码还额外创建了两个不会绑定任何资源的空视图，这是为了当着色器采样资源不存在时绑定该空视图以保证hlsl代码中的采样操作正常进行不报错。</p><p>最后，着色器还需要使用两种采样器对纹理进行采样，其中wrap模式采样器用于采样一般的纹理，而clamp模式的采样器用于采样Shadow map（这样可以保证采样点超出阴影图范围的部分也位于阴影内，如果使用wrap模式会导致阴影采样结果明显不正确，具体可以参考<a target="_blank" rel="noopener" href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping"><code>这篇文章</code></a>的讲解）。</p><p>函数的最后还需要创建一个用于分配命令列表的命令分配器。该命令分配器负责主线程中一些临时命令的录制。事实上后面还会看到每个线程各自都会创建自己的命令分配器和命令列表来并行录制绘制命令（命令分配器和命令列表并不是线程自由的对象，因此每个线程都理应要有自己的分配器和列表）。</p><p>接下来分析<i><font color="Green">loadAssets</font></i>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Load the sample assets.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::LoadAssets</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Create the root signature.</span><br>    &#123;<br>        D3D12_FEATURE_DATA_ROOT_SIGNATURE featureData = &#123;&#125;;<br><br>        <span class="hljs-comment">// This is the highest version the sample supports. If CheckFeatureSupport succeeds, the HighestVersion returned will not be greater than this.</span><br>        featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_1;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FAILED</span>(m_device-&gt;<span class="hljs-built_in">CheckFeatureSupport</span>(D3D12_FEATURE_ROOT_SIGNATURE, &amp;featureData, <span class="hljs-built_in">sizeof</span>(featureData))))<br>        &#123;<br>            featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_0;<br>        &#125;<br><br>        CD3DX12_DESCRIPTOR_RANGE1 ranges[<span class="hljs-number">4</span>]; <span class="hljs-comment">// Perfomance TIP: Order from most frequent to least frequent.</span><br>        ranges[<span class="hljs-number">0</span>].<span class="hljs-built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC);    <span class="hljs-comment">// 2 frequently changed diffuse + normal textures - using registers t1 and t2.</span><br>        ranges[<span class="hljs-number">1</span>].<span class="hljs-built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC);    <span class="hljs-comment">// 1 frequently changed constant buffer.</span><br>        ranges[<span class="hljs-number">2</span>].<span class="hljs-built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);                                                <span class="hljs-comment">// 1 infrequently changed shadow texture - starting in register t0.</span><br>        ranges[<span class="hljs-number">3</span>].<span class="hljs-built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_SAMPLER, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);                                            <span class="hljs-comment">// 2 static samplers.</span><br><br>        CD3DX12_ROOT_PARAMETER1 rootParameters[<span class="hljs-number">4</span>];<br>        rootParameters[<span class="hljs-number">0</span>].<span class="hljs-built_in">InitAsDescriptorTable</span>(<span class="hljs-number">1</span>, &amp;ranges[<span class="hljs-number">0</span>], D3D12_SHADER_VISIBILITY_PIXEL);<br>        rootParameters[<span class="hljs-number">1</span>].<span class="hljs-built_in">InitAsDescriptorTable</span>(<span class="hljs-number">1</span>, &amp;ranges[<span class="hljs-number">1</span>], D3D12_SHADER_VISIBILITY_ALL);<br>        rootParameters[<span class="hljs-number">2</span>].<span class="hljs-built_in">InitAsDescriptorTable</span>(<span class="hljs-number">1</span>, &amp;ranges[<span class="hljs-number">2</span>], D3D12_SHADER_VISIBILITY_PIXEL);<br>        rootParameters[<span class="hljs-number">3</span>].<span class="hljs-built_in">InitAsDescriptorTable</span>(<span class="hljs-number">1</span>, &amp;ranges[<span class="hljs-number">3</span>], D3D12_SHADER_VISIBILITY_PIXEL);<br><br>        CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;<br>        rootSignatureDesc.<span class="hljs-built_in">Init_1_1</span>(_countof(rootParameters), rootParameters, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);<br><br>        ComPtr&lt;ID3DBlob&gt; signature;<br>        ComPtr&lt;ID3DBlob&gt; error;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">D3DX12SerializeVersionedRootSignature</span>(&amp;rootSignatureDesc, featureData.HighestVersion, &amp;signature, &amp;error));<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateRootSignature</span>(<span class="hljs-number">0</span>, signature-&gt;<span class="hljs-built_in">GetBufferPointer</span>(), signature-&gt;<span class="hljs-built_in">GetBufferSize</span>(), <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_rootSignature)));<br>        <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_rootSignature);<br>    &#125;<br><br>    <span class="hljs-comment">// Create the pipeline state, which includes loading shaders.</span><br>    &#123;<br>        ComPtr&lt;ID3DBlob&gt; vertexShader;<br>        ComPtr&lt;ID3DBlob&gt; pixelShader;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_DEBUG)</span><br>        <span class="hljs-comment">// Enable better shader debugging with the graphics debugging tools.</span><br>        UINT compileFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        UINT compileFlags = D3DCOMPILE_OPTIMIZATION_LEVEL3;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">D3DCompileFromFile</span>(<span class="hljs-built_in">GetAssetFullPath</span>(<span class="hljs-string">L&quot;shaders.hlsl&quot;</span>).<span class="hljs-built_in">c_str</span>(), <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;VSMain&quot;</span>, <span class="hljs-string">&quot;vs_5_0&quot;</span>, compileFlags, <span class="hljs-number">0</span>, &amp;vertexShader, <span class="hljs-literal">nullptr</span>));<br>        <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">D3DCompileFromFile</span>(<span class="hljs-built_in">GetAssetFullPath</span>(<span class="hljs-string">L&quot;shaders.hlsl&quot;</span>).<span class="hljs-built_in">c_str</span>(), <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;PSMain&quot;</span>, <span class="hljs-string">&quot;ps_5_0&quot;</span>, compileFlags, <span class="hljs-number">0</span>, &amp;pixelShader, <span class="hljs-literal">nullptr</span>));<br><br>        D3D12_INPUT_LAYOUT_DESC inputLayoutDesc;<br>        inputLayoutDesc.pInputElementDescs = SampleAssets::StandardVertexDescription;<br>        inputLayoutDesc.NumElements = _countof(SampleAssets::StandardVertexDescription);<br><br>        <span class="hljs-function">CD3DX12_DEPTH_STENCIL_DESC <span class="hljs-title">depthStencilDesc</span><span class="hljs-params">(D3D12_DEFAULT)</span></span>;<br>        depthStencilDesc.DepthEnable = <span class="hljs-literal">true</span>;<br>        depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;<br>        depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;<br>        depthStencilDesc.StencilEnable = FALSE;<br><br>        <span class="hljs-comment">// Describe and create the PSO for rendering the scene.</span><br>        D3D12_GRAPHICS_PIPELINE_STATE_DESC psoDesc = &#123;&#125;;<br>        psoDesc.InputLayout = inputLayoutDesc;<br>        psoDesc.pRootSignature = m_rootSignature.<span class="hljs-built_in">Get</span>();<br>        psoDesc.VS = <span class="hljs-built_in">CD3DX12_SHADER_BYTECODE</span>(vertexShader.<span class="hljs-built_in">Get</span>());<br>        psoDesc.PS = <span class="hljs-built_in">CD3DX12_SHADER_BYTECODE</span>(pixelShader.<span class="hljs-built_in">Get</span>());<br>        psoDesc.RasterizerState = <span class="hljs-built_in">CD3DX12_RASTERIZER_DESC</span>(D3D12_DEFAULT);<br>        psoDesc.BlendState = <span class="hljs-built_in">CD3DX12_BLEND_DESC</span>(D3D12_DEFAULT);<br>        psoDesc.DepthStencilState = depthStencilDesc;<br>        psoDesc.SampleMask = UINT_MAX;<br>        psoDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;<br>        psoDesc.NumRenderTargets = <span class="hljs-number">1</span>;<br>        psoDesc.RTVFormats[<span class="hljs-number">0</span>] = DXGI_FORMAT_R8G8B8A8_UNORM;<br>        psoDesc.DSVFormat = DXGI_FORMAT_D32_FLOAT;<br>        psoDesc.SampleDesc.Count = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateGraphicsPipelineState</span>(&amp;psoDesc, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_pipelineState)));<br>        <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_pipelineState);<br><br>        <span class="hljs-comment">// Alter the description and create the PSO for rendering</span><br>        <span class="hljs-comment">// the shadow map.  The shadow map does not use a pixel</span><br>        <span class="hljs-comment">// shader or render targets.</span><br>        psoDesc.PS = <span class="hljs-built_in">CD3DX12_SHADER_BYTECODE</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        psoDesc.RTVFormats[<span class="hljs-number">0</span>] = DXGI_FORMAT_UNKNOWN;<br>        psoDesc.NumRenderTargets = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateGraphicsPipelineState</span>(&amp;psoDesc, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_pipelineStateShadowMap)));<br>        <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_pipelineStateShadowMap);<br>    &#125;<br><br>    <span class="hljs-comment">// Create temporary command list for initial GPU setup.</span><br>    ComPtr&lt;ID3D12GraphicsCommandList&gt; commandList;<br>    <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommandList</span>(<span class="hljs-number">0</span>, D3D12_COMMAND_LIST_TYPE_DIRECT, m_commandAllocator.<span class="hljs-built_in">Get</span>(), m_pipelineState.<span class="hljs-built_in">Get</span>(), <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;commandList)));<br><br>    <span class="hljs-comment">// Create render target views (RTVs).</span><br>    <span class="hljs-function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="hljs-title">rtvHandle</span><span class="hljs-params">(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart())</span></span>;<br>    <span class="hljs-keyword">for</span> (UINT i = <span class="hljs-number">0</span>; i &lt; FrameCount; i++)<br>    &#123;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_swapChain-&gt;<span class="hljs-built_in">GetBuffer</span>(i, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_renderTargets[i])));<br>        m_device-&gt;<span class="hljs-built_in">CreateRenderTargetView</span>(m_renderTargets[i].<span class="hljs-built_in">Get</span>(), <span class="hljs-literal">nullptr</span>, rtvHandle);<br>        rtvHandle.<span class="hljs-built_in">Offset</span>(<span class="hljs-number">1</span>, m_rtvDescriptorSize);<br><br>        <span class="hljs-built_in">NAME_D3D12_OBJECT_INDEXED</span>(m_renderTargets, i);<br>    &#125;<br><br>    <span class="hljs-comment">// Create the depth stencil.</span><br>    &#123;<br>        <span class="hljs-function">CD3DX12_RESOURCE_DESC <span class="hljs-title">shadowTextureDesc</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            D3D12_RESOURCE_DIMENSION_TEXTURE2D,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">static_cast</span>&lt;UINT&gt;(m_viewport.Width), </span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">static_cast</span>&lt;UINT&gt;(m_viewport.Height), </span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-number">1</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-number">1</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            DXGI_FORMAT_D32_FLOAT,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-number">1</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            D3D12_TEXTURE_LAYOUT_UNKNOWN,</span></span><br><span class="hljs-params"><span class="hljs-function">            D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL | D3D12_RESOURCE_FLAG_DENY_SHADER_RESOURCE)</span></span>;<br><br>        D3D12_CLEAR_VALUE clearValue;    <span class="hljs-comment">// Performance tip: Tell the runtime at resource creation the desired clear value.</span><br>        clearValue.Format = DXGI_FORMAT_D32_FLOAT;<br>        clearValue.DepthStencil.Depth = <span class="hljs-number">1.0f</span>;<br>        clearValue.DepthStencil.Stencil = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>            &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_DEFAULT),<br>            D3D12_HEAP_FLAG_NONE,<br>            &amp;shadowTextureDesc,<br>            D3D12_RESOURCE_STATE_DEPTH_WRITE,<br>            &amp;clearValue,<br>            <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_depthStencil)));<br><br>        <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_depthStencil);<br><br>        <span class="hljs-comment">// Create the depth stencil view.</span><br>        m_device-&gt;<span class="hljs-built_in">CreateDepthStencilView</span>(m_depthStencil.<span class="hljs-built_in">Get</span>(), <span class="hljs-literal">nullptr</span>, m_dsvHeap-&gt;<span class="hljs-built_in">GetCPUDescriptorHandleForHeapStart</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// Load scene assets.</span><br>    UINT fileSize = <span class="hljs-number">0</span>;<br>    UINT8* pAssetData;<br>    <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">ReadDataFromFile</span>(<span class="hljs-built_in">GetAssetFullPath</span>(SampleAssets::DataFileName).<span class="hljs-built_in">c_str</span>(), &amp;pAssetData, &amp;fileSize));<br><br>    <span class="hljs-comment">// Create the vertex buffer.</span><br>    &#123;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>            &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_DEFAULT),<br>            D3D12_HEAP_FLAG_NONE,<br>            &amp;CD3DX12_RESOURCE_DESC::<span class="hljs-built_in">Buffer</span>(SampleAssets::VertexDataSize),<br>            D3D12_RESOURCE_STATE_COPY_DEST,<br>            <span class="hljs-literal">nullptr</span>,<br>            <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_vertexBuffer)));<br><br>        <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_vertexBuffer);<br><br>        &#123;<br>            <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>                &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_UPLOAD),<br>                D3D12_HEAP_FLAG_NONE,<br>                &amp;CD3DX12_RESOURCE_DESC::<span class="hljs-built_in">Buffer</span>(SampleAssets::VertexDataSize),<br>                D3D12_RESOURCE_STATE_GENERIC_READ,<br>                <span class="hljs-literal">nullptr</span>,<br>                <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_vertexBufferUpload)));<br><br>            <span class="hljs-comment">// Copy data to the upload heap and then schedule a copy </span><br>            <span class="hljs-comment">// from the upload heap to the vertex buffer.</span><br>            D3D12_SUBRESOURCE_DATA vertexData = &#123;&#125;;<br>            vertexData.pData = pAssetData + SampleAssets::VertexDataOffset;<br>            vertexData.RowPitch = SampleAssets::VertexDataSize;<br>            vertexData.SlicePitch = vertexData.RowPitch;<br><br>            <span class="hljs-built_in">PIXBeginEvent</span>(commandList.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;Copy vertex buffer data to default resource...&quot;</span>);<br><br>            <span class="hljs-built_in">UpdateSubresources</span>&lt;<span class="hljs-number">1</span>&gt;(commandList.<span class="hljs-built_in">Get</span>(), m_vertexBuffer.<span class="hljs-built_in">Get</span>(), m_vertexBufferUpload.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;vertexData);<br>            commandList-&gt;<span class="hljs-built_in">ResourceBarrier</span>(<span class="hljs-number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="hljs-built_in">Transition</span>(m_vertexBuffer.<span class="hljs-built_in">Get</span>(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER));<br><br>            <span class="hljs-built_in">PIXEndEvent</span>(commandList.<span class="hljs-built_in">Get</span>());<br>        &#125;<br><br>        <span class="hljs-comment">// Initialize the vertex buffer view.</span><br>        m_vertexBufferView.BufferLocation = m_vertexBuffer-&gt;<span class="hljs-built_in">GetGPUVirtualAddress</span>();<br>        m_vertexBufferView.SizeInBytes = SampleAssets::VertexDataSize;<br>        m_vertexBufferView.StrideInBytes = SampleAssets::StandardVertexStride;<br>    &#125;<br><br>    <span class="hljs-comment">// Create the index buffer.</span><br>    &#123;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>            &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_DEFAULT),<br>            D3D12_HEAP_FLAG_NONE,<br>            &amp;CD3DX12_RESOURCE_DESC::<span class="hljs-built_in">Buffer</span>(SampleAssets::IndexDataSize),<br>            D3D12_RESOURCE_STATE_COPY_DEST,<br>            <span class="hljs-literal">nullptr</span>,<br>            <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_indexBuffer)));<br><br>        <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_indexBuffer);<br><br>        &#123;<br>            <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>                &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_UPLOAD),<br>                D3D12_HEAP_FLAG_NONE,<br>                &amp;CD3DX12_RESOURCE_DESC::<span class="hljs-built_in">Buffer</span>(SampleAssets::IndexDataSize),<br>                D3D12_RESOURCE_STATE_GENERIC_READ,<br>                <span class="hljs-literal">nullptr</span>,<br>                <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_indexBufferUpload)));<br><br>            <span class="hljs-comment">// Copy data to the upload heap and then schedule a copy </span><br>            <span class="hljs-comment">// from the upload heap to the index buffer.</span><br>            D3D12_SUBRESOURCE_DATA indexData = &#123;&#125;;<br>            indexData.pData = pAssetData + SampleAssets::IndexDataOffset;<br>            indexData.RowPitch = SampleAssets::IndexDataSize;<br>            indexData.SlicePitch = indexData.RowPitch;<br><br>            <span class="hljs-built_in">PIXBeginEvent</span>(commandList.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;Copy index buffer data to default resource...&quot;</span>);<br><br>            <span class="hljs-built_in">UpdateSubresources</span>&lt;<span class="hljs-number">1</span>&gt;(commandList.<span class="hljs-built_in">Get</span>(), m_indexBuffer.<span class="hljs-built_in">Get</span>(), m_indexBufferUpload.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;indexData);<br>            commandList-&gt;<span class="hljs-built_in">ResourceBarrier</span>(<span class="hljs-number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="hljs-built_in">Transition</span>(m_indexBuffer.<span class="hljs-built_in">Get</span>(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_INDEX_BUFFER));<br><br>            <span class="hljs-built_in">PIXEndEvent</span>(commandList.<span class="hljs-built_in">Get</span>());<br>        &#125;<br><br>        <span class="hljs-comment">// Initialize the index buffer view.</span><br>        m_indexBufferView.BufferLocation = m_indexBuffer-&gt;<span class="hljs-built_in">GetGPUVirtualAddress</span>();<br>        m_indexBufferView.SizeInBytes = SampleAssets::IndexDataSize;<br>        m_indexBufferView.Format = SampleAssets::StandardIndexFormat;<br>    &#125;<br><br>    <span class="hljs-comment">// Create shader resources.</span><br>    &#123;<br>        <span class="hljs-comment">// Get the CBV SRV descriptor size for the current device.</span><br>        <span class="hljs-type">const</span> UINT cbvSrvDescriptorSize = m_device-&gt;<span class="hljs-built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);<br><br>        <span class="hljs-comment">// Get a handle to the start of the descriptor heap.</span><br>        <span class="hljs-function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="hljs-title">cbvSrvHandle</span><span class="hljs-params">(m_cbvSrvHeap-&gt;GetCPUDescriptorHandleForHeapStart())</span></span>;<br><br>        &#123;<br>            <span class="hljs-comment">// Describe and create 2 null SRVs. Null descriptors are needed in order </span><br>            <span class="hljs-comment">// to achieve the effect of an &quot;unbound&quot; resource.</span><br>            D3D12_SHADER_RESOURCE_VIEW_DESC nullSrvDesc = &#123;&#125;;<br>            nullSrvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;<br>            nullSrvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;<br>            nullSrvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;<br>            nullSrvDesc.Texture2D.MipLevels = <span class="hljs-number">1</span>;<br>            nullSrvDesc.Texture2D.MostDetailedMip = <span class="hljs-number">0</span>;<br>            nullSrvDesc.Texture2D.ResourceMinLODClamp = <span class="hljs-number">0.0f</span>;<br><br>            m_device-&gt;<span class="hljs-built_in">CreateShaderResourceView</span>(<span class="hljs-literal">nullptr</span>, &amp;nullSrvDesc, cbvSrvHandle);<br>            cbvSrvHandle.<span class="hljs-built_in">Offset</span>(cbvSrvDescriptorSize);<br><br>            m_device-&gt;<span class="hljs-built_in">CreateShaderResourceView</span>(<span class="hljs-literal">nullptr</span>, &amp;nullSrvDesc, cbvSrvHandle);<br>            cbvSrvHandle.<span class="hljs-built_in">Offset</span>(cbvSrvDescriptorSize);<br>        &#125;<br><br>        <span class="hljs-comment">// Create each texture and SRV descriptor.</span><br>        <span class="hljs-type">const</span> UINT srvCount = _countof(SampleAssets::Textures);<br>        <span class="hljs-built_in">PIXBeginEvent</span>(commandList.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;Copy diffuse and normal texture data to default resources...&quot;</span>);<br>        <span class="hljs-keyword">for</span> (UINT i = <span class="hljs-number">0</span>; i &lt; srvCount; i++)<br>        &#123;<br>            <span class="hljs-comment">// Describe and create a Texture2D.</span><br>            <span class="hljs-type">const</span> SampleAssets::TextureResource &amp;tex = SampleAssets::Textures[i];<br>            <span class="hljs-function">CD3DX12_RESOURCE_DESC <span class="hljs-title">texDesc</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">                D3D12_RESOURCE_DIMENSION_TEXTURE2D,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                tex.Width, </span></span><br><span class="hljs-params"><span class="hljs-function">                tex.Height, </span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-number">1</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">static_cast</span>&lt;UINT16&gt;(tex.MipLevels),</span></span><br><span class="hljs-params"><span class="hljs-function">                tex.Format,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-number">1</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                D3D12_TEXTURE_LAYOUT_UNKNOWN,</span></span><br><span class="hljs-params"><span class="hljs-function">                D3D12_RESOURCE_FLAG_NONE)</span></span>;<br><br>            <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>                &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_DEFAULT),<br>                D3D12_HEAP_FLAG_NONE,<br>                &amp;texDesc,<br>                D3D12_RESOURCE_STATE_COPY_DEST,<br>                <span class="hljs-literal">nullptr</span>,<br>                <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_textures[i])));<br><br>            <span class="hljs-built_in">NAME_D3D12_OBJECT_INDEXED</span>(m_textures, i);<br><br>            &#123;<br>                <span class="hljs-type">const</span> UINT subresourceCount = texDesc.DepthOrArraySize * texDesc.MipLevels;<br>                UINT64 uploadBufferSize = <span class="hljs-built_in">GetRequiredIntermediateSize</span>(m_textures[i].<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, subresourceCount);<br>                <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>                    &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_UPLOAD),<br>                    D3D12_HEAP_FLAG_NONE,<br>                    &amp;CD3DX12_RESOURCE_DESC::<span class="hljs-built_in">Buffer</span>(uploadBufferSize),<br>                    D3D12_RESOURCE_STATE_GENERIC_READ,<br>                    <span class="hljs-literal">nullptr</span>,<br>                    <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_textureUploads[i])));<br><br>                <span class="hljs-comment">// Copy data to the intermediate upload heap and then schedule a copy</span><br>                <span class="hljs-comment">// from the upload heap to the Texture2D.</span><br>                D3D12_SUBRESOURCE_DATA textureData = &#123;&#125;;<br>                textureData.pData = pAssetData + tex.Data-&gt;Offset;<br>                textureData.RowPitch = tex.Data-&gt;Pitch;<br>                textureData.SlicePitch = tex.Data-&gt;Size;<br><br>                <span class="hljs-built_in">UpdateSubresources</span>(commandList.<span class="hljs-built_in">Get</span>(), m_textures[i].<span class="hljs-built_in">Get</span>(), m_textureUploads[i].<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, subresourceCount, &amp;textureData);<br>                commandList-&gt;<span class="hljs-built_in">ResourceBarrier</span>(<span class="hljs-number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="hljs-built_in">Transition</span>(m_textures[i].<span class="hljs-built_in">Get</span>(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE));<br>            &#125;<br><br>            <span class="hljs-comment">// Describe and create an SRV.</span><br>            D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = &#123;&#125;;<br>            srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;<br>            srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;<br>            srvDesc.Format = tex.Format;<br>            srvDesc.Texture2D.MipLevels = tex.MipLevels;<br>            srvDesc.Texture2D.MostDetailedMip = <span class="hljs-number">0</span>;<br>            srvDesc.Texture2D.ResourceMinLODClamp = <span class="hljs-number">0.0f</span>;<br>            m_device-&gt;<span class="hljs-built_in">CreateShaderResourceView</span>(m_textures[i].<span class="hljs-built_in">Get</span>(), &amp;srvDesc, cbvSrvHandle);<br><br>            <span class="hljs-comment">// Move to the next descriptor slot.</span><br>            cbvSrvHandle.<span class="hljs-built_in">Offset</span>(cbvSrvDescriptorSize);<br>        &#125;<br>        <span class="hljs-built_in">PIXEndEvent</span>(commandList.<span class="hljs-built_in">Get</span>());<br>    &#125;<br><br>    <span class="hljs-built_in">free</span>(pAssetData);<br><br>    <span class="hljs-comment">// Create the samplers.</span><br>    &#123;<br>        <span class="hljs-comment">// Get the sampler descriptor size for the current device.</span><br>        <span class="hljs-type">const</span> UINT samplerDescriptorSize = m_device-&gt;<span class="hljs-built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER);<br><br>        <span class="hljs-comment">// Get a handle to the start of the descriptor heap.</span><br>        <span class="hljs-function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="hljs-title">samplerHandle</span><span class="hljs-params">(m_samplerHeap-&gt;GetCPUDescriptorHandleForHeapStart())</span></span>;<br><br>        <span class="hljs-comment">// Describe and create the wrapping sampler, which is used for </span><br>        <span class="hljs-comment">// sampling diffuse/normal maps.</span><br>        D3D12_SAMPLER_DESC wrapSamplerDesc = &#123;&#125;;<br>        wrapSamplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;<br>        wrapSamplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;<br>        wrapSamplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;<br>        wrapSamplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;<br>        wrapSamplerDesc.MinLOD = <span class="hljs-number">0</span>;<br>        wrapSamplerDesc.MaxLOD = D3D12_FLOAT32_MAX;<br>        wrapSamplerDesc.MipLODBias = <span class="hljs-number">0.0f</span>;<br>        wrapSamplerDesc.MaxAnisotropy = <span class="hljs-number">1</span>;<br>        wrapSamplerDesc.ComparisonFunc = D3D12_COMPARISON_FUNC_ALWAYS;<br>        wrapSamplerDesc.BorderColor[<span class="hljs-number">0</span>] = wrapSamplerDesc.BorderColor[<span class="hljs-number">1</span>] = wrapSamplerDesc.BorderColor[<span class="hljs-number">2</span>] = wrapSamplerDesc.BorderColor[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;<br>        m_device-&gt;<span class="hljs-built_in">CreateSampler</span>(&amp;wrapSamplerDesc, samplerHandle);<br><br>        <span class="hljs-comment">// Move the handle to the next slot in the descriptor heap.</span><br>        samplerHandle.<span class="hljs-built_in">Offset</span>(samplerDescriptorSize);<br><br>        <span class="hljs-comment">// Describe and create the point clamping sampler, which is </span><br>        <span class="hljs-comment">// used for the shadow map.</span><br>        D3D12_SAMPLER_DESC clampSamplerDesc = &#123;&#125;;<br>        clampSamplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_POINT;<br>        clampSamplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;<br>        clampSamplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;<br>        clampSamplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;<br>        clampSamplerDesc.MipLODBias = <span class="hljs-number">0.0f</span>;<br>        clampSamplerDesc.MaxAnisotropy = <span class="hljs-number">1</span>;<br>        clampSamplerDesc.ComparisonFunc = D3D12_COMPARISON_FUNC_ALWAYS;<br>        clampSamplerDesc.BorderColor[<span class="hljs-number">0</span>] = clampSamplerDesc.BorderColor[<span class="hljs-number">1</span>] = clampSamplerDesc.BorderColor[<span class="hljs-number">2</span>] = clampSamplerDesc.BorderColor[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;<br>        clampSamplerDesc.MinLOD = <span class="hljs-number">0</span>;<br>        clampSamplerDesc.MaxLOD = D3D12_FLOAT32_MAX;<br>        m_device-&gt;<span class="hljs-built_in">CreateSampler</span>(&amp;clampSamplerDesc, samplerHandle);<br>    &#125;<br><br>    <span class="hljs-comment">// Create lights.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NumLights; i++)<br>    &#123;<br>        <span class="hljs-comment">// Set up each of the light positions and directions (they all start </span><br>        <span class="hljs-comment">// in the same place).</span><br>        m_lights[i].position = &#123; <span class="hljs-number">0.0f</span>, <span class="hljs-number">15.0f</span>, <span class="hljs-number">-30.0f</span>, <span class="hljs-number">1.0f</span> &#125;;<br>        m_lights[i].direction = &#123; <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span> &#125;;<br>        m_lights[i].falloff = &#123; <span class="hljs-number">800.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span> &#125;;<br>        m_lights[i].color = &#123; <span class="hljs-number">0.7f</span>, <span class="hljs-number">0.7f</span>, <span class="hljs-number">0.7f</span>, <span class="hljs-number">1.0f</span> &#125;;<br><br>        XMVECTOR eye = <span class="hljs-built_in">XMLoadFloat4</span>(&amp;m_lights[i].position);<br>        XMVECTOR at = <span class="hljs-built_in">XMVectorAdd</span>(eye, <span class="hljs-built_in">XMLoadFloat4</span>(&amp;m_lights[i].direction));<br>        XMVECTOR up = <span class="hljs-built_in">XMVectorSet</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>);<br><br>        m_lightCameras[i].<span class="hljs-built_in">Set</span>(eye, at, up);<br>    &#125;<br><br>    <span class="hljs-comment">// Close the command list and use it to execute the initial GPU setup.</span><br>    <span class="hljs-built_in">ThrowIfFailed</span>(commandList-&gt;<span class="hljs-built_in">Close</span>());<br>    ID3D12CommandList* ppCommandLists[] = &#123; commandList.<span class="hljs-built_in">Get</span>() &#125;;<br>    m_commandQueue-&gt;<span class="hljs-built_in">ExecuteCommandLists</span>(_countof(ppCommandLists), ppCommandLists);<br><br>    <span class="hljs-comment">// Create frame resources.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; FrameCount; i++)<br>    &#123;<br>        m_frameResources[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FrameResource</span>(m_device.<span class="hljs-built_in">Get</span>(), m_pipelineState.<span class="hljs-built_in">Get</span>(), m_pipelineStateShadowMap.<span class="hljs-built_in">Get</span>(), m_dsvHeap.<span class="hljs-built_in">Get</span>(), m_cbvSrvHeap.<span class="hljs-built_in">Get</span>(), &amp;m_viewport, i);<br>        m_frameResources[i]-&gt;<span class="hljs-built_in">WriteConstantBuffers</span>(&amp;m_viewport, &amp;m_camera, m_lightCameras, m_lights);<br>    &#125;<br>    m_currentFrameResourceIndex = <span class="hljs-number">0</span>;<br>    m_pCurrentFrameResource = m_frameResources[m_currentFrameResourceIndex];<br><br>    <span class="hljs-comment">// Create synchronization objects and wait until assets have been uploaded to the GPU.</span><br>    &#123;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateFence</span>(m_fenceValue, D3D12_FENCE_FLAG_NONE, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_fence)));<br>        m_fenceValue++;<br><br>        <span class="hljs-comment">// Create an event handle to use for frame synchronization.</span><br>        m_fenceEvent = <span class="hljs-built_in">CreateEvent</span>(<span class="hljs-literal">nullptr</span>, FALSE, FALSE, <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">if</span> (m_fenceEvent == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">HRESULT_FROM_WIN32</span>(<span class="hljs-built_in">GetLastError</span>()));<br>        &#125;<br><br>        <span class="hljs-comment">// Wait for the command list to execute; we are reusing the same command </span><br>        <span class="hljs-comment">// list in our main loop but for now, we just want to wait for setup to </span><br>        <span class="hljs-comment">// complete before continuing.</span><br><br>        <span class="hljs-comment">// Signal and increment the fence value.</span><br>        <span class="hljs-type">const</span> UINT64 fenceToWaitFor = m_fenceValue;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_commandQueue-&gt;<span class="hljs-built_in">Signal</span>(m_fence.<span class="hljs-built_in">Get</span>(), fenceToWaitFor));<br>        m_fenceValue++;<br><br>        <span class="hljs-comment">// Wait until the fence is completed.</span><br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_fence-&gt;<span class="hljs-built_in">SetEventOnCompletion</span>(fenceToWaitFor, m_fenceEvent));<br>        <span class="hljs-built_in">WaitForSingleObject</span>(m_fenceEvent, INFINITE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数用于创建除了帧资源以外的一切场景所需资源。</p><p>首先函数创建管线所需的根签名。着色器中可能需要使用到一个Shadow map、一个物体的diffuse map以及一个normal map、一个常量缓冲区以及两个采样器。因此代码创建了四个描述符表分别用于指定上述四个资源（其中diffuse map和normal map被打包在一个描述符表中，两个采样器也被打包在一个描述符表中）。</p><p>接下来，函数将着色器代码加载到程序中来并加以编译。如果在Debug模式下运行程序则需要指定<i><font color="Red">D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION</font></i>标志以禁用编译器优化，如果在Release模式下运行则可以打开编译器优化选项。下面给出本示例使用的着色器代码。事实上，该着色器使用的代码就是简单的Blinn Phong着色模型以及PCF软阴影，关于PCF在<a target="_blank" rel="noopener" href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping"><code>LearnOpenGL</code></a>中有关于它的理论介绍以及相应的代码框架。<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY?vd_source=96b763f75b621baa119e5118b6164aee&amp;spm_id_from=333.788.videopod.episodes&amp;p=3"><code>games202</code></a>中也有关于这部分内容更深入的介绍（包括PCSS软阴影等），这里不再详细地分析该着色器代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><code class="hljs c">Texture2D shadowMap : <span class="hljs-keyword">register</span>(t0);<br>Texture2D diffuseMap : <span class="hljs-keyword">register</span>(t1);<br>Texture2D normalMap : <span class="hljs-keyword">register</span>(t2);<br><br>SamplerState sampleWrap : <span class="hljs-keyword">register</span>(s0);<br>SamplerState sampleClamp : <span class="hljs-keyword">register</span>(s1);<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_LIGHTS 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHADOW_DEPTH_BIAS 0.00005f</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LightState</span></span><br><span class="hljs-class">&#123;</span><br>    float3 position;<br>    float3 direction;<br>    float4 color;<br>    float4 falloff;<br>    float4x4 view;<br>    float4x4 projection;<br>&#125;;<br><br>cbuffer SceneConstantBuffer : <span class="hljs-keyword">register</span>(b0)<br>&#123;<br>    float4x4 model;<br>    float4x4 view;<br>    float4x4 projection;<br>    float4 ambientColor;<br>    <span class="hljs-type">bool</span> sampleShadowMap;<br>    LightState lights[NUM_LIGHTS];<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PSInput</span></span><br><span class="hljs-class">&#123;</span><br>    float4 position : SV_POSITION;<br>    float4 worldpos : POSITION;<br>    float2 uv : TEXCOORD0;<br>    float3 normal : NORMAL;<br>    float3 tangent : TANGENT;<br>&#125;;<br><br><br><span class="hljs-comment">//--------------------------------------------------------------------------------------</span><br><span class="hljs-comment">// Sample normal map, convert to signed, apply tangent-to-world space transform.</span><br><span class="hljs-comment">//--------------------------------------------------------------------------------------</span><br>float3 <span class="hljs-title function_">CalcPerPixelNormal</span><span class="hljs-params">(float2 vTexcoord, float3 vVertNormal, float3 vVertTangent)</span><br>&#123;<br>    <span class="hljs-comment">// Compute tangent frame.</span><br>    vVertNormal = normalize(vVertNormal);<br>    vVertTangent = normalize(vVertTangent);<br><br>    float3 vVertBinormal = normalize(cross(vVertTangent, vVertNormal));<br>    float3x3 mTangentSpaceToWorldSpace = float3x3(vVertTangent, vVertBinormal, vVertNormal);<br><br>    <span class="hljs-comment">// Compute per-pixel normal.</span><br>    float3 vBumpNormal = (float3)normalMap.Sample(sampleWrap, vTexcoord);<br>    vBumpNormal = <span class="hljs-number">2.0f</span> * vBumpNormal - <span class="hljs-number">1.0f</span>;<br><br>    <span class="hljs-keyword">return</span> mul(vBumpNormal, mTangentSpaceToWorldSpace);<br>&#125;<br><br><span class="hljs-comment">//--------------------------------------------------------------------------------------</span><br><span class="hljs-comment">// Diffuse lighting calculation, with angle and distance falloff.</span><br><span class="hljs-comment">//--------------------------------------------------------------------------------------</span><br>float4 <span class="hljs-title function_">CalcLightingColor</span><span class="hljs-params">(float3 vLightPos, float3 vLightDir, float4 vLightColor, float4 vFalloffs, float3 vPosWorld, float3 vPerPixelNormal)</span><br>&#123;<br>    float3 vLightToPixelUnNormalized = vPosWorld - vLightPos;<br><br>    <span class="hljs-comment">// Dist falloff = 0 at vFalloffs.x, 1 at vFalloffs.x - vFalloffs.y</span><br>    <span class="hljs-type">float</span> fDist = length(vLightToPixelUnNormalized);<br><br>    <span class="hljs-type">float</span> fDistFalloff = saturate((vFalloffs.x - fDist) / vFalloffs.y);<br><br>    <span class="hljs-comment">// Normalize from here on.</span><br>    float3 vLightToPixelNormalized = vLightToPixelUnNormalized / fDist;<br><br>    <span class="hljs-comment">// Angle falloff = 0 at vFalloffs.z, 1 at vFalloffs.z - vFalloffs.w</span><br>    <span class="hljs-type">float</span> fCosAngle = dot(vLightToPixelNormalized, vLightDir / length(vLightDir));<br>    <span class="hljs-type">float</span> fAngleFalloff = saturate((fCosAngle - vFalloffs.z) / vFalloffs.w);<br><br>    <span class="hljs-comment">// Diffuse contribution.</span><br>    <span class="hljs-type">float</span> fNDotL = saturate(-dot(vLightToPixelNormalized, vPerPixelNormal));<br><br>    <span class="hljs-keyword">return</span> vLightColor * fNDotL * fDistFalloff * fAngleFalloff;<br>&#125;<br><br><span class="hljs-comment">//--------------------------------------------------------------------------------------</span><br><span class="hljs-comment">// Test how much pixel is in shadow, using 2x2 percentage-closer filtering.</span><br><span class="hljs-comment">//--------------------------------------------------------------------------------------</span><br>float4 <span class="hljs-title function_">CalcUnshadowedAmountPCF2x2</span><span class="hljs-params">(<span class="hljs-type">int</span> lightIndex, float4 vPosWorld)</span><br>&#123;<br>    <span class="hljs-comment">// Compute pixel position in light space.</span><br>    float4 vLightSpacePos = vPosWorld;<br>    vLightSpacePos = mul(vLightSpacePos, lights[lightIndex].view);<br>    vLightSpacePos = mul(vLightSpacePos, lights[lightIndex].projection);<br><br>    vLightSpacePos.xyz /= vLightSpacePos.w;<br><br>    <span class="hljs-comment">// Translate from homogeneous coords to texture coords.</span><br>    float2 vShadowTexCoord = <span class="hljs-number">0.5f</span> * vLightSpacePos.xy + <span class="hljs-number">0.5f</span>;<br>    vShadowTexCoord.y = <span class="hljs-number">1.0f</span> - vShadowTexCoord.y;<br><br>    <span class="hljs-comment">// Depth bias to avoid pixel self-shadowing.</span><br>    <span class="hljs-type">float</span> vLightSpaceDepth = vLightSpacePos.z - SHADOW_DEPTH_BIAS;<br><br>    <span class="hljs-comment">// Find sub-pixel weights.</span><br>    float2 vShadowMapDims = float2(<span class="hljs-number">1280.0f</span>, <span class="hljs-number">720.0f</span>); <span class="hljs-comment">// need to keep in sync with .cpp file</span><br>    float4 vSubPixelCoords = float4(<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>);<br>    vSubPixelCoords.xy = frac(vShadowMapDims * vShadowTexCoord);<br>    vSubPixelCoords.zw = <span class="hljs-number">1.0f</span> - vSubPixelCoords.xy;<br>    float4 vBilinearWeights = vSubPixelCoords.zxzx * vSubPixelCoords.wwyy;<br><br>    <span class="hljs-comment">// 2x2 percentage closer filtering.</span><br>    float2 vTexelUnits = <span class="hljs-number">1.0f</span> / vShadowMapDims;<br>    float4 vShadowDepths;<br>    vShadowDepths.x = shadowMap.Sample(sampleClamp, vShadowTexCoord);<br>    vShadowDepths.y = shadowMap.Sample(sampleClamp, vShadowTexCoord + float2(vTexelUnits.x, <span class="hljs-number">0.0f</span>));<br>    vShadowDepths.z = shadowMap.Sample(sampleClamp, vShadowTexCoord + float2(<span class="hljs-number">0.0f</span>, vTexelUnits.y));<br>    vShadowDepths.w = shadowMap.Sample(sampleClamp, vShadowTexCoord + vTexelUnits);<br><br>    <span class="hljs-comment">// What weighted fraction of the 4 samples are nearer to the light than this pixel?</span><br>    float4 vShadowTests = (vShadowDepths &gt;= vLightSpaceDepth) ? <span class="hljs-number">1.0f</span> : <span class="hljs-number">0.0f</span>;<br>    <span class="hljs-keyword">return</span> dot(vBilinearWeights, vShadowTests);<br>&#125;<br><br>PSInput <span class="hljs-title function_">VSMain</span><span class="hljs-params">(float3 position : POSITION, float3 normal : NORMAL, float2 uv : TEXCOORD0, float3 tangent : TANGENT)</span><br>&#123;<br>    PSInput result;<br><br>    float4 newPosition = float4(position, <span class="hljs-number">1.0f</span>);<br><br>    normal.z *= <span class="hljs-number">-1.0f</span>;<br>    newPosition = mul(newPosition, model);<br><br>    result.worldpos = newPosition;<br><br>    newPosition = mul(newPosition, view);<br>    newPosition = mul(newPosition, projection);<br><br>    result.position = newPosition;<br>    result.uv = uv;<br>    result.normal = normal;<br>    result.tangent = tangent;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>float4 <span class="hljs-title function_">PSMain</span><span class="hljs-params">(PSInput input)</span> : SV_TARGET<br>&#123;<br>    float4 diffuseColor = diffuseMap.Sample(sampleWrap, input.uv);<br>    float3 pixelNormal = CalcPerPixelNormal(input.uv, input.normal, input.tangent);<br>    float4 totalLight = ambientColor;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_LIGHTS; i++)<br>    &#123;<br>        float4 lightPass = CalcLightingColor(lights[i].position, lights[i].direction, lights[i].color, lights[i].falloff, input.worldpos.xyz, pixelNormal);<br>        <span class="hljs-keyword">if</span> (sampleShadowMap &amp;&amp; i == <span class="hljs-number">0</span>)<br>        &#123;<br>            lightPass *= CalcUnshadowedAmountPCF2x2(i, input.worldpos);<br>        &#125;<br>        totalLight += lightPass;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> diffuseColor * saturate(totalLight);<br>&#125;<br></code></pre></td></tr></table></figure><p>回到<i><font color="Green">LoadAssets</font></i>函数，在编译完着色器代码之后，紧接着需要指定将要创建的渲染管线所需的一些状态。首先是管线的输入布局，从上文着色器代码中看到顶点数据包括了位置、发现、纹理坐标、切向量信息，于是这些信息都需要在顶点输入布局中指定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> D3D12_INPUT_ELEMENT_DESC StandardVertexDescription[] =<br>&#123;<br>    &#123; <span class="hljs-string">&quot;POSITION&quot;</span>, <span class="hljs-number">0</span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,  D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="hljs-number">0</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;NORMAL&quot;</span>,   <span class="hljs-number">0</span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="hljs-number">0</span>, <span class="hljs-number">12</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="hljs-number">0</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;TEXCOORD&quot;</span>, <span class="hljs-number">0</span>, DXGI_FORMAT_R32G32_FLOAT,    <span class="hljs-number">0</span>, <span class="hljs-number">24</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="hljs-number">0</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;TANGENT&quot;</span>,  <span class="hljs-number">0</span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="hljs-number">0</span>, <span class="hljs-number">32</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="hljs-number">0</span> &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后还需要指定深度模板状态，本示例只需要正常开启深度测试和写入即可。</p><p>下面就可以创建管线状态对象了。这部分也是常规的设置，需要的信息在前面已经生成好了。不过需要注意的是示例需要创建两个管线对象分别用于shadow pass和scene pass，其中shadow pass是不需要使用像素着色器的，只需要将深度值写入shadow map即可。</p><p>接下来就需要创建真正用于绑定的资源及其相应的视图了。首先创建一个临时的命令列表用于提交资源创建有关的命令。然后代码先是为所有的后台缓冲区创建了相应的RTV，并且创建了用于scene pass深度缓冲的2D纹理以及相应的视图。紧接着，函数将场景资源加载到程序中来（保存在一个uint8数组<i><font color="Orange">pAssetData</font></i>中），并且将其中的顶点信息上传到创建的顶点缓冲中去。顶点缓冲的创建需要借助一个上传堆中的临时缓冲区作为中介，因为顶点缓冲区是设置在默认堆中的，无法直接和CPU中的数据进行交互。另外还需要注意顶点缓冲创建初始的布局是指定为<i><font color="Red">D3D12_RESOURCE_STATE_COPY_DEST</font></i>以作为临时缓冲传输顶点数据的目的地，在数据传输完毕之后还需要将其布局转换为<i><font color="Red">D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER</font></i>以供顶点着色器读取顶点信息。之后的索引缓冲创建过程和顶点缓冲几乎一致，不再赘述。当然，不能忘了为顶点缓冲和索引缓冲创建相应的视图。</p><p>接下来就是创建着色器资源视图了。示例指定的描述符顺序是：cbv_srv_uav描述符堆的头两个是空SRV，在创建这两个空视图的时候指定其绑定资源为nullptr即可。空视图之后是所有的纹理着色器资源视图。为了创建纹理视图，首先当然需要先创建好所有的纹理资源，然后同样通过一个临时缓冲区将实际的纹理数据上传到实际的纹理缓冲区中。不过这里需要注意的是，纹理缓冲区所需的大小就不太容易如同顶点和索引缓冲区那样直接手动计算出来了，因为纹理缓冲中存储的可能是一个纹理数组，每个纹理也有可能具有多级渐远纹理，所以这里使用WINAPI<code>GetRequiredIntermediateSize</code>来辅助计算缓冲区大小。在创建好纹理资源之后，为每个资源指定一个视图即可。然后就是创建采样器所需的视图，示例需要一个wrap模式以及一个clamp模式的采样器，只需在描述结构体<code>D3D12_SAMPLER_DESC</code>中指定好相应信息即可。注意在这部分资源创建逻辑中，代码事实上并没有创建shadow map实际的资源以及它对应的两个视图，常量缓冲区及其视图同样也还没有创建，这些资源会在<code>FrameResource</code>类的构造函数中创建，因为每帧都应该有自己的这些资源，所以放在帧资源类中创建对应于当前帧的资源是合理的。</p><p>事实上，在创建好全局的资源，设定好灯光信息之后，紧接着程序就开始创建帧资源了。那么下面就来看看帧资源类的构造函数代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><code class="hljs c++">FrameResource::<span class="hljs-built_in">FrameResource</span>(ID3D12Device* pDevice, ID3D12PipelineState* pPso, ID3D12PipelineState* pShadowMapPso, ID3D12DescriptorHeap* pDsvHeap, ID3D12DescriptorHeap* pCbvSrvHeap, D3D12_VIEWPORT* pViewport, UINT frameResourceIndex) :<br>    <span class="hljs-built_in">m_fenceValue</span>(<span class="hljs-number">0</span>),<br>    <span class="hljs-built_in">m_pipelineState</span>(pPso),<br>    <span class="hljs-built_in">m_pipelineStateShadowMap</span>(pShadowMapPso)<br>&#123;<br>    <span class="hljs-keyword">for</span> (UINT i = <span class="hljs-number">0</span>; i &lt; CommandListCount; i++)<br>    &#123;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(pDevice-&gt;<span class="hljs-built_in">CreateCommandAllocator</span>(D3D12_COMMAND_LIST_TYPE_DIRECT, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_commandAllocators[i])));<br>        <span class="hljs-built_in">ThrowIfFailed</span>(pDevice-&gt;<span class="hljs-built_in">CreateCommandList</span>(<span class="hljs-number">0</span>, D3D12_COMMAND_LIST_TYPE_DIRECT, m_commandAllocators[i].<span class="hljs-built_in">Get</span>(), m_pipelineState.<span class="hljs-built_in">Get</span>(), <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_commandLists[i])));<br><br>        <span class="hljs-built_in">NAME_D3D12_OBJECT_INDEXED</span>(m_commandLists, i);<br><br>        <span class="hljs-comment">// Close these command lists; don&#x27;t record into them for now.</span><br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_commandLists[i]-&gt;<span class="hljs-built_in">Close</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (UINT i = <span class="hljs-number">0</span>; i &lt; NumContexts; i++)<br>    &#123;<br>        <span class="hljs-comment">// Create command list allocators for worker threads. One alloc is </span><br>        <span class="hljs-comment">// for the shadow pass command list, and one is for the scene pass.</span><br>        <span class="hljs-built_in">ThrowIfFailed</span>(pDevice-&gt;<span class="hljs-built_in">CreateCommandAllocator</span>(D3D12_COMMAND_LIST_TYPE_DIRECT, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_shadowCommandAllocators[i])));<br>        <span class="hljs-built_in">ThrowIfFailed</span>(pDevice-&gt;<span class="hljs-built_in">CreateCommandAllocator</span>(D3D12_COMMAND_LIST_TYPE_DIRECT, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_sceneCommandAllocators[i])));<br><br>        <span class="hljs-built_in">ThrowIfFailed</span>(pDevice-&gt;<span class="hljs-built_in">CreateCommandList</span>(<span class="hljs-number">0</span>, D3D12_COMMAND_LIST_TYPE_DIRECT, m_shadowCommandAllocators[i].<span class="hljs-built_in">Get</span>(), m_pipelineStateShadowMap.<span class="hljs-built_in">Get</span>(), <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_shadowCommandLists[i])));<br>        <span class="hljs-built_in">ThrowIfFailed</span>(pDevice-&gt;<span class="hljs-built_in">CreateCommandList</span>(<span class="hljs-number">0</span>, D3D12_COMMAND_LIST_TYPE_DIRECT, m_sceneCommandAllocators[i].<span class="hljs-built_in">Get</span>(), m_pipelineState.<span class="hljs-built_in">Get</span>(), <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_sceneCommandLists[i])));<br><br>        <span class="hljs-built_in">NAME_D3D12_OBJECT_INDEXED</span>(m_shadowCommandLists, i);<br>        <span class="hljs-built_in">NAME_D3D12_OBJECT_INDEXED</span>(m_sceneCommandLists, i);<br><br>        <span class="hljs-comment">// Close these command lists; don&#x27;t record into them for now. We will </span><br>        <span class="hljs-comment">// reset them to a recording state when we start the render loop.</span><br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_shadowCommandLists[i]-&gt;<span class="hljs-built_in">Close</span>());<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_sceneCommandLists[i]-&gt;<span class="hljs-built_in">Close</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// Describe and create the shadow map texture.</span><br>    <span class="hljs-function">CD3DX12_RESOURCE_DESC <span class="hljs-title">shadowTexDesc</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        D3D12_RESOURCE_DIMENSION_TEXTURE2D,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">static_cast</span>&lt;UINT&gt;(pViewport-&gt;Width), </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">static_cast</span>&lt;UINT&gt;(pViewport-&gt;Height), </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-number">1</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-number">1</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        DXGI_FORMAT_R32_TYPELESS,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-number">1</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        D3D12_TEXTURE_LAYOUT_UNKNOWN,</span></span><br><span class="hljs-params"><span class="hljs-function">        D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL)</span></span>;<br><br>    D3D12_CLEAR_VALUE clearValue;        <span class="hljs-comment">// Performance tip: Tell the runtime at resource creation the desired clear value.</span><br>    clearValue.Format = DXGI_FORMAT_D32_FLOAT;<br>    clearValue.DepthStencil.Depth = <span class="hljs-number">1.0f</span>;<br>    clearValue.DepthStencil.Stencil = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">ThrowIfFailed</span>(pDevice-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>        &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_DEFAULT),<br>        D3D12_HEAP_FLAG_NONE,<br>        &amp;shadowTexDesc,<br>        D3D12_RESOURCE_STATE_DEPTH_WRITE,<br>        &amp;clearValue,<br>        <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_shadowTexture)));<br><br>    <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_shadowTexture);<br><br>    <span class="hljs-comment">// Get a handle to the start of the descriptor heap then offset </span><br>    <span class="hljs-comment">// it based on the frame resource index.</span><br>    <span class="hljs-type">const</span> UINT dsvDescriptorSize = pDevice-&gt;<span class="hljs-built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_DSV);<br>    <span class="hljs-function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="hljs-title">depthHandle</span><span class="hljs-params">(pDsvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), <span class="hljs-number">1</span> + frameResourceIndex, dsvDescriptorSize)</span></span>; <span class="hljs-comment">// + 1 for the shadow map.</span><br><br>    <span class="hljs-comment">// Describe and create the shadow depth view and cache the CPU </span><br>    <span class="hljs-comment">// descriptor handle.</span><br>    D3D12_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc = &#123;&#125;;<br>    depthStencilViewDesc.Format = DXGI_FORMAT_D32_FLOAT;<br>    depthStencilViewDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;<br>    depthStencilViewDesc.Texture2D.MipSlice = <span class="hljs-number">0</span>;<br>    pDevice-&gt;<span class="hljs-built_in">CreateDepthStencilView</span>(m_shadowTexture.<span class="hljs-built_in">Get</span>(), &amp;depthStencilViewDesc, depthHandle);<br>    m_shadowDepthView = depthHandle;<br><br>    <span class="hljs-comment">// Get a handle to the start of the descriptor heap then offset it </span><br>    <span class="hljs-comment">// based on the existing textures and the frame resource index. Each </span><br>    <span class="hljs-comment">// frame has 1 SRV (shadow tex) and 2 CBVs.</span><br>    <span class="hljs-type">const</span> UINT nullSrvCount = <span class="hljs-number">2</span>;                                <span class="hljs-comment">// Null descriptors at the start of the heap.</span><br>    <span class="hljs-type">const</span> UINT textureCount = _countof(SampleAssets::Textures);    <span class="hljs-comment">// Diffuse + normal textures near the start of the heap.  Ideally, track descriptor heap contents/offsets at a higher level.</span><br>    <span class="hljs-type">const</span> UINT cbvSrvDescriptorSize = pDevice-&gt;<span class="hljs-built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);<br>    <span class="hljs-function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="hljs-title">cbvSrvCpuHandle</span><span class="hljs-params">(pCbvSrvHeap-&gt;GetCPUDescriptorHandleForHeapStart())</span></span>;<br>    <span class="hljs-function">CD3DX12_GPU_DESCRIPTOR_HANDLE <span class="hljs-title">cbvSrvGpuHandle</span><span class="hljs-params">(pCbvSrvHeap-&gt;GetGPUDescriptorHandleForHeapStart())</span></span>;<br>    m_nullSrvHandle = cbvSrvGpuHandle;<br>    cbvSrvCpuHandle.<span class="hljs-built_in">Offset</span>(nullSrvCount + textureCount + (frameResourceIndex * FrameCount), cbvSrvDescriptorSize);<br>    cbvSrvGpuHandle.<span class="hljs-built_in">Offset</span>(nullSrvCount + textureCount + (frameResourceIndex * FrameCount), cbvSrvDescriptorSize);<br><br>    <span class="hljs-comment">// Describe and create a shader resource view (SRV) for the shadow depth </span><br>    <span class="hljs-comment">// texture and cache the GPU descriptor handle. This SRV is for sampling </span><br>    <span class="hljs-comment">// the shadow map from our shader. It uses the same texture that we use </span><br>    <span class="hljs-comment">// as a depth-stencil during the shadow pass.</span><br>    D3D12_SHADER_RESOURCE_VIEW_DESC shadowSrvDesc = &#123;&#125;;<br>    shadowSrvDesc.Format = DXGI_FORMAT_R32_FLOAT;<br>    shadowSrvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;<br>    shadowSrvDesc.Texture2D.MipLevels = <span class="hljs-number">1</span>;<br>    shadowSrvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;<br>    pDevice-&gt;<span class="hljs-built_in">CreateShaderResourceView</span>(m_shadowTexture.<span class="hljs-built_in">Get</span>(), &amp;shadowSrvDesc, cbvSrvCpuHandle);<br>    m_shadowDepthHandle = cbvSrvGpuHandle;<br><br>    <span class="hljs-comment">// Increment the descriptor handles.</span><br>    cbvSrvCpuHandle.<span class="hljs-built_in">Offset</span>(cbvSrvDescriptorSize);<br>    cbvSrvGpuHandle.<span class="hljs-built_in">Offset</span>(cbvSrvDescriptorSize);<br><br>    <span class="hljs-comment">// Create the constant buffers.</span><br>    <span class="hljs-type">const</span> UINT constantBufferSize = (<span class="hljs-built_in">sizeof</span>(SceneConstantBuffer) + (D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT - <span class="hljs-number">1</span>)) &amp; ~(D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT - <span class="hljs-number">1</span>); <span class="hljs-comment">// must be a multiple 256 bytes</span><br>    <span class="hljs-built_in">ThrowIfFailed</span>(pDevice-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>        &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_UPLOAD),<br>        D3D12_HEAP_FLAG_NONE,<br>        &amp;CD3DX12_RESOURCE_DESC::<span class="hljs-built_in">Buffer</span>(constantBufferSize),<br>        D3D12_RESOURCE_STATE_GENERIC_READ,<br>        <span class="hljs-literal">nullptr</span>,<br>        <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_shadowConstantBuffer)));<br>    <span class="hljs-built_in">ThrowIfFailed</span>(pDevice-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>        &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_UPLOAD),<br>        D3D12_HEAP_FLAG_NONE,<br>        &amp;CD3DX12_RESOURCE_DESC::<span class="hljs-built_in">Buffer</span>(constantBufferSize),<br>        D3D12_RESOURCE_STATE_GENERIC_READ,<br>        <span class="hljs-literal">nullptr</span>,<br>        <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_sceneConstantBuffer)));<br><br>    <span class="hljs-comment">// Map the constant buffers and cache their heap pointers.</span><br>    <span class="hljs-function">CD3DX12_RANGE <span class="hljs-title">readRange</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;        <span class="hljs-comment">// We do not intend to read from this resource on the CPU.</span><br>    <span class="hljs-built_in">ThrowIfFailed</span>(m_shadowConstantBuffer-&gt;<span class="hljs-built_in">Map</span>(<span class="hljs-number">0</span>, &amp;readRange, <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>**&gt;(&amp;mp_shadowConstantBufferWO)));<br>    <span class="hljs-built_in">ThrowIfFailed</span>(m_sceneConstantBuffer-&gt;<span class="hljs-built_in">Map</span>(<span class="hljs-number">0</span>, &amp;readRange, <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>**&gt;(&amp;mp_sceneConstantBufferWO)));<br><br>    <span class="hljs-comment">// Create the constant buffer views: one for the shadow pass and</span><br>    <span class="hljs-comment">// another for the scene pass.</span><br>    D3D12_CONSTANT_BUFFER_VIEW_DESC cbvDesc = &#123;&#125;;<br>    cbvDesc.SizeInBytes = constantBufferSize;<br><br>    <span class="hljs-comment">// Describe and create the shadow constant buffer view (CBV) and </span><br>    <span class="hljs-comment">// cache the GPU descriptor handle.</span><br>    cbvDesc.BufferLocation = m_shadowConstantBuffer-&gt;<span class="hljs-built_in">GetGPUVirtualAddress</span>();<br>    pDevice-&gt;<span class="hljs-built_in">CreateConstantBufferView</span>(&amp;cbvDesc, cbvSrvCpuHandle);<br>    m_shadowCbvHandle = cbvSrvGpuHandle;<br><br>    <span class="hljs-comment">// Increment the descriptor handles.</span><br>    cbvSrvCpuHandle.<span class="hljs-built_in">Offset</span>(cbvSrvDescriptorSize);<br>    cbvSrvGpuHandle.<span class="hljs-built_in">Offset</span>(cbvSrvDescriptorSize);<br><br>    <span class="hljs-comment">// Describe and create the scene constant buffer view (CBV) and </span><br>    <span class="hljs-comment">// cache the GPU descriptor handle.</span><br>    cbvDesc.BufferLocation = m_sceneConstantBuffer-&gt;<span class="hljs-built_in">GetGPUVirtualAddress</span>();<br>    pDevice-&gt;<span class="hljs-built_in">CreateConstantBufferView</span>(&amp;cbvDesc, cbvSrvCpuHandle);<br>    m_sceneCbvHandle = cbvSrvGpuHandle;<br><br>    <span class="hljs-comment">// Batch up command lists for execution later.</span><br>    <span class="hljs-type">const</span> UINT batchSize = _countof(m_sceneCommandLists) + _countof(m_shadowCommandLists) + <span class="hljs-number">3</span>;<br>    m_batchSubmit[<span class="hljs-number">0</span>] = m_commandLists[CommandListPre].<span class="hljs-built_in">Get</span>();<br>    <span class="hljs-built_in">memcpy</span>(m_batchSubmit + <span class="hljs-number">1</span>, m_shadowCommandLists, _countof(m_shadowCommandLists) * <span class="hljs-built_in">sizeof</span>(ID3D12CommandList*));<br>    m_batchSubmit[_countof(m_shadowCommandLists) + <span class="hljs-number">1</span>] = m_commandLists[CommandListMid].<span class="hljs-built_in">Get</span>();<br>    <span class="hljs-built_in">memcpy</span>(m_batchSubmit + _countof(m_shadowCommandLists) + <span class="hljs-number">2</span>, m_sceneCommandLists, _countof(m_sceneCommandLists) * <span class="hljs-built_in">sizeof</span>(ID3D12CommandList*));<br>    m_batchSubmit[batchSize - <span class="hljs-number">1</span>] = m_commandLists[CommandListPost].<span class="hljs-built_in">Get</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，构造函数创建了用于构建并提交当前帧命令的命令队列以及命令分配器，总共是创建了2倍线程数加上3个队列和分配器对。由于渲染流程是先进行shadow pass的渲染，然后进行scene pass的渲染，因此在开启多线程录制命令之前，首先需要使用一个命令队列来提交一些开始渲染前的准备工作（清除渲染视图和深度视图等），然后开启多线程录制，录制用于shadow pass的命令。在录制结束之后，需要一个单独的命令队列来进行shadow pass渲染结束后shadow map布局的转换。在此之后就可以启动多线程录制scene pass的命令，最后在scene pass执行完毕后也需要一个单独的命令队列来进行一些收尾工作的提交（将shadow map布局转换回去等），后续我们会详细地看到有关代码逻辑。</p><p>在此之后，构造函数创建了Shadow map资源。这里需要注意的是创建Shadow map时图像格式指定为<i><font color="Red">DXGI_FORMAT_R32_TYPELESS</font></i>，这是因为后续Shadow map会分别用作深度缓冲和着色器资源，其格式是会变换的，因此需要通过在对应的视图中指定其具体格式。</p><p>接下来成勋就创建了该Shadow map的深度视图，并且创建了当前帧的Shadow map的着色器资源视图以及两个常量缓冲区视图。需要注意的是，常量缓冲区是在上传堆中生成的，这是因为常量缓冲区中的数据需要不断变换，直接放在上传堆上有助于数据的传递。另外，我们可以发现程序对常量缓冲区使用了<strong>persistent map</strong>的手段，也就是映射该缓冲区到CPU内存并且在程序运行过程中不解除映射，这样可以节省映射过程带来的性能消耗。</p><p>最后，构造函数将所有的命令队列合批在一个队列列表中，这样就可以一次性执行各线程中录制好的命令的。</p><p>回到<i><font color="Green">LoadAssets</font></i>函数。在初始化帧资源之后，下一步就是初始化常量缓冲区的数据。这可以通过帧资源类成员函数<i><font color="Green">WriteConstantBuffers</font></i>来完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Builds and writes constant buffers from scratch to the proper slots for </span><br><span class="hljs-comment">// this frame resource.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FrameResource::WriteConstantBuffers</span><span class="hljs-params">(D3D12_VIEWPORT* pViewport, Camera* pSceneCamera, Camera lightCams[NumLights], LightState lights[NumLights])</span></span><br><span class="hljs-function"></span>&#123;<br>    SceneConstantBuffer sceneConsts = &#123;&#125;; <br>    SceneConstantBuffer shadowConsts = &#123;&#125;;<br>    <br>    <span class="hljs-comment">// Scale down the world a bit.</span><br>    ::<span class="hljs-built_in">XMStoreFloat4x4</span>(&amp;sceneConsts.model, <span class="hljs-built_in">XMMatrixScaling</span>(<span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>));<br>    ::<span class="hljs-built_in">XMStoreFloat4x4</span>(&amp;shadowConsts.model, <span class="hljs-built_in">XMMatrixScaling</span>(<span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>));<br><br>    <span class="hljs-comment">// The scene pass is drawn from the camera.</span><br>    pSceneCamera-&gt;<span class="hljs-built_in">Get3DViewProjMatrices</span>(&amp;sceneConsts.view, &amp;sceneConsts.projection, <span class="hljs-number">90.0f</span>, pViewport-&gt;Width, pViewport-&gt;Height);<br><br>    <span class="hljs-comment">// The light pass is drawn from the first light.</span><br>    lightCams[<span class="hljs-number">0</span>].<span class="hljs-built_in">Get3DViewProjMatrices</span>(&amp;shadowConsts.view, &amp;shadowConsts.projection, <span class="hljs-number">90.0f</span>, pViewport-&gt;Width, pViewport-&gt;Height);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NumLights; i++)<br>    &#123;<br>        <span class="hljs-built_in">memcpy</span>(&amp;sceneConsts.lights[i], &amp;lights[i], <span class="hljs-built_in">sizeof</span>(LightState));<br>        <span class="hljs-built_in">memcpy</span>(&amp;shadowConsts.lights[i], &amp;lights[i], <span class="hljs-built_in">sizeof</span>(LightState));<br>    &#125;<br><br>    <span class="hljs-comment">// The shadow pass won&#x27;t sample the shadow map, but rather write to it.</span><br>    shadowConsts.sampleShadowMap = FALSE;<br><br>    <span class="hljs-comment">// The scene pass samples the shadow map.</span><br>    sceneConsts.sampleShadowMap = TRUE;<br><br>    shadowConsts.ambientColor = sceneConsts.ambientColor = &#123; <span class="hljs-number">0.1f</span>, <span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">1.0f</span> &#125;;<br><br>    <span class="hljs-built_in">memcpy</span>(mp_sceneConstantBufferWO, &amp;sceneConsts, <span class="hljs-built_in">sizeof</span>(SceneConstantBuffer));<br>    <span class="hljs-built_in">memcpy</span>(mp_shadowConstantBufferWO, &amp;shadowConsts, <span class="hljs-built_in">sizeof</span>(SceneConstantBuffer));<br>&#125;<br></code></pre></td></tr></table></figure><p>在<i><font color="Green">LoadAssets</font></i>函数的最后，代码创建了用于CPU—GPU同步的栅栏对象，并且令其等待之前的GPU资源创建执行完毕。</p><p>那么接下来就来分析初始化函数<i><font color="Green">OnInit</font></i>中的最后一个函数调用：<i><font color="Green">LoadContexts</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Initialize threads and events.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::LoadContexts</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !SINGLETHREADED</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">threadwrapper</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> WINAPI <span class="hljs-title">thunk</span><span class="hljs-params">(LPVOID lpParameter)</span></span><br><span class="hljs-function">        </span>&#123;<br>            ThreadParameter* parameter = <span class="hljs-built_in">reinterpret_cast</span>&lt;ThreadParameter*&gt;(lpParameter);<br>            D3D12Multithreading::<span class="hljs-built_in">Get</span>()-&gt;<span class="hljs-built_in">WorkerThread</span>(parameter-&gt;threadIndex);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NumContexts; i++)<br>    &#123;<br>        m_workerBeginRenderFrame[i] = <span class="hljs-built_in">CreateEvent</span>(<br>            <span class="hljs-literal">NULL</span>,<br>            FALSE,<br>            FALSE,<br>            <span class="hljs-literal">NULL</span>);<br><br>        m_workerFinishedRenderFrame[i] = <span class="hljs-built_in">CreateEvent</span>(<br>            <span class="hljs-literal">NULL</span>,<br>            FALSE,<br>            FALSE,<br>            <span class="hljs-literal">NULL</span>);<br><br>        m_workerFinishShadowPass[i] = <span class="hljs-built_in">CreateEvent</span>(<br>            <span class="hljs-literal">NULL</span>,<br>            FALSE,<br>            FALSE,<br>            <span class="hljs-literal">NULL</span>);<br><br>        m_threadParameters[i].threadIndex = i;<br><br>        m_threadHandles[i] = <span class="hljs-built_in">reinterpret_cast</span>&lt;HANDLE&gt;(_beginthreadex(<br>            <span class="hljs-literal">nullptr</span>,<br>            <span class="hljs-number">0</span>,<br>            threadwrapper::thunk,<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;LPVOID&gt;(&amp;m_threadParameters[i]),<br>            <span class="hljs-number">0</span>,<br>            <span class="hljs-literal">nullptr</span>));<br><br>        <span class="hljs-built_in">assert</span>(m_workerBeginRenderFrame[i] != <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">assert</span>(m_workerFinishedRenderFrame[i] != <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">assert</span>(m_threadHandles[i] != <span class="hljs-literal">NULL</span>);<br><br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>该函数用于分配各个线程录制命令任务。</p><p>函数开始处首先定义了一个仅包含一个静态函数的结构体<code>threadwrapper</code>，该结构体内静态函数<i><font color="Green">WorkerThread</font></i>的作用就是录制绘制命令，该函数需要一个自定义结构体<code>ThreadParameter</code>对象作为其参数，该结构体定义十分简单，仅包含一个代表线程ID的整数值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThreadParameter</span><br>&#123;<br>    <span class="hljs-type">int</span> threadIndex;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面来看<i><font color="Green">WorkerThread</font></i>函数的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Worker thread body. workerIndex is an integer from 0 to NumContexts </span><br><span class="hljs-comment">// describing the worker&#x27;s thread index.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::WorkerThread</span><span class="hljs-params">(<span class="hljs-type">int</span> threadIndex)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(threadIndex &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">assert</span>(threadIndex &lt; NumContexts);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !SINGLETHREADED</span><br><br>    <span class="hljs-keyword">while</span> (threadIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; threadIndex &lt; NumContexts)<br>    &#123;<br>        <span class="hljs-comment">// Wait for main thread to tell us to draw.</span><br><br>        <span class="hljs-built_in">WaitForSingleObject</span>(m_workerBeginRenderFrame[threadIndex], INFINITE);<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        ID3D12GraphicsCommandList* pShadowCommandList = m_pCurrentFrameResource-&gt;m_shadowCommandLists[threadIndex].<span class="hljs-built_in">Get</span>();<br>        ID3D12GraphicsCommandList* pSceneCommandList = m_pCurrentFrameResource-&gt;m_sceneCommandLists[threadIndex].<span class="hljs-built_in">Get</span>();<br><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// Shadow pass</span><br>        <span class="hljs-comment">//</span><br><br>        <span class="hljs-comment">// Populate the command list.</span><br>        <span class="hljs-built_in">SetCommonPipelineState</span>(pShadowCommandList);<br>        m_pCurrentFrameResource-&gt;<span class="hljs-built_in">Bind</span>(pShadowCommandList, FALSE, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);    <span class="hljs-comment">// No need to pass RTV or DSV descriptor heap.</span><br><br>        <span class="hljs-comment">// Set null SRVs for the diffuse/normal textures.</span><br>        pShadowCommandList-&gt;<span class="hljs-built_in">SetGraphicsRootDescriptorTable</span>(<span class="hljs-number">0</span>, m_cbvSrvHeap-&gt;<span class="hljs-built_in">GetGPUDescriptorHandleForHeapStart</span>());<br><br>        <span class="hljs-comment">// Distribute objects over threads by drawing only 1/NumContexts </span><br>        <span class="hljs-comment">// objects per worker (i.e. every object such that objectnum % </span><br>        <span class="hljs-comment">// NumContexts == threadIndex).</span><br>        <span class="hljs-built_in">PIXBeginEvent</span>(pShadowCommandList, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;Worker drawing shadow pass...&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = threadIndex; j &lt; _countof(SampleAssets::Draws); j += NumContexts)<br>        &#123;<br>            SampleAssets::DrawParameters drawArgs = SampleAssets::Draws[j];<br><br>            pShadowCommandList-&gt;<span class="hljs-built_in">DrawIndexedInstanced</span>(drawArgs.IndexCount, <span class="hljs-number">1</span>, drawArgs.IndexStart, drawArgs.VertexBase, <span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">PIXEndEvent</span>(pShadowCommandList);<br><br>        <span class="hljs-built_in">ThrowIfFailed</span>(pShadowCommandList-&gt;<span class="hljs-built_in">Close</span>());<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !SINGLETHREADED</span><br>        <span class="hljs-comment">// Submit shadow pass.</span><br>        <span class="hljs-built_in">SetEvent</span>(m_workerFinishShadowPass[threadIndex]);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// Scene pass</span><br>        <span class="hljs-comment">// </span><br><br>        <span class="hljs-comment">// Populate the command list.  These can only be sent after the shadow </span><br>        <span class="hljs-comment">// passes for this frame have been submitted.</span><br>        <span class="hljs-built_in">SetCommonPipelineState</span>(pSceneCommandList);<br>        <span class="hljs-function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="hljs-title">rtvHandle</span><span class="hljs-params">(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize)</span></span>;<br>        <span class="hljs-function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="hljs-title">dsvHandle</span><span class="hljs-params">(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart())</span></span>;<br>        m_pCurrentFrameResource-&gt;<span class="hljs-built_in">Bind</span>(pSceneCommandList, TRUE, &amp;rtvHandle, &amp;dsvHandle);<br><br>        <span class="hljs-built_in">PIXBeginEvent</span>(pSceneCommandList, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;Worker drawing scene pass...&quot;</span>);<br><br>        D3D12_GPU_DESCRIPTOR_HANDLE cbvSrvHeapStart = m_cbvSrvHeap-&gt;<span class="hljs-built_in">GetGPUDescriptorHandleForHeapStart</span>();<br>        <span class="hljs-type">const</span> UINT cbvSrvDescriptorSize = m_device-&gt;<span class="hljs-built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);<br>        <span class="hljs-type">const</span> UINT nullSrvCount = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = threadIndex; j &lt; _countof(SampleAssets::Draws); j += NumContexts)<br>        &#123;<br>            SampleAssets::DrawParameters drawArgs = SampleAssets::Draws[j];<br><br>            <span class="hljs-comment">// Set the diffuse and normal textures for the current object.</span><br>            <span class="hljs-function">CD3DX12_GPU_DESCRIPTOR_HANDLE <span class="hljs-title">cbvSrvHandle</span><span class="hljs-params">(cbvSrvHeapStart, nullSrvCount + drawArgs.DiffuseTextureIndex, cbvSrvDescriptorSize)</span></span>;<br>            pSceneCommandList-&gt;<span class="hljs-built_in">SetGraphicsRootDescriptorTable</span>(<span class="hljs-number">0</span>, cbvSrvHandle);<br><br>            pSceneCommandList-&gt;<span class="hljs-built_in">DrawIndexedInstanced</span>(drawArgs.IndexCount, <span class="hljs-number">1</span>, drawArgs.IndexStart, drawArgs.VertexBase, <span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">PIXEndEvent</span>(pSceneCommandList);<br>        <span class="hljs-built_in">ThrowIfFailed</span>(pSceneCommandList-&gt;<span class="hljs-built_in">Close</span>());<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !SINGLETHREADED</span><br>        <span class="hljs-comment">// Tell main thread that we are done.</span><br>        <span class="hljs-built_in">SetEvent</span>(m_workerFinishedRenderFrame[threadIndex]); <br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>首先，调用该函数的线程会等待对应的<i><font color="Orange">m_workerBeginRenderFrame</font></i>事件被触发，后续我们将会看到该事件实际上会在渲染循环开始时开头的线程做好准备工作之后被触发。也就是说一旦准备工作做好了，就可以开始录制绘制命令了。</p><p>我们已经知道该示例的绘制过程分两趟，首先需要进行shadow pass。D3D12中要开启一个pass的绘制，首先需要设置好一系列的管线状态以及资源对象。两趟pass公共的资源和状态设置是通过<i><font color="Green">SetCommonPipelineState</font></i>来完成的。该函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::SetCommonPipelineState</span><span class="hljs-params">(ID3D12GraphicsCommandList* pCommandList)</span></span><br><span class="hljs-function"></span>&#123;<br>    pCommandList-&gt;<span class="hljs-built_in">SetGraphicsRootSignature</span>(m_rootSignature.<span class="hljs-built_in">Get</span>());<br><br>    ID3D12DescriptorHeap* ppHeaps[] = &#123; m_cbvSrvHeap.<span class="hljs-built_in">Get</span>(), m_samplerHeap.<span class="hljs-built_in">Get</span>() &#125;;<br>    pCommandList-&gt;<span class="hljs-built_in">SetDescriptorHeaps</span>(_countof(ppHeaps), ppHeaps);<br><br>    pCommandList-&gt;<span class="hljs-built_in">RSSetViewports</span>(<span class="hljs-number">1</span>, &amp;m_viewport);<br>    pCommandList-&gt;<span class="hljs-built_in">RSSetScissorRects</span>(<span class="hljs-number">1</span>, &amp;m_scissorRect);<br>    pCommandList-&gt;<span class="hljs-built_in">IASetPrimitiveTopology</span>(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);<br>    pCommandList-&gt;<span class="hljs-built_in">IASetVertexBuffers</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;m_vertexBufferView);<br>    pCommandList-&gt;<span class="hljs-built_in">IASetIndexBuffer</span>(&amp;m_indexBufferView);<br>    pCommandList-&gt;<span class="hljs-built_in">SetGraphicsRootDescriptorTable</span>(<span class="hljs-number">3</span>, m_samplerHeap-&gt;<span class="hljs-built_in">GetGPUDescriptorHandleForHeapStart</span>());<br>    pCommandList-&gt;<span class="hljs-built_in">OMSetStencilRef</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// Render targets and depth stencil are set elsewhere because the </span><br>    <span class="hljs-comment">// depth stencil depends on the frame resource being used.</span><br><br>    <span class="hljs-comment">// Constant buffers are set elsewhere because they depend on the </span><br>    <span class="hljs-comment">// frame resource being used.</span><br><br>    <span class="hljs-comment">// SRVs are set elsewhere because they change based on the object </span><br>    <span class="hljs-comment">// being drawn.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注释中也明确说明了，渲染目标、深度缓冲、常量缓冲以及着色器资源并不会在该函数中设置，因为它们具体绑定哪个资源取决于当前帧或者当前绘制的对象。</p><p>在设置好通用资源状态之后，接下来就来绑定shadow pass的帧资源。帧资源类的<i><font color="Green">Bind</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Sets up the descriptor tables for the worker command list to use </span><br><span class="hljs-comment">// resources provided by frame resource.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FrameResource::Bind</span><span class="hljs-params">(ID3D12GraphicsCommandList* pCommandList, BOOL scenePass, D3D12_CPU_DESCRIPTOR_HANDLE* pRtvHandle, D3D12_CPU_DESCRIPTOR_HANDLE* pDsvHandle)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (scenePass)<br>    &#123;<br>        <span class="hljs-comment">// Scene pass. We use constant buf #2 and depth stencil #2</span><br>        <span class="hljs-comment">// with rendering to the render target enabled.</span><br>        pCommandList-&gt;<span class="hljs-built_in">SetGraphicsRootDescriptorTable</span>(<span class="hljs-number">2</span>, m_shadowDepthHandle);        <span class="hljs-comment">// Set the shadow texture as an SRV.</span><br>        pCommandList-&gt;<span class="hljs-built_in">SetGraphicsRootDescriptorTable</span>(<span class="hljs-number">1</span>, m_sceneCbvHandle);<br>        <br>        <span class="hljs-built_in">assert</span>(pRtvHandle != <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-built_in">assert</span>(pDsvHandle != <span class="hljs-literal">nullptr</span>);<br><br>        pCommandList-&gt;<span class="hljs-built_in">OMSetRenderTargets</span>(<span class="hljs-number">1</span>, pRtvHandle, FALSE, pDsvHandle);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// Shadow pass. We use constant buf #1 and depth stencil #1</span><br>        <span class="hljs-comment">// with rendering to the render target disabled.</span><br>        pCommandList-&gt;<span class="hljs-built_in">SetGraphicsRootDescriptorTable</span>(<span class="hljs-number">2</span>, m_nullSrvHandle);            <span class="hljs-comment">// Set a null SRV for the shadow texture.</span><br>        pCommandList-&gt;<span class="hljs-built_in">SetGraphicsRootDescriptorTable</span>(<span class="hljs-number">1</span>, m_shadowCbvHandle);<br><br>        pCommandList-&gt;<span class="hljs-built_in">OMSetRenderTargets</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, FALSE, &amp;m_shadowDepthView);    <span class="hljs-comment">// No render target needed for the shadow pass.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数会区分当前渲染的是shadow还是scene。如果是场景渲染，那么应当设置好之前的shadow pass生成的shadow map以及scene pass的常量缓冲区，渲染目标应该设置为正常的后台缓冲区。但是如果是阴影渲染，那么只需要设置shadow pass的常量缓冲区即可，该pass的作用是生成shadow map，因此shader中shadow map资源绑定一个空视图即可，而且由于渲染深度图并不需要有任何颜色渲染，因此不需要绑定渲染目标，简单地将渲染目标设置为nullptr即可。</p><p>回到<i><font color="Green">WorkerThread</font></i>函数，在绑定了帧资源之后，对于shadow pass，由于该pass同样不需要用到diffuse map和normal map，因此着色器中该资源对应的视图也可以直接绑定为空视图。注意空视图在之前的创建过程中是创建在描述符堆的开始处，所以只需要绑定<code>GetGPUDescriptorHandleForHeapStart</code>返回的描述符句柄即可。</p><p>在完成了所有资源的绑定和渲染状态的设置之后，终于可以进行shadow pass的绘制了。每个线程会负责录制<strong>总绘制物体数/线程数</strong>个物体的绘制命令。</p><p>在完成了shadow pass绘制命令的录制之后，就可以激活<i><font color="Orange">m_workerFinishShadowPass</font></i>事件以通知主线程该线程shadow pass命令录制已经完成，接着主线程就会在所有线程的相应事件都被激活之后统一提交所有线程录制的shadow pass有关命令，在后文分析渲染函数<i><font color="Green">OnRender</font></i>代码的时候会详细分析这一块的执行顺序和逻辑。</p><p>在录制完shadow pass的命令后，线程可以紧接着开始录制scene pass的命令。即使此时shadow pass的命令还没有执行完毕，提前录制scene pass渲染命令并不会有什么问题，因为后文在分析<i><font color="Green">OnRender</font></i>代码的时候会看到绘制命令的执行会在shadow map的布局转换之后，而shadow pass的绘制命令会在布局转换之前完成，因此即使提前录制好了命令，也不会立刻执行，不会产生资源冲突。</p><p>scene pass绘制命令的录制流程和shadow pass差不多，只不过绑定的资源不尽相同，这里不再赘述。</p><p>在录制完所有scene pass绘制命令之后，同样需要将<i><font color="Orange">m_workerFinishedRenderFrame</font></i>设置为激活状态，以通知主线程可以提交并执行scene pass的命令。</p><p>下面回到<i><font color="Green">LoadContexts</font></i>函数。从上文<i><font color="Green">WorkerThread</font></i>函数代码可以看到在渲染命令的执行过程中需要用到许多事件进行同步，因此在初始化阶段理应创建好这些事件。这部分代码只需要注意到<code>CreateEvent</code>函数的第二个参数始终设置为FALSE，这意味着系统在释放单一等待线程之后（也就是某线程中的<code>WaitForSingleObject</code>函数等待到了该激活的事件）会自动将该事件重置回未激活状态，如果该参数设置为TRUE则需要使用<code>ResetEvent</code>才能将被激活的事件重置为未激活的状态。另外<code>CreateEvent</code>的第三个参数代表事件创建时是否处于激活状态，这里也设置为FALSE。</p><p>在创建好这些同步量之后，就可以调用<code>_beginthreadex</code>来启动每个线程了。该函数限制传递给它的执行函数类型一定要为<code>unsigned (__stdcall *)(void *)</code>，也就是说它的参数一定要是一个void*指针，这就是为什么代码需要费劲地将传递给该函数的指向<code>ThreadParameter</code>对象的指针参数转换为void* *，然后在<i><font color="Green">thunk</font></i>函数中又将其转换回来的原因。另外，即使在准备阶段就启动了线程，也不用担心资源竞争，因为前文看到了各线程录制命令需要等待<i><font color="Orange">m_workerBeginRenderFrame</font></i>事件被激活，而该事件只会在渲染开始时被激活。</p><p>准备阶段终于是告一段落了，接下来让我们短暂地回到最开始的<i><font color="Green">Win32Application::Run</font></i>函数，现在我们已经分析完了<i><font color="Green">OnInit</font></i>函数，可以看到接下来就是主渲染循环了。该循环中系统会反复触发<i><font color="Red">WM_PAINT</font></i>信号，回调函数处理该信号的方式是先后调用应用程序类的<i><font color="Green">OnUpdate</font></i>和<i><font color="Green">OnRender</font></i>函数，那接下来就来依次分析这两个函数的代码。</p><hr><h2 id="onupdate">OnUpdate</h2><p>该函数用于更新每一帧有关的资源，其代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Update frame-based values.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::OnUpdate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    m_timer.<span class="hljs-built_in">Tick</span>(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">PIXSetMarker</span>(m_commandQueue.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;Getting last completed fence.&quot;</span>);<br><br>    <span class="hljs-comment">// Get current GPU progress against submitted workload. Resources still scheduled </span><br>    <span class="hljs-comment">// for GPU execution cannot be modified or else undefined behavior will result.</span><br>    <span class="hljs-type">const</span> UINT64 lastCompletedFence = m_fence-&gt;<span class="hljs-built_in">GetCompletedValue</span>();<br><br>    <span class="hljs-comment">// Move to the next frame resource.</span><br>    m_currentFrameResourceIndex = (m_currentFrameResourceIndex + <span class="hljs-number">1</span>) % FrameCount;<br>    m_pCurrentFrameResource = m_frameResources[m_currentFrameResourceIndex];<br><br>    <span class="hljs-comment">// Make sure that this frame resource isn&#x27;t still in use by the GPU.</span><br>    <span class="hljs-comment">// If it is, wait for it to complete.</span><br>    <span class="hljs-keyword">if</span> (m_pCurrentFrameResource-&gt;m_fenceValue &gt; lastCompletedFence)<br>    &#123;<br>        HANDLE eventHandle = <span class="hljs-built_in">CreateEvent</span>(<span class="hljs-literal">nullptr</span>, FALSE, FALSE, <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">if</span> (eventHandle == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">HRESULT_FROM_WIN32</span>(<span class="hljs-built_in">GetLastError</span>()));<br>        &#125;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_fence-&gt;<span class="hljs-built_in">SetEventOnCompletion</span>(m_pCurrentFrameResource-&gt;m_fenceValue, eventHandle));<br>        <span class="hljs-built_in">WaitForSingleObject</span>(eventHandle, INFINITE);<br>        <span class="hljs-built_in">CloseHandle</span>(eventHandle);<br>    &#125;<br><br>    m_cpuTimer.<span class="hljs-built_in">Tick</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">float</span> frameTime = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(m_timer.<span class="hljs-built_in">GetElapsedSeconds</span>());<br>    <span class="hljs-type">float</span> frameChange = <span class="hljs-number">2.0f</span> * frameTime;<br><br>    <span class="hljs-keyword">if</span> (m_keyboardInput.leftArrowPressed)<br>        m_camera.<span class="hljs-built_in">RotateYaw</span>(-frameChange);<br>    <span class="hljs-keyword">if</span> (m_keyboardInput.rightArrowPressed)<br>        m_camera.<span class="hljs-built_in">RotateYaw</span>(frameChange);<br>    <span class="hljs-keyword">if</span> (m_keyboardInput.upArrowPressed)<br>        m_camera.<span class="hljs-built_in">RotatePitch</span>(frameChange);<br>    <span class="hljs-keyword">if</span> (m_keyboardInput.downArrowPressed)<br>        m_camera.<span class="hljs-built_in">RotatePitch</span>(-frameChange);<br><br>    <span class="hljs-keyword">if</span> (m_keyboardInput.animate)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NumLights; i++)<br>        &#123;<br>            <span class="hljs-type">float</span> direction = frameChange * <span class="hljs-built_in">pow</span>(<span class="hljs-number">-1.0f</span>, i);<br>            <span class="hljs-built_in">XMStoreFloat4</span>(&amp;m_lights[i].position, <span class="hljs-built_in">XMVector4Transform</span>(<span class="hljs-built_in">XMLoadFloat4</span>(&amp;m_lights[i].position), <span class="hljs-built_in">XMMatrixRotationY</span>(direction)));<br><br>            XMVECTOR eye = <span class="hljs-built_in">XMLoadFloat4</span>(&amp;m_lights[i].position);<br>            XMVECTOR at = <span class="hljs-built_in">XMVectorSet</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">8.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>);<br>            <span class="hljs-built_in">XMStoreFloat4</span>(&amp;m_lights[i].direction, <span class="hljs-built_in">XMVector3Normalize</span>(<span class="hljs-built_in">XMVectorSubtract</span>(at, eye)));<br>            XMVECTOR up = <span class="hljs-built_in">XMVectorSet</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>);<br>            m_lightCameras[i].<span class="hljs-built_in">Set</span>(eye, at, up);<br><br>            m_lightCameras[i].<span class="hljs-built_in">Get3DViewProjMatrices</span>(&amp;m_lights[i].view, &amp;m_lights[i].projection, <span class="hljs-number">90.0f</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(m_width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(m_height));<br>        &#125;<br>    &#125;<br><br>    m_pCurrentFrameResource-&gt;<span class="hljs-built_in">WriteConstantBuffers</span>(&amp;m_viewport, &amp;m_camera, m_lightCameras, m_lights);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的逻辑十分简单：首先等待当前帧的所有帧资源被GPU使用完毕，这是通过判断当前帧的栅栏值是否大于<code>m_fence-&gt;GetCompletedValue()</code>得到的栅栏值来实现的，如果大于意味着GPU端还没有执行到这个栅栏点，因此需要在CPU端等待GPU执行完毕才能继续更新当前帧资源。如果读者对栅栏的使用不是十分了解的话，建议阅读龙书的初始化章节。</p><p>在GPU端执行完毕之后，程序就可以更新帧资源了，本示例中需要更新的资源只有传递给shadow pass的常量缓冲区中的灯光信息（前提是打开了<code>animate</code>选项），虽说代码中有处理键盘输入的逻辑，但之前我们也看到了，示例为了简单起见将键盘输入处理函数体设置为空，所以实际上这部分并没有发生任何更新。</p><hr><h2 id="onrender">OnRender</h2><p>这就是真正提交渲染命令的函数了，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Render the scene.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::OnRender</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-built_in">BeginFrame</span>();<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> SINGLETHREADED</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NumContexts; i++)<br>        &#123;<br>            <span class="hljs-built_in">WorkerThread</span>(i);<br>        &#125;<br>        <span class="hljs-built_in">MidFrame</span>();<br>        <span class="hljs-built_in">EndFrame</span>();<br>        m_commandQueue-&gt;<span class="hljs-built_in">ExecuteCommandLists</span>(_countof(m_pCurrentFrameResource-&gt;m_batchSubmit), m_pCurrentFrameResource-&gt;m_batchSubmit);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NumContexts; i++)<br>        &#123;<br>            <span class="hljs-built_in">SetEvent</span>(m_workerBeginRenderFrame[i]); <span class="hljs-comment">// Tell each worker to start drawing.</span><br>        &#125;<br><br>        <span class="hljs-built_in">MidFrame</span>();<br>        <span class="hljs-built_in">EndFrame</span>();<br><br>        <span class="hljs-built_in">WaitForMultipleObjects</span>(NumContexts, m_workerFinishShadowPass, TRUE, INFINITE);<br><br>        <span class="hljs-comment">// You can execute command lists on any thread. Depending on the work </span><br>        <span class="hljs-comment">// load, apps can choose between using ExecuteCommandLists on one thread </span><br>        <span class="hljs-comment">// vs ExecuteCommandList from multiple threads.</span><br>        m_commandQueue-&gt;<span class="hljs-built_in">ExecuteCommandLists</span>(NumContexts + <span class="hljs-number">2</span>, m_pCurrentFrameResource-&gt;m_batchSubmit); <span class="hljs-comment">// Submit PRE, MID and shadows.</span><br><br>        <span class="hljs-built_in">WaitForMultipleObjects</span>(NumContexts, m_workerFinishedRenderFrame, TRUE, INFINITE);<br><br>        <span class="hljs-comment">// Submit remaining command lists.</span><br>        m_commandQueue-&gt;<span class="hljs-built_in">ExecuteCommandLists</span>(_countof(m_pCurrentFrameResource-&gt;m_batchSubmit) - NumContexts - <span class="hljs-number">2</span>, m_pCurrentFrameResource-&gt;m_batchSubmit + NumContexts + <span class="hljs-number">2</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        m_cpuTimer.<span class="hljs-built_in">Tick</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span> (m_titleCount == TitleThrottle)<br>        &#123;<br>            WCHAR cpu[<span class="hljs-number">64</span>];<br>            <span class="hljs-built_in">swprintf_s</span>(cpu, <span class="hljs-string">L&quot;%.4f CPU&quot;</span>, m_cpuTime / m_titleCount);<br>            <span class="hljs-built_in">SetCustomWindowText</span>(cpu);<br><br>            m_titleCount = <span class="hljs-number">0</span>;<br>            m_cpuTime = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            m_titleCount++;<br>            m_cpuTime += m_cpuTimer.<span class="hljs-built_in">GetElapsedSeconds</span>() * <span class="hljs-number">1000</span>;<br>            m_cpuTimer.<span class="hljs-built_in">ResetElapsedTime</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// Present and update the frame index for the next frame.</span><br>        <span class="hljs-built_in">PIXBeginEvent</span>(m_commandQueue.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;Presenting to screen&quot;</span>);<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_swapChain-&gt;<span class="hljs-built_in">Present</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-built_in">PIXEndEvent</span>(m_commandQueue.<span class="hljs-built_in">Get</span>());<br>        m_frameIndex = m_swapChain-&gt;<span class="hljs-built_in">GetCurrentBackBufferIndex</span>();<br><br>        <span class="hljs-comment">// Signal and increment the fence value.</span><br>        m_pCurrentFrameResource-&gt;m_fenceValue = m_fenceValue;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_commandQueue-&gt;<span class="hljs-built_in">Signal</span>(m_fence.<span class="hljs-built_in">Get</span>(), m_fenceValue));<br>        m_fenceValue++;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (HrException&amp; e)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">Error</span>() == DXGI_ERROR_DEVICE_REMOVED || e.<span class="hljs-built_in">Error</span>() == DXGI_ERROR_DEVICE_RESET)<br>        &#123;<br>            <span class="hljs-built_in">RestoreD3DResources</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">throw</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数的开头使用<i><font color="Green">BeginFrame</font></i>进行渲染前的一些准备工作，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Assemble the CommandListPre command list.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::BeginFrame</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    m_pCurrentFrameResource-&gt;<span class="hljs-built_in">Init</span>();<br><br>    <span class="hljs-comment">// Indicate that the back buffer will be used as a render target.</span><br>    m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;<span class="hljs-built_in">ResourceBarrier</span>(<span class="hljs-number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="hljs-built_in">Transition</span>(m_renderTargets[m_frameIndex].<span class="hljs-built_in">Get</span>(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));<br><br>    <span class="hljs-comment">// Clear the render target and depth stencil.</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> clearColor[] = &#123; <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span> &#125;;<br>    <span class="hljs-function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="hljs-title">rtvHandle</span><span class="hljs-params">(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize)</span></span>;<br>    m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;<span class="hljs-built_in">ClearRenderTargetView</span>(rtvHandle, clearColor, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>    m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;<span class="hljs-built_in">ClearDepthStencilView</span>(m_dsvHeap-&gt;<span class="hljs-built_in">GetCPUDescriptorHandleForHeapStart</span>(), D3D12_CLEAR_FLAG_DEPTH, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-built_in">ThrowIfFailed</span>(m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;<span class="hljs-built_in">Close</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，该函数会先初始化帧资源，帧资源初始化函数<i><font color="Green">Init</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FrameResource::Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Reset the command allocators and lists for the main thread.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CommandListCount; i++)<br>    &#123;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_commandAllocators[i]-&gt;<span class="hljs-built_in">Reset</span>());<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_commandLists[i]-&gt;<span class="hljs-built_in">Reset</span>(m_commandAllocators[i].<span class="hljs-built_in">Get</span>(), m_pipelineState.<span class="hljs-built_in">Get</span>()));<br>    &#125;<br><br>    <span class="hljs-comment">// Clear the depth stencil buffer in preparation for rendering the shadow map.</span><br>    m_commandLists[CommandListPre]-&gt;<span class="hljs-built_in">ClearDepthStencilView</span>(m_shadowDepthView, D3D12_CLEAR_FLAG_DEPTH, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-comment">// Reset the worker command allocators and lists.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NumContexts; i++)<br>    &#123;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_shadowCommandAllocators[i]-&gt;<span class="hljs-built_in">Reset</span>());<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_shadowCommandLists[i]-&gt;<span class="hljs-built_in">Reset</span>(m_shadowCommandAllocators[i].<span class="hljs-built_in">Get</span>(), m_pipelineStateShadowMap.<span class="hljs-built_in">Get</span>()));<br><br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_sceneCommandAllocators[i]-&gt;<span class="hljs-built_in">Reset</span>());<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_sceneCommandLists[i]-&gt;<span class="hljs-built_in">Reset</span>(m_sceneCommandAllocators[i].<span class="hljs-built_in">Get</span>(), m_pipelineState.<span class="hljs-built_in">Get</span>()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数会负责重置该帧所有的命令列表和分配器。前面看到了在调用<i><font color="Green">OnUpdate</font></i>函数的时候会等待命令列表中的命令全部执行完毕，因此在GPU执行完命令分配器所引用的所有命令之后重置分配器是没有问题的。另外，该函数还会在<i><font color="Orange">CommandListPre</font></i>（也就是第一个命令列表）中录制好清除深度缓存的命令，因为首先开始的是shadow pass，此时的深度缓存应该是shadow map，它是帧资源，当然应该由帧资源的初始化函数负责清除工作。</p><p>回到<i><font color="Green">BeginFrame</font></i>函数，在重置帧资源命令列表之后，由于上一帧（指当前帧资源对应的上一帧，实际应该是前三帧）的后备缓冲区还处于显示布局，因此还应该将其转换回渲染目标布局，然后需要清除该缓冲区的颜色值，并且清除scene pass的深度缓冲区。这些命令全部录制在最开始的命令列表<i><font color="Orange">CommandListPre</font></i>中。</p><p>在做好准备工作之后，就可以设置<i><font color="Orange">m_workerBeginRenderFrame</font></i>事件为激活状态以开启各个线程的命令录制工作。接下来<i><font color="Green">OnRender</font></i>分别调用<i><font color="Green">MidFrame</font></i>和<i><font color="Green">EndFrame</font></i>函数来录制shadow pass与scene pass之间的命令以及scene pass结束之后的命令。先看<i><font color="Green">MidFrame</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Assemble the CommandListMid command list.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::MidFrame</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Transition our shadow map from the shadow pass to readable in the scene pass.</span><br>    m_pCurrentFrameResource-&gt;<span class="hljs-built_in">SwapBarriers</span>();<br><br>    <span class="hljs-built_in">ThrowIfFailed</span>(m_pCurrentFrameResource-&gt;m_commandLists[CommandListMid]-&gt;<span class="hljs-built_in">Close</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>首先调用帧资源类的<i><font color="Green">SwapBarrier</font></i>函数，其代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FrameResource::SwapBarriers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Transition the shadow map from writeable to readable.</span><br>    m_commandLists[CommandListMid]-&gt;<span class="hljs-built_in">ResourceBarrier</span>(<span class="hljs-number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="hljs-built_in">Transition</span>(m_shadowTexture.<span class="hljs-built_in">Get</span>(), D3D12_RESOURCE_STATE_DEPTH_WRITE, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到该函数的作用就是将shadow pass中用作深度缓冲的shadow map转换为可以作为scene pass的着色器可读资源的布局，这也是<i><font color="Orange">CommandListMid</font></i>中录制的唯一命令。接下来来看<i><font color="Green">EndFrame</font></i>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Assemble the CommandListPost command list.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::EndFrame</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    m_pCurrentFrameResource-&gt;<span class="hljs-built_in">Finish</span>();<br><br>    <span class="hljs-comment">// Indicate that the back buffer will now be used to present.</span><br>    m_pCurrentFrameResource-&gt;m_commandLists[CommandListPost]-&gt;<span class="hljs-built_in">ResourceBarrier</span>(<span class="hljs-number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="hljs-built_in">Transition</span>(m_renderTargets[m_frameIndex].<span class="hljs-built_in">Get</span>(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));<br><br>    <span class="hljs-built_in">ThrowIfFailed</span>(m_pCurrentFrameResource-&gt;m_commandLists[CommandListPost]-&gt;<span class="hljs-built_in">Close</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p><i><font color="Green">Finish</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FrameResource::Finish</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    m_commandLists[CommandListPost]-&gt;<span class="hljs-built_in">ResourceBarrier</span>(<span class="hljs-number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="hljs-built_in">Transition</span>(m_shadowTexture.<span class="hljs-built_in">Get</span>(), D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_DEPTH_WRITE));<br>&#125;<br></code></pre></td></tr></table></figure><p>它的作用是将shadow map的布局转变回可以写入深度的布局以便下一帧的shadow pass写入深度。<i><font color="Green">EndFrame</font></i>还负责将后备缓冲区布局转换为显示布局以便显示到屏幕上。</p><p>这样事实上该示例的所有命令都已经录制完毕了。在此之后<i><font color="Green">OnRender</font></i>会等待所有线程均录制完shadow pass所需的命令并激活相应的<i><font color="Orange">m_workerFinishShadowPass</font></i>事件，一旦所有线程均录制完成，就可以一并提交<i><font color="Orange">CommandListPre</font></i>、所有线程中用于录制shadow pass命令的命令列表以及<i><font color="Orange">CommandListMid</font></i>到命令队列执行。那么这些不同列表之间的命令究竟是如何得到同步的呢？首先，<code>ExecuteCommandLists</code>可以提交一系列的命令列表，这些命令列表一定会按照提交的顺序开始执行，也就是说后提交的命令一定会等到先提交的命令开始执行了才开始执行，但是注意，这并不意味着后提交的命令一定会后于先提交的命令完成，这些命令的完成顺序仍然是未知的。这也就是说，<i><font color="Orange">CommandListMid</font></i>中录制的命令一定会晚于shadow pass命令列表中的命令开始，而在<i><font color="Orange">CommandListMid</font></i>中代码仅仅是录制了一条借助资源屏障的shadow map布局转换命令，但是资源屏障本身就是具有同步的作用的。具体来说，资源屏障可以保证位于资源屏障之前录制的命令一定在执行到资源屏障命令之前完成，同样的，录制在资源屏障命令之后的命令一定会等待资源屏障命令执行完毕之后才会开始执行，因此，命令列表的提交顺序保证了shadow pass的命令是在资源屏障命令之前录制的，而资源屏障本身又保证了shadow pass中的命令一定会在后续命令开始之前完成，这样就完成了资源的同步，保证后续scene pass可以使用到正确布局且并未被GPU占用的资源。</p><p>接下来<i><font color="Green">OnRender</font></i>同样会等待所有线程的<i><font color="Orange">m_workerFinishedRenderFrame</font></i>事件被激活，这意味着scene pass的命令录制已经全部完成，那么就可以将scene pass的所有线程命令列表以及最后的<i><font color="Orange">CommandListEnd</font></i>一并提交到命令队列执行。同样，<i><font color="Orange">CommandListMid</font></i>中使用的资源屏障保证了scene pass的渲染命令一定会在shadow map完成了布局转换之后执行，而<i><font color="Orange">CommandListEnd</font></i>中使用的资源布局保证了scene pass的渲染操作能够在显示渲染结果之前完成。</p><p>然后就是一些计时有关的操作，这里不做详细分析。最后，<i><font color="Green">OnRender</font></i>还需要更新保存的当前帧索引<i><font color="Orange">m_frameIndex</font></i>（由于已经调用了<code>Present</code>函数，因此当前后备缓冲区已经发生了更新，所以直接使用<code>GetCurrentBackBufferIndex</code>就可以获取当前帧索引）。最后，函数激活并且增加栅栏值以供下一帧<i><font color="Orange">OnUpdate</font></i>进行同步的时候使用。</p><p>这样就完成了渲染循环的分析。整个代码的分析也基本结束了。在程序的最后还有资源销毁函数<i><font color="Green">OnDestroy</font></i>，销毁资源时唯一需要注意的是要等待GPU完成所有工作了再销毁程序资源。这里对该函数不做分析，仅放上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::OnDestroy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Ensure that the GPU is no longer referencing resources that are about to be</span><br>    <span class="hljs-comment">// cleaned up by the destructor.</span><br>    &#123;<br>        <span class="hljs-type">const</span> UINT64 fence = m_fenceValue;<br>        <span class="hljs-type">const</span> UINT64 lastCompletedFence = m_fence-&gt;<span class="hljs-built_in">GetCompletedValue</span>();<br><br>        <span class="hljs-comment">// Signal and increment the fence value.</span><br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_commandQueue-&gt;<span class="hljs-built_in">Signal</span>(m_fence.<span class="hljs-built_in">Get</span>(), m_fenceValue));<br>        m_fenceValue++;<br><br>        <span class="hljs-comment">// Wait until the previous frame is finished.</span><br>        <span class="hljs-keyword">if</span> (lastCompletedFence &lt; fence)<br>        &#123;<br>            <span class="hljs-built_in">ThrowIfFailed</span>(m_fence-&gt;<span class="hljs-built_in">SetEventOnCompletion</span>(fence, m_fenceEvent));<br>            <span class="hljs-built_in">WaitForSingleObject</span>(m_fenceEvent, INFINITE);<br>        &#125;<br>        <span class="hljs-built_in">CloseHandle</span>(m_fenceEvent);<br>    &#125;<br><br>    <span class="hljs-comment">// Close thread events and thread handles.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NumContexts; i++)<br>    &#123;<br>        <span class="hljs-built_in">CloseHandle</span>(m_workerBeginRenderFrame[i]);<br>        <span class="hljs-built_in">CloseHandle</span>(m_workerFinishShadowPass[i]);<br>        <span class="hljs-built_in">CloseHandle</span>(m_workerFinishedRenderFrame[i]);<br>        <span class="hljs-built_in">CloseHandle</span>(m_threadHandles[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; _countof(m_frameResources); i++)<br>    &#123;<br>        <span class="hljs-keyword">delete</span> m_frameResources[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样总算是理清了该示例的整体逻辑，也看到了多线程并发在实时渲染中的威力以及相应的复杂性，这也是现代图形API相对于古早API的一大优势，是现代图形API学习者所必须掌握的一环。</p><hr><h2 id="性能分析">性能分析</h2><p>最后我在官方代码的基础上添加了一个ImGui组件用于显示渲染帧率。关于在D3D12中ImGui的使用范例可以参考<a target="_blank" rel="noopener" href="https://github.com/ocornut/imgui/blob/master/examples/example_win32_directx12/main.cpp#L479"><code>ImGui官方示例</code></a>。</p><p>首先是为项目添加ImGui支持。本来只需要添加相应的文件到项目中来就好了。然而官方示例将文件<strong>stdafx.h</strong>进行了预编译（在项目属性的预编译头栏中可以看到），导致所有添加到项目中的源文件都必须include这个头文件，然而ImGui源文件里面肯定是不能直接添加一个include该头文件的指令的（自己也试了下，报一堆错，懒得分析了。。。），然而又必须得将ImGui相应的源文件添加到项目中来，不然会报错无法解析的外部符号（链接器找不到ImGui头文件里面函数的定义）。。。于是思来想去，我决定将需要使用到的ImGui文件编译为一个静态库然后链接到程序中去，并且在<strong>stdafx.h</strong>中添加对ImGui头文件的include指令，此问题得以解决。</p><p>然后就是绘制Gui了。这里我主要是参考的官方示例，不过略微改动了一下示例的<i><font color="Green">EndFrame</font></i>函数，将其中对渲染目标布局的转换命令挪到了之后执行的Gui绘制命令列表中进行录制，这是因为我们当然不希望在绘制Gui的时候渲染目标的布局已经变为显示布局了。下面放上我添加的Gui绘制相应代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::OnRender</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <br>    m_cpuTimer.<span class="hljs-built_in">Tick</span>(<span class="hljs-literal">NULL</span>);<br><br>	<span class="hljs-keyword">if</span> (m_titleCount == TitleThrottle)<br>	&#123;<br>  	  	WCHAR cpu[<span class="hljs-number">64</span>];<br>  	  	<span class="hljs-built_in">swprintf_s</span>(cpu, <span class="hljs-string">L&quot;%.4f CPU&quot;</span>, m_cpuTime / m_titleCount);<br>   	 	<span class="hljs-built_in">SetCustomWindowText</span>(cpu);<br><br>    	m_titleCount = <span class="hljs-number">0</span>;<br>    	m_cpuTime = <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>    	m_titleCount++;<br>    	m_cpuTime += m_cpuTimer.<span class="hljs-built_in">GetElapsedSeconds</span>() * <span class="hljs-number">1000</span>;<br>   	 	m_cpuTimer.<span class="hljs-built_in">ResetElapsedTime</span>();<br>	&#125;<br><br>    <span class="hljs-comment">//进行Gui的绘制</span><br>	<span class="hljs-built_in">ThrowIfFailed</span>(gui_commands-&gt;<span class="hljs-built_in">Reset</span>(m_commandAllocator.<span class="hljs-built_in">Get</span>(), <span class="hljs-literal">nullptr</span>));<br>	<span class="hljs-built_in">recordGui</span>();<br>	m_commandQueue-&gt;<span class="hljs-built_in">ExecuteCommandLists</span>(<span class="hljs-number">1</span>, submit_commands.<span class="hljs-built_in">GetAddressOf</span>());<br><br>	<span class="hljs-comment">// Present and update the frame index for the next frame.</span><br>	<span class="hljs-built_in">PIXBeginEvent</span>(m_commandQueue.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;Presenting to screen&quot;</span>);<br>	<span class="hljs-built_in">ThrowIfFailed</span>(m_swapChain-&gt;<span class="hljs-built_in">Present</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>	<span class="hljs-built_in">PIXEndEvent</span>(m_commandQueue.<span class="hljs-built_in">Get</span>());<br>	m_frameIndex = m_swapChain-&gt;<span class="hljs-built_in">GetCurrentBackBufferIndex</span>();<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::drawGui</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">ImGui_ImplDX12_NewFrame</span>();<br>    <span class="hljs-built_in">ImGui_ImplWin32_NewFrame</span>();<br>    ImGui::<span class="hljs-built_in">NewFrame</span>();<br><br>    ImGui::<span class="hljs-built_in">Begin</span>(<span class="hljs-string">&quot;Profiler&quot;</span>);<br>    <span class="hljs-type">float</span> frameTime = m_cpuTime / m_titleCount;<br>    ImGui::<span class="hljs-built_in">Text</span>(<span class="hljs-string">&quot;Frame Time:   %.4f ms/frame&quot;</span>, frameTime);<br>    ImGui::<span class="hljs-built_in">Text</span>(<span class="hljs-string">&quot;Framerate:   %.4f fps&quot;</span>, <span class="hljs-number">1000.0f</span> / frameTime);<br>    ImGui::<span class="hljs-built_in">End</span>();<br><br>    ImGui::<span class="hljs-built_in">Render</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::recordGui</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">drawGui</span>();<br>    <span class="hljs-function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="hljs-title">rtvHandle</span><span class="hljs-params">(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize)</span></span>;<br>    gui_commands-&gt;<span class="hljs-built_in">OMSetRenderTargets</span>(<span class="hljs-number">1</span>, &amp;rtvHandle, FALSE, <span class="hljs-literal">nullptr</span>);<br>    gui_commands-&gt;<span class="hljs-built_in">SetDescriptorHeaps</span>(<span class="hljs-number">1</span>, gui_heap.<span class="hljs-built_in">GetAddressOf</span>());<br>    <span class="hljs-built_in">ImGui_ImplDX12_RenderDrawData</span>(ImGui::<span class="hljs-built_in">GetDrawData</span>(), gui_commands.<span class="hljs-built_in">Get</span>());<br>    gui_commands-&gt;<span class="hljs-built_in">ResourceBarrier</span>(<span class="hljs-number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="hljs-built_in">Transition</span>(m_renderTargets[m_frameIndex].<span class="hljs-built_in">Get</span>(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));<br>    gui_commands-&gt;<span class="hljs-built_in">Close</span>();<br><br>    submit_commands = gui_commands.<span class="hljs-built_in">Get</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>Gui的初始化部分和官方示例基本一致，这里就没有给出相应的代码部分了。</p><p>最后，来对比一下使用单线程和多线程渲染的帧率：</p><figure><img src="/2025/03/07/CG_api/d3d12/directX_samples/D3D12Multithreading/single.png" srcset="/img/loading.gif" lazyload alt="单线程"><figcaption aria-hidden="true">单线程</figcaption></figure><figure><img src="/2025/03/07/CG_api/d3d12/directX_samples/D3D12Multithreading/multi.png" srcset="/img/loading.gif" lazyload alt="多线程"><figcaption aria-hidden="true">多线程</figcaption></figure><p>可以看到在本示例中多线程渲染的帧率在我的电脑上几乎是单线程帧率的两倍，该示例还是比较简单的场景，更为复杂的场景或许使用多线程渲染会有更加显著的性能提升，多线程渲染在实时渲染中的作用可见一斑。</p><hr></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/CG-api/" class="category-chain-item">CG_api</a> <span>></span> <a href="/categories/CG-api/d3d12/" class="category-chain-item">d3d12</a> <span>></span> <a href="/categories/CG-api/d3d12/DirectX-samples/" class="category-chain-item">DirectX_samples</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>post</div><div>http://example.com/2025/03/07/CG_api/d3d12/directX_samples/D3D12Multithreading/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>ZPC-dsg</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年3月7日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/2025/02/27/CG_api/vulkan/vulkan_samples/ray_tracing_basic/" title="Ray tracing basic"><span class="hidden-mobile">Ray tracing basic</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>