<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/icon/mikuicon.jpg"><link rel="icon" href="/images/icon/mikuicon.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="ZPC-dsg"><meta name="keywords" content=""><meta name="description" content="前言 所谓Multi draw indirect（多重间接绘制，下文简称mdi），指的是改变从CPU上传绘制命令的绘制参数到GPU进行绘制的方式，改为将绘制参数储存在GPU缓冲区中，绘制命令调用的时候直接从该缓冲区提取绘制参数信息。使用mdi有如下几点好处：  所有绘制物体的顶点和索引可以放在同一个顶点和索引缓冲区中，只需要绑定顶点缓冲区和索引缓冲区一次就可以进行所有绘制，无需像普通的绘制"><meta property="og:type" content="article"><meta property="og:title" content="post"><meta property="og:url" content="http://example.com/2025/02/23/CG_api/vulkan/vulkan_samples/multi_draw_indirect/index.html"><meta property="og:site_name" content="ZPC の Blog"><meta property="og:description" content="前言 所谓Multi draw indirect（多重间接绘制，下文简称mdi），指的是改变从CPU上传绘制命令的绘制参数到GPU进行绘制的方式，改为将绘制参数储存在GPU缓冲区中，绘制命令调用的时候直接从该缓冲区提取绘制参数信息。使用mdi有如下几点好处：  所有绘制物体的顶点和索引可以放在同一个顶点和索引缓冲区中，只需要绑定顶点缓冲区和索引缓冲区一次就可以进行所有绘制，无需像普通的绘制"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/images/textbg/CG_api/vk_sample_mdi.jpg"><meta property="article:published_time" content="2025-02-23T08:11:50.000Z"><meta property="article:modified_time" content="2025-02-27T08:46:57.095Z"><meta property="article:author" content="ZPC-dsg"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/images/textbg/CG_api/vk_sample_mdi.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>post - ZPC の Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:"measurement_id:G-X8N3TZCB57",tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>ZPC の Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/images/textbg/CG_api/vk_sample_mdi.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="post"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> ZPC-dsg </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-02-23 16:11" pubdate>2025年2月23日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 12k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 97 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">post</h1><div class="markdown-body"><h2 id="前言">前言</h2><p>所谓<strong>Multi draw indirect</strong>（多重间接绘制，下文简称mdi），指的是改变从CPU上传绘制命令的绘制参数到GPU进行绘制的方式，改为将绘制参数储存在GPU缓冲区中，绘制命令调用的时候直接从该缓冲区提取绘制参数信息。使用mdi有如下几点好处：</p><ul><li>所有绘制物体的顶点和索引可以放在同一个顶点和索引缓冲区中，只需要绑定顶点缓冲区和索引缓冲区一次就可以进行所有绘制，无需像普通的绘制调用一样，不同物体的绘制需要反复绑定具有新的顶点缓冲和输入布局的管线对象。</li><li>显著减少了资源的绑定次数，比如所有模型用到的纹理可以存储在一个纹理序列中供像素着色器通过实例索引来选择正确的纹理进行绘制，而无需像普通的绘制一样，每个物体需要各自绑定自己所需要的纹理等资源。</li><li>mdi在绘制参数中允许指定顶点和索引偏移，这就允许索引缓冲区在索引数目远多于<i><font color="Orange">uint_16</font></i>所能表示的最大数目的时候仍有可能使用<i><font color="Orange">uint_16</font></i>的索引格式（因为每个模型的索引值都可以从0开始指定，然后通过偏移索引到正确的顶点，只要每单个绘制模型的索引数小于<i><font color="Orange">uint_16</font></i>能表示的最大数目就行）。</li><li>一组draw call可以一次性被GPU执行，这显著减少了命令缓冲区的开销。</li></ul><p>Vulkan官方示例集的<a target="_blank" rel="noopener" href="https://docs.vulkan.org/samples/latest/samples/performance/multi_draw_indirect/README.html">文档</a>中给出了关于mdi的基本介绍，可以参考。</p><p>另外，mdi是<strong>GPU-driven-pipeline</strong>的一个重要环节，所谓<strong>GPU-driven-pipeline</strong>，简单来说就是将很多CPU做的工作放到GPU上执行。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/409244895?utm_psn=1877657433960222722">知乎大佬</a>的文章对这一块做了一个概要性的介绍，可以对<strong>GPU-driven-pipeline</strong>的基础流程有一个了解。</p><p>下面废话不多说，让我们进入到示例集源码的世界中探寻基本mdi功能的实现细节~。</p><hr><h2 id="特性拓展要求">特性拓展要求</h2><p>首先想要启用mdi，需要检查一些拓展和特性硬件是否支持。可以看到在<strong>multi_draw_indirect.h</strong>头文件中应用程序类<i><font color="Orange">MultiDrawIndirect</font></i>中有三个布尔成员：<i><font color="Orange">m_supports_mdi</font></i>、<i><font color="Orange">m_supports_first_instance</font></i>和<i><font color="Orange">m_supports_buffer_device</font></i>。</p><p>第一个成员显然用于标识硬件是否支持多重间接绘制，如果不支持的话，那么在调用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexedIndirect.html"><code>vkCmdDrawIndexedIndirect</code></a>的时候它的<code>drawCount</code>参数只能为0或1，这也就意味着我们只能对每个要绘制的实例单独调用一次<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexedIndirect.html"><code>vkCmdDrawIndexedIndirect</code></a>，而如果支持的话，那么就可以通过将<code>drawCount</code>指定为需要的绘制次数从而一次绘制调用绘制所有物体。</p><p>第二个成员用于决定mdi是否支持实例偏移，也就是在调用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexedIndirect.html"><code>vkCmdDrawIndexedIndirect</code></a>的时候指定<code>firstInstance</code>偏移值，如果不支持的话那么该参数只能取值为0，也就是不允许偏移。在官方示例中后续的绘制命令调用实际上直接默认该特性是支持的了，也不知道为什么。。。</p><p>最后一个成员决定硬件是否支持缓冲区地址，这会决定使用CS进行视锥剔除的时候结果会怎么写入存储绘制参数的缓冲区，这在后文分析GPU cull的时候会讲到。</p><p>最后来看一下代码是怎么填写这些布尔成员的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++">MultiDrawIndirect::<span class="hljs-built_in">MultiDrawIndirect</span>()<br>&#123;<br>	<span class="hljs-built_in">set_api_version</span>(VK_API_VERSION_1_2);<br>	<span class="hljs-built_in">add_device_extension</span>(VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME, <span class="hljs-literal">true</span> <span class="hljs-comment">/* optional */</span>);<br>&#125;<br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::request_gpu_features</span><span class="hljs-params">(vkb::PhysicalDevice &amp;gpu)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (gpu.<span class="hljs-built_in">get_features</span>().multiDrawIndirect)<br>	&#123;<br>		gpu.<span class="hljs-built_in">get_mutable_requested_features</span>().multiDrawIndirect = VK_TRUE;<br>		m_supports_mdi                                         = <span class="hljs-literal">true</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (gpu.<span class="hljs-built_in">get_features</span>().drawIndirectFirstInstance)<br>	&#123;<br>		gpu.<span class="hljs-built_in">get_mutable_requested_features</span>().drawIndirectFirstInstance = VK_TRUE;<br>		m_supports_first_instance                                      = <span class="hljs-literal">true</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// Query whether the device supports buffer device addresses</span><br>	m_supports_buffer_device =<br>	    <span class="hljs-built_in">REQUEST_OPTIONAL_FEATURE</span>(gpu, VkPhysicalDeviceVulkan12Features, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES, bufferDeviceAddress);<br><br>	<span class="hljs-comment">// This sample references 128 objects. We need to check whether this is supported by the device</span><br>	VkPhysicalDeviceProperties physical_device_properties;<br>	<span class="hljs-built_in">vkGetPhysicalDeviceProperties</span>(gpu.<span class="hljs-built_in">get_handle</span>(), &amp;physical_device_properties);<br><br>	<span class="hljs-keyword">if</span> (physical_device_properties.limits.maxPerStageDescriptorSamplers &lt; <span class="hljs-number">128</span>)<br>	&#123;<br>		<span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(fmt::format(<span class="hljs-built_in">FMT_STRING</span>(<span class="hljs-string">&quot;This sample requires at least 128 descriptor samplers, but device only supports &#123;:d&#125;&quot;</span>), physical_device_properties.limits.maxPerStageDescriptorSamplers));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于mdi和firstInstance，可以看到查询比较简单，只需要查询<a target="_blank" rel="noopener" href="https://docs.vulkan.org/spec/latest/chapters/features.html"><code>VkPhysicalDeviceFeatures</code></a>结构体就可以了，<code>multiDrawIndirect</code>和<code>drawIndirectFirstInstance</code>就是对应的我们希望查询的成员。只需要查询硬件是否支持，支持就启用然后把相应的布尔成员设置为true就可以了。而如果要查询硬件对buffer address的支持状态，我们还需要启用拓展<i><font color="Red">VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME</font></i>，然后才可以进行相应的查询。查询的时候，我们需要将<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVulkan12Features.html"><code>VkPhysicalDeviceVulkan12Features</code></a>传递给<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFeatures2.html"><code>VkPhysicalDeviceFeatures2</code></a>的pNext指针，然后交给<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures2.html"><code>vkGetPhysicalDeviceFeatures2</code></a>进行查询和结构体的填充工作即可。</p><p>最后要注意的是，由于我们准备将所有的纹理一起绑定成一个数组供像素着色器使用，所以最后还需要查询硬件是否支持在单阶段内绑定采样器数量大于128，如果不行的话那程序也无法运行。</p><p>在我的电脑上所有的这些布尔成员都会被设置为true。</p><hr><h2 id="准备阶段">准备阶段</h2><p>然后我们就来着重分析<i><font color="Orange">prepare</font></i>函数的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MultiDrawIndirect::prepare</span><span class="hljs-params">(<span class="hljs-type">const</span> vkb::ApplicationOptions &amp;options)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (!ApiVulkanSample::<span class="hljs-built_in">prepare</span>(options))<br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	camera.type = vkb::CameraType::FirstPerson;<br>	camera.<span class="hljs-built_in">set_perspective</span>(<span class="hljs-number">60.0f</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(width) / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(height), <span class="hljs-number">0.001f</span>, <span class="hljs-number">512.0f</span>);<br>	camera.<span class="hljs-built_in">set_rotation</span>(glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">-23.5</span>, <span class="hljs-number">-45</span>, <span class="hljs-number">0</span>));<br>	camera.<span class="hljs-built_in">set_translation</span>(glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">-0.2</span>));<br><br>	<span class="hljs-keyword">if</span> (!compute_queue)<br>	&#123;<br>		compute_queue = &amp;<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_by_flags</span>(VK_QUEUE_COMPUTE_BIT, <span class="hljs-number">0</span>);<br>	&#125;<br><br>	queue_families.<span class="hljs-built_in">clear</span>();<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;queue_bit : &#123;VK_QUEUE_GRAPHICS_BIT, VK_QUEUE_COMPUTE_BIT&#125;)<br>	&#123;<br>		<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> index = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_by_flags</span>(queue_bit, <span class="hljs-number">0</span>).<span class="hljs-built_in">get_family_index</span>();<br>		<span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">find</span>(queue_families.<span class="hljs-built_in">cbegin</span>(), queue_families.<span class="hljs-built_in">cend</span>(), index) == queue_families.<span class="hljs-built_in">cend</span>())<br>		&#123;<br>			queue_families.<span class="hljs-built_in">emplace_back</span>(index);<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-built_in">create_samplers</span>();<br>	<span class="hljs-built_in">load_scene</span>();<br>	<span class="hljs-built_in">initialize_resources</span>();<br>	<span class="hljs-built_in">update_scene_uniform</span>();<br>	<span class="hljs-built_in">create_pipeline</span>();<br>	<span class="hljs-built_in">create_compute_pipeline</span>();<br>	<span class="hljs-built_in">initialize_descriptors</span>();<br>	<span class="hljs-built_in">build_command_buffers</span>();<br>	<span class="hljs-built_in">cpu_cull</span>();        <span class="hljs-comment">// initialize buffer</span><br>	<span class="hljs-built_in">run_cull</span>();<br><br>	prepared = <span class="hljs-literal">true</span>;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先还是调用基类的准备函数，包括创建一些基础的同步量、交换链、命令缓冲等，这里不详细展开了。然后是设置好摄像机的模式和参数，并且申请到图形和计算队列的使用权，后续会提交命令到这两个队列中去。</p><p>接下来开始逐个分析下方一连串的函数调用：</p><h3 id="create_samplers">create_samplers</h3><p>先上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::create_samplers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	VkSamplerCreateInfo sampler_info = vkb::initializers::<span class="hljs-built_in">sampler_create_info</span>();<br>	sampler_info.magFilter           = VK_FILTER_LINEAR;<br>	sampler_info.minFilter           = VK_FILTER_LINEAR;<br>	sampler_info.mipmapMode          = VK_SAMPLER_MIPMAP_MODE_LINEAR;<br>	sampler_info.addressModeU        = VK_SAMPLER_ADDRESS_MODE_REPEAT;<br>	sampler_info.addressModeV        = VK_SAMPLER_ADDRESS_MODE_REPEAT;<br>	sampler_info.addressModeW        = VK_SAMPLER_ADDRESS_MODE_REPEAT;<br>	sampler_info.mipLodBias          = <span class="hljs-number">0.0f</span>;<br>	sampler_info.maxAnisotropy       = <span class="hljs-number">1.0f</span>;<br>	sampler_info.minLod              = <span class="hljs-number">0.0f</span>;<br>	sampler_info.maxLod              = <span class="hljs-number">1.0f</span>;<br>	sampler_info.borderColor         = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE;<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateSampler</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;sampler_info, <span class="hljs-literal">nullptr</span>, &amp;sampler_linear));<br><br>	<span class="hljs-comment">// Some formats don&#x27;t support linear filtering, so create a nearest filtered sampler as a fallback</span><br>	sampler_info.magFilter  = VK_FILTER_NEAREST;<br>	sampler_info.minFilter  = VK_FILTER_NEAREST;<br>	sampler_info.mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST;<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateSampler</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;sampler_info, <span class="hljs-literal">nullptr</span>, &amp;sampler_nearest));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这只是一个很简单的采样器创建操作，分别创建了两种采样器，一种使用线性过滤的方式进行采样，另一种使用最近过滤的方式进行采样，如果一些图像格式不支持线性过滤，那么就会使用最近过滤的采样器作为fallback。没什么需要多分析的了，继续继续~</p><h3 id="load_scene">load_scene</h3><p>同样先上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::load_scene</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">const</span> std::string scene_path = <span class="hljs-string">&quot;scenes/vokselia/&quot;</span>;<br>	ApiVulkanSample::<span class="hljs-built_in">load_scene</span>(scene_path + <span class="hljs-string">&quot;vokselia.gltf&quot;</span>);<br><br>	<span class="hljs-built_in">assert</span>(<span class="hljs-built_in">has_scene</span>());<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;mesh : <span class="hljs-built_in">get_scene</span>().<span class="hljs-built_in">get_components</span>&lt;vkb::sg::Mesh&gt;())<br>	&#123;<br>		<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> texture_index = textures.<span class="hljs-built_in">size</span>();<br>		<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>  &amp;short_name    = mesh-&gt;<span class="hljs-built_in">get_name</span>();<br>		<span class="hljs-keyword">auto</span>         image_name    = scene_path + short_name + <span class="hljs-string">&quot;.ktx&quot;</span>;<br>		<span class="hljs-keyword">auto</span>         image         = vkb::sg::Image::<span class="hljs-built_in">load</span>(image_name, image_name, vkb::sg::Image::Color);<br><br>		image-&gt;<span class="hljs-built_in">create_vk_image</span>(<span class="hljs-built_in">get_device</span>());<br>		Texture texture;<br>		texture.n_mip_maps = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(image-&gt;<span class="hljs-built_in">get_mipmaps</span>().<span class="hljs-built_in">size</span>());<br>		<span class="hljs-built_in">assert</span>(texture.n_mip_maps == <span class="hljs-number">1</span>);<br>		texture.image = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::Image&gt;(<span class="hljs-built_in">get_device</span>(),<br>		                                                   image-&gt;<span class="hljs-built_in">get_extent</span>(),<br>		                                                   image-&gt;<span class="hljs-built_in">get_format</span>(),<br>		                                                   VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT,<br>		                                                   VMA_MEMORY_USAGE_GPU_ONLY,<br>		                                                   VK_SAMPLE_COUNT_1_BIT,<br>		                                                   <span class="hljs-number">1</span>,<br>		                                                   <span class="hljs-number">1</span>,<br>		                                                   VK_IMAGE_TILING_OPTIMAL,<br>		                                                   <span class="hljs-number">0</span>);<br><br>		<span class="hljs-keyword">auto</span> data_buffer = vkb::core::BufferC::<span class="hljs-built_in">create_staging_buffer</span>(<span class="hljs-built_in">get_device</span>(), image-&gt;<span class="hljs-built_in">get_data</span>());<br><br>		<span class="hljs-keyword">auto</span> &amp;texture_cmd = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_command_pool</span>().<span class="hljs-built_in">request_command_buffer</span>();<br>		texture_cmd.<span class="hljs-built_in">begin</span>(VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, VK_NULL_HANDLE);<br><br>		VkImageSubresourceRange subresource_range = &#123;VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>		subresource_range.baseMipLevel            = <span class="hljs-number">0</span>;<br>		subresource_range.levelCount              = texture.n_mip_maps;<br><br>		vkb::<span class="hljs-built_in">image_layout_transition</span>(<br>		    texture_cmd.<span class="hljs-built_in">get_handle</span>(), texture.image-&gt;<span class="hljs-built_in">get_handle</span>(), VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, subresource_range);<br><br>		<span class="hljs-keyword">auto</span>              offsets              = image-&gt;<span class="hljs-built_in">get_offsets</span>();<br>		VkBufferImageCopy region               = &#123;&#125;;<br>		region.imageSubresource.aspectMask     = VK_IMAGE_ASPECT_COLOR_BIT;<br>		region.imageSubresource.mipLevel       = <span class="hljs-number">0</span>;<br>		region.imageSubresource.baseArrayLayer = <span class="hljs-number">0</span>;<br>		region.imageSubresource.layerCount     = <span class="hljs-number">1</span>;<br>		region.imageExtent                     = image-&gt;<span class="hljs-built_in">get_extent</span>();<br>		region.bufferOffset                    = offsets[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><br>		texture_cmd.<span class="hljs-built_in">copy_buffer_to_image</span>(data_buffer, *texture.image, &#123;region&#125;);<br>		texture_cmd.<span class="hljs-built_in">end</span>();<br><br>		<span class="hljs-keyword">auto</span> &amp;queue = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_by_flags</span>(VK_QUEUE_GRAPHICS_BIT, <span class="hljs-number">0</span>);<br>		queue.<span class="hljs-built_in">submit</span>(texture_cmd, <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">request_fence</span>());<br>		<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_fence_pool</span>().<span class="hljs-built_in">wait</span>();<br>		<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_fence_pool</span>().<span class="hljs-built_in">reset</span>();<br><br>		texture.image_view = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::ImageView&gt;(*texture.image, VK_IMAGE_VIEW_TYPE_2D);<br><br>		<span class="hljs-comment">// Get the properties for the image format. We&#x27;ll need to check whether a linear sampler is valid.</span><br>		<span class="hljs-type">const</span> VkFormatProperties fmtProps = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_format_properties</span>(image-&gt;<span class="hljs-built_in">get_format</span>());<br><br>		VkDescriptorImageInfo image_descriptor;<br>		image_descriptor.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;<br>		image_descriptor.imageView   = texture.image_view-&gt;<span class="hljs-built_in">get_handle</span>();<br>		image_descriptor.sampler     = (fmtProps.optimalTilingFeatures &amp; VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT) ?<br>		                                   sampler_linear :<br>		                                   sampler_nearest;<br>		image_descriptors.<span class="hljs-built_in">push_back</span>(image_descriptor);<br>		textures.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">move</span>(texture));<br><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;sub_mesh : mesh-&gt;<span class="hljs-built_in">get_submeshes</span>())<br>		&#123;<br>			SceneModel model;<br>			model.texture_index = texture_index;<br><br>			<span class="hljs-keyword">auto</span> pts = CopyBuffer&lt;glm::vec3&gt;&#123;&#125;(sub_mesh-&gt;vertex_buffers, <span class="hljs-string">&quot;position&quot;</span>);<br>			<span class="hljs-keyword">auto</span> uvs = CopyBuffer&lt;glm::vec2&gt;&#123;&#125;(sub_mesh-&gt;vertex_buffers, <span class="hljs-string">&quot;texcoord_0&quot;</span>);<br>			<span class="hljs-built_in">assert</span>(uvs.<span class="hljs-built_in">size</span>() == pts.<span class="hljs-built_in">size</span>());<br><br>			model.vertices.<span class="hljs-built_in">resize</span>(pts.<span class="hljs-built_in">size</span>());<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; pts.<span class="hljs-built_in">size</span>(); ++i)<br>			&#123;<br>				model.vertices[i].pt = &#123;pts[i].x, -pts[i].y, pts[i].z&#125;;<br>				model.vertices[i].uv = uvs[i];<br>			&#125;<br><br>			<span class="hljs-built_in">assert</span>(sub_mesh-&gt;index_type == VK_INDEX_TYPE_UINT16);<br>			<span class="hljs-keyword">auto</span> buffer = sub_mesh-&gt;index_buffer.<span class="hljs-built_in">get</span>();<br>			<span class="hljs-keyword">if</span> (buffer)<br>			&#123;<br>				<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> sz         = buffer-&gt;<span class="hljs-built_in">get_size</span>();<br>				<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> nTriangles = sz / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint16_t</span>) / <span class="hljs-number">3</span>;<br>				model.triangles.<span class="hljs-built_in">resize</span>(nTriangles);<br>				<span class="hljs-keyword">auto</span> ptr = buffer-&gt;<span class="hljs-built_in">get_data</span>();<br>				<span class="hljs-built_in">assert</span>(!!ptr);<br>				<span class="hljs-function">std::vector&lt;<span class="hljs-type">uint16_t</span>&gt; <span class="hljs-title">temp_buffer</span><span class="hljs-params">(nTriangles * <span class="hljs-number">3</span>)</span></span>;<br>				<span class="hljs-built_in">memcpy</span>(temp_buffer.<span class="hljs-built_in">data</span>(), ptr, nTriangles * <span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(temp_buffer[<span class="hljs-number">0</span>]));<br>				model.triangles.<span class="hljs-built_in">resize</span>(nTriangles);<br>				<span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; nTriangles; ++i)<br>				&#123;<br>					model.triangles[i] = &#123;<br>					    <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint16_t</span>&gt;(temp_buffer[<span class="hljs-number">3</span> * i]),<br>					    <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint16_t</span>&gt;(temp_buffer[<span class="hljs-number">3</span> * i + <span class="hljs-number">1</span>]),<br>					    <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint16_t</span>&gt;(temp_buffer[<span class="hljs-number">3</span> * i + <span class="hljs-number">2</span>])&#125;;<br>				&#125;<br>			&#125;<br>			model.bounding_sphere = <span class="hljs-built_in">BoundingSphere</span>(pts);<br>			models.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">move</span>(model));<br>		&#125;<br>	&#125;<br><br>	std::vector&lt;std::pair&lt;VkImage, VkImageSubresourceRange&gt;&gt; imagesAndRanges;<br>	imagesAndRanges.<span class="hljs-built_in">reserve</span>(textures.<span class="hljs-built_in">size</span>());<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> &amp;texture : textures)<br>	&#123;<br>		imagesAndRanges.<span class="hljs-built_in">emplace_back</span>(<br>		    std::<span class="hljs-built_in">make_pair</span>(texture.image-&gt;<span class="hljs-built_in">get_handle</span>(), VkImageSubresourceRange&#123;VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">0</span>, texture.n_mip_maps, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;));<br>	&#125;<br><br>	<span class="hljs-keyword">auto</span> &amp;cmd = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_command_pool</span>().<span class="hljs-built_in">request_command_buffer</span>();<br>	cmd.<span class="hljs-built_in">begin</span>(VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, VK_NULL_HANDLE);<br>	vkb::<span class="hljs-built_in">image_layout_transition</span>(cmd.<span class="hljs-built_in">get_handle</span>(), imagesAndRanges, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);<br>	cmd.<span class="hljs-built_in">end</span>();<br>	<span class="hljs-keyword">auto</span> &amp;queue = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_by_flags</span>(VK_QUEUE_GRAPHICS_BIT, <span class="hljs-number">0</span>);<br>	queue.<span class="hljs-built_in">submit</span>(cmd, <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">request_fence</span>());<br>	<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_fence_pool</span>().<span class="hljs-built_in">wait</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这就比较冗长了，让我们耐下心来逐行分析吧。</p><p>首先需要将场景模型给加载到程序中来，使用工具函数<i><font color="Green">load_scene</font></i>即可完成加载。这里我们并不会具体分析这个加载函数的代码，对于这些框架类代码的分析会留待日后进行，这里我们只需要知道加载进来的模型包含了很多信息，包括我们需要使用的<code>mesh</code>信息，其中每个<code>mesh</code>又是由很多许多<code>submesh</code>所组成的。<code>mesh</code>中包含了名称、纹理名称等众多信息，顶点、索引等信息则存储在每一个<code>submesh</code>中。</p><p><i><font color="Green">load_scene</font></i>用一个循环来处理模型所有的mesh，首先通过mesh存储的纹理名确定它的存储路径，并使用<i><font color="Green">create_vk_image</font></i>工具函数将纹理数据创建为一个Vulkan图像对象。<i><font color="Green">create_vk_image</font></i>就是一个简单的<code>VkImage</code>和相应的<code>VkImageView</code>创建函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Image::create_vk_image</span><span class="hljs-params">(Device &amp;device, VkImageViewType image_view_type, VkImageCreateFlags flags)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">assert</span>(!vk_image &amp;&amp; !vk_image_view &amp;&amp; <span class="hljs-string">&quot;Vulkan image already constructed&quot;</span>);<br><br>	vk_image = std::<span class="hljs-built_in">make_unique</span>&lt;core::Image&gt;(device,<br>	                                         <span class="hljs-built_in">get_extent</span>(),<br>	                                         format,<br>	                                         VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT,<br>	                                         VMA_MEMORY_USAGE_GPU_ONLY,<br>	                                         VK_SAMPLE_COUNT_1_BIT,<br>	                                         <span class="hljs-built_in">to_u32</span>(mipmaps.<span class="hljs-built_in">size</span>()),<br>	                                         layers,<br>	                                         VK_IMAGE_TILING_OPTIMAL,<br>	                                         flags);<br>	vk_image-&gt;<span class="hljs-built_in">set_debug_name</span>(<span class="hljs-built_in">get_name</span>());<br><br>	vk_image_view = std::<span class="hljs-built_in">make_unique</span>&lt;core::ImageView&gt;(*vk_image, image_view_type);<br>	vk_image_view-&gt;<span class="hljs-built_in">set_debug_name</span>(<span class="hljs-string">&quot;View on &quot;</span> + <span class="hljs-built_in">get_name</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>然后代码将为该Image对象创建一个<code>Texture</code>结构体中，并一并保存到<i><font color="Orange">textures</font></i>向量中以构建完整的纹理数组。<code>Texture</code>结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Texture</span><br>&#123;<br>	std::unique_ptr&lt;vkb::core::Image&gt;     image;<br>	std::unique_ptr&lt;vkb::core::ImageView&gt; image_view;<br>	<span class="hljs-type">uint32_t</span>                              n_mip_maps;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可见我们需要填充构成该纹理的图像、视图和mipmap等级。程序中会验证所有的纹理mipmap等级都为1，然后使用一个staging buffer，将<i><font color="Orange">image</font></i>中的图像数据传递到<code>Texture</code>结构体的<i><font color="Orange">image</font></i>成员中（<code>vkb::sg::Image</code>类将构建该图像的数据信息保存在私有成员<i><font color="Orange">std::vector<uint_8>data</uint_8></font></i>中，通过<i><font color="Green">get_data</font></i>成员函数获取）。当然，在将staging buffer中的数据copy到纹理对象<i><font color="Orange">texture.image</font></i>之前，我们还需要对<i><font color="Orange">texture.image</font></i>进行图像布局的转换，因为图像刚创建的时候其布局是未定义的。关于布局转换有关的基础内容可以参考我之前的博客中对Vulkan Tutorial对应内容的<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/12/12/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F/"><code>翻译和理解</code></a>。为了进行布局的转换和数据的复制，我们需要启动一个command buffer来录制有关命令并提交给队列执行。这部分代码中的<i><font color="Green">image_layout_transition</font></i>和<i><font color="Green">copy_buffer_to_image</font></i>函数就是封装了对应的布局转换和复制数据过程，其中布局转换就是通过一个<code>VkImageMemoryBarrier</code>来实现，而数据复制则通过调用<code>VkCmdCopyBufferToImage</code>来完成。再录制好相关命令之后，只需提交到图形队列执行，然后在CPU端等待所有操作执行完毕即可。在创建好了图像之后图像视图也就直接在此基础上创建即可。</p><p>纹理对象创建完毕了，但为了使用纹理资源我们需要创建相应的描述符才行。于是代码在创建好<i><font color="Orange">texture</font></i>后马上填写该纹理对应的描述符信息，并且通过查询该纹理图像的格式来决定该纹理能否使用线性过滤的采样器。填写好的<code>VkDescriptorImageInfo</code>同样放进应用程序类的一个向量成员<i><font color="Orange">image_descriptors</font></i>中供后续真正创建和绑定描述符的时候使用。</p><p>在完成了对<code>mesh</code>的纹理的储存之后，还需要提取出每个<code>submesh</code>的顶点和索引信息，每个<code>submesh</code>的顶点和索引信息都会保存在<code>SceneModel</code>结构体中，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SceneModel</span><br>&#123;<br>	std::vector&lt;Vertex&gt;                  vertices;<br>	std::vector&lt;std::array&lt;<span class="hljs-type">uint16_t</span>, 3&gt;&gt; triangles;<br>	<span class="hljs-type">size_t</span>                               vertex_buffer_offset = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">size_t</span>                               index_buffer_offset  = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">size_t</span>                               texture_index        = <span class="hljs-number">0</span>;<br>	BoundingSphere                       bounding_sphere;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看见，我们需要填写的信息包括顶点信息，顶点所构成的三角形的索引信息，顶点在最终构建的所有模型的顶点缓冲中的偏移以及索引的偏移，该<code>submesh</code>使用的纹理索引（后续像素着色器也就是通过这个值来索引纹理数组中的纹理）以及该<code>submesh</code>的包围球（用于视锥剔除），其中<code>Vertex</code>结构体和<code>BoundingSphere</code>结构体分别定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vertex</span><br>&#123;<br>	glm::vec3 pt;<span class="hljs-comment">//位置向量</span><br>	glm::vec2 uv;<span class="hljs-comment">//纹理坐标</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BoundingSphere</span><br>&#123;<br>	<span class="hljs-built_in">BoundingSphere</span>() = <span class="hljs-keyword">default</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">BoundingSphere</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;glm::vec3&gt; &amp;pts)</span></span>;<br>	glm::vec3 center = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>	<span class="hljs-type">float</span>     radius = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>来看代码对每个<code>submesh</code>对应的<code>SceneModel</code>的填写逻辑：首先是填写纹理索引，这就是当前<code>mesh</code>对应的索引。然后从<code>submesh</code>中提取出位置和纹理坐标信息，构成顶点后填入到<code>SceneModel</code>内。这个信息的提取过程是通过应用程序类附带的一个工具函数对象类<code>CopyBuffer</code>实现的，其代码也非常直观（其实就是一个简单的内存复制<code>memcpy</code>操作），放在下方：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CopyBuffer</span><br>&#123;<br>	<span class="hljs-function">std::vector&lt;T&gt; <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(std::unordered_map&lt;std::string, vkb::core::BufferC&gt; &amp;buffers, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *bufferName)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">auto</span> iter = buffers.<span class="hljs-built_in">find</span>(bufferName);<br>		<span class="hljs-keyword">if</span> (iter == buffers.<span class="hljs-built_in">cend</span>())<br>		&#123;<br>			<span class="hljs-keyword">return</span> &#123;&#125;;<br>		&#125;<br>		<span class="hljs-keyword">auto</span>          &amp;buffer = iter-&gt;second;<br>		std::vector&lt;T&gt; out;<br><br>		<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> sz = buffer.<span class="hljs-built_in">get_size</span>();<br>		out.<span class="hljs-built_in">resize</span>(sz / <span class="hljs-built_in">sizeof</span>(T));<br>		<span class="hljs-type">const</span> <span class="hljs-type">bool</span> alreadyMapped = buffer.<span class="hljs-built_in">get_data</span>() != <span class="hljs-literal">nullptr</span>;<br>		<span class="hljs-keyword">if</span> (!alreadyMapped)<br>		&#123;<br>			buffer.<span class="hljs-built_in">map</span>();<br>		&#125;<br>		<span class="hljs-built_in">memcpy</span>(&amp;out[<span class="hljs-number">0</span>], buffer.<span class="hljs-built_in">get_data</span>(), sz);<br>		<span class="hljs-keyword">if</span> (!alreadyMapped)<br>		&#123;<br>			buffer.<span class="hljs-built_in">unmap</span>();<br>		&#125;<br>		<span class="hljs-keyword">return</span> out;<br>	&#125;<br>&#125;;<br><br>&#125;        <span class="hljs-comment">// namespace</span><br></code></pre></td></tr></table></figure><p>然后再来处理三角形索引信息，这个逻辑也非常直观，这里不再赘述。最后根据该<code>submesh</code>的所有顶点位置创建相应的包围球，相应的创建逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">BoundingSphere</span>(<span class="hljs-type">const</span> std::vector&lt;glm::vec3&gt; &amp;pts)<br>&#123;<br>	<span class="hljs-keyword">if</span> (pts.<span class="hljs-built_in">empty</span>())<br>	&#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// This is a simple method of calculating a bounding sphere.</span><br>	<span class="hljs-comment">// For finding an optimal bounding sphere, see Welzl&#x27;s algorithm</span><br>	<span class="hljs-keyword">this</span>-&gt;center = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;pt : pts)<br>	&#123;<br>		<span class="hljs-keyword">this</span>-&gt;center += pt;<br>	&#125;<br>	<span class="hljs-keyword">this</span>-&gt;center /= <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(pts.<span class="hljs-built_in">size</span>());<br>	<span class="hljs-keyword">this</span>-&gt;radius = glm::<span class="hljs-built_in">distance2</span>(pts[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>-&gt;center);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">1</span>; i &lt; pts.<span class="hljs-built_in">size</span>(); ++i)<br>	&#123;<br>		<span class="hljs-keyword">this</span>-&gt;radius = std::<span class="hljs-built_in">max</span>(<span class="hljs-keyword">this</span>-&gt;radius, glm::<span class="hljs-built_in">distance2</span>(pts[i], <span class="hljs-keyword">this</span>-&gt;center));<br>	&#125;<br>	<span class="hljs-keyword">this</span>-&gt;radius = std::<span class="hljs-built_in">nextafter</span>(<span class="hljs-built_in">sqrtf</span>(<span class="hljs-keyword">this</span>-&gt;radius), std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">max</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>可见创建的过程其实就是取所有顶点的平均点（也可以说是它们的重心）为包围球的中心，半径就是该中心点到所有点的最远距离。这是一种简单的创建包围球的思路。这里解释一下<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/numeric/math/nextafter"><code>std::nextafter</code></a>，它的作用其实就是在浮点数之间找到下一个可表示的值。它通常用于数值计算中，以便在浮点数的精度范围内进行微小的增量调整。</p><p>在完成所有<code>mesh</code>信息的存储工作之后，最终我们还需要将所有之前创建的纹理对象的布局从之前的<i><font color="Red">VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</font></i>转换为<i><font color="Red">VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</font></i>以方便后续像素着色器对它们的读取。这样就完成了整个<i><font color="Green">load_scene</font></i>的工作。</p><h3 id="initialize_resources">initialize_resources</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::initialize_resources</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">size_t</span>       vertex_buffer_size = <span class="hljs-number">0</span>, index_buffer_size = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> model_buffer_size = models.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(SceneModel);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;model : models)<br>	&#123;<br>		model.vertex_buffer_offset = vertex_buffer_size;<br>		model.index_buffer_offset  = index_buffer_size;<br><br>		vertex_buffer_size += model.vertices.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(Vertex);<br>		index_buffer_size += model.triangles.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(model.triangles[<span class="hljs-number">0</span>]);<br>	&#125;<br><br>	<span class="hljs-built_in">assert</span>(vertex_buffer_size &amp;&amp; index_buffer_size &amp;&amp; model_buffer_size);<br>	<span class="hljs-keyword">auto</span> staging_vertex_buffer = vkb::core::BufferC::<span class="hljs-built_in">create_staging_buffer</span>(<span class="hljs-built_in">get_device</span>(), vertex_buffer_size, <span class="hljs-literal">nullptr</span>);<br>	<span class="hljs-keyword">auto</span> staging_index_buffer  = vkb::core::BufferC::<span class="hljs-built_in">create_staging_buffer</span>(<span class="hljs-built_in">get_device</span>(), index_buffer_size, <span class="hljs-literal">nullptr</span>);<br>	<span class="hljs-keyword">auto</span> staging_model_buffer  = vkb::core::BufferC::<span class="hljs-built_in">create_staging_buffer</span>(<span class="hljs-built_in">get_device</span>(), model_buffer_size, <span class="hljs-literal">nullptr</span>);<br><br>	<span class="hljs-comment">// We will store the GPU commands in the indirect call buffer</span><br>	<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> default_indirect_flags = VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;<br>	<span class="hljs-keyword">auto</span>           indirect_flags         = default_indirect_flags;<br>	<span class="hljs-keyword">if</span> (m_supports_buffer_device)<br>	&#123;<br>		indirect_flags |= VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;<br>	&#125;<br>	indirect_call_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), models.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(VkDrawIndexedIndirectCommand), indirect_flags, VMA_MEMORY_USAGE_GPU_ONLY, VMA_ALLOCATION_CREATE_MAPPED_BIT, queue_families);<br><br>	<span class="hljs-comment">// Create a buffer containing the addresses of the indirect calls.</span><br>	<span class="hljs-comment">// In this sample, the order of the addresses will match that of the other buffers, but in general they could be in any order</span><br>	<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> address_buffer_size    = <span class="hljs-built_in">sizeof</span>(VkDeviceAddress);<br>	<span class="hljs-keyword">auto</span>         staging_address_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), address_buffer_size, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VMA_MEMORY_USAGE_CPU_TO_GPU);<br>	<span class="hljs-keyword">if</span> (m_supports_buffer_device)<br>	&#123;<br>		<span class="hljs-keyword">auto</span> *destPtr = (<span class="hljs-type">uint64_t</span> *) staging_address_buffer-&gt;<span class="hljs-built_in">get_data</span>();<br><br>		VkBufferDeviceAddressInfoKHR address_info&#123;VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR&#125;;<br>		address_info.buffer    = indirect_call_buffer-&gt;<span class="hljs-built_in">get_handle</span>();<br>		VkDeviceAddress srcPtr = <span class="hljs-built_in">vkGetBufferDeviceAddressKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;address_info);<br><br>		*destPtr = srcPtr;<br>	&#125;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; models.<span class="hljs-built_in">size</span>(); ++i)<br>	&#123;<br>		<span class="hljs-keyword">auto</span> &amp;model = models[i];<br>		staging_vertex_buffer.<span class="hljs-built_in">update</span>(model.vertices.<span class="hljs-built_in">data</span>(), model.vertices.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(Vertex), model.vertex_buffer_offset);<br>		staging_index_buffer.<span class="hljs-built_in">update</span>(model.triangles.<span class="hljs-built_in">data</span>(), model.triangles.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(model.triangles[<span class="hljs-number">0</span>]), model.index_buffer_offset);<br><br>		GpuModelInformation model_information;<br>		model_information.bounding_sphere_center = model.bounding_sphere.center;<br>		model_information.bounding_sphere_radius = model.bounding_sphere.radius;<br>		model_information.texture_index          = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(model.texture_index);<br>		model_information.firstIndex             = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(model.index_buffer_offset / (<span class="hljs-built_in">sizeof</span>(model.triangles[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])));<br>		model_information.indexCount             = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(model.triangles.<span class="hljs-built_in">size</span>());<br>		staging_model_buffer.<span class="hljs-built_in">update</span>(&amp;model_information, <span class="hljs-built_in">sizeof</span>(GpuModelInformation), i * <span class="hljs-built_in">sizeof</span>(GpuModelInformation));<br>	&#125;<br><br>	staging_vertex_buffer.<span class="hljs-built_in">flush</span>();<br>	staging_index_buffer.<span class="hljs-built_in">flush</span>();<br>	staging_model_buffer.<span class="hljs-built_in">flush</span>();<br><br>	<span class="hljs-keyword">auto</span> &amp;cmd = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">request_command_buffer</span>();<br>	cmd.<span class="hljs-built_in">begin</span>(VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, VK_NULL_HANDLE);<br>	<span class="hljs-keyword">auto</span> copy = [<span class="hljs-keyword">this</span>, &amp;cmd](vkb::core::BufferC &amp;staging_buffer, VkBufferUsageFlags buffer_usage_flags) &#123;<br>		<span class="hljs-keyword">auto</span> output_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), staging_buffer.<span class="hljs-built_in">get_size</span>(), buffer_usage_flags | VK_BUFFER_USAGE_TRANSFER_DST_BIT, VMA_MEMORY_USAGE_GPU_ONLY, VMA_ALLOCATION_CREATE_MAPPED_BIT, queue_families);<br>		cmd.<span class="hljs-built_in">copy_buffer</span>(staging_buffer, *output_buffer, staging_buffer.<span class="hljs-built_in">get_size</span>());<br><br>		vkb::BufferMemoryBarrier barrier;<br>		barrier.src_stage_mask  = VK_PIPELINE_STAGE_TRANSFER_BIT;<br>		barrier.dst_stage_mask  = VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT;<br>		barrier.src_access_mask = VK_ACCESS_TRANSFER_WRITE_BIT;<br>		barrier.dst_access_mask = VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_SHADER_WRITE_BIT;<br>		cmd.<span class="hljs-built_in">buffer_memory_barrier</span>(*output_buffer, <span class="hljs-number">0</span>, VK_WHOLE_SIZE, barrier);<br>		<span class="hljs-keyword">return</span> output_buffer;<br>	&#125;;<br>	vertex_buffer            = <span class="hljs-built_in">copy</span>(staging_vertex_buffer, VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_STORAGE_BUFFER_BIT);<br>	index_buffer             = <span class="hljs-built_in">copy</span>(staging_index_buffer, VK_BUFFER_USAGE_INDEX_BUFFER_BIT);<br>	model_information_buffer = <span class="hljs-built_in">copy</span>(staging_model_buffer, VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT);<br>	<span class="hljs-keyword">if</span> (m_supports_buffer_device)<br>	&#123;<br>		<span class="hljs-comment">// In this sample, we use a staging buffer for the device address buffer (i.e. for device exclusive memory).</span><br>		<span class="hljs-comment">// However, since the size of each element (sizeof(uint64_t)) is smaller than the objects it&#x27;s pointing to, it could instead use host-visible memory</span><br>		<span class="hljs-comment">// for fast referencing of the underlying data</span><br>		device_address_buffer = <span class="hljs-built_in">copy</span>(*staging_address_buffer, VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT);<br>	&#125;<br><br>	cmd.<span class="hljs-built_in">end</span>();<br>	<span class="hljs-keyword">auto</span> &amp;queue = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_by_flags</span>(VK_QUEUE_GRAPHICS_BIT, <span class="hljs-number">0</span>);<br>	queue.<span class="hljs-built_in">submit</span>(cmd, <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">request_fence</span>());<br>	<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_fence_pool</span>().<span class="hljs-built_in">wait</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数的所完成的工作就是创建好所有之后的计算或者渲染阶段需要使用到的缓冲区。</p><p>要创建缓冲区，首先当然需要知道想要创建的缓冲区大小。我们希望创建一个包含了所有模型的顶点缓冲区和对应的索引缓冲区，包含所有绘制命令的间接绘制缓冲区以及会用作实例缓冲区和CS使用的SSBO的模型数据缓冲区。因此函数开头首先使用一个循环遍历之前保存的所有<code>SceneModel</code>，将每个<code>SceneModel</code>之前没有填写的顶点和索引偏移信息填写进去（偏移就是排在该<code>SceneModel</code>之前的所有顶点数和索引数之和），同时通过累加获取需要创建的大顶点缓冲区和索引缓冲区的大小。因为顶点、索引和模型数据在初始化之后就不再改变了，我们当然希望这些缓冲区都是device local的，因此需要首先创建相应的staging buffer，将数据先传递到staging buffer中，再复制到真正的缓冲区中。</p><p>绘制调用的参数虽说会改变，但是程序仍然将绘制参数缓冲区存放在device local的内存区域中，该缓冲区的初始化逻辑在<i><font color="Green">cpu_cull</font></i>函数中执行，后续我们会讲到，在<i><font color="Green">initialize_resources</font></i>函数中只是将这个缓冲区创建好，并没有填写所需的数据。需要注意的是这个缓冲区的用途设置，它被设置为<i><font color="Red">VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT</font></i>的一个位组合，如果硬件还支持device address的话那么该缓冲区还应该具有<i><font color="Red">VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</font></i>的作用，后续在分析着色器的时候会看到如果该缓冲区设置了这个标志位，那么计算着色器可以直接读取这个缓冲区的地址来对缓冲区内的数据进行访问而无需绑定该缓冲区。不过为了访问绘制参数缓冲区的地址，仍需创建一个用于存储该地址的address buffer，通过<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferDeviceAddress.html"><code>vkGetBufferDeviceAddress</code></a>获取绘制参数缓冲区的地址然后传递给staging buffer，再将staging buffer中的数据复制到address buffer中供计算着色器使用即可。这个copy操作会在后续通过一个lambda表达式和顶点、索引、模型缓冲区一并进行。</p><p>接下来函数首先将顶点、索引以及所有模型信息的数据上传到它们对应的staging buffer中去，然后将staging buffer中的数据copy到真正使用的缓冲区中。这部分没什么好说的，就是录制复制相关的命令然后提交给图形队列执行，在CPU端等待执行结束即可。同样，模型信息缓冲区也需要上传相应的数据，其中存储的会是<code>GpuModelInformation</code>数组，该结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GpuModelInformation</span><br>&#123;<br>	glm::vec3 bounding_sphere_center;<br>	<span class="hljs-type">float</span>     bounding_sphere_radius;<br>	<span class="hljs-type">uint32_t</span>  texture_index = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">uint32_t</span>  firstIndex    = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">uint32_t</span>  indexCount    = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">uint32_t</span>  _pad          = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个结构体最后多出一个占位用的<i><font color="Orange">_pad</font></i>，这是为了满足Vulkan的内存对齐需求。因为在glsl中一个<strong>vec3</strong>向量实际要求的内存对齐必须和<strong>vec4</strong>一致，也就是16字节，如果最后没有这个<i><font color="Orange">_pad</font></i>的话，缓冲区中的<code>GpuModelInformation</code>数组中相邻两个结构体之间就会有一个字节空隙，但是代码中在将数据上传到staging buffer的时候是直接通过c++结构体大小来计算更新位置的偏移的，这就很可能会导致上传数据的大小超出了缓冲区的实际大小或者数据错位。关于数据对齐部分的内容同样可以参考我之前对Vulkan Tutorial相关部分的<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/12/06/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B1%A0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86/"><code>翻译</code></a>，更详细的说明可以直接参考<a target="_blank" rel="noopener" href="https://docs.vulkan.org/spec/latest/chapters/interfaces.html#interfaces-resources-layout"><code>官方说明文档</code></a>。</p><p>回到模型信息缓冲区的数据上传，整体逻辑上大体没啥问题，但是让我有些不理解的地方在于代码将模型信息的<i><font color="Orange">indexCount</font></i>成员设置为模型的三角形数量，为什么不需要乘以一个3呢？不过似乎这个地方并不影响后续的程序运行，因为这个成员好像压根就没用上。。。</p><h3 id="update_scene_uniform">update_scene_uniform</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!scene_uniform_buffer)<br>&#123;<br>	scene_uniform_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<br>	    <span class="hljs-built_in">get_device</span>(), <span class="hljs-built_in">sizeof</span>(SceneUniform), VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, VMA_MEMORY_USAGE_CPU_TO_GPU, VMA_ALLOCATION_CREATE_MAPPED_BIT, queue_families);<br>&#125;<br>scene_uniform.proj        = camera.matrices.perspective;<br>scene_uniform.view        = camera.matrices.view;<br>scene_uniform.proj_view   = scene_uniform.proj * scene_uniform.view;<br>scene_uniform.model_count = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(models.<span class="hljs-built_in">size</span>());<br><br>scene_uniform_buffer-&gt;<span class="hljs-built_in">update</span>(&amp;scene_uniform, <span class="hljs-built_in">sizeof</span>(scene_uniform), <span class="hljs-number">0</span>);<br><br>scene_uniform_buffer-&gt;<span class="hljs-built_in">flush</span>();<br></code></pre></td></tr></table></figure><p>这个逻辑就相当简单了，无非是负责创建并更新场景缓冲区，包括投影矩阵、视图矩阵、模型数信息。</p><h3 id="create_pipeline">create_pipeline</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::create_pipeline</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::vector&lt;VkDescriptorPoolSize&gt; pool_sizes = &#123;<br>	    &#123;VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, <span class="hljs-number">6</span>&#125;,<br>	    &#123;VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="hljs-number">1</span> * <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(textures.<span class="hljs-built_in">size</span>())&#125;,<br>	    &#123;VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">6</span>&#125;&#125;;<br>	VkDescriptorPoolCreateInfo descriptor_pool_create_info = vkb::initializers::<span class="hljs-built_in">descriptor_pool_create_info</span>(pool_sizes, <span class="hljs-number">3</span>);<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorPool</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_pool_create_info, <span class="hljs-literal">nullptr</span>, &amp;descriptor_pool));<br><br>	<span class="hljs-comment">// The model information will be used to index textures in the fragment shader,</span><br>	<span class="hljs-comment">// as well as perform frustum culling in the compute shader</span><br>	VkDescriptorSetLayoutBinding model_information_binding&#123;&#125;;<br>	model_information_binding.binding         = <span class="hljs-number">0</span>;<br>	model_information_binding.descriptorType  = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;<br>	model_information_binding.descriptorCount = <span class="hljs-number">1</span>;<br>	model_information_binding.stageFlags      = VK_SHADER_STAGE_COMPUTE_BIT;<br><br>	<span class="hljs-comment">// This array of textures will be accessed via the instance ID</span><br>	VkDescriptorSetLayoutBinding image_array_binding&#123;&#125;;<br>	image_array_binding.binding         = <span class="hljs-number">1</span>;<br>	image_array_binding.descriptorType  = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;<br>	image_array_binding.descriptorCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(textures.<span class="hljs-built_in">size</span>());<br>	image_array_binding.stageFlags      = VK_SHADER_STAGE_FRAGMENT_BIT;<br><br>	VkDescriptorSetLayoutBinding scene_uniform_binding&#123;&#125;;<br>	scene_uniform_binding.binding         = <span class="hljs-number">2</span>;<br>	scene_uniform_binding.descriptorType  = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;<br>	scene_uniform_binding.descriptorCount = <span class="hljs-number">1</span>;<br>	scene_uniform_binding.stageFlags      = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT | VK_SHADER_STAGE_COMPUTE_BIT;<br><br>	VkDescriptorSetLayoutBinding command_buffer_binding&#123;&#125;;<br>	command_buffer_binding.binding         = <span class="hljs-number">3</span>;<br>	command_buffer_binding.descriptorType  = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;<br>	command_buffer_binding.descriptorCount = <span class="hljs-number">1</span>;<br>	command_buffer_binding.stageFlags      = VK_SHADER_STAGE_COMPUTE_BIT;<br><br>	<span class="hljs-comment">// Create descriptors</span><br>	<span class="hljs-keyword">auto</span> create_descriptors = [<span class="hljs-keyword">this</span>](<span class="hljs-type">const</span> std::vector&lt;VkDescriptorSetLayoutBinding&gt; &amp;set_layout_bindings, VkDescriptorSetLayout &amp;_descriptor_set_layout, VkPipelineLayout &amp;_pipeline_layout) &#123;<br>		VkDescriptorSetLayoutCreateInfo descriptor_layout = vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_create_info</span>(set_layout_bindings.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(set_layout_bindings.<span class="hljs-built_in">size</span>()));<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorSetLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_layout, <span class="hljs-literal">nullptr</span>, &amp;_descriptor_set_layout));<br><br>		VkPipelineLayoutCreateInfo pipeline_layout_create_info =<br>		    vkb::initializers::<span class="hljs-built_in">pipeline_layout_create_info</span>(<br>		        &amp;_descriptor_set_layout,<br>		        <span class="hljs-number">1</span>);<br><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreatePipelineLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;pipeline_layout_create_info, <span class="hljs-literal">nullptr</span>, &amp;_pipeline_layout));<br>	&#125;;<br><br>	<span class="hljs-comment">// Render pipeline</span><br>	std::vector&lt;VkDescriptorSetLayoutBinding&gt; set_layout_bindings = &#123;model_information_binding, image_array_binding, scene_uniform_binding, command_buffer_binding&#125;;<br>	<span class="hljs-built_in">create_descriptors</span>(set_layout_bindings, descriptor_set_layout, pipeline_layout);<br><br>	<span class="hljs-comment">// Compute pipeline</span><br>	<span class="hljs-comment">// Note we don&#x27;t include the texture array</span><br>	std::vector&lt;VkDescriptorSetLayoutBinding&gt; gpu_compute_set_layout_bindings = &#123;model_information_binding, scene_uniform_binding, command_buffer_binding&#125;;<br>	<span class="hljs-built_in">create_descriptors</span>(gpu_compute_set_layout_bindings, gpu_cull_descriptor_set_layout, gpu_cull_pipeline_layout);<br><br>	<span class="hljs-comment">// Device address pipeline</span><br>	<span class="hljs-comment">// Note that we don&#x27;t bind the command buffer directly; instead, we use the references from the device addresses</span><br>	<span class="hljs-comment">// This will be used in the device address shader (cull_address.comp)</span><br>	<span class="hljs-keyword">if</span> (m_supports_buffer_device)<br>	&#123;<br>		VkDescriptorSetLayoutBinding device_address_binding&#123;&#125;;<br>		device_address_binding.binding                                           = <span class="hljs-number">4</span>;<br>		device_address_binding.descriptorType                                    = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;<br>		device_address_binding.descriptorCount                                   = <span class="hljs-number">1</span>;<br>		device_address_binding.stageFlags                                        = VK_SHADER_STAGE_COMPUTE_BIT;<br>		std::vector&lt;VkDescriptorSetLayoutBinding&gt; device_address_layout_bindings = &#123;model_information_binding, scene_uniform_binding, device_address_binding&#125;;<br>		<span class="hljs-built_in">create_descriptors</span>(device_address_layout_bindings, device_address_descriptor_set_layout, device_address_pipeline_layout);<br>	&#125;<br><br>	VkPipelineInputAssemblyStateCreateInfo input_assembly_state = vkb::initializers::<span class="hljs-built_in">pipeline_input_assembly_state_create_info</span>(VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, <span class="hljs-number">0</span>, VK_FALSE);<br><br>	VkPipelineRasterizationStateCreateInfo rasterization_state = vkb::initializers::<span class="hljs-built_in">pipeline_rasterization_state_create_info</span>(VK_POLYGON_MODE_FILL, VK_CULL_MODE_BACK_BIT, VK_FRONT_FACE_COUNTER_CLOCKWISE, <span class="hljs-number">0</span>);<br><br>	VkPipelineColorBlendAttachmentState blend_attachment_state = vkb::initializers::<span class="hljs-built_in">pipeline_color_blend_attachment_state</span>(<span class="hljs-number">0xf</span>, VK_FALSE);<br><br>	VkPipelineColorBlendStateCreateInfo color_blend_state = vkb::initializers::<span class="hljs-built_in">pipeline_color_blend_state_create_info</span>(<span class="hljs-number">1</span>, &amp;blend_attachment_state);<br><br>	VkPipelineDepthStencilStateCreateInfo depth_stencil_state = vkb::initializers::<span class="hljs-built_in">pipeline_depth_stencil_state_create_info</span>(VK_TRUE, VK_TRUE, VK_COMPARE_OP_LESS);<br>	depth_stencil_state.depthBoundsTestEnable                 = VK_FALSE;<br>	depth_stencil_state.minDepthBounds                        = <span class="hljs-number">0.f</span>;<br>	depth_stencil_state.maxDepthBounds                        = <span class="hljs-number">1.f</span>;<br><br>	VkPipelineViewportStateCreateInfo viewport_state = vkb::initializers::<span class="hljs-built_in">pipeline_viewport_state_create_info</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><br>	std::vector&lt;VkDynamicState&gt; dynamic_state_enables = &#123;<br>	    VK_DYNAMIC_STATE_VIEWPORT,<br>	    VK_DYNAMIC_STATE_SCISSOR&#125;;<br>	VkPipelineDynamicStateCreateInfo dynamic_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_dynamic_state_create_info</span>(<br>	        dynamic_state_enables.<span class="hljs-built_in">data</span>(),<br>	        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(dynamic_state_enables.<span class="hljs-built_in">size</span>()),<br>	        <span class="hljs-number">0</span>);<br><br>	VkPipelineMultisampleStateCreateInfo multisample_state = vkb::initializers::<span class="hljs-built_in">pipeline_multisample_state_create_info</span>(VK_SAMPLE_COUNT_1_BIT, <span class="hljs-number">0</span>);<br><br>	<span class="hljs-comment">// Vertex bindings and attributes</span><br>	<span class="hljs-type">const</span> std::vector&lt;VkVertexInputBindingDescription&gt; vertex_input_bindings = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_binding_description</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Vertex), VK_VERTEX_INPUT_RATE_VERTEX),<br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_binding_description</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">sizeof</span>(GpuModelInformation), VK_VERTEX_INPUT_RATE_INSTANCE),<br>	&#125;;<br>	<span class="hljs-type">const</span> std::vector&lt;VkVertexInputAttributeDescription&gt; vertex_input_attributes = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, VK_FORMAT_R32G32B32_SFLOAT, <span class="hljs-built_in">offsetof</span>(Vertex, pt)),<br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, VK_FORMAT_R32G32_SFLOAT, <span class="hljs-built_in">offsetof</span>(Vertex, uv)),<br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, VK_FORMAT_R32G32B32_SFLOAT, <span class="hljs-built_in">offsetof</span>(GpuModelInformation, bounding_sphere_center)),<br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, VK_FORMAT_R32_SFLOAT, <span class="hljs-built_in">offsetof</span>(GpuModelInformation, bounding_sphere_radius)),<br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, VK_FORMAT_R32_UINT, <span class="hljs-built_in">offsetof</span>(GpuModelInformation, texture_index)),<br>	&#125;;<br>	VkPipelineVertexInputStateCreateInfo vertex_input_state = vkb::initializers::<span class="hljs-built_in">pipeline_vertex_input_state_create_info</span>();<br>	vertex_input_state.vertexBindingDescriptionCount        = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertex_input_bindings.<span class="hljs-built_in">size</span>());<br>	vertex_input_state.pVertexBindingDescriptions           = vertex_input_bindings.<span class="hljs-built_in">data</span>();<br>	vertex_input_state.vertexAttributeDescriptionCount      = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertex_input_attributes.<span class="hljs-built_in">size</span>());<br>	vertex_input_state.pVertexAttributeDescriptions         = vertex_input_attributes.<span class="hljs-built_in">data</span>();<br><br>	VkGraphicsPipelineCreateInfo pipeline_create_info = vkb::initializers::<span class="hljs-built_in">pipeline_create_info</span>(pipeline_layout, render_pass, <span class="hljs-number">0</span>);<br>	pipeline_create_info.pVertexInputState            = &amp;vertex_input_state;<br>	pipeline_create_info.pInputAssemblyState          = &amp;input_assembly_state;<br>	pipeline_create_info.pRasterizationState          = &amp;rasterization_state;<br>	pipeline_create_info.pColorBlendState             = &amp;color_blend_state;<br>	pipeline_create_info.pMultisampleState            = &amp;multisample_state;<br>	pipeline_create_info.pViewportState               = &amp;viewport_state;<br>	pipeline_create_info.pDepthStencilState           = &amp;depth_stencil_state;<br>	pipeline_create_info.pDynamicState                = &amp;dynamic_state;<br><br>	<span class="hljs-type">const</span> std::array&lt;VkPipelineShaderStageCreateInfo, 2&gt; shader_stages = &#123;<br>	    <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;multi_draw_indirect/multi_draw_indirect.vert&quot;</span>, VK_SHADER_STAGE_VERTEX_BIT),<br>	    <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;multi_draw_indirect/multi_draw_indirect.frag&quot;</span>, VK_SHADER_STAGE_FRAGMENT_BIT)&#125;;<br><br>	pipeline_create_info.stageCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(shader_stages.<span class="hljs-built_in">size</span>());<br>	pipeline_create_info.pStages    = shader_stages.<span class="hljs-built_in">data</span>();<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateGraphicsPipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;pipeline));<br>&#125;<br></code></pre></td></tr></table></figure><p>看着是真挺吓人的，不过大多都是已经司空见惯的操作罢了（没办法，Vulkan创建管线就是这么麻烦，不写这么多也不行。。。），我们快速地浏览一下对应的逻辑：</p><p>函数首先创建了用于分配缓冲区、SSBO、组合图像采样器描述符集的描述符池，然后开始填写创建<code>pipeline layout</code>所需的<code>descriptor set layout</code>信息，而填写<code>descriptor set layout</code>有需要填写该描述符集绑定的所有描述符的类型、绑定点、数量、绑定阶段等信息。这一部分本身涉及到Vulkan的资源绑定原理，确实是比较绕的，这部分推荐一下在知乎上看到的<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/616099137?utm_psn=1877761418515861505"><code>大佬的文章</code></a>，个人感觉看完后也是对于这一部分的理解清晰和系统化了不少，可谓受益良多。</p><p>事实上应用程序类中保存了三个PSO，分别为<i><font color="Orange">pipeline</font></i>，<i><font color="Orange">gpu_cull_pipeline</font></i>和<i><font color="Orange">device_address_pipeline</font></i>，它们各自当然具有不同的描述符绑定状态。<i><font color="Orange">pipeline</font></i>就是图形管线对象，它需要绑定的描述符有场景缓冲区、模型信息缓冲区、组合采样器以及绘制参数缓冲区，另外注意组合采样器的绑定，它是在一个绑定点指定绑定了所有的纹理，所以最后在片段着色器中会用到一个纹理的数组；<i><font color="Orange">gpu_cull_pipeline</font></i>是GPU视锥剔除管线对象，它所需要使用的描述符有场景缓冲区、模型信息缓冲区以及绘制参数缓冲区；最后是<i><font color="Orange">device_address_pipeline</font></i>对象，如果硬件支持device address，并且用户设置应用程序的剔除模式为<i><font color="Red">GPU_DEVICE_ADDRESS</font></i>，那么程序就会使用该管线来进行GPU上的视锥剔除。它使用到的描述符则是将<i><font color="Orange">gpu_cull_pipeline</font></i>使用的绘制参数缓冲区换成了设备地址缓冲区，也就是用于保存绘制参数缓冲区地址的缓冲区。事实上，该示例提供了三种视锥剔除模式供用户选择：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">RenderMode</span><br>&#123;<br>	CPU,<br>	GPU,<br>	GPU_DEVICE_ADDRESS<br>&#125; render_mode = GPU;<br></code></pre></td></tr></table></figure><p>默认的模式是普通的GPU剔除。</p><p>接下来的一系列渲染管线的固定管线阶段设置都是常规操作，这里不再赘述，不熟悉的读者可以参考我的博客上之前的<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/"><code>系列文章</code></a>。</p><p>接下来就是指定顶点输入布局了。顶点输入槽0将会绑定模型顶点信息，包括了位置和纹理坐标属性；输入槽1则会绑定实例缓冲，也就是存储模型信息的缓冲，注意此时要将<code>VkVertexInputRate</code>设置为<i><font color="Red">VK_VERTEX_INPUT_RATE_INSTANCE</font></i>以表明这是一个逐实例属性，另外可以发现我们在顶点属性中只用到了<code>GpuModelInformation</code>的包围球球心、包围球半径以及纹理索引三个成员。</p><p>在创建管线对象的最后，程序指定了图形管线使用到的顶点和像素着色器。两个着色器的代码都十分简单易懂：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//vertex shader</span><br><br><span class="hljs-meta">#version 460</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> position;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> uv;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> sphere_center;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">float</span> sphere_radius;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">4</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">uint</span> texture_index;<br><br><span class="hljs-keyword">layout</span>(set = <span class="hljs-number">0</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">uniform</span> GlobalUniform<br>&#123;<br>	<span class="hljs-type">mat4</span> view;<br>	<span class="hljs-type">mat4</span> proj;<br>	<span class="hljs-type">mat4</span> proj_view;<br>	<span class="hljs-type">uint</span> model_count;<br>&#125;<br>global_uniform;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> o_uv;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">uint</span> o_texture_index;<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>)<br>&#123;<br>	o_uv            = uv;<br>	<span class="hljs-built_in">gl_Position</span>     = global_uniform.proj * global_uniform.view * <span class="hljs-type">vec4</span>(position, <span class="hljs-number">1.0</span>);<br>	o_texture_index = texture_index;<br>&#125;<br><br><span class="hljs-comment">//fragment shader</span><br><br><span class="hljs-meta">#version 460</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> in_uv;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">flat</span> <span class="hljs-keyword">in</span> <span class="hljs-type">uint</span> in_texture_index;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> o_color;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>, set = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> textures[<span class="hljs-number">225</span>];<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>)<br>&#123;<br>	o_color = <span class="hljs-type">vec4</span>(<span class="hljs-built_in">texture</span>(textures[<span class="hljs-type">uint</span>(<span class="hljs-built_in">round</span>(in_texture_index))], in_uv));<br>	o_color.rgb *= <span class="hljs-number">1.5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到事实上代码中也没有用到包围球的半径和中心，那为啥还要上传这两个顶点属性？为了之后代码的拓展性吗？不是很懂。。。</p><h3 id="create_compute_pipeline">create_compute_pipeline</h3><p>同样上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::create_compute_pipeline</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">auto</span> create = [<span class="hljs-keyword">this</span>](VkPipelineLayout &amp;layout, VkPipeline &amp;_pipeline, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename) &#123;<br>		VkComputePipelineCreateInfo compute_create_info = vkb::initializers::<span class="hljs-built_in">compute_pipeline_create_info</span>(layout, <span class="hljs-number">0</span>);<br>		compute_create_info.stage                       = <span class="hljs-built_in">load_shader</span>(filename, VK_SHADER_STAGE_COMPUTE_BIT);<br><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateComputePipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;compute_create_info, <span class="hljs-literal">nullptr</span>, &amp;_pipeline));<br>	&#125;;<br><br>	<span class="hljs-built_in">create</span>(gpu_cull_pipeline_layout, gpu_cull_pipeline, <span class="hljs-string">&quot;multi_draw_indirect/cull.comp&quot;</span>);<br><br>	<span class="hljs-keyword">if</span> (m_supports_buffer_device)<br>	&#123;<br>		<span class="hljs-built_in">create</span>(device_address_pipeline_layout, device_address_pipeline, <span class="hljs-string">&quot;multi_draw_indirect/cull_address.comp&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>没什么好说的，就是创建两个用于视锥剔除的计算管线。主要看一下这两个管线用到的CS：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//cull.comp</span><br><br><span class="hljs-meta">#version 460</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">local_size_x</span> = <span class="hljs-number">64</span>) <span class="hljs-keyword">in</span>;<br><br>struct ModelInformation<br>&#123;<br>	<span class="hljs-type">float</span> x;<br>	<span class="hljs-type">float</span> y;<br>	<span class="hljs-type">float</span> z;<br>	<span class="hljs-type">float</span> r;<br>	<span class="hljs-type">uint</span>  texture_index;<br>	<span class="hljs-type">uint</span>  firstIndex;<br>	<span class="hljs-type">uint</span>  indexCount;<br>	<span class="hljs-type">uint</span>  _pad;<br>&#125;;<br><br>struct VkDrawIndexedIndirectCommand<br>&#123;<br>	<span class="hljs-type">uint</span> indexCount;<br>	<span class="hljs-type">uint</span> instanceCount;<br>	<span class="hljs-type">uint</span> firstIndex;<br>	<span class="hljs-type">int</span>  vertexOffset;<br>	<span class="hljs-type">uint</span> firstInstance;<br>&#125;;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">std430</span>, set = <span class="hljs-number">0</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">buffer</span> <span class="hljs-keyword">readonly</span> ModelInformationBuffer<br>&#123;<br>	ModelInformation arr[];<br>&#125;<br>model_buffer;<br><br><span class="hljs-keyword">layout</span>(set = <span class="hljs-number">0</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">uniform</span> GlobalUniform<br>&#123;<br>	<span class="hljs-type">mat4</span> view;<br>	<span class="hljs-type">mat4</span> proj;<br>	<span class="hljs-type">mat4</span> proj_view;<br>	<span class="hljs-type">uint</span> model_count;<br>&#125;<br>global_uniform;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">std430</span>, set = <span class="hljs-number">0</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">buffer</span> <span class="hljs-keyword">writeonly</span> CommandBuffer<br>&#123;<br>	VkDrawIndexedIndirectCommand commands[];<br>&#125;<br>command_buffer;<br><br><span class="hljs-comment">// See &quot;VisibilityTester&quot; in the C++ code for explanation</span><br><span class="hljs-type">bool</span> check_is_visible(<span class="hljs-type">mat4</span> mat, <span class="hljs-type">vec3</span> origin, <span class="hljs-type">float</span> radius)<br>&#123;<br>	<span class="hljs-type">uint</span> plane_index = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">uint</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i)<br>	&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">uint</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; ++j, ++plane_index)<br>		&#123;<br>			<span class="hljs-keyword">if</span> (plane_index == <span class="hljs-number">2</span> || plane_index == <span class="hljs-number">3</span>)<br>			&#123;<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br>			<span class="hljs-keyword">const</span> <span class="hljs-type">float</span> <span class="hljs-built_in">sign</span>  = (j &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1.</span>f : <span class="hljs-number">-1.</span>f;<br>			<span class="hljs-type">vec4</span>        plane = <span class="hljs-type">vec4</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">uint</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; ++k)<br>			&#123;<br>				plane[k] = mat[k][<span class="hljs-number">3</span>] + <span class="hljs-built_in">sign</span> * mat[k][i];<br>			&#125;<br>			plane.xyzw /= <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">dot</span>(plane.xyz, plane.xyz));<br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">dot</span>(origin, plane.xyz) + plane.w + radius &lt; <span class="hljs-number">0</span>)<br>			&#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>	<span class="hljs-type">uint</span> id = <span class="hljs-built_in">gl_GlobalInvocationID</span>.x;<br>	<span class="hljs-keyword">if</span> (id &gt;= global_uniform.model_count)<br>	&#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	ModelInformation model                    = model_buffer.arr[id];<br>	<span class="hljs-type">bool</span>             is_visible               = check_is_visible(global_uniform.proj_view, <span class="hljs-type">vec3</span>(model.x, model.y, model.z), model.r);<br>	command_buffer.commands[id].instanceCount = is_visible ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//cull_address.comp</span><br><br><span class="hljs-meta">#version 460</span><br><br><span class="hljs-meta">#extension GL_EXT_buffer_reference : require</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">local_size_x</span> = <span class="hljs-number">64</span>) <span class="hljs-keyword">in</span>;<br><br>struct ModelInformation<br>&#123;<br>	<span class="hljs-type">float</span> x;<br>	<span class="hljs-type">float</span> y;<br>	<span class="hljs-type">float</span> z;<br>	<span class="hljs-type">float</span> r;<br>	<span class="hljs-type">uint</span>  texture_index;<br>	<span class="hljs-type">uint</span>  firstIndex;<br>	<span class="hljs-type">uint</span>  indexCount;<br>	<span class="hljs-type">uint</span>  _pad;<br>&#125;;<br><br>struct VkDrawIndexedIndirectCommand<br>&#123;<br>	<span class="hljs-type">uint</span> indexCount;<br>	<span class="hljs-type">uint</span> instanceCount;<br>	<span class="hljs-type">uint</span> firstIndex;<br>	<span class="hljs-type">int</span>  vertexOffset;<br>	<span class="hljs-type">uint</span> firstInstance;<br>&#125;;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">std430</span>, set = <span class="hljs-number">0</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">buffer</span> <span class="hljs-keyword">readonly</span> ModelInformationBuffer<br>&#123;<br>	ModelInformation arr[];<br>&#125;<br>model_buffer;<br><br><span class="hljs-keyword">layout</span>(set = <span class="hljs-number">0</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">uniform</span> GlobalUniform<br>&#123;<br>	<span class="hljs-type">mat4</span> view;<br>	<span class="hljs-type">mat4</span> proj;<br>	<span class="hljs-type">mat4</span> proj_view;<br>	<span class="hljs-type">uint</span> model_count;<br>&#125;<br>global_uniform;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">std430</span>, buffer_reference) <span class="hljs-keyword">buffer</span> CommandBuffer<br>&#123;<br>	VkDrawIndexedIndirectCommand commands[];<br>&#125;<br>command_buffer;<br><br><span class="hljs-keyword">layout</span>(set = <span class="hljs-number">0</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">4</span>) <span class="hljs-keyword">buffer</span> Addresses<br>&#123;<br>	CommandBuffer command_buffer;<br>&#125;<br>addresses;<br><br><span class="hljs-comment">// See &quot;VisibilityTester&quot; in the C++ code for explanation</span><br><span class="hljs-type">bool</span> check_is_visible(<span class="hljs-type">mat4</span> mat, <span class="hljs-type">vec3</span> origin, <span class="hljs-type">float</span> radius)<br>&#123;<br>	<span class="hljs-type">uint</span> plane_index = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">uint</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i)<br>	&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">uint</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; ++j, ++plane_index)<br>		&#123;<br>			<span class="hljs-keyword">if</span> (plane_index == <span class="hljs-number">2</span> || plane_index == <span class="hljs-number">3</span>)<br>			&#123;<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br>			<span class="hljs-keyword">const</span> <span class="hljs-type">float</span> <span class="hljs-built_in">sign</span>  = (j &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1.</span>f : <span class="hljs-number">-1.</span>f;<br>			<span class="hljs-type">vec4</span>        plane = <span class="hljs-type">vec4</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">uint</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; ++k)<br>			&#123;<br>				plane[k] = mat[k][<span class="hljs-number">3</span>] + <span class="hljs-built_in">sign</span> * mat[k][i];<br>			&#125;<br>			plane.xyzw /= <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">dot</span>(plane.xyz, plane.xyz));<br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">dot</span>(origin, plane.xyz) + plane.w + radius &lt; <span class="hljs-number">0</span>)<br>			&#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>	<span class="hljs-type">uint</span>             id         = <span class="hljs-built_in">gl_GlobalInvocationID</span>.x;<br>	<span class="hljs-keyword">if</span> (id &gt;= global_uniform.model_count)<br>	&#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	ModelInformation model      = model_buffer.arr[id];<br>	<span class="hljs-type">bool</span>             is_visible = check_is_visible(global_uniform.proj_view, <span class="hljs-type">vec3</span>(model.x, model.y, model.z), model.r);<br><br>	addresses.command_buffer.commands[id].instanceCount = is_visible ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个计算着色器的逻辑是相同的，就是结合模型信息缓冲区给出的包围球半径和中心信息，使用<i><font color="Green">check_is_visible</font></i>函数判断该<code>submesh</code>在不在视锥体内，在就将绘制参数缓冲区中存储的每个<code>VkDrawIndexedIndirectCommand</code>的<i><font color="Orange">instanceCount</font></i>成员设置为1，这样绘制命令在调用这些绘制参数的时候就会知道需要绘制1个实例；反之如果不在视锥体内那这个<code>submesh</code>就无需绘制，那么只需要将<i><font color="Orange">instanceCount</font></i>成员设置为0，绘制命令调用该参数的时候自然就知道该实例无需绘制了。</p><p>两个着色器代码唯一的区别在于对绘制参数缓冲区的访问方式。如果设备不支持device address，那么就只有通过将该缓冲区绑定到着色器上访问，但若是支持这个特性，就可以通过缓冲区地址来访问该缓冲区而无需绑定。在glsl中为了这样使用缓冲区，只需要首先启用拓展<strong>GL_EXT_buffer_reference</strong>，然后将想要通过引用访问的缓冲区的布局指定为<strong>buffer_reference</strong>，这样这个缓冲区中的数据就可以作为着色器代码中的一个变量或者另外一个缓冲区或结构体的成员被访问了，访问方式仍然是通过.运算符。更详细的关于<strong>GL_EXT_buffer_reference</strong>拓展的说明可以参考<a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_buffer_reference.txt"><code>这个页面</code></a>。</p><p>最后关于判断可见性的函数<i><font color="Green">check_is_visible</font></i>，它的逻辑和CPU视锥剔除使用的逻辑是完全一样的，我会在下文分析到CPU剔除的时候加以说明。</p><h3 id="initialize_descriptors">initialize_descriptors</h3><p>先上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::initialize_descriptors</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Target</span><br>	&#123;<br>		RenderPipeline,<br>		ComputePipeline,<br>		AddressPipeline<br>	&#125;;<br><br>	<span class="hljs-keyword">auto</span> bind = [<span class="hljs-keyword">this</span>](VkDescriptorSet &amp;_descriptor_set, VkDescriptorSetLayout &amp;_descriptor_set_layout, Target target) &#123;<br>		VkDescriptorSetAllocateInfo descriptor_set_allocate_info = vkb::initializers::<span class="hljs-built_in">descriptor_set_allocate_info</span>(descriptor_pool, &amp;_descriptor_set_layout, <span class="hljs-number">1</span>);<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_set_allocate_info, &amp;_descriptor_set));<br><br>		VkDescriptorBufferInfo model_buffer_descriptor = <span class="hljs-built_in">create_descriptor</span>(*model_information_buffer);<br>		VkWriteDescriptorSet   model_write             = vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(_descriptor_set, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, <span class="hljs-number">0</span>, &amp;model_buffer_descriptor, <span class="hljs-number">1</span>);<br><br>		VkWriteDescriptorSet texture_array_write = vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(_descriptor_set, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="hljs-number">1</span>, image_descriptors.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(image_descriptors.<span class="hljs-built_in">size</span>()));<br><br>		VkDescriptorBufferInfo scene_descriptor = <span class="hljs-built_in">create_descriptor</span>(*scene_uniform_buffer);<br>		VkWriteDescriptorSet   scene_write      = vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(_descriptor_set, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">2</span>, &amp;scene_descriptor, <span class="hljs-number">1</span>);<br><br>		VkDescriptorBufferInfo draw_command_descriptor = <span class="hljs-built_in">create_descriptor</span>(*indirect_call_buffer);<br>		VkWriteDescriptorSet   draw_command_write      = vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(_descriptor_set, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, <span class="hljs-number">3</span>, &amp;draw_command_descriptor, <span class="hljs-number">1</span>);<br><br>		VkDescriptorBufferInfo device_address_descriptor;<br>		VkWriteDescriptorSet   device_address_write;<br>		<span class="hljs-keyword">if</span> (m_supports_buffer_device &amp;&amp; device_address_buffer)<br>		&#123;<br>			device_address_descriptor = <span class="hljs-built_in">create_descriptor</span>(*device_address_buffer);<br>			device_address_write      = vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(_descriptor_set, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, <span class="hljs-number">4</span>, &amp;device_address_descriptor, <span class="hljs-number">1</span>);<br>		&#125;<br><br>		std::vector&lt;VkWriteDescriptorSet&gt; write_descriptor_sets;<br>		<span class="hljs-keyword">switch</span> (target)<br>		&#123;<br>			<span class="hljs-keyword">case</span> Target::RenderPipeline:<br>				write_descriptor_sets = &#123;model_write, texture_array_write, scene_write, draw_command_write&#125;;<br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">case</span> Target::ComputePipeline:<br>				write_descriptor_sets = &#123;model_write, scene_write, draw_command_write&#125;;<br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">case</span> Target::AddressPipeline:<br>				write_descriptor_sets = &#123;model_write, scene_write, device_address_write&#125;;<br>				<span class="hljs-keyword">break</span>;<br>		&#125;<br><br>		<span class="hljs-built_in">vkUpdateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(write_descriptor_sets.<span class="hljs-built_in">size</span>()), write_descriptor_sets.<span class="hljs-built_in">data</span>(), <span class="hljs-number">0</span>, VK_NULL_HANDLE);<br>	&#125;;<br><br>	<span class="hljs-comment">// render pipeline</span><br>	<span class="hljs-built_in">bind</span>(descriptor_set, descriptor_set_layout, Target::RenderPipeline);<br><br>	<span class="hljs-comment">//  compute pipeline</span><br>	<span class="hljs-built_in">bind</span>(gpu_cull_descriptor_set, gpu_cull_descriptor_set_layout, Target::ComputePipeline);<br><br>	<span class="hljs-comment">// Device address pipeline</span><br>	<span class="hljs-keyword">if</span> (m_supports_buffer_device)<br>	&#123;<br>		<span class="hljs-built_in">bind</span>(device_address_descriptor_set, device_address_descriptor_set_layout, Target::AddressPipeline);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数用于真正指定描述符绑定的资源对象。这部分内容也没什么好说的，函数开头的枚举类就是为了后续指定不同管线所需要绑定的不同描述符，然后后续为每个管线都指定好对应的描述符资源绑定就行了。</p><h3 id="build_command_buffers">build_command_buffers</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::build_command_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	VkCommandBufferBeginInfo command_buffer_begin_info = vkb::initializers::<span class="hljs-built_in">command_buffer_begin_info</span>();<br><br>	VkClearValue clear_values[<span class="hljs-number">2</span>];<br>	clear_values[<span class="hljs-number">0</span>].color        = default_clear_color;<br>	clear_values[<span class="hljs-number">1</span>].depthStencil = &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0</span>&#125;;<br><br>	VkRenderPassBeginInfo render_pass_begin_info    = vkb::initializers::<span class="hljs-built_in">render_pass_begin_info</span>();<br>	render_pass_begin_info.renderPass               = render_pass;<br>	render_pass_begin_info.renderArea.offset.x      = <span class="hljs-number">0</span>;<br>	render_pass_begin_info.renderArea.offset.y      = <span class="hljs-number">0</span>;<br>	render_pass_begin_info.renderArea.extent.width  = width;<br>	render_pass_begin_info.renderArea.extent.height = height;<br>	render_pass_begin_info.clearValueCount          = <span class="hljs-number">2</span>;<br>	render_pass_begin_info.pClearValues             = clear_values;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; draw_cmd_buffers.<span class="hljs-built_in">size</span>(); ++i)<br>	&#123;<br>		render_pass_begin_info.framebuffer = framebuffers[i];<br><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBeginCommandBuffer</span>(draw_cmd_buffers[i], &amp;command_buffer_begin_info));<br><br>		<span class="hljs-built_in">vkCmdBeginRenderPass</span>(draw_cmd_buffers[i], &amp;render_pass_begin_info, VK_SUBPASS_CONTENTS_INLINE);<br><br>		VkViewport viewport = vkb::initializers::<span class="hljs-built_in">viewport</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(height), <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br>		<span class="hljs-built_in">vkCmdSetViewport</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;viewport);<br><br>		VkRect2D scissor = vkb::initializers::<span class="hljs-built_in">rect2D</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int32_t</span>&gt;(width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int32_t</span>&gt;(height), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>		<span class="hljs-built_in">vkCmdSetScissor</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;scissor);<br><br>		<span class="hljs-built_in">vkCmdBindPipeline</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline);<br>		<span class="hljs-built_in">vkCmdBindDescriptorSets</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline_layout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;descriptor_set, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>		VkDeviceSize offsets[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>		<span class="hljs-built_in">vkCmdBindIndexBuffer</span>(draw_cmd_buffers[i], index_buffer-&gt;<span class="hljs-built_in">get_handle</span>(), <span class="hljs-number">0</span>, VK_INDEX_TYPE_UINT16);<br>		<span class="hljs-built_in">vkCmdBindVertexBuffers</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, vertex_buffer-&gt;<span class="hljs-built_in">get</span>(), offsets);<br>		<span class="hljs-built_in">vkCmdBindVertexBuffers</span>(draw_cmd_buffers[i], <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, model_information_buffer-&gt;<span class="hljs-built_in">get</span>(), offsets);<br><br>		<span class="hljs-keyword">if</span> (m_enable_mdi &amp;&amp; m_supports_mdi)<br>		&#123;<br>			<span class="hljs-built_in">vkCmdDrawIndexedIndirect</span>(draw_cmd_buffers[i], indirect_call_buffer-&gt;<span class="hljs-built_in">get_handle</span>(), <span class="hljs-number">0</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(cpu_commands.<span class="hljs-built_in">size</span>()), <span class="hljs-built_in">sizeof</span>(cpu_commands[<span class="hljs-number">0</span>]));<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; cpu_commands.<span class="hljs-built_in">size</span>(); ++j)<br>			&#123;<br>				<span class="hljs-built_in">vkCmdDrawIndexedIndirect</span>(draw_cmd_buffers[i], indirect_call_buffer-&gt;<span class="hljs-built_in">get_handle</span>(), j * <span class="hljs-built_in">sizeof</span>(cpu_commands[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>, <span class="hljs-built_in">sizeof</span>(cpu_commands[<span class="hljs-number">0</span>]));<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-built_in">draw_ui</span>(draw_cmd_buffers[i]);<br><br>		<span class="hljs-built_in">vkCmdEndRenderPass</span>(draw_cmd_buffers[i]);<br><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkEndCommandBuffer</span>(draw_cmd_buffers[i]));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数用于录制绘制命令，其中的逻辑也是司空见惯，无非是开启渲染通道，设置动态阶段（这里是视口和剪裁区域），绑定PSO，绑定描述符集，绑定索引和顶点缓冲，最后调用间接绘制函数。不过这里还是有一些细节需要注意一下：首先是代码绑定了两个顶点缓冲区，分别绑定于绑定点0，1上，其中后一个绑定的缓冲区存储的就是实例信息。另外，根据硬件是否支持mdi以及是否启用mdi，调用间接绘制的方式也是不同的，如果支持且启用了mdi，那么就可以一个绘制调用绘制所有物体，反之则只能每个实例都调用一次绘制函数了，并且还需要为每个绘制指定绘制参数在绘制参数缓冲区中的偏移。</p><h3 id="cpu_cull">cpu_cull</h3><p>在准备阶段的最后，还需要进行一次CPU端的视锥剔除，这是因为在后面的主渲染循环中我们会看到，在一帧渲染之后程序会进行下一帧的视锥剔除，这也就意味着第一帧的剔除需要在循环之外先行进行。另外，用于传递数据到绘制参数缓冲区的staging buffer也是在第一次调用该函数的时候创建，因此需要在准备阶段先调用一次这个函数，创建好staging buffer并且将第一帧的剔除结果写入到绘制参数缓冲区中，后续如果使用GPU视锥剔除的话才能顺利更新绘制参数缓冲区的内容。下面放上该函数的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::cpu_cull</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cpu_commands.<span class="hljs-built_in">resize</span>(models.<span class="hljs-built_in">size</span>());<br><br>	<span class="hljs-function">VisibilityTester <span class="hljs-title">tester</span><span class="hljs-params">(scene_uniform.proj * scene_uniform.view)</span></span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; models.<span class="hljs-built_in">size</span>(); ++i)<br>	&#123;<br>		<span class="hljs-comment">// we control visibility by changing the instance count</span><br>		<span class="hljs-keyword">auto</span>                        &amp;model = models[i];<br>		VkDrawIndexedIndirectCommand cmd&#123;&#125;;<br>		cmd.firstIndex    = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(model.index_buffer_offset / (<span class="hljs-built_in">sizeof</span>(model.triangles[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])));<br>		cmd.indexCount    = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(model.triangles.<span class="hljs-built_in">size</span>()) * <span class="hljs-number">3</span>;<br>		cmd.vertexOffset  = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int32_t</span>&gt;(model.vertex_buffer_offset / <span class="hljs-built_in">sizeof</span>(Vertex));<br>		cmd.firstInstance = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(i);<br>		cmd.instanceCount = tester.<span class="hljs-built_in">is_visible</span>(model.bounding_sphere.center, model.bounding_sphere.radius);<br>		cpu_commands[i]   = cmd;<br>	&#125;<br><br>	<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> call_buffer_size = cpu_commands.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(cpu_commands[<span class="hljs-number">0</span>]);<br>	<span class="hljs-built_in">assert</span>(!!indirect_call_buffer &amp;&amp; indirect_call_buffer-&gt;<span class="hljs-built_in">get_size</span>() == call_buffer_size);<br><br>	<span class="hljs-keyword">if</span> (!cpu_staging_buffer || cpu_staging_buffer-&gt;<span class="hljs-built_in">get_size</span>() != call_buffer_size)<br>	&#123;<br>		cpu_staging_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), models.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(VkDrawIndexedIndirectCommand), VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VMA_MEMORY_USAGE_CPU_TO_GPU);<br>	&#125;<br><br>	cpu_staging_buffer-&gt;<span class="hljs-built_in">update</span>(cpu_commands.<span class="hljs-built_in">data</span>(), call_buffer_size, <span class="hljs-number">0</span>);<br>	cpu_staging_buffer-&gt;<span class="hljs-built_in">flush</span>();<br><br>	<span class="hljs-keyword">auto</span> &amp;transfer_cmd = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_command_pool</span>().<span class="hljs-built_in">request_command_buffer</span>();<br>	transfer_cmd.<span class="hljs-built_in">begin</span>(VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, VK_NULL_HANDLE);<br>	transfer_cmd.<span class="hljs-built_in">copy_buffer</span>(*cpu_staging_buffer, *indirect_call_buffer, call_buffer_size);<br>	transfer_cmd.<span class="hljs-built_in">end</span>();<br><br>	<span class="hljs-keyword">auto</span> &amp;queue = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_by_flags</span>(VK_QUEUE_GRAPHICS_BIT, <span class="hljs-number">0</span>);<br>	queue.<span class="hljs-built_in">submit</span>(transfer_cmd, <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">request_fence</span>());<br>	<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_fence_pool</span>().<span class="hljs-built_in">wait</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是在CPU端通过视锥裁剪更新绘制参数向量的内容。为了指定绘制参数，对每个<code>submesh</code>，我们都需要填写<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDrawIndexedIndirectCommand.html"><code>VkDrawIndexedIndirectCommand</code></a>结构体，为了指定该<code>submesh</code>的绘制参数，我们需要指定它的顶点在顶点缓冲区中的范围，这是通过指定索引的起始偏移和数量，结合顶点的偏移来计算的，其偏移量可以很容易地根据之前在<code>SceneModel</code>结构体中保存的偏移量得到（实际上这个偏移量也就是顺次保存这些<code>submesh</code>的顶点和索引数据时排在该<code>submesh</code>之前的所有顶点和索引的数目）。然后还需要指定的绘制参数是本次绘制的实例偏移以及数目，偏移就是本次绘制的模型在<code>SceneModel</code>向量中的偏移（这样后续顶点着色器在获取实例缓冲区信息的时候就会根据这个偏移索引到正确的实例模型信息），而绘制的实例数目取决于视锥剔除的结果，通过视锥剔除了就绘制一个实例，否则不绘制。可以看到视锥剔除是通过一个自定义的判断可见性结构体<code>VisibilityTester</code>来完成的，它的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Test for visibility using bounding sphere.</span><br><span class="hljs-comment"> * See https://www.gamedevs.org/uploads/fast-extraction-viewing-frustum-planes-from-world-view-projection-matrix.pdf</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">VisibilityTester</span><br>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">VisibilityTester</span><span class="hljs-params">(glm::mat4x4 view_matrix)</span> :</span><br><span class="hljs-function">	    planes(get_view_planes(view_matrix))</span><br><span class="hljs-function">	&#123;</span>&#125;<br>	std::array&lt;glm::vec4, 6&gt; planes;<br><br>	<span class="hljs-function"><span class="hljs-type">static</span> std::array&lt;glm::vec4, 6&gt; <span class="hljs-title">get_view_planes</span><span class="hljs-params">(<span class="hljs-type">const</span> glm::mat4x4 &amp;mat)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> glm;<br>		std::array&lt;vec4, 6&gt; out&#123;&#125;;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i)<br>		&#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; ++j)<br>			&#123;<br>				<span class="hljs-type">const</span> <span class="hljs-type">float</span> sign = j ? <span class="hljs-number">1.f</span> : <span class="hljs-number">-1.f</span>;<br>				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; ++k)<br>				&#123;<br>					out[<span class="hljs-number">2</span> * i + j][k] = mat[k][<span class="hljs-number">3</span>] + sign * mat[k][i];<br>				&#125;<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">// normalize plane; see Appendix A.2</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;plane : out)<br>		&#123;<br>			plane /= <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-built_in">length</span>(<span class="hljs-built_in">vec3</span>(plane.xyz)));<br>		&#125;<br>		<span class="hljs-keyword">return</span> out;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_visible</span><span class="hljs-params">(glm::vec3 origin, <span class="hljs-type">float</span> radius)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> glm;<br>		std::array&lt;<span class="hljs-type">int</span>, 4&gt; V&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>		<span class="hljs-keyword">return</span> std::<span class="hljs-built_in">all_of</span>(V.<span class="hljs-built_in">begin</span>(), V.<span class="hljs-built_in">end</span>(), [<span class="hljs-keyword">this</span>, origin, radius](<span class="hljs-type">size_t</span> i) &#123;<br>			<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;plane = planes[i];<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">dot</span>(origin, <span class="hljs-built_in">vec3</span>(plane.xyz)) + plane.w + radius &gt;= <span class="hljs-number">0</span>;<br>		&#125;);<br>	&#125;<br>&#125;;<br><br>&#125;        <span class="hljs-comment">// namespace</span><br></code></pre></td></tr></table></figure><p>判断一个物体是不是处于视锥体内，只需要判断这个物体是不是位于视锥体的每一个面内（即面的法线向量同侧），如果是则说明该物体可见（不过这里的实现实际上只是判断了物体在不在左右和前后平面内，不知道为啥。。。），反之则需要剔除。在<a target="_blank" rel="noopener" href="https://www.gamedevs.org/uploads/fast-extraction-viewing-frustum-planes-from-world-view-projection-matrix.pdf"><code>注释中给出的文章</code></a>中详细地给出了从投影矩阵或者VP矩阵或者MVP矩阵重建视锥体六个面的方法，简单来讲其实就是一个线性变换，将齐次裁剪空间中的平面方程变为观察空间（或者世界空间，或者模型空间）中的平面方程，而这个线性变换其实就由投影矩阵（或者VP,MVP矩阵）给出。具体的实现读者可以自行详细分析。</p><p>接下来当然就是将CPU端的数据首先上传到staging buffer，然后再用staging buffer中的数据更新绘制参数缓冲区，这里不再赘述。</p><h3 id="run_cull">run_cull</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::run_cull</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">switch</span> (render_mode)<br>	&#123;<br>		<span class="hljs-keyword">case</span> RenderMode::CPU:<br>			<span class="hljs-built_in">cpu_cull</span>();<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> RenderMode::GPU:<br>		<span class="hljs-keyword">case</span> RenderMode::GPU_DEVICE_ADDRESS:<br>			<span class="hljs-built_in">run_gpu_cull</span>();<br>			<span class="hljs-keyword">break</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在准备阶段的最后，执行玩CPU剔除后，程序还执行了一次剔除。由于程序的默认剔除模式是GPU，所以事实上在第一帧之前程序还会进行一次GPU的剔除，那么我们就顺势分析一下GPU剔除函数<i><font color="Green">run_gpu_cull</font></i>都做了什么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::run_gpu_cull</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">assert</span>(!!gpu_cull_pipeline);<br>	<span class="hljs-keyword">auto</span>                     cmd   = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">create_command_buffer</span>(VK_COMMAND_BUFFER_LEVEL_PRIMARY);<br>	VkCommandBufferBeginInfo begin = vkb::initializers::<span class="hljs-built_in">command_buffer_begin_info</span>();<br><br>	<span class="hljs-built_in">vkBeginCommandBuffer</span>(cmd, &amp;begin);<br>	<span class="hljs-keyword">auto</span> bind = [&amp;cmd](VkPipeline &amp;_pipeline, VkPipelineLayout &amp;_pipeline_layout, VkDescriptorSet &amp;_descriptor_set) &#123;<br>		<span class="hljs-built_in">vkCmdBindPipeline</span>(cmd, VK_PIPELINE_BIND_POINT_COMPUTE, _pipeline);<br>		<span class="hljs-built_in">vkCmdBindDescriptorSets</span>(cmd, VK_PIPELINE_BIND_POINT_COMPUTE, _pipeline_layout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;_descriptor_set, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>	&#125;;<br><br>	<span class="hljs-keyword">if</span> (render_mode == RenderMode::GPU)<br>	&#123;<br>		<span class="hljs-built_in">bind</span>(gpu_cull_pipeline, gpu_cull_pipeline_layout, gpu_cull_descriptor_set);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-built_in">bind</span>(device_address_pipeline, device_address_pipeline_layout, device_address_descriptor_set);<br>	&#125;<br><br>	<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> dispatch_x = !models.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">1</span> + <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;((models.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) / <span class="hljs-number">64</span>) : <span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">vkCmdDispatch</span>(cmd, dispatch_x, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">vkEndCommandBuffer</span>(cmd);<br><br>	VkSubmitInfo submit       = vkb::initializers::<span class="hljs-built_in">submit_info</span>();<br>	submit.commandBufferCount = <span class="hljs-number">1</span>;<br>	submit.pCommandBuffers    = &amp;cmd;<br><br>	<span class="hljs-built_in">vkQueueSubmit</span>(compute_queue-&gt;<span class="hljs-built_in">get_handle</span>(), <span class="hljs-number">1</span>, &amp;submit, <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">request_fence</span>());<br>	<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_fence_pool</span>().<span class="hljs-built_in">wait</span>();<br>	<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_fence_pool</span>().<span class="hljs-built_in">reset</span>();<br>	<span class="hljs-comment">// we&#x27;re done so dealloc it from the pool.</span><br>	<span class="hljs-built_in">vkFreeCommandBuffers</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_command_pool</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-number">1</span>, &amp;cmd);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，<i><font color="Green">run_gpu_cull</font></i>函数就是录制了执行GPU剔除的命令并且提交计算队列执行。启动GPU剔除的过程十分简单，就是绑定管线对象以及所需的描述符集，然后执行dispatch即可。可以看到程序是将一个工作组的大小设置为了64。最后代码是设定为让CPU端等待命令执行完毕。实际上为了追求更高的效率，是可以让上一帧的CS在运行的时候就进行下一帧的前置逻辑的，不过就需要在下一帧绘制开始之前同步CS，使得在渲染开始前CS已经执行完毕。</p><hr><h2 id="渲染阶段">渲染阶段</h2><p>漫长的准备阶段终于是结束了，接下来就开始进入渲染循环的分析了。渲染循环主要调用的是<i><font color="Green">render</font></i>函数，其代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::render</span><span class="hljs-params">(<span class="hljs-type">float</span> delta_time)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (!prepared)<br>	&#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (render_mode == GPU_DEVICE_ADDRESS &amp;&amp; !m_supports_buffer_device)<br>	&#123;<br>		render_mode = GPU;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (m_requires_rebuild)<br>	&#123;<br>		<span class="hljs-built_in">rebuild_command_buffers</span>();<br>		m_requires_rebuild = <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	<span class="hljs-built_in">draw</span>();<br><br>	<span class="hljs-built_in">update_scene_uniform</span>();<br><br>	<span class="hljs-keyword">if</span> (!m_freeze_cull)<br>	&#123;<br>		<span class="hljs-built_in">run_cull</span>();<br>	&#125;<br>	<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_fence_pool</span>().<span class="hljs-built_in">wait</span>();<br>	<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_fence_pool</span>().<span class="hljs-built_in">reset</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到一帧的渲染主逻辑就是绘制——更新场景属性——进行下一帧的剔除。更新场景信息和进行剔除的函数已经在前文分析过了，下面只需要来看<i><font color="Green">draw</font></i>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	ApiVulkanSample::<span class="hljs-built_in">prepare_frame</span>();<br><br>	<span class="hljs-comment">// Command buffer to be submitted to the queue</span><br>	submit_info.commandBufferCount = <span class="hljs-number">1</span>;<br>	submit_info.pCommandBuffers    = &amp;draw_cmd_buffers[current_buffer];<br><br>	<span class="hljs-comment">// Submit to queue</span><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkQueueSubmit</span>(queue, <span class="hljs-number">1</span>, &amp;submit_info, VK_NULL_HANDLE));<br><br>	ApiVulkanSample::<span class="hljs-built_in">submit_frame</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到<i><font color="Green">draw</font></i>的代码逻辑也十分简单，就是准备好渲染所需的资源（交换链图像等），然后提交准备阶段录制好的渲染命令（每一帧渲染命令都是一致的，无需每帧录制），最后显示渲染结果即可。</p><p>代码部分就此分析完毕，可喜可贺！！</p><h2 id="效果对比">效果对比</h2><p>下面来看一下在我的电脑上使用不同的视锥剔除方式运行该示例的性能分别怎么样：</p><figure><img src="/2025/02/23/CG_api/vulkan/vulkan_samples/multi_draw_indirect/cpu.png" srcset="/img/loading.gif" lazyload alt="CPU Cull"><figcaption aria-hidden="true">CPU Cull</figcaption></figure><figure><img src="/2025/02/23/CG_api/vulkan/vulkan_samples/multi_draw_indirect/gpu.png" srcset="/img/loading.gif" lazyload alt="GPU Cull"><figcaption aria-hidden="true">GPU Cull</figcaption></figure><figure><img src="/2025/02/23/CG_api/vulkan/vulkan_samples/multi_draw_indirect/gpu_da.png" srcset="/img/loading.gif" lazyload alt="GPU Address Cull"><figcaption aria-hidden="true">GPU Address Cull</figcaption></figure><p>可以看到反而是CPU剔除的效率最高，难道是因为场景不够大，还无法完全发挥出GPU大人的实力吗（</p><hr><h2 id="尝试welzl算法">尝试Welzl算法</h2><p>最后，官方示例在计算包围球的代码（也就是包围球构造函数）中提到了Welzl算法是计算最佳包围球的算法。于是我就想着要么去实现一下这个算法，算法逻辑和代码框架可以参考<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/minimum-enclosing-circle-using-welzls-algorithm/"><code>这篇文章</code></a>，简单点说其实就是一个递归算法：包含n个点的最小包围球，可以由包含n-1个点的最小包围球得到，如果这n-1个点的最小包围球包含第n个点，那么这n-1个点的最小包围球就是这n个点的最小包围球，如果不然，则第n个点一定在最小包围球的边界上（证明也比较容易，读者可以自行想象）。我当时一看逻辑和代码框架，感觉这不是很好理解吗？于是马上兴致勃勃地动手实践了一下：首先在应用程序类中新添一个枚举类<i><font color="Orange">CalcMethod</font></i>用于代表包围球的计算方式是按照原来程序的方式计算还是按照Welzl算法计算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">CalcMethod</span><br>&#123;<br>	SIMPLE,<br>	WELZL<br>&#125; calc_method = SIMPLE;<br></code></pre></td></tr></table></figure><p>然后在程序窗口中新添一个选项框用于选择包围球的计算模式。</p><p>在准备场景的<i><font color="Green">load_scene</font></i>函数中，我准备直接计算好每个模型的简单包围球和Welzl包围球，并一并保存在<code>SceneModel</code>结构体中。然后就是包围球计算的实现，这里放上我写的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs c++">MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">BoundingSphere</span>(<span class="hljs-type">const</span> std::vector&lt;glm::vec3&gt; &amp;pts, CalcMethod method)<br>&#123;<br>	<span class="hljs-keyword">if</span> (method == CalcMethod::SIMPLE)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (pts.<span class="hljs-built_in">empty</span>())<br>		&#123;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br><br>		<span class="hljs-comment">// This is a simple method of calculating a bounding sphere.</span><br>		<span class="hljs-comment">// For finding an optimal bounding sphere, see Welzl&#x27;s algorithm</span><br>		<span class="hljs-keyword">this</span>-&gt;center = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;pt : pts)<br>		&#123;<br>			<span class="hljs-keyword">this</span>-&gt;center += pt;<br>		&#125;<br>		<span class="hljs-keyword">this</span>-&gt;center /= <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(pts.<span class="hljs-built_in">size</span>());<br>		<span class="hljs-keyword">this</span>-&gt;radius = glm::<span class="hljs-built_in">distance2</span>(pts[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>-&gt;center);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">1</span>; i &lt; pts.<span class="hljs-built_in">size</span>(); ++i)<br>		&#123;<br>			<span class="hljs-keyword">this</span>-&gt;radius = std::<span class="hljs-built_in">max</span>(<span class="hljs-keyword">this</span>-&gt;radius, glm::<span class="hljs-built_in">distance2</span>(pts[i], <span class="hljs-keyword">this</span>-&gt;center));<br>		&#125;<br>		<span class="hljs-keyword">this</span>-&gt;radius = std::<span class="hljs-built_in">nextafter</span>(<span class="hljs-built_in">sqrtf</span>(<span class="hljs-keyword">this</span>-&gt;radius), std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">max</span>());<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		std::vector&lt;glm::vec3&gt; points = pts;<br>		std::random_device rd;<br>		<span class="hljs-function">std::mt19937 <span class="hljs-title">g</span><span class="hljs-params">(rd())</span></span>; <br>		std::<span class="hljs-built_in">shuffle</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), g);<br>		<span class="hljs-built_in">welzlHelper</span>(points, &#123;&#125;, pts.<span class="hljs-built_in">size</span>());<br>	&#125;<br>&#125;<br><br><span class="hljs-type">void</span> MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">welzlHelper</span>(std::vector&lt;glm::vec3&gt; points, std::vector&lt;glm::vec3&gt; bounds, <span class="hljs-type">int</span> n)<br>&#123;<br>	<span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || bounds.<span class="hljs-built_in">size</span>() == <span class="hljs-number">3</span>)<br>	&#123;<br>		<span class="hljs-built_in">minCircleTrivial</span>(bounds);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-type">int</span> id = <span class="hljs-built_in">rand</span>() % n;<br>	glm::vec3 point = points[id];<br><br>	std::<span class="hljs-built_in">swap</span>(points[id], points[n - <span class="hljs-number">1</span>]);<br><br>	<span class="hljs-built_in">welzlHelper</span>(points, bounds, n<span class="hljs-number">-1</span>);<br><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isInside</span>(center, radius, point))<br>	&#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<br>	bounds.<span class="hljs-built_in">push_back</span>(point);<br>	<span class="hljs-built_in">welzlHelper</span>(points, bounds, n - <span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">void</span> MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">minCircleTrivial</span>(std::vector&lt;glm::vec3&gt; points) &#123;<br>	<span class="hljs-built_in">assert</span>(points.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">3</span>);<br><br>	<span class="hljs-keyword">if</span> (points.<span class="hljs-built_in">empty</span>())<br>	&#123;<br>		center = &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;;<br>		radius = <span class="hljs-number">0.0f</span>;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (points.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>	&#123;<br>		center = points[<span class="hljs-number">0</span>];<br>		radius = <span class="hljs-number">0.0f</span>;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (points.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>)<br>	&#123;<br>		<span class="hljs-built_in">circleFrom</span>(points[<span class="hljs-number">0</span>], points[<span class="hljs-number">1</span>]);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>	&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">3</span>; j++)<br>		&#123;<br>			<span class="hljs-built_in">circleFrom</span>(points[i], points[j]);<br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValidCircle</span>(center, radius, points))<br>			&#123;<br>				<span class="hljs-keyword">return</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-built_in">circleFrom</span>(points[<span class="hljs-number">0</span>], points[<span class="hljs-number">1</span>], points[<span class="hljs-number">2</span>]);<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">isInside</span>(glm::vec3 center, <span class="hljs-type">float</span> radius, glm::vec3 point)<br>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>(center, point) &lt;= radius - epsilon;<br>&#125;<br><br><span class="hljs-type">bool</span> MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">isValidCircle</span>(glm::vec3 center, <span class="hljs-type">float</span> radius, std::vector&lt;glm::vec3&gt; points)<br>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;p : points)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isInside</span>(center, radius, p))<br>		&#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">float</span> MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">dist</span>(glm::vec3 point_1, glm::vec3 point_2)<br>&#123;<br>	<span class="hljs-keyword">return</span> std::<span class="hljs-built_in">nextafter</span>(<span class="hljs-built_in">sqrtf</span>(glm::<span class="hljs-built_in">dot</span>(point_2 - point_1, point_2 - point_1)), std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">max</span>());<br>&#125;<br><br><span class="hljs-type">void</span> MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">circleFrom</span>(glm::vec3 point_1, glm::vec3 point_2)<br>&#123;<br>	center = (point_1 + point_2) / <span class="hljs-number">2.0f</span>;<br>	radius = <span class="hljs-built_in">dist</span>(point_1, point_2) / <span class="hljs-number">2.0f</span>;<br>&#125;<br><br><span class="hljs-type">void</span> MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">circleFrom</span>(glm::vec3 point_1, glm::vec3 point_2, glm::vec3 point_3)<br>&#123;<br>	center = point_1 + <span class="hljs-built_in">getCircleCenter</span>(point_2 - point_1, point_3 - point_1);<br>	radius = <span class="hljs-built_in">dist</span>(center, point_1);<br>&#125;<br><br>glm::vec3 MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">getCircleCenter</span>(glm::vec3 vec_1, glm::vec3 vec_2)<br>&#123;<br>	<span class="hljs-type">float</span> length_1 = glm::<span class="hljs-built_in">dot</span>(vec_1, vec_1);<br>	<span class="hljs-type">float</span> length_2 = glm::<span class="hljs-built_in">dot</span>(vec_2, vec_2);<br>	<span class="hljs-type">float</span> dot=glm::<span class="hljs-built_in">dot</span>(vec_1,vec_2);<br><br>	<span class="hljs-type">float</span> x = (length_1 * length_2 - length_2 * dot) / (<span class="hljs-number">2</span> * (length_1 * length_2 - dot * dot));<br>	<span class="hljs-type">float</span> y = (length_1 * length_2 - length_1 * dot) / (<span class="hljs-number">2</span> * (length_1 * length_2 - dot * dot));<br><br>	<span class="hljs-keyword">return</span> x * vec_1 + y * vec_2;<br>&#125;<br></code></pre></td></tr></table></figure><p>大功告成！本来以为程序就能这么愉快地运行下去了，然而事与愿违：由于这是一个递归算法，由于模型的顶点过多，直接让调用栈内存爆了。。。我这是真没辙啊，也没有看到相应的迭代实现，自己也想不出来。本想着是不是可以保留部分离模型中心点较远的点，然后仅仅计算这部分点的包围球作为整个模型的包围球，但想来想去都无法严谨地证明这么做得到的包围球一定可以包含所有模型顶点，几种选点的方法都被自己证伪了。。。然后只能在google上漫无目的地搜查优化方案，结果还真给找到了，不过是<a target="_blank" rel="noopener" href="https://informatica.vu.lt/journal/INFORMATICA/article/1251/text"><code>一篇论文</code></a>，大致思路其实也是选择部分点计算包围球，但是整体看上去还是比较复杂的，虽说看懂没问题，但复现还是需要花费大量的时间，目前时间紧张，只能挖个坑日后来填了~</p><hr></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/CG-api/" class="category-chain-item">CG_api</a> <span>></span> <a href="/categories/CG-api/vulkan/" class="category-chain-item">vulkan</a> <span>></span> <a href="/categories/CG-api/vulkan/vulkan-samples/" class="category-chain-item">vulkan_samples</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>post</div><div>http://example.com/2025/02/23/CG_api/vulkan/vulkan_samples/multi_draw_indirect/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>ZPC-dsg</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年2月23日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/2025/02/17/CG_api/d3d11/d3d11_with_windowsSDK/%E5%88%9D%E7%BA%A7%E7%AF%87%E7%BB%86%E8%8A%82%E8%A1%A5%E5%85%85/" title="post"><span class="hidden-mobile">post</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>