<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>临时缓冲区</title>
    <link href="/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/"/>
    <url>/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>创建顶点缓冲</title>
    <link href="/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/"/>
    <url>/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在<a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0/">上一章</a>创建好实际的顶点数据以及顶点描述之后，现在我们需要创建用于读取、写入和存储这些数据以供GPU使用的部件，那就是顶点缓冲。创建和使用顶点缓冲可以分为四步：</p><ul><li>创建缓冲对象</li><li>分配缓冲内存</li><li>填充顶点数据</li><li>绑定顶点缓冲</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Vertex_buffers/Vertex_buffer_creation">Vertexbuffer creation</a>章节。</p><hr><h2 id="创建缓冲对象">创建缓冲对象</h2><p>首先，在<i><font color="Green">initVulkan</font></i>函数中的<i><font color="Green">createCommandBuffers</font></i>函数之前添加一个成员函数<i><font color="Green">voidcreateVertexBuffer()</font></i>用来完成顶点缓冲对象的创建，并且在类内新增一个成员<i><font color="Orange">VkBuffervertexBuffer</font></i>来保存创建的顶点缓冲对象。</p><p>要创建顶点缓冲，我们当然需要首先填写创建结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferCreateInfo.html"><code>VkBufferCreateInfo</code></a>有关信息，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkBufferCreateInfo</span> &#123;</span><br>    VkStructureType        sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*            pNext;<br>    VkBufferCreateFlags    flags;<br>    VkDeviceSize           size;<br>    VkBufferUsageFlags     usage;<br>    VkSharingMode          sharingMode;<br>    <span class="hljs-type">uint32_t</span>               queueFamilyIndexCount;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*        pQueueFamilyIndices;<br>&#125; VkBufferCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>涉及到稀疏内存等特殊的缓冲参数，这里我们不会使用到，不做过多介绍。</p><p><i><font color="Orange">usage</font></i>代表该缓冲区的使用方式，它的可能取值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkBufferUsageFlagBits</span> &#123;</span><br>    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = <span class="hljs-number">0x00000001</span>,<br>    VK_BUFFER_USAGE_TRANSFER_DST_BIT = <span class="hljs-number">0x00000002</span>,<br>    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = <span class="hljs-number">0x00000004</span>,<br>    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = <span class="hljs-number">0x00000008</span>,<br>    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = <span class="hljs-number">0x00000010</span>,<br>    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = <span class="hljs-number">0x00000020</span>,<br>    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = <span class="hljs-number">0x00000040</span>,<br>    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = <span class="hljs-number">0x00000080</span>,<br>    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = <span class="hljs-number">0x00000100</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = <span class="hljs-number">0x00020000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_decode_queue</span><br>    VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR = <span class="hljs-number">0x00002000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_decode_queue</span><br>    VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR = <span class="hljs-number">0x00004000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_transform_feedback</span><br>    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = <span class="hljs-number">0x00000800</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_transform_feedback</span><br>    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = <span class="hljs-number">0x00001000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_conditional_rendering</span><br>    VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = <span class="hljs-number">0x00000200</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> VK_ENABLE_BETA_EXTENSIONS</span><br>  <span class="hljs-comment">// Provided by VK_AMDX_shader_enqueue</span><br>    VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX = <span class="hljs-number">0x02000000</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br>    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = <span class="hljs-number">0x00080000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br>    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = <span class="hljs-number">0x00100000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_ray_tracing_pipeline</span><br>    VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR = <span class="hljs-number">0x00000400</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_encode_queue</span><br>    VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR = <span class="hljs-number">0x00008000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_encode_queue</span><br>    VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = <span class="hljs-number">0x00010000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_descriptor_buffer</span><br>    VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = <span class="hljs-number">0x00200000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_descriptor_buffer</span><br>    VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = <span class="hljs-number">0x00400000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_descriptor_buffer</span><br>    VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = <span class="hljs-number">0x04000000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_opacity_micromap</span><br>    VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = <span class="hljs-number">0x00800000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_opacity_micromap</span><br>    VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT = <span class="hljs-number">0x01000000</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_ray_tracing</span><br>    VK_BUFFER_USAGE_RAY_TRACING_BIT_NV = VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR,<br>  <span class="hljs-comment">// Provided by VK_EXT_buffer_device_address</span><br>    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,<br>  <span class="hljs-comment">// Provided by VK_KHR_buffer_device_address</span><br>    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,<br>&#125; VkBufferUsageFlagBits;<br></code></pre></td></tr></table></figure><p>可能的取值较多，我们不做一一介绍，这里我们希望将该缓冲区用作顶点缓冲，在之后的章节中我们会涉及到一些其它的缓冲类型。</p><p><i><font color="Orange">sharingMode</font></i>代表该缓冲的共享模式，缓冲区和交换链的图像一样可以被多个队列家族共享，我们这里只有一个队列家族需要使用该缓冲区，即图像队列家族，所以该成员设置为<i><font color="Red">VK_SHARING_MODE_EXCLUSIVE</font></i>即可。</p><p>最后的两个成员用于指定共享该缓冲的队列家族的数量及各自对应的索引，如果共享模式设置为<i><font color="Red">VK_SHARING_MODE_EXCLUSIVE</font></i>，那么这两个成员无需显式指定。</p><p>因此，我们的<i><font color="Green">createVertexBuffer</font></i>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createVertexBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>    VkBufferCreateInfo bufferInfo&#123;&#125;;<br>    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;<br>    bufferInfo.size = <span class="hljs-built_in">sizeof</span>(vertices[<span class="hljs-number">0</span>]) * vertices.<span class="hljs-built_in">size</span>();<br>    bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;<br>    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateBuffer</span>(device, &amp;bufferInfo, <span class="hljs-literal">nullptr</span>, &amp;vertexBuffer) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create vertex buffer!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="分配缓冲内存">分配缓冲内存</h2><p>与我们之前创建的那些Vulkan对象不同，缓冲对象在创建后Vulkan并不会为其自动分配内存，我们需要手动为缓冲对象分配内存。</p><p>在分配内存之前，我们首先需要查询创建的顶点缓冲对象对分配的内存有什么要求以及我们使用的物理设备可以分配的内存种类中是否有满足这些要求的种类，在查询有内存种类满足要求后我们才能真正为缓冲对象分配内存，下面我们依次进行这三步。</p><h4 id="查询内存要求">查询内存要求</h4><p>查询内存要求可以简单地通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetBufferMemoryRequirements.html"><code>vkGetBufferMemoryRequirements</code></a>函数来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkMemoryRequirements memRequirements;<br><span class="hljs-built_in">vkGetBufferMemoryRequirements</span>(device, vertexBuffer, &amp;memRequirements);<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkMemoryRequirements.html"><code>VkMemoryRequirements</code></a>结构体包含了缓冲对象对内存的要求明细，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkMemoryRequirements</span> &#123;</span><br>    VkDeviceSize    size;<br>    VkDeviceSize    alignment;<br>    <span class="hljs-type">uint32_t</span>        memoryTypeBits;<br>&#125; VkMemoryRequirements;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">size</font></i>描述需要分配内存的大小，这个大小有可能和内存中真正存储的缓冲数据大小不一致（因为存储在这块内存中的数据可能会有偏移）。</p><p><i><font color="Orange">alignment</font></i>代表缓冲数据的起始位置相对于缓冲内存的起始位置的偏移，这个数值取决于缓冲区的使用方式（<i><font color="Orange">usage</font></i>成员）以及标志位（<i><font color="Orange">flags</font></i>成员）。</p><p><i><font color="Orange">memoryTypeBits</font></i>代表适用于该缓冲的内存类型，它是一些内存类型的位组合，具体来说就是如果查询物理设备内存属性（使用<a href="https://vkdoc.net/man/vkGetPhysicalDeviceMemoryProperties"><code>VkGetPhysicalDeviceMemoryProperties</code></a>，也就是接下来的第二步）得到的结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryProperties.html"><code>VkPhysicalDeviceMemoryProperties</code></a>中的内存类型i （用位<strong>1&lt;&lt;i</strong>表示）支持用于该缓冲对象时，位 i就会被置位。</p><h4 id="寻找满足要求的内存类型">寻找满足要求的内存类型</h4><p>接下来我们需要寻找物理设备支持的内存类型中是否有满足顶点缓冲需求的类型。我们创建一个<i><font color="Green">uint32_tfindMemoryType(uint32_t typeFilter, VkMemoryPropertyFlagsproperties)</font></i>函数来完成有关工作。</p><p>首先，我们当然需要查询物理设备所支持的所有内存属性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPhysicalDeviceMemoryProperties memProperties;<br><span class="hljs-built_in">vkGetPhysicalDeviceMemoryProperties</span>(physicalDevice, &amp;memProperties);<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryProperties.html"><code>VkPhysicalDeviceMemoryProperties</code></a>结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VkPhysicalDeviceMemoryProperties</span> &#123;<br>    <span class="hljs-type">uint32_t</span>        memoryTypeCount;<br>    VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];<br>    <span class="hljs-type">uint32_t</span>        memoryHeapCount;<br>    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];<br>&#125; VkPhysicalDeviceMemoryProperties;<br></code></pre></td></tr></table></figure><p>该结构体主要包含两方面内存信息：内存类型和内存所属堆。内存堆指的是一些内存资源，如专用的显存（VRAM）和当显存不足时用于交换的RAM空间，不同种类的内存可能从不同种类的内存堆中分配。这里我们只考虑内存类型。</p><p>接下来我们从这些支持类型中寻找满足缓冲区需求的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; memProperties.memoryTypeCount; i++) &#123;<br>    <span class="hljs-keyword">if</span> ((typeFilter &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) &amp;&amp; (memProperties.memoryTypes[i].propertyFlags &amp; properties) == properties) &#123;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断一个类型是否满足需求分为两个方面：一是判断该类型对应的位i是否在缓冲区的<i><font color="Orange">memoryTypeBits</font></i>中置位，如果置位说明该类型可供缓冲区使用；二是判断该类型是否具有我们需要的内存属性，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkMemoryType.html"><code>VkMemoryType</code></a>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkMemoryType</span> &#123;</span><br>    VkMemoryPropertyFlags    propertyFlags;<br>    <span class="hljs-type">uint32_t</span>                 heapIndex;<br>&#125; VkMemoryType;<br></code></pre></td></tr></table></figure><p>有关属性的部分我们会在下一步详细描述。</p><h4 id="分配缓冲区内存">分配缓冲区内存</h4><p>如果寻找到了满足缓冲区要求的内存类型。接下来我们就可以分配相应的内存了。分配缓冲区内存需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkMemoryAllocateInfo.html"><code>VkMemoryAllocateInfo</code></a>结构体，其定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkMemoryAllocateInfo</span> &#123;</span><br>    VkStructureType    sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*        pNext;<br>    VkDeviceSize       allocationSize;<br>    <span class="hljs-type">uint32_t</span>           memoryTypeIndex;<br>&#125; VkMemoryAllocateInfo;<br></code></pre></td></tr></table></figure></p><p>每个成员的含义都是易于理解的，我们的分配代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkMemoryAllocateInfo allocInfo&#123;&#125;;<br>allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;<br>allocInfo.allocationSize = memRequirements.size;<br>allocInfo.memoryTypeIndex = <span class="hljs-built_in">findMemoryType</span>(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);<br></code></pre></td></tr></table></figure><p>这里我们传递给<i><font color="Green">findMemoryType</font></i>函数的属性参数为<i><font color="Red">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT|VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</font></i>。我们这里列举出属性所有可能的取值，并且大致解释以下它们每一个的含义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkMemoryPropertyFlagBits</span> &#123;</span><br>    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//分配的内存能够被设备高效使用</span><br>    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//分配的内存可以映射给CPU使用</span><br>    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//CPU上对该内存的一切修改操作都能立刻一致地同步到GPU上而不需要显式使用vkFlushMappedMemoryRanges和vkInvalidateMappedMemoryRanges同步内存数据一致性</span><br>    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//映射后的内存会置于CPU的高速缓存区，具有更快的访问效率，但是置于主内存的映射后内存一定是host coherent的</span><br>    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = <span class="hljs-number">0x00000010</span>,<span class="hljs-comment">//内存只允许设备访问，并且该内存可能是懒分配的，这个标志不能和VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT set同时使用</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_MEMORY_PROPERTY_PROTECTED_BIT = <span class="hljs-number">0x00000020</span>,<span class="hljs-comment">//内存只允许设备访问，并且只允许具有保护权限的队列操作访问。这个标志不能和VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT、VK_MEMORY_PROPERTY_HOST_COHERENT_BIT或者VK_MEMORY_PROPERTY_HOST_CACHED_BIT 中的任意一个同时使用</span><br>  <span class="hljs-comment">// Provided by VK_AMD_device_coherent_memory</span><br>    VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = <span class="hljs-number">0x00000040</span>,<span class="hljs-comment">//设备对内存的任何修改对CPU立即可见并且一致，一般作调试用，会影响内存使用效率，如非必要不建议使用</span><br>  <span class="hljs-comment">// Provided by VK_AMD_device_coherent_memory</span><br>    VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = <span class="hljs-number">0x00000080</span>,<span class="hljs-comment">//内存不会置于GPU高速缓存区，这样的内存一定是device coherent的</span><br>  <span class="hljs-comment">// Provided by VK_NV_external_memory_rdma</span><br>    VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = <span class="hljs-number">0x00000100</span>,<span class="hljs-comment">//其它设备可以直接访问这块内存</span><br>&#125; VkMemoryPropertyFlagBits;<br></code></pre></td></tr></table></figure><p>我们希望能够将CPU中的顶点数据复制给GPU，因此我们需要分配的缓冲区内存能够将自己映射到CPU上供CPU填充数据，因此我们需要设置<i><font color="Red">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</font></i>；另外，我们希望CPU将数据复值给映射后内存后，GPU能够立即同步该内存信息到自己的内存区域并且开始使用，因此我们需要设置<i><font color="Red">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</font></i>。</p><p>然后我们使用这份信息来分配顶点缓冲内存。首先在类内创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceMemory.html"><code>VkDeviceMemory</code></a>类型的成员<i><font color="Orange">vertexBufferMemory</font></i>，然后调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAllocateMemory.html"><code>vkAllocateMemory</code></a>即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkAllocateMemory</span>(device, &amp;allocInfo, <span class="hljs-literal">nullptr</span>, &amp;vertexBufferMemory) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to allocate vertex buffer memory!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们需要将这块分配好的内存绑定到对应的顶点缓冲区上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkBindBufferMemory</span>(device, vertexBuffer, vertexBufferMemory, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>最后一个参数代表缓冲在该内存中的偏移。我们的内存块中只有一个顶点缓冲，因此偏移设置为0即可，如果该值不为0，那么它一定需要被<i><font color="Orange">memRequirements.alignment</font></i>整除。</p><hr><h2 id="填充顶点数据">填充顶点数据</h2><p>现在我们需要将顶点数据填充至顶点缓存中，这需要我们首先将分配的顶点缓冲内存（在GPU中）映射到CPU可见的内存上，然后将CPU中的顶点数据复制到映射后内存中，之后设备会将该内存中的数据同步到缓冲区中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">void</span>* data;<br><span class="hljs-built_in">vkMapMemory</span>(device, vertexBufferMemory, <span class="hljs-number">0</span>, bufferInfo.size, <span class="hljs-number">0</span>, &amp;data);<br>    <span class="hljs-built_in">memcpy</span>(data, vertices.<span class="hljs-built_in">data</span>(), (<span class="hljs-type">size_t</span>) bufferInfo.size);<br><span class="hljs-built_in">vkUnmapMemory</span>(device, vertexBufferMemory);<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkMapMemory.html"><code>vkMapMemory</code></a>的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkMapMemory</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDevice                                    device,<span class="hljs-comment">//设备</span></span><br><span class="hljs-params">    VkDeviceMemory                              memory,<span class="hljs-comment">//映射的内存</span></span><br><span class="hljs-params">    VkDeviceSize                                offset,<span class="hljs-comment">//映射开始位置在内存中的偏移</span></span><br><span class="hljs-params">    VkDeviceSize                                size,<span class="hljs-comment">//映射内存的范围大小</span></span><br><span class="hljs-params">    VkMemoryMapFlags                            flags,<span class="hljs-comment">//标志位，指定特殊的操作</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span>**                                      ppData)</span>;<span class="hljs-comment">//映射后内存地址</span><br></code></pre></td></tr></table></figure><p>这样就完成了顶点数据的填充。</p><hr><h2 id="绑定顶点缓冲">绑定顶点缓冲</h2><p>最后，我们需要在绘制三角形命令之前将顶点缓冲绑定到着色器的绑定点以供着色器使用，这可以通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers.html"><code>vkCmdBindVertexBuffers</code></a>来完成，该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdBindVertexBuffers</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    firstBinding,<span class="hljs-comment">//第一个绑定点索引</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    bindingCount,<span class="hljs-comment">//绑定点总数</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkBuffer*                             pBuffers,<span class="hljs-comment">//需要绑定的一系列缓冲区</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkDeviceSize*                         pOffsets)</span>;<span class="hljs-comment">//每个缓冲区对应的开始读取数据的偏移</span><br><br></code></pre></td></tr></table></figure><p>然后在录制命令的函数<i><font color="Green">recordCommandBuffer</font></i>中添加录制绑定顶点缓冲区的代码即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdBindPipeline</span>(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);<br><br>VkBuffer vertexBuffers[] = &#123;vertexBuffer&#125;;<br>VkDeviceSize offsets[] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">vkCmdBindVertexBuffers</span>(commandBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, vertexBuffers, offsets);<br><br><span class="hljs-built_in">vkCmdDraw</span>(commandBuffer, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertices.<span class="hljs-built_in">size</span>()), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>大功告成！</p><p><a href="https://zpc-dsg.github.io/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/">下一章</a>我们将看到如何通过临时缓冲区更高效地使用顶点缓冲。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0/">上一篇：顶点输入描述</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/">下一篇：临时缓冲区</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>顶点输入描述</title>
    <link href="/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0/"/>
    <url>/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在接下来的几个章节中，我们将用顶点缓冲代替之前硬编码在着色器中的顶点数据。这一节中，我们首先关注顶点输入数据的描述。创建对顶点数据的描述可以分为三步：</p><ul><li>在CPU中准备好需要传入顶点着色器的数据</li><li>在顶点着色器中添加对输入数据的引用代码</li><li>创建对应于引用代码的两种顶点描述结构体供创建渲染管线时顶点输入阶段使用</li></ul><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Vertex_buffers/Vertex_input_description">Vertexinput description</a>章节。</p><hr><h2 id="定义顶点数据">定义顶点数据</h2><p>为了在CPU中定义我们需要的顶点数据，我们可以使用<a href="https://github.com/g-truc/glm">GLM数学库</a>作为辅助。在程序中新添一个表示每个顶点所包含数据的结构体<i><font color="Orange">Vertex</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vertex</span> &#123;<br>    glm::vec2 pos;<br>    glm::vec3 color;<br>&#125;;<br></code></pre></td></tr></table></figure><p>目前该结构体十分简单，因为我们绘制三角形的程序只需要每个顶点的二维坐标和颜色值。</p><p>然后，在程序代码中添加我们需要传递给顶点着色器的具体的顶点数据即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;Vertex&gt; vertices = &#123;<br>    &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">-0.5f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="着色器添加顶点引用">着色器添加顶点引用</h2><p>现在我们可以去掉顶点着色器中硬编码的顶点数据了。为了引用我们在CPU中定义的顶点数据，我们需要在顶点着色器中添加如下代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inPosition;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inColor;<br></code></pre></td></tr></table></figure><p>顶点着色器代码现在如下所示：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inPosition;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inColor;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fragColor;<br><br><span class="hljs-type">void</span> main() &#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(inPosition, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fragColor = inColor;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>in</strong>关键字代表这些数据将从顶点缓冲读入，<strong>location</strong>关键字代表了对应顶点属性在顶点数据中的位置，这个位置将在后文创建顶点描述结构体的时候被引用以和CPU中定义的顶点数据形成正确的对应从而确保输入着色器数据的正确性。</p><hr><h2 id="创建描述结构体">创建描述结构体</h2><p>下面我们就可以创建与着色器中顶点输入数据格式相匹配的顶点输入描述结构体了。我们需要创建两种结构体：<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkVertexInputBindingDescription.html"><code>VkVertexInputBindingDescription</code></a>和<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkVertexInputAttributeDescription.html"><code>VkVertexInputAttributeDescription</code></a>。</p><h4 id="vkvertexinputbindingdescription">VkVertexInputBindingDescription</h4><p>该结构体用于描述每个顶点的字节大小，即从一个顶点到下一个顶点在缓冲区中的字节距离，并且指定数据是逐顶点的还是逐实例提供的，它的定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkVertexInputBindingDescription</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>             binding;<span class="hljs-comment">//绑定的索引，表示在顶点输入阶段使用的顶点缓冲区的编号</span><br>    <span class="hljs-type">uint32_t</span>             stride;<span class="hljs-comment">//每个顶点的字节大小</span><br>    VkVertexInputRate    inputRate;<span class="hljs-comment">//指定数据是每个顶点（VK_VERTEX_INPUT_RATE_VERTEX）还是每个实例（VK_VERTEX_INPUT_RATE_INSTANCE）提供的</span><br>&#125; VkVertexInputBindingDescription;<br></code></pre></td></tr></table></figure></p><p>每个成员的含义都是易于理解的。为了创建这个描述结构体，我们在<i><font color="Orange">Vertex</font></i>结构体中新增一个创建该结构体的静态函数<i><font color="Green">staticVkVertexInputBindingDescription getBindingDescription()</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> VkVertexInputBindingDescription <span class="hljs-title">getBindingDescription</span><span class="hljs-params">()</span> </span>&#123;<br>    VkVertexInputBindingDescription bindingDescription&#123;&#125;;<br>    <br>    VkVertexInputBindingDescription bindingDescription&#123;&#125;;<br>bindingDescription.binding = <span class="hljs-number">0</span>;<br>bindingDescription.stride = <span class="hljs-built_in">sizeof</span>(Vertex);<br>bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;<br>    <br>    <span class="hljs-keyword">return</span> bindingDescription;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="vkvertexinputattributedescription">VkVertexInputAttributeDescription</h4><p>该结构体用于描述顶点属性，帮助开发者定义如何从顶点缓冲区中提取和解释数据，它的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VkVertexInputAttributeDescription</span> &#123;<br>    <span class="hljs-type">uint32_t</span>    location;<span class="hljs-comment">//属性的索引，表示在着色器中的位置，通常与顶点着色器中的输入变量对应</span><br>    <span class="hljs-type">uint32_t</span>    binding;<span class="hljs-comment">//绑定的索引，指向 VkVertexInputBindingDescription 中定义的绑定，表明该属性属于哪个顶点缓冲区</span><br>    VkFormat    format;<span class="hljs-comment">//属性的数据格式</span><br>    <span class="hljs-type">uint32_t</span>    offset;<span class="hljs-comment">//相对于绑定缓冲区中每个顶点的起始位置的偏移量，指明该属性在顶点数据中的具体位置</span><br>&#125; VkVertexInputAttributeDescription;<br></code></pre></td></tr></table></figure><p>有多少个顶点属性，我们就需要定义多少个相应的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkVertexInputAttributeDescription.html"><code>VkVertexInputAttributeDescription</code></a>结构体。该结构体中的第一个成员<i><font color="Orange">location</font></i>就对应了着色器代码中对应输入顶点属性的location。另外，结构体中的属性格式也要和着色器代码中对应属性数据格式相对应。一般来讲，该结构体中属性格式的颜色通道数应该要和着色器中属性数据的向量长度一致。同样，我们在<i><font color="Orange">Vertex</font></i>结构体中新增一个创建该结构体的静态函数<i><font color="Green">staticstd::array&lt;VkVertexInputAttributeDescription, 2&gt;getAttributeDescriptions()</font></i>（因为我们有两种属性，所以返回一个二元数组）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> std::array&lt;VkVertexInputAttributeDescription, 2&gt; <span class="hljs-title">getAttributeDescriptions</span><span class="hljs-params">()</span> </span>&#123;<br>    std::array&lt;VkVertexInputAttributeDescription, 2&gt; attributeDescriptions&#123;&#125;;<br><br>    attributeDescriptions[<span class="hljs-number">0</span>].binding = <span class="hljs-number">0</span>;<br>attributeDescriptions[<span class="hljs-number">0</span>].location = <span class="hljs-number">0</span>;<br>attributeDescriptions[<span class="hljs-number">0</span>].format = VK_FORMAT_R32G32_SFLOAT;<br>attributeDescriptions[<span class="hljs-number">0</span>].offset = <span class="hljs-built_in">offsetof</span>(Vertex, pos);<br>    <br>    attributeDescriptions[<span class="hljs-number">1</span>].binding = <span class="hljs-number">0</span>;<br>attributeDescriptions[<span class="hljs-number">1</span>].location = <span class="hljs-number">1</span>;<br>attributeDescriptions[<span class="hljs-number">1</span>].format = VK_FORMAT_R32G32B32_SFLOAT;<br>attributeDescriptions[<span class="hljs-number">1</span>].offset = <span class="hljs-built_in">offsetof</span>(Vertex, color);<br>    <br>    <span class="hljs-keyword">return</span> attributeDescriptions;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们准备好了所有顶点输入阶段需要的顶点数据描述结构体，最后我们只需要在创建渲染管线的顶点输入阶段时引用这两个结构体即可（之前我们是没有设置顶点输入阶段的，因为当时顶点数据硬编码在着色器中）。在<i><font color="Green">createGraphicsPipeline</font></i>函数中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> bindingDescription = Vertex::<span class="hljs-built_in">getBindingDescription</span>();<br><span class="hljs-keyword">auto</span> attributeDescriptions = Vertex::<span class="hljs-built_in">getAttributeDescriptions</span>();<br><br>vertexInputInfo.vertexBindingDescriptionCount = <span class="hljs-number">1</span>;<br>vertexInputInfo.vertexAttributeDescriptionCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attributeDescriptions.<span class="hljs-built_in">size</span>());<br>vertexInputInfo.pVertexBindingDescriptions = &amp;bindingDescription;<br>vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/22/CG_api/vulkan/vulkan_tutorial/%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/">上一篇：重建交换链</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/">下一篇：创建顶点缓冲</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>重建交换链</title>
    <link href="/2024/11/22/CG_api/vulkan/vulkan_tutorial/%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/"/>
    <url>/2024/11/22/CG_api/vulkan/vulkan_tutorial/%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>我们的绘制三角形程序已经基本完成了，但仍然有一些问题需要解决。其中一个重要的问题就是当窗口表面发生改变（如缩放）的时候，交换链就不再和窗口表面兼容了。此时为了显示正确的图像到屏幕上我们需要重新构建一个和当下窗口表面兼容的交换链。重建交换链主要需要考虑如下几个问题：</p><ul><li>怎么检测重建交换链的时机</li><li>如何重建交换链</li></ul><p>我们将创建一个<i><font color="Green">voidrecreateSwapchain()</font></i>函数来执行交换链的重建工作。</p><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Swap_chain_recreation">Swapchain recreation</a>章节。</p><hr><h2 id="检测时机方式">检测时机方式</h2><p>还记得我们在<a href="https://zpc-dsg.github.io/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/">渲染和显示</a>这篇文章中曾经提到我们会在之后完善对<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html"><code>vkAcquireNextImageKHR</code></a>和<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>的调试工作吗？事实上，这两个函数也会返回一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkResult.html"><code>VkResult</code></a>类型的值来反映函数执行情况。其中，有两个特殊的可能返回值就和当前交换链是否和窗口表面兼容有关，分别为：</p><ul><li><i><font color="Red">VK_ERROR_OUT_OF_DATE_KHR</font></i>：交换链和表面不兼容并且已经无法继续用于渲染了。</li><li><i><font color="Red">VK_SUBOPTIMAL_KHR</font></i>：交换链仍可用于渲染和显示，但是它和表面的属性已经不完全匹配了。</li></ul><p>因此，我们可以对这两个函数的返回值进行侦测并据此进一步判断是否需要重建交换链。本教程中对应的检测代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br><br>VkResult result = <span class="hljs-built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);<br><br><span class="hljs-keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR) &#123;<br>    <span class="hljs-built_in">recreateSwapChain</span>();<br>    <span class="hljs-keyword">return</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != VK_SUCCESS &amp;&amp; result != VK_SUBOPTIMAL_KHR) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to acquire swap chain image!&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br>result = <span class="hljs-built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);<br><br><span class="hljs-keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR) &#123;<br>    <span class="hljs-built_in">recreateSwapChain</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to present swap chain image!&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure></p><p>然而，这么写代码其实会诱发死锁：注意到栅栏已经在该代码之前重置为未点亮状态，并且需要后续的命令缓冲中的所有命令完成后才能点亮，如果我们缩放了窗口大小，函数会在重建交换链之后直接返回，然而此时栅栏就永远不会被点亮了！于是代码就卡死在了<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html"><code>vkWaitForFences</code></a>上。</p><p>为了解决这个问题，我们可以将<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/vkResetFences.html"><code>vkResetFences</code></a>放在对<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html"><code>vkAcquireNextImageKHR</code></a>返回结果的处理代码后，这样即使因为重建交换链返回了也可以保证此时栅栏仍然是点亮状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkWaitForFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);<br><br><span class="hljs-type">uint32_t</span> imageIndex;<br>VkResult result = <span class="hljs-built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);<br><br><span class="hljs-keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR) &#123;<br>    <span class="hljs-built_in">recreateSwapChain</span>();<br>    <span class="hljs-keyword">return</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != VK_SUCCESS &amp;&amp; result != VK_SUBOPTIMAL_KHR) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to acquire swap chain image!&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">vkResetFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame]);<br></code></pre></td></tr></table></figure><p>不过这还不算结束。尽管许多平台在窗口大小调整之后会自动触发<i><font color="Red">VK_ERROR_OUT_OF_DATE_KHR</font></i>，但并非所有的硬件都会保证这一点。因此，为了真正在所有平台上都能精准检测到窗口大小的变化，我们还应该显式地获取窗口大小信息以检测其大小变化。为了显式地获取窗口信息并据此决定是否重建交换链，我们需要设置一个窗口回调函数<i><font color="Green">staticvoid framebufferResizeCallback(GLFWwindow* window, int width, intheight)</font></i>以供<a href="https://www.glfw.org/docs/3.3/group__window.html#ga3c96d80d363e67d13a41b5d1821f3242"><code>GLFWwindow</code></a>对象在侦测到窗口大小改变时调用，并且在类内新建一个成员<i><font color="Orange">boolframebufferResized</font></i>用于指示窗口大小是否发生了变换。之所以将这个函数设置为静态函数是因为<a href="https://www.glfw.org/docs/3.3/group__window.html#ga3c96d80d363e67d13a41b5d1821f3242"><code>GLFWwindow</code></a>对象并不知道如何正确调用一个带有this指针的成员回调函数。</p><p>尽管<a href="https://www.glfw.org/docs/3.3/group__window.html#ga3c96d80d363e67d13a41b5d1821f3242"><code>GLFWwindow</code></a>对象不能正确处理this指针，但它允许使用<a href="https://www.glfw.org/docs/3.3/group__window.html#ga3d2fc6026e690ab31a13f78bc9fd3651"><code>glfwSetWindowUserPointer</code></a>在该对象内保存一个任意类型的指针。我们可以利用这个指针保存我们的this指针以便在回调函数中改变应用程序类中的<i><font color="Orange">framebufferResized</font></i>的值。</p><p>回调函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">framebufferResizeCallback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> app = <span class="hljs-built_in">reinterpret_cast</span>&lt;HelloTriangleApplication*&gt;(<span class="hljs-built_in">glfwGetWindowUserPointer</span>(window));<br>    app-&gt;framebufferResized = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们需要在GLFW窗口系统中设置这个回调函数，这可以通过在窗口初始化成员函数<i><font color="Green">initWindow</font></i>中使用<a href="https://www.glfw.org/docs/3.3/group__window.html#gab3fb7c3366577daef18c0023e2a8591f"><code>glfwSetFramebufferSizeCallback</code></a>函数来完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initWindow</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">glfwInit</span>();<br><br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CLIENT_API, GLFW_NO_API);<br><br>    window = <span class="hljs-built_in">glfwCreateWindow</span>(WIDTH, HEIGHT, <span class="hljs-string">&quot;Vulkan&quot;</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(window, framebufferResizeCallback);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们需要在检测<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>返回结果的代码中加入对<i><font color="Orange">framebufferResized</font></i>值的检测，一旦它变为真，就重建交换链：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">result = <span class="hljs-built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);<br><br><span class="hljs-keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || framebufferResized) &#123;<br>   framebufferResized = <span class="hljs-literal">false</span>;<br>   <span class="hljs-built_in">recreateSwapChain</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != VK_SUCCESS) &#123;<br>   <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to present swap chain image!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就处理好了因为窗口大小改变造成的交换链图像失效问题。</p><hr><h2 id="重建交换链">重建交换链</h2><p>重建交换链的函数<i><font color="Green">recreateSwapChain</font></i>完全可以重用我们之前创建交换链所使用的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recreateSwapChain</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">vkDeviceWaitIdle</span>(device);<br><br>    <span class="hljs-built_in">cleanupSwapChain</span>();<br>    <br>    <span class="hljs-built_in">createSwapChain</span>();<br>    <span class="hljs-built_in">createImageViews</span>();<br>    <span class="hljs-built_in">createFramebuffers</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>想要重建交换链，只需重新创建交换链对象，以及它对应的图像视图和帧缓冲对象即可。图像不用手动重新创建，因为交换链对象的创建本身会自动生成相应的图像。另外，我们在函数头也需要首先等待设备完成其它正在进行的工作，因为我们不希望在旧的交换链仍然有工作没有完成时就清除掉旧的交换链。</p><p>这里我们新创建了一个成员函数<i><font color="Green">voidcleanupSwapChain()</font></i>来完成对交换链的销毁工作，它同样可以重用<i><font color="Green">cleanup</font></i>函数中销毁交换链有关的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cleanupSwapChain</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainFramebuffers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-built_in">vkDestroyFramebuffer</span>(device, swapChainFramebuffers[i], <span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainImageViews.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-built_in">vkDestroyImageView</span>(device, swapChainImageViews[i], <span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">vkDestroySwapchainKHR</span>(device, swapChain, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就完成了重建交换链的工作。好吧，实际上还有一种特殊的情况我们没有给予关注，那就是最小化窗口的时候。窗口最小化的时候，我们有理由希望此时我们的应用程序暂时停止渲染有关的一切工作，直到用户再次打开应用界面。因此，我们可以在<i><font color="Green">recreateSwapChain</font></i>函数的开头处加入以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recreateSwapChain</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> width = <span class="hljs-number">0</span>, height = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);<br>    <span class="hljs-keyword">while</span> (width == <span class="hljs-number">0</span> || height == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);<br>        <span class="hljs-built_in">glfwWaitEvents</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">vkDeviceWaitIdle</span>(device);<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果最小化，那么帧缓冲大小会变为0，这样我们就可以通过判断该大小是否为0来决定是否需要暂时挂起我们的程序。</p><p>另外，教程评论区有人发现这段处理最小化的代码仍然有疏漏之处：如果在最小化窗口时右键点击任务栏程序图标关闭程序，那么此时尽管窗口关闭了，但<a href="https://www.glfw.org/docs/3.3/group__window.html#ga554e37d781f0a997656c26b2c56c835e"><code>glfwWaitEvents</code></a>仍然处于等待状态，因此此时程序并不会终止而是仍然处于挂起运行的状态。于是，我们需要在处理最小化的代码中显式处理窗口关闭的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (width == <span class="hljs-number">0</span> || height == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwWindowShouldClose</span>(window))<br>        <span class="hljs-keyword">return</span>;<br>    <br>        <span class="hljs-built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);<br>        <span class="hljs-built_in">glfwWaitEvents</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><p>终于大功告成！</p><p>接下来的章节我们将开启一个新的主题：顶点缓冲。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/20/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E5%B8%A7%E5%90%8C%E6%97%B6%E6%B8%B2%E6%9F%93/">上一篇：多帧同时渲染</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0/">下一篇：顶点输入描述</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多帧同时渲染</title>
    <link href="/2024/11/20/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E5%B8%A7%E5%90%8C%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    <url>/2024/11/20/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E5%B8%A7%E5%90%8C%E6%97%B6%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在<a href="https://zpc-dsg.github.io/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/">上一章</a>我们提到，目前应用程序只支持一帧一帧地渲染，但是我们会更希望下一帧的命令录制等操作可以和上一帧的渲染同时进行以提高效率。因此，本节就来实现多帧同时渲染。</p><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Frames_in_flight">Framesin flight</a>章节。</p><hr><h2 id="多帧同时渲染">多帧同时渲染</h2><p>首先，我们来指定需要多少帧同时进行工作，在类外定义一个帧数常量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_FRAMES_IN_FLIGHT = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>我们这里指定两帧。</p><p>接下来，我们需要将命令缓冲、信号量、栅栏资源数目均翻倍，因为我们希望每一帧拥有自己独立的命令和同步资源，这样两帧同时工作的时候就不会互相干扰。因此，将类内相应成员改动如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;VkCommandBuffer&gt; commandBuffers;<br><br>std::vector&lt;VkSemaphore&gt; imageAvailableSemaphores;<br>std::vector&lt;VkSemaphore&gt; renderFinishedSemaphores;<br>std::vector&lt;VkFence&gt; inFlightFences;<br></code></pre></td></tr></table></figure><p>现在，我们需要修改一下相应资源的构建函数。首先将构建命令缓冲的成员函数<i><font color="Green">createCommandBuffer</font></i>改为<i><font color="Green">createCommandBuffers</font></i>，将函数体做如下改动即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createCommandBuffers</span><span class="hljs-params">()</span> </span>&#123;<br>    commandBuffers.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br>    <span class="hljs-comment">//...</span><br>    allocInfo.commandBufferCount = (<span class="hljs-type">uint32_t</span>) commandBuffers.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkAllocateCommandBuffers</span>(device, &amp;allocInfo, commandBuffers.<span class="hljs-built_in">data</span>()) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to allocate command buffers!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样，<i><font color="Green">createSyncObjects</font></i>函数也需要做如下改动以创建多个信号量和栅栏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createSyncObjects</span><span class="hljs-params">()</span> </span>&#123;<br>    imageAvailableSemaphores.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br>    renderFinishedSemaphores.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br>    inFlightFences.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br><br>    VkSemaphoreCreateInfo semaphoreInfo&#123;&#125;;<br>    semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;<br><br>    VkFenceCreateInfo fenceInfo&#123;&#125;;<br>    fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;<br>    fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;imageAvailableSemaphores[i]) != VK_SUCCESS ||<br>            <span class="hljs-built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;renderFinishedSemaphores[i]) != VK_SUCCESS ||<br>            <span class="hljs-built_in">vkCreateFence</span>(device, &amp;fenceInfo, <span class="hljs-literal">nullptr</span>, &amp;inFlightFences[i]) != VK_SUCCESS) &#123;<br><br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create synchronization objects for a frame!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>资源创建完毕了，接下来我们就可以着手多帧渲染了。首先在类内添加一个成员<i><font color="Orange">currentFrame</font></i>代表初始帧索引：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> currentFrame = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>由于我们想要同时渲染两帧，因此每一帧的最后我们都需要将索引切换到另一个并且在该帧内使用相应索引的资源。对<i><font color="Green">drawFrame</font></i>函数的改动部分如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">vkWaitForFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);<br>    <span class="hljs-built_in">vkResetFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame]);<br><br>    <span class="hljs-built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);<br><br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-built_in">vkResetCommandBuffer</span>(commandBuffers[currentFrame],  <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">recordCommandBuffer</span>(commandBuffers[currentFrame], imageIndex);<br><br>    <span class="hljs-comment">//...</span><br><br>    submitInfo.pCommandBuffers = &amp;commandBuffers[currentFrame];<br><br>    <span class="hljs-comment">//...</span><br><br>    VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphores[currentFrame]&#125;;<br><br>    <span class="hljs-comment">//...</span><br><br>    VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphores[currentFrame]&#125;;<br><br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkQueueSubmit</span>(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//...</span><br>    <br>    currentFrame = (currentFrame + <span class="hljs-number">1</span>) % MAX_FRAMES_IN_FLIGHT;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们给出教程中<i><font color="Green">drawFrame</font></i>函数的完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">vkWaitForFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);<br>    <span class="hljs-built_in">vkResetFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame]);<br><br>    <span class="hljs-type">uint32_t</span> imageIndex;<br>    <span class="hljs-built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);<br><br>    <span class="hljs-built_in">vkResetCommandBuffer</span>(commandBuffers[currentFrame], <span class="hljs-comment">/*VkCommandBufferResetFlagBits*/</span> <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">recordCommandBuffer</span>(commandBuffers[currentFrame], imageIndex);<br><br>    VkSubmitInfo submitInfo&#123;&#125;;<br>    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;<br><br>    VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphores[currentFrame]&#125;;<br>    VkPipelineStageFlags waitStages[] = &#123;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&#125;;<br>    submitInfo.waitSemaphoreCount = <span class="hljs-number">1</span>;<br>    submitInfo.pWaitSemaphores = waitSemaphores;<br>    submitInfo.pWaitDstStageMask = waitStages;<br><br>    submitInfo.commandBufferCount = <span class="hljs-number">1</span>;<br>    submitInfo.pCommandBuffers = &amp;commandBuffers[currentFrame];<br><br>    VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphores[currentFrame]&#125;;<br>    submitInfo.signalSemaphoreCount = <span class="hljs-number">1</span>;<br>    submitInfo.pSignalSemaphores = signalSemaphores;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkQueueSubmit</span>(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to submit draw command buffer!&quot;</span>);<br>    &#125;<br><br>    VkPresentInfoKHR presentInfo&#123;&#125;;<br>    presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;<br><br>    presentInfo.waitSemaphoreCount = <span class="hljs-number">1</span>;<br>    presentInfo.pWaitSemaphores = signalSemaphores;<br><br>    VkSwapchainKHR swapChains[] = &#123;swapChain&#125;;<br>    presentInfo.swapchainCount = <span class="hljs-number">1</span>;<br>    presentInfo.pSwapchains = swapChains;<br><br>    presentInfo.pImageIndices = &amp;imageIndex;<br><br>    <span class="hljs-built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);<br><br>    currentFrame = (currentFrame + <span class="hljs-number">1</span>) % MAX_FRAMES_IN_FLIGHT;<br>&#125;<br></code></pre></td></tr></table></figure><p>大功告成！</p><hr><h2 id="一些疑点">一些疑点</h2><p>关于本篇教程我有一点同样百思不得其解。</p><p>显然在上文<i><font color="Green">drawFrame</font></i>代码中，索引不同的两帧之间的工作是互不干扰的，因为它们各自具有独立的一套命令缓冲和同步对象。但是问题在于如果这样的话，那么本应先后渲染的两帧最后渲染和显示的顺序不是也就不确定了吗？比如说有两帧在同时工作，本应先显示的前一帧因为某种原因工作时长较长，但是因为它和后一帧使用不同的信号量，因此前一帧还在工作并不能迫使后一帧等待前一帧完成工作，那么这不就可能出现后一帧先渲染显示的情况了吗？</p><p>在我看来，本篇教程的目的应该在于充分调动CPU，使得GPU在工作的时候已经完成本帧工作的CPU可以继续进行下一帧的工作，而GPU仍然应该按照顺序一帧一帧地运行。那么如果按照这么理解的话不是应该栅栏要有多个，而每个信号量成员仍然只有一个吗？这样才能在保证GPU上的运行顺序的同时让CPU进行更多的工作吧？大惑不解，望高人指点~</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/">上一篇：渲染和显示</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/22/CG_api/vulkan/vulkan_tutorial/%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/">下一篇：重建交换链</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>渲染和显示</title>
    <link href="/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/"/>
    <url>/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>现在我们已经做好了绘制三角形所需要的所有准备工作，下面我们将创建一个<i><font color="Green">voiddrawFrame()</font></i>函数用于渲染循环中来进行真正的绘制和显示三角形的工作。</p><p>一帧中需要进行的工作主要分为以下五步：</p><ul><li>等待上一帧结束</li><li>从交换链获取一张图像用于渲染</li><li>录制命令</li><li>提交命令进行渲染</li><li>显示渲染好的图像</li></ul><p>在这五步中，第二、四、五步的部分或全部工作在GPU上完成，但是Vulkan中许多在GPU上工作的函数都是异步的，也就是说这种函数返回时函数内部的指令可能仍然在运行。因此，我们需要适当的同步手段来保证这三步一定是按顺序进行的，后者只有在前者完成工作时才会继续执行。</p><p>另外，我们还希望在开始下一帧的渲染之前上一帧命令缓冲中的命令都已经执行完毕了，这样才能保证下一帧开始录制命令时不会重置或覆盖正在执行的命令。这种情形和上文描述的GPU同步略有不同，因为等待上一帧结束这个过程应该发生在CPU端，所以我们还希望能够有一种同步机制来调节GPU和CPU间的操作顺序。</p><p>本文将首先介绍为达到上述同步目的应该使用的同步机制与同步对象，然后再顺次介绍渲染一帧的完整流程。最后，我将给出一个对本章节自己百思不得其解的疑点，当作一个有待日后解答的开放性问题。</p><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Rendering_and_presentation#page_What-to-choose">Renderingand presentation</a>章节。</p><hr><h2 id="同步操作概述">同步操作概述</h2><p>概述部分我们已经看到了，需要同步的操作可以分成两类：交换链上的操作（获取图像和显示图像）以及等待上一帧结束的操作。这两种操作需要两种不同的同步量，因为前者完全发生在GPU上，后者涉及GPU和CPU的通信。这里我们将分别使用<strong>信号量（Semaphore）</strong>和<strong>栅栏（Fence）</strong>作为这两种操作的同步工具，下面分别介绍这两种同步量并且创建需要的对应同步对象。</p><hr><h2 id="同步对象创建">同步对象创建</h2><p>我们将在类内创建一个<i><font color="Green">voidcreateSyncObjects()</font></i>函数来创建所需的同步对象。</p><h4 id="信号量简介semaphore">信号量简介（Semaphore）</h4><p>事实上，Vulkan中的信号量包含两种：二进制信号量（BinarySemaphore）以及时间线信号量（TimelineSemaphore）。二进制信号量只能取两个值：0 或1。它通常用于实现互斥锁或简单的资源访问控制，而时间线信号量是一种更复杂的信号量，允许多个值，并且可以用于更复杂的同步场景。它通常用于图形编程和GPU任务调度。我们之后仅使用二进制信号量，因此后文但凡涉及信号量指的都是二进制信号量。</p><p>如没有任何特殊设置，信号量一开始是未点亮的（unsignaled），它的使用方法一般是需要先完成的操作负责点亮这个信号量，该操作会在完成后点亮信号量，而需要后完成的操作等待这个信号量被点亮，一旦它发现该信号量被点亮，该操作就可以开始执行了，并且此时信号量自动复位为未点亮状态，这样它就可以被继续使用了。</p><h4 id="栅栏简介fence">栅栏简介（Fence）</h4><p>栅栏和信号量的作用类似，但是它是用来同步CPU，也就是所谓的<strong>host</strong>上操作的顺序的。简单来讲，当CPU端需要知道GPU端什么时候完成了指定工作时，我们就可以使用栅栏。</p><p>栅栏的使用方式一般是给GPU上某一项工作指定一个栅栏对象，该对象会在该工作完成时被点亮，CPU端会等待这个栅栏被点亮之后再执行下一步的工作。但是使用栅栏会阻塞CPU端的工作，也就是说GPU端的工作没有完成的话，CPU端是无法做任何工作的（这与信号量不同，信号量并不会阻塞GPU执行其它工作）。另外，栅栏也并不会自动复位为未点亮状态，而是需要CPU端手动复位。</p><h4 id="创建所需信号量">创建所需信号量</h4><p>前面我们提到了，我们需要在从交换链获取图像和在渲染完毕后准备显示这两个节点处设置信号量以固定它们的执行顺序。因此，我们在类内创建两个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSemaphore.html"><code>VkSemaphore</code></a>成员<i><font color="Orange">imageAvailableSemaphore</font></i>和<i><font color="Orange">renderFinishedSemaphore</font></i>。为了创建信号量，我们同样需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSemaphoreCreateInfo.html"><code>VkSemaphoreCreateInfo</code></a>结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSemaphoreCreateInfo</span> &#123;</span><br>    VkStructureType           sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*               pNext;<br>    VkSemaphoreCreateFlags    flags;<span class="hljs-comment">//目前还没有</span><br>&#125; VkSemaphoreCreateInfo;<br></code></pre></td></tr></table></figure><p>这个信息结构体只包含最基本的几个成员，因此填写十分简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSemaphoreCreateInfo semaphoreInfo&#123;&#125;;<br>semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;<br></code></pre></td></tr></table></figure><p>接下来只需调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateSemaphore.html"><code>vkCreateSemaphore</code></a>创建相应对象即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;imageAvailableSemaphore) != VK_SUCCESS ||<br>    <span class="hljs-built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;renderFinishedSemaphore) != VK_SUCCESS || &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create semaphores!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建所需栅栏">创建所需栅栏</h4><p>我们需要创建一个用于告知CPU端GPU上的命令缓冲中的命令已经执行完毕，可以开启下一帧了。因此，在类内添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFence.html"><code>VkFence</code></a>类型的对象<i><font color="Orange">inFlightFence</font></i>，然后在<i><font color="Green">createSyncObjects</font></i>函数中填写创建信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFenceCreateInfo.html"><code>VkFenceCreateInfo</code></a>。其中<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFenceCreateInfo.html"><code>VkFenceCreateInfo</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkFenceCreateInfo</span> &#123;</span><br>    VkStructureType       sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*           pNext;<br>    VkFenceCreateFlags    flags;<br>&#125; VkFenceCreateInfo;<br></code></pre></td></tr></table></figure><p>这里<i><font color="Orange">flags</font></i>成员可能的取值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkFenceCreateFlagBits</span> &#123;</span><br>    VK_FENCE_CREATE_SIGNALED_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//指定栅栏在创建时为被点亮状态</span><br>&#125; VkFenceCreateFlagBits;<br></code></pre></td></tr></table></figure><p>于是填写栅栏信息和创建栅栏的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkFenceCreateInfo fenceInfo&#123;&#125;;<br>fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;<br>fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateFence</span>(device, &amp;fenceInfo, <span class="hljs-literal">nullptr</span>, &amp;inFlightFence) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create semaphores!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>至于这里为什么需要设置栅栏在创建时为点亮状态，我们将在<a href="#上一帧">等待上一帧小节</a>中 加以说明。</p><hr><h2 id="上一帧">等待上一帧</h2><p>在<i><font color="Green">drawFrame</font></i>函数的开头，我们首先需要等待上一帧的结束。为此，我们可以调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html"><code>vkWaitForFences</code></a>函数来等待上一帧的<i><font color="Orange">inFlightFence</font></i>被点亮（点亮操作会在渲染完成后执行）。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html"><code>vkWaitForFences</code></a>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkWaitForFences</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDevice                                    device,    <span class="hljs-comment">//栅栏所属逻辑设备</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    fenceCount,<span class="hljs-comment">//栅栏数目</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkFence*                              pFences,   <span class="hljs-comment">//栅栏</span></span><br><span class="hljs-params">    VkBool32                                    waitAll,   <span class="hljs-comment">//是否等待所有栅栏都被点亮</span></span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span>                                    timeout)</span>;  <span class="hljs-comment">//等待时长  </span><br></code></pre></td></tr></table></figure><p>可以看到，我们可以指定CPU端等待多个栅栏，<i><font color="Orange">waitAll</font></i>参数可以指定我们需要等待其中所有栅栏都被点亮还是等待其中任意一个被点亮。<i><font color="Orange">timeout</font></i>指定最长的等待时限，如果在该时限内等待的栅栏被点亮了，那么该函数将返回<i><font color="Red">VK_SUCCESS</font></i>，否则，该函数会返回<i><font color="Red">VK_TIMEOUT</font></i>。</p><p>在我们的应用程序中，我们只有一个栅栏，并且不需要设置等待时限，于是我们可以如下调用该函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">vkWaitForFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFence, VK_TRUE, UINT64_MAX);<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，在栅栏被成功点亮后，我们需要手动重置其为非点亮状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkResetFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFence);<br></code></pre></td></tr></table></figure><p>等待上一帧的操作就结束了。不过，细心的读者可能会注意到一个违和之处：每次进入下一帧的时候都要等待上一帧的栅栏被点亮，但如果是第一帧呢？它没办法等待上一帧点亮栅栏，因此在第一次循环进入到该函数时栅栏就处于未点亮的状态，那么<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html"><code>vkWaitForFences</code></a>永远无法成功返回！这个问题其实有很多的解决方案，在本教程中我们是通过上文创建栅栏时将其初始状态设置为点亮状态来实现的，这样就可以轻松解决这个问题~</p><hr><h2 id="获取交换链图像">获取交换链图像</h2><p>在上一帧命令执行结束后，我们就可以获取这一帧渲染需要的图像了。这通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html"><code>vkAcquireNextImageKHR</code></a>来完成。该函数原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br>VkResult <span class="hljs-title function_">vkAcquireNextImageKHR</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDevice                                    device,      <span class="hljs-comment">//需要获取图片的逻辑设备</span></span><br><span class="hljs-params">    VkSwapchainKHR                              swapchain,   <span class="hljs-comment">//图片所在交换链</span></span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span>                                    timeout,     <span class="hljs-comment">//等待获取时长</span></span><br><span class="hljs-params">    VkSemaphore                                 semaphore,   <span class="hljs-comment">//等待操作完成后点亮的信号量</span></span><br><span class="hljs-params">    VkFence                                     fence,       <span class="hljs-comment">//等待操作完成后点亮的栅栏</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>*                                   pImageIndex)</span>;<span class="hljs-comment">//获取的图片的索引</span><br></code></pre></td></tr></table></figure></p><p>我们只需设置一个信号量<i><font color="Orange">imageAvailableSemaphore</font></i>用于等待获取图像操作的结束，因此获取交换链图像的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> imageIndex;<br><span class="hljs-built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphore, VK_NULL_HANDLE, &amp;imageIndex);<br></code></pre></td></tr></table></figure><p>另外需要注意的是，这个函数保证在返回<i><font color="Red">VK_SUCCESS</font></i>时，<i><font color="Orange">imageIndex</font></i>一定是有效且正确的，但是并不保证返回时该函数所进行的一切工作都结束了。</p><hr><h2 id="录制命令">录制命令</h2><p>接下来我们可以录制对获取到的图像所需要进行的命令了（之前提到了尽管先前的<i><font color="Green">vkAcquireNextImageKHR</font></i>可能还没有执行完所有工作，但是图像索引已经得到了，录制命令这步工作是在CPU端进行的，并且只需要用到图像的索引，GPU端还有其它的工作未完成并不影响继续录制命令），因此我们调用<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/"><code>命令缓冲</code></a>章节添加的<i><font color="Green">recordCommandBuffer</font></i>函数来完成所需命令的录制。当然，在此之前我们需要先使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkResetCommandBuffer.html"><code>vkResetCommandBuffer</code></a>重置命令缓冲以清除上一帧录制的命令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkResetCommandBuffer</span>(commandBuffer, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">recordCommandBuffer</span>(commandBuffer, imageIndex);<br></code></pre></td></tr></table></figure><hr><h2 id="提交命令并渲染">提交命令并渲染</h2><p>录制好命令后我们就可以将命令缓冲中的命令提交给队列执行了。提交命令同样需要填写相应的信息<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo.html"><code>VkSubmitInfo</code></a>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSubmitInfo</span> &#123;</span><br>    VkStructureType                sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                    pNext;<br>    <span class="hljs-type">uint32_t</span>                       waitSemaphoreCount;<br>    <span class="hljs-type">const</span> VkSemaphore*             pWaitSemaphores;<br>    <span class="hljs-type">const</span> VkPipelineStageFlags*    pWaitDstStageMask;<br>    <span class="hljs-type">uint32_t</span>                       commandBufferCount;<br>    <span class="hljs-type">const</span> VkCommandBuffer*         pCommandBuffers;<br>    <span class="hljs-type">uint32_t</span>                       signalSemaphoreCount;<br>    <span class="hljs-type">const</span> VkSemaphore*             pSignalSemaphores;<br>&#125; VkSubmitInfo;<br></code></pre></td></tr></table></figure><p>这里唯一需要解释一下的参数就是<i><font color="Orange">pWaitDstStageMask</font></i>，它用于指定每个等待信号量对应在管线中等待的阶段，也就是管线中哪个阶段需要等待该信号量被点亮后才能继续执行。注意，如果渲染管线中对应阶段被执行了多次（比如一个渲染通道中有多个子通道），那么每个该阶段的执行都需要等待该信号量被点亮。</p><p>在我们的应用程序中，我们需要在绘制前等待图像获取完毕，于是我们需要等待的信号量为<i><font color="Orange">imageAvailableSemaphore</font></i>，等待的管线阶段可以设置为<i><font color="Red">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>（全部的管线阶段及其相关信息可以参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlagBits.html">这个页面</a>），这意味着我们只要求在绘制到帧缓冲之前图像必须获取完毕，而在之前的管线阶段，比如顶点着色器运行阶段等则并不要求图像获取完毕，这么做延长了图像获取操作的允许时长，提高了时间利用效率。在命令缓冲中的命令全部执行完毕后，我们还需要点亮<i><font color="Orange">renderFinishedSemaphore</font></i>以告知程序渲染已经完成，可以进行后续的显示操作了。因此，该信息结构体的填写代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSubmitInfo submitInfo&#123;&#125;;<br>submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;<br><br>VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphore&#125;;<br>VkPipelineStageFlags waitStages[] = &#123;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&#125;;<br>submitInfo.waitSemaphoreCount = <span class="hljs-number">1</span>;<br>submitInfo.pWaitSemaphores = waitSemaphores;<br>submitInfo.pWaitDstStageMask = waitStages;<br>submitInfo.commandBufferCount = <span class="hljs-number">1</span>;<br>submitInfo.pCommandBuffers = &amp;commandBuffer;<br>VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphore&#125;;<br>submitInfo.signalSemaphoreCount = <span class="hljs-number">1</span>;<br>submitInfo.pSignalSemaphores = signalSemaphores;<br></code></pre></td></tr></table></figure><p>接下来我们需要调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit.html"><code>vkQueueSubmit</code></a>函数执行提交操作，该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkQueueSubmit</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkQueue                                     <span class="hljs-built_in">queue</span>,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    submitCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkSubmitInfo*                         pSubmits,</span><br><span class="hljs-params">    VkFence                                     fence)</span>;<br></code></pre></td></tr></table></figure><p>每一个参数都是易于理解的，其中最后一个参数代表一个可选的在提交的命令运行结束后会被点亮的栅栏。我们显然应该将<i><font color="Orange">inFlightFence</font></i>赋予这个参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkQueueSubmit</span>(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, inFlightFence) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to submit draw command buffer!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，命令提交结束，渲染可以开始了。但是事实上这里仍然存在一个很隐晦的问题：还记得我们的渲染通道中指定了一个子通道吗？事实上，除了这个我们显式设置的通道之外，还存在两个隐式的通道，一个位于渲染通道的开始处，一个位于渲染通道的结束处，这些子通道会通过一种叫做<strong>Subpassdependencies</strong>的结构控制子通道之间图像格式的转换。如果不显式设置这种依赖关系，那么默认的开始处的子通道到我们设置的子通道之间格式的转换将发生在渲染管线的开始阶段（该阶段对应Vulkan中管线阶段的枚举值为<i><font color="Red">VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</font></i>），但是问题是，我们之前设置的提交命令的等待阶段为输出到帧缓冲的阶段，也就是说在<i><font color="Red">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>之前，我们甚至不能保证图像获取操作已经完全结束了，也就是说我们不能保证在这个阶段之前图象是完全有效的，甚至渲染管线开始的时候图像可能还根本没有获取到！当然，我们可以将之前<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo.html"><code>VkSubmitInfo</code></a>中的<i><font color="Orange">pWaitDstStageMask</font></i>设置为<i><font color="Red">VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</font></i>，但是一来这样会使得时间利用率降低，二来我们也希望借此机会探索一下<strong>Subpassdependencies</strong>的结构和设置方式。因此，我们接下来就在<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/"><code>渲染通道</code></a>章节中创建的<i><font color="Green">createRenderPass</font></i>函数中添加手动设置<strong>Subpassdependencies</strong>的相关代码：</p><p>首先还是来看一下依赖关系结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubpassDependency.html"><code>VkSubpassDependency</code></a>的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSubpassDependency</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>                srcSubpass;<span class="hljs-comment">//依赖关系的源子通道的索引。如果设置为 VK_SUBPASS_EXTERNAL，则表示依赖于外部命令（即在渲染通道开始之前的命令）</span><br>    <span class="hljs-type">uint32_t</span>                dstSubpass;<span class="hljs-comment">//依赖关系的目标子通道的索引。如果设置为 VK_SUBPASS_EXTERNAL，则表示依赖于外部命令（即在渲染通道结束之后的命令）。另外，该索引值一定要大于等于srcSubpass表示的索引值以避免循环依赖（除非dstSubpass为VK_SUBPASS_EXTERNAL）</span><br>    VkPipelineStageFlags    srcStageMask;<span class="hljs-comment">//指定源子通道中需要同步的管线阶段。这决定了哪些阶段的操作需要在目标子通道开始之前完成</span><br>    VkPipelineStageFlags    dstStageMask;<span class="hljs-comment">//指定目标子通道中需要同步的管线阶段。这决定了目标子通道中哪些阶段的操作需要等待源子通道的完成</span><br>    VkAccessFlags           srcAccessMask;<span class="hljs-comment">//指定在源子通道中访问的资源类型（如读取、写入等）。这用于确定在源子通道中需要等待的访问类型</span><br>    VkAccessFlags           dstAccessMask;<span class="hljs-comment">//指定在目标子通道中访问的资源类型。这用于确定目标子通道中需要等待的访问类型</span><br>    VkDependencyFlags       dependencyFlags;<span class="hljs-comment">//指定依赖关系的标志，控制依赖行为的特性</span><br>&#125; VkSubpassDependency;<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAccessFlagBits.html"><code>VkAccessFlagBits</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkAccessFlagBits</span> &#123;</span><br>    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = <span class="hljs-number">0x00000001</span>,<br>    VK_ACCESS_INDEX_READ_BIT = <span class="hljs-number">0x00000002</span>,<br>    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = <span class="hljs-number">0x00000004</span>,<br>    VK_ACCESS_UNIFORM_READ_BIT = <span class="hljs-number">0x00000008</span>,<br>    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = <span class="hljs-number">0x00000010</span>,<br>    VK_ACCESS_SHADER_READ_BIT = <span class="hljs-number">0x00000020</span>,<br>    VK_ACCESS_SHADER_WRITE_BIT = <span class="hljs-number">0x00000040</span>,<br>    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = <span class="hljs-number">0x00000080</span>,<br>    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = <span class="hljs-number">0x00000100</span>,<br>    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = <span class="hljs-number">0x00000200</span>,<br>    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = <span class="hljs-number">0x00000400</span>,<br>    VK_ACCESS_TRANSFER_READ_BIT = <span class="hljs-number">0x00000800</span>,<br>    VK_ACCESS_TRANSFER_WRITE_BIT = <span class="hljs-number">0x00001000</span>,<br>    VK_ACCESS_HOST_READ_BIT = <span class="hljs-number">0x00002000</span>,<br>    VK_ACCESS_HOST_WRITE_BIT = <span class="hljs-number">0x00004000</span>,<br>    VK_ACCESS_MEMORY_READ_BIT = <span class="hljs-number">0x00008000</span>,<br>    VK_ACCESS_MEMORY_WRITE_BIT = <span class="hljs-number">0x00010000</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_ACCESS_NONE = <span class="hljs-number">0</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_transform_feedback</span><br>    VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = <span class="hljs-number">0x02000000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_transform_feedback</span><br>    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = <span class="hljs-number">0x04000000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_transform_feedback</span><br>    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = <span class="hljs-number">0x08000000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_conditional_rendering</span><br>    VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = <span class="hljs-number">0x00100000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_blend_operation_advanced</span><br>    VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = <span class="hljs-number">0x00080000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br>    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = <span class="hljs-number">0x00200000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br>    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = <span class="hljs-number">0x00400000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_fragment_density_map</span><br>    VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = <span class="hljs-number">0x01000000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_fragment_shading_rate</span><br>    VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = <span class="hljs-number">0x00800000</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_device_generated_commands</span><br>    VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV = <span class="hljs-number">0x00020000</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_device_generated_commands</span><br>    VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV = <span class="hljs-number">0x00040000</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_shading_rate_image</span><br>    VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR,<br>  <span class="hljs-comment">// Provided by VK_NV_ray_tracing</span><br>    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR,<br>  <span class="hljs-comment">// Provided by VK_NV_ray_tracing</span><br>    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR,<br>  <span class="hljs-comment">// Provided by VK_KHR_synchronization2</span><br>    VK_ACCESS_NONE_KHR = VK_ACCESS_NONE,<br>  <span class="hljs-comment">// Provided by VK_EXT_device_generated_commands</span><br>    VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT = VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV,<br>  <span class="hljs-comment">// Provided by VK_EXT_device_generated_commands</span><br>    VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT = VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV,<br>&#125; VkAccessFlagBits;<br></code></pre></td></tr></table></figure><p>每一个枚举都代表一种资源访问类型，我们这里不做过多解释。</p><p><a href="https://www.zhihu.com/question/424430509/answer/1632072443"><code>VkDependencyFlagBits</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDependencyFlagBits</span> &#123;</span><br>    VK_DEPENDENCY_BY_REGION_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//表示依赖关系是基于区域的。这意味着在源和目标子通道之间的依赖关系是区域相关的，确保在访问同一区域时不会发生数据竞争</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_DEPENDENCY_DEVICE_GROUP_BIT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//表示依赖关系涉及设备组。这在使用多个 GPU 时特别有用，确保在设备组中的不同设备之间的操作顺序</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_DEPENDENCY_VIEW_LOCAL_BIT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//表示依赖关系是视图局部的。这通常用于多视图渲染，确保在不同视图之间的依赖关系是局部的，适合多视图场景的渲染</span><br>  <span class="hljs-comment">// Provided by VK_EXT_attachment_feedback_loop_layout</span><br>    VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//这是一个扩展标志，表示存在反馈循环的依赖关系。这通常用于处理需要在多个渲染通道之间进行反馈的场景</span><br>  <span class="hljs-comment">// Provided by VK_KHR_multiview</span><br>    VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = VK_DEPENDENCY_VIEW_LOCAL_BIT,<br>  <span class="hljs-comment">// Provided by VK_KHR_device_group</span><br>    VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = VK_DEPENDENCY_DEVICE_GROUP_BIT,<br>&#125; VkDependencyFlagBits;<br></code></pre></td></tr></table></figure><p>根据前文的叙述，我们需要重新设置开始处子通道和我们设置的子通道之间的依赖关系。相应的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSubpassDependency dependency&#123;&#125;;<br><br>dependency.srcSubpass = VK_SUBPASS_EXTERNAL;<br>dependency.dstSubpass = <span class="hljs-number">0</span>;<br>dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;<br>dependency.srcAccessMask = <span class="hljs-number">0</span>;<br>dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;<br>dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;<br></code></pre></td></tr></table></figure><p>我们将<i><font color="Orange">srcStageMask</font></i>设置为<i><font color="Red">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>，这样开始时的图像格式转换就会发生在该阶段之后，此时可以保证图像是存在有效的。另外，将<i><font color="Orange">srcAccessMask</font></i>设置为0意味着我们并不需要等待开始处子通道完成任何资源访问操作，事实上我们也没有在该子通道处有什么特别的操作要进行。之后<i><font color="Orange">dstStageMask</font></i>同样设置为<i><font color="Red">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>，资源访问操作<i><font color="Orange">dstAccessMask</font></i>设置为<i><font color="Red">VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</font></i>以指定将渲染结果写入帧缓冲的操作要在图像格式已经成功转换之后再执行。（不过知乎上的<a href="https://www.zhihu.com/question/424430509/answer/1632072443">一篇文章</a>里说这部分其实写的有问题，我也始终感觉这一部分想得不明不白的。。。望高人指点</p><p>最后不要忘了在<i><font color="Orange">renderPassInfo</font></i>中指定依赖关系成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">renderPassInfo.dependencyCount = <span class="hljs-number">1</span>;<br>renderPassInfo.pDependencies = &amp;dependency;<br></code></pre></td></tr></table></figure><hr><h2 id="显示图像">显示图像</h2><p>最后，我们只需要将渲染好的图像显示到屏幕上即可。为此，我们需要首先填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPresentInfoKHR.html"><code>VkPresentInfoKHR</code></a>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPresentInfoKHR</span> &#123;</span><br>    VkStructureType          sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*              pNext;<br>    <span class="hljs-type">uint32_t</span>                 waitSemaphoreCount;<br>    <span class="hljs-type">const</span> VkSemaphore*       pWaitSemaphores;<br>    <span class="hljs-type">uint32_t</span>                 swapchainCount;<br>    <span class="hljs-type">const</span> VkSwapchainKHR*    pSwapchains;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*          pImageIndices;<br>    VkResult*                pResults;<br>&#125; VkPresentInfoKHR;<br></code></pre></td></tr></table></figure><p>这里只需要解释一下最后一个成员<i><font color="Orange">pResults</font></i>，该参数会返回每个对应交换链显示图像的结果是否成功。如果只有一个交换链（事实上绝大多数的情况也是如此），那么就没有必要指定这个成员，因为我们可以直接使用显示函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>的返回值来查看图像显示是否成功。</p><p>我们的填写代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPresentInfoKHR presentInfo&#123;&#125;;<br>presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;<br><br>presentInfo.waitSemaphoreCount = <span class="hljs-number">1</span>;<br>presentInfo.pWaitSemaphores = signalSemaphores;<br><br>VkSwapchainKHR swapChains[] = &#123;swapChain&#125;;<br>presentInfo.swapchainCount = <span class="hljs-number">1</span>;<br>presentInfo.pSwapchains = swapChains;<br>presentInfo.pImageIndices = &amp;imageIndex;<br></code></pre></td></tr></table></figure><p>由于我们需要等待渲染操作结束才能显示图像，因此<i><font color="Orange">pWaitSemaphores</font></i>应该设置为<i><font color="Orange">renderFinishedSemaphore</font></i>。</p><p>最后，使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>显示图像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);<br></code></pre></td></tr></table></figure><p>注意到这里我们并没有使用这个函数调用的返回值，包括之前在调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html"><code>vkAcquireNextImageKHR</code></a>的时候我们也没有这么做，因为和之前的函数不同，这两个函数即使返回错误值，也不意味着我们需要立即终止我们的程序，所以我们会在之后的章节中单独处理这两个函数的调试。</p><p>这样，我们终于成功绘制了Vulkan中的第一个三角形！天哪，这真是一段漫长的旅程。。。</p><figure><img src="/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/first_triangle.png" alt="第一个三角形"><figcaption aria-hidden="true">第一个三角形</figcaption></figure><p>不过没有那么多时间沉浸在自我感动中了，因为接下来赶到战场的是验证层的报错。。。是的，心满意足地欣赏完近1000行代码编写出来的“鸿篇巨制”之后，准备退出程序的你此时却必然会受到验证层的最后一击：</p><figure><img src="/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/validation_error.png" alt="不老实的验证层"><figcaption aria-hidden="true">不老实的验证层</figcaption></figure><p>这是为什么？</p><p>事实上原因在于我们在最后一帧结束程序时，退出循环后CPU会执行<i><font color="Green">cleanup</font></i>函数来清理掉所有Vulkan对象，但是还记得我们之前说GPU上的一些函数在返回后相应的工作还可能在运行吗？问题就出在这里！有些GPU上的工作还没执行完毕我们就清理掉了相应的资源！</p><p>解决方法也有很多，我们这里采取一种简单粗暴的方式即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mainLoop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">glfwWindowShouldClose</span>(window)) &#123;<br>        <span class="hljs-built_in">glfwPollEvents</span>();<br>        <span class="hljs-built_in">drawFrame</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">vkDeviceWaitIdle</span>(device);<br>&#125;<br></code></pre></td></tr></table></figure><p>在渲染循环之后加入<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDeviceWaitIdle.html"><code>vkDeviceWaitIdle</code></a>来等待所有的队列操作执行完毕再进行清理工作，这样我们终于可以安心退出程序而不用担心验证层的抱怨了！太棒了！</p><hr><h2 id="一个小疑点">一个小疑点</h2><p>关于这一节我仍然有一个疑问没有解决，那就是关于显示图像的同步问题。</p><p>假设这么一种情况：当前帧运行到了<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>，由于该函数运行在GPU上，它可能没有完成显示就已经返回了，此时<i><font color="Green">drawFrame</font></i>函数进入下一帧，由于此时所有的信号量、栅栏、命令缓冲等都处于可用状态，因此下一帧会畅通无阻地运行到<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>，那么万一此时上一帧的显示因为种种原因还没有完成呢？岂不是会同时显示两帧图像？</p><p>我发现Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Rendering_and_presentation#page_What-to-choose">Renderingand presentation</a>章节评论区中有人也提出了类似的问题：</p><figure><img src="/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/comments.png" alt="疑点"><figcaption aria-hidden="true">疑点</figcaption></figure><p>可以看到有人给出了一些可能的解释，不过也并没有完全回答这种类似的问题。因此暂时保留该疑问，以待日后思考~</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/">上一篇：命令缓冲</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/20/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E5%B8%A7%E5%90%8C%E6%97%B6%E6%B8%B2%E6%9F%93/">下一篇：多帧同时渲染</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>命令缓冲</title>
    <link href="/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/"/>
    <url>/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在Vulkan中，执行命令不是简单地通过调用函数来实现的。我们需要将命令记录在命令缓冲中，然后将该缓冲提交给队列执行。这么做的优点是我们可以将所有命令统一打包提交以便Vulkan优化执行过程。</p><p>记录下绘制一个三角形需要的命令主要分为三步：</p><ul><li>创建命令池<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandPool.html"><code>VkCommandPool</code></a></li><li>从命令池分配出需要数目的命令缓冲<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html"><code>VkCommandBuffer</code></a></li><li>录制需要执行的命令到分配出的命令缓冲</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Command_buffers">Commandbuffers</a>章节。</p><hr><h2 id="创建命令池">创建命令池</h2><p>命令缓冲必须从某个管理缓冲内存的内存池中分配。因此我们在应用程序类内添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandPool.html"><code>VkCommandPool</code></a>类型的成员<i><font color="Orange">commandPool</font></i>，并且创建一个<i><font color="Green">voidcreateCommandPool()</font></i>函数来构建该对象。</p><p>首先我们当然需要填写构建信息<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateInfo.html"><code>VkCommandPoolCreateInfo</code></a>，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkCommandPoolCreateInfo</span> &#123;</span><br>    VkStructureType             sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                 pNext;<br>    VkCommandPoolCreateFlags    flags;<br>    <span class="hljs-type">uint32_t</span>                    queueFamilyIndex;<br>&#125; VkCommandPoolCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>可以是以下值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkCommandPoolCreateFlagBits</span> &#123;</span><br>    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = <span class="hljs-number">0x00000001</span>,<br>    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = <span class="hljs-number">0x00000002</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_COMMAND_POOL_CREATE_PROTECTED_BIT = <span class="hljs-number">0x00000004</span>,<br>&#125; VkCommandPoolCreateFlagBits;<br></code></pre></td></tr></table></figure><p>我们来详细解释一下这些标志位：</p><ul><li><p><i><font color="Red">VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</font></i>标志位表明从这个命令池分配的命令缓冲都是临时的，也就是说它们会经常地被重置或释放再分配。这可以帮助命令池调整它的内存管理行为，适合于动态场景中快速更换命令缓冲区的情况。</p></li><li><p><i><font color="Red">VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</font></i>标志位设置后，将允许显示使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkResetCommandBuffer.html"><code>vkResetCommandBuffer</code></a>重置单个命令缓冲（如果该标志位没有设置，则一定不能使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkResetCommandBuffer.html"><code>vkResetCommandBuffer</code></a>重置命令缓冲，只能隐式通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkBeginCommandBuffer.html">vkBeginCommandBuffer</a>重置或者直接释放并重新分配新的缓冲）。这一版用于需要反复使用相同命令缓冲区的场景。</p></li><li><p><i><font color="Red">VK_COMMAND_POOL_CREATE_PROTECTED_BIT</font></i>用于创建保护模式命令池从而分配保护模式命令缓冲区，这些缓冲区只能在具有保护访问权限的设备上执行。这通常用于处理敏感数据的场景，例如加密或DRM（数字版权管理）内容，确保数据不会被未授权的访问所读取或修改。</p></li></ul><p>我们在绘制三角形时每一帧使用的都是相同的命令，因此可以将该标志设置为<i><font color="Red">VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</font></i>。</p><p>接下来，<i><font color="Orange">queueFamilyIndex</font></i>指定从该命令池分配的命令缓冲的提交队列。每个命令池分配的缓冲只能提交至一种队列。我们希望录制绘制三角形的命令，因此应该将该成员设置为图形队列。</p><p>最终填写代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">QueueFamilyIndices queueFamilyIndices = <span class="hljs-built_in">findQueueFamilies</span>(physicalDevice);<br><br>VkCommandPoolCreateInfo poolInfo&#123;&#125;;<br>poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;<br>poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;<br>poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily.<span class="hljs-built_in">value</span>();<br></code></pre></td></tr></table></figure><p>然后就可以创建命令池了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateCommandPool</span>(device, &amp;poolInfo, <span class="hljs-literal">nullptr</span>, &amp;commandPool) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create command pool!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="分配命令缓冲">分配命令缓冲</h2><p>构建好命令池后，我们就可以分配命令缓冲了。</p><p>我们目前只需要一个命令缓冲区，因此在类内创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html"><code>VkCommandBuffer</code></a>类型的成员<i><font color="Orange">commandBuffer</font></i>，并且创建一个<i><font color="Green">voidcreateCommandBuffer()</font></i>来分配该对象。</p><p>为了从命令池分配该对象，我们需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBufferAllocateInfo.html"><code>VkCommandBufferAllocateInfo</code></a>信息。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkCommandBufferAllocateInfo</span> &#123;</span><br>    VkStructureType         sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*             pNext;<br>    VkCommandPool           commandPool;<br>    VkCommandBufferLevel    level;<br>    <span class="hljs-type">uint32_t</span>                commandBufferCount;<br>&#125; VkCommandBufferAllocateInfo;<br></code></pre></td></tr></table></figure><p>这里唯一需要解释的成员是<i><font color="Orange">level</font></i>。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBufferLevel.html"><code>VkCommandBufferLevel</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkCommandBufferLevel</span> &#123;</span><br>    VK_COMMAND_BUFFER_LEVEL_PRIMARY = <span class="hljs-number">0</span>,<br>    VK_COMMAND_BUFFER_LEVEL_SECONDARY = <span class="hljs-number">1</span>,<br>&#125; VkCommandBufferLevel;<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><i><font color="Red">VK_COMMAND_BUFFER_LEVEL_PRIMARY</font></i>指定该命令缓冲区为初级命令缓冲，意味着该缓冲区可以直接提交队列执行，但不能被其它命令缓冲调用</li><li><i><font color="Red">VK_COMMAND_BUFFER_LEVEL_SECONDARY</font></i>指定该命令缓冲区为次级命令缓冲，意味着该缓冲区不能直接提交队列执行，但是可以被初级命令缓冲调用</li></ul><p>我们无需使用次级命令缓冲，因此<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBufferAllocateInfo.html"><code>VkCommandBufferAllocateInfo</code></a>信息填写与缓冲区分配代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkCommandBufferAllocateInfo allocInfo&#123;&#125;;<br>allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;<br>allocInfo.commandPool = commandPool;<br>allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;<br>allocInfo.commandBufferCount = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkAllocateCommandBuffers</span>(device, &amp;allocInfo, &amp;commandBuffer) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to allocate command buffers!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="录制命令">录制命令</h2><p>接下来我们可以开始录制命令了。创建一个<i><font color="Green">voidrecordCommandBuffer(VkCommandBuffer commandBuffer, uint32_timageIndex)</font></i>函数用于命令的录制。使用图像索引作为参数是因为我们希望给每个图像绘制都录制好相应的绘制命令。</p><p>为了开始录制，我们总是需要填写一个指定命令缓冲使用上的一些细节的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBufferBeginInfo.html"><code>VkCommandBufferBeginInfo</code></a>结构体。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkCommandBufferBeginInfo</span> &#123;</span><br>    VkStructureType                          sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                              pNext;<br>    VkCommandBufferUsageFlags                flags;<br>    <span class="hljs-type">const</span> VkCommandBufferInheritanceInfo*    pInheritanceInfo;<br>&#125; VkCommandBufferBeginInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>指定命令缓冲的用法有关信息，它可以是如下值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkCommandBufferUsageFlagBits</span> &#123;</span><br>    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = <span class="hljs-number">0x00000001</span>,<br>    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = <span class="hljs-number">0x00000002</span>,<br>    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = <span class="hljs-number">0x00000004</span>,<br>&#125; VkCommandBufferUsageFlagBits;<br></code></pre></td></tr></table></figure><p>我们分别解释每个枚举的含义：</p><ul><li><i><font color="Red">VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</font></i>表明该命令缓冲只会被提交一次，提交后该缓冲区立刻变得无效。在两次提交之间该缓冲区一定要被重置并且重新录制。</li><li><i><font color="Red">VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</font></i>针对次级缓冲区，表明该缓冲完全处于一个渲染通道中。这意味着该次级命令缓冲区的命令可以在当前渲染通道中继续执行，而不需要结束当前的渲染通道。这允许Vulkan驱动程序在执行命令时进行更高效的优化。如果不设置该标志位则一定要在一个新的渲染通道中执行该次级缓冲中的命令（也就是说如果当前已经使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html"><code>vkCmdBeginRenderPass</code></a>开启了一个渲染通道并且还未结束，那么如果要调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdExecuteCommands.html"><code>vkCmdExecuteCommands</code></a>录制执行次级缓冲的命令，那么一定要在这之前使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdEndRenderPass.html"><code>vkCmdEndRenderPass</code></a>结束当前渲染通道并开启一个新的渲染通道来执行次级缓冲命令）。如果针对一个初级缓冲设置该标志位，则该标志位会被忽略。</li><li><i><font color="Red">VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</font></i>针对次级缓冲，表明该命令缓冲区可以在它处于待处理（pending）状态时被多次提交到同一个队列族的任何队列。这意味着我们可以在命令缓冲区尚未被执行完成时，重新提交它。这个标志位还允许一个命令缓冲区被录制到多个主命令缓冲区中。这意味着我们可以在不同的主命令缓冲区中重复使用同一个次级命令缓冲区，而不需要重新录制（如果不设置该标志位，那么次级缓冲一旦在某个初级缓冲中使用过后就立马变成无效状态）。</li></ul><p>我们目前不需要设置任何标志位。</p><p>接下来的<i><font color="Orange">pInheritanceInfo</font></i>仅用于次级缓冲区，它用于指定该次级缓冲从调用它的初级缓冲中继承的一些渲染通道状态信息。我们这里无需指定。</p><p>填写好该结构体后，我们就可以开启录制了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkCommandBufferBeginInfo beginInfo&#123;&#125;;<br>beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;<br>beginInfo.flags = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>beginInfo.pInheritanceInfo = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkBeginCommandBuffer</span>(commandBuffer, &amp;beginInfo) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to begin recording command buffer!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们希望录制绘制命令，那么首先需要开启绘制使用的渲染通道，这通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html"><code>vkCmdBeginRenderPass</code></a>完成（Vulkan中所有的录制命令名称中都带有<strong>Cmd</strong>）。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html"><code>vkCmdBeginRenderPass</code></a>的主要功能包括：</p><ul><li><strong>设置渲染状态</strong>：通过指定渲染通道的描述符，设置当前的渲染状态，包括使用的帧缓冲、附件格式等。</li><li><strong>绑定帧缓冲</strong>：绑定与渲染通道相关的帧缓冲对象，这些帧缓冲将用于存储渲染结果。</li><li><strong>初始化附件</strong>：根据渲染通道的设置，初始化颜色、深度和模板附件。这些附件会被清空或设置为特定的初始值（如清除颜色）。</li><li><strong>开始绘制命令</strong>：一旦渲染通道开始，后续的绘制命令（如绘制三角形、绑定管线等）将被记录并在该渲染通道内执行。</li></ul><p>为了实现这些功能，我们需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRenderPassBeginInfo.html"><code>VkRenderPassBeginInfo</code></a>结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkRenderPassBeginInfo</span> &#123;</span><br>    VkStructureType        sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*            pNext;<br>    VkRenderPass           renderPass;<br>    VkFramebuffer          framebuffer;<br>    VkRect2D               renderArea;<span class="hljs-comment">//着色器绘制的区域，此区域之外的像素颜色将未定义</span><br>    <span class="hljs-type">uint32_t</span>               clearValueCount;<br>    <span class="hljs-type">const</span> VkClearValue*    pClearValues;<br>&#125; VkRenderPassBeginInfo;<br></code></pre></td></tr></table></figure><p>每个成员都是易于理解的，我们如下填写该结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkRenderPassBeginInfo renderPassInfo&#123;&#125;;<br>renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;<br>renderPassInfo.renderPass = renderPass;<br>renderPassInfo.framebuffer = swapChainFramebuffers[imageIndex];<br>renderPassInfo.renderArea.offset = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>renderPassInfo.renderArea.extent = swapChainExtent;<br>VkClearValue clearColor = &#123;&#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;&#125;;<span class="hljs-comment">//使用完全不透明的黑色作为清除色（我们之前指定了渲染开始前图像的颜色将会重置为清除色）</span><br>renderPassInfo.clearValueCount = <span class="hljs-number">1</span>;<br>renderPassInfo.pClearValues = &amp;clearColor;<br></code></pre></td></tr></table></figure><p>接下来只需调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html"><code>vkCmdBeginRenderPass</code></a>即可。该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdBeginRenderPass</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkRenderPassBeginInfo*                pRenderPassBegin,</span><br><span class="hljs-params">    VkSubpassContents                           contents)</span>;<br></code></pre></td></tr></table></figure><p>需要解释的是第三个参数。<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/"><code>VkSubpassContents</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkSubpassContents</span> &#123;</span><br>    VK_SUBPASS_CONTENTS_INLINE = <span class="hljs-number">0</span>,<span class="hljs-comment">//表示在渲染通道中使用的是内联命令。这意味着所有的绘制命令和状态设置都直接在主命令缓冲区中执行，而不涉及任何次级命令缓冲区的调用。</span><br>    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = <span class="hljs-number">1</span>,<span class="hljs-comment">//表示在渲染通道中将使用次级命令缓冲区。也就是说，主命令缓冲区会调用一个或多个次级命令缓冲区来执行绘制命令和状态设置。在这种模式下，主命令缓冲区只能使用 vkCmdExecuteCommands 这个命令来执行次级命令缓冲区的内容。也就是说，您不能在这个命令缓冲区中执行其他类型的命令，直到调用 vkCmdNextSubpass 或 vkCmdEndRenderPass。</span><br>  <span class="hljs-comment">// Provided by VK_KHR_maintenance7</span><br>    VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR = <span class="hljs-number">1000451000</span>,<span class="hljs-comment">//表示在同一个渲染通道中可以同时使用内联命令和次级命令缓冲区。这允许更灵活的命令组织，可以在同一个渲染通道中混合使用这两种类型的命令。</span><br>  <span class="hljs-comment">// Provided by VK_EXT_nested_command_buffer</span><br>    VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT = VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR,<br>&#125; VkSubpassContents;<br></code></pre></td></tr></table></figure><p>我们只使用初级缓冲，因此该参数应该设定为<i><font color="Red">VK_SUBPASS_CONTENTS_INLINE</font></i>。</p><p>然后调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html"><code>vkCmdBeginRenderPass</code></a>绑定渲染通道：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdBeginRenderPass</span>(commandBuffer, &amp;renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);<br></code></pre></td></tr></table></figure><p>现在我们就可以录制绘制命令了。首先需要绑定渲染管线对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdBindPipeline</span>(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);<br></code></pre></td></tr></table></figure><p>第二个参数指定我们绑定的是图形渲染管线而不是计算管线。</p><p>另外，在之前的<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/">固定管线</a>章节，我们指定视口裁剪阶段为动态阶段，这也就意味着在渲染管线对象中我们并没有设置关于它们的信息，这里在录制绘制命令之前我们必须把这些动态阶段信息也给录制好，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkViewport viewport&#123;&#125;;<br>viewport.x = <span class="hljs-number">0.0f</span>;<br>viewport.y = <span class="hljs-number">0.0f</span>;<br>viewport.width = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(swapChainExtent.width);<br>viewport.height = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(swapChainExtent.height);<br>viewport.minDepth = <span class="hljs-number">0.0f</span>;<br>viewport.maxDepth = <span class="hljs-number">1.0f</span>;<br><span class="hljs-built_in">vkCmdSetViewport</span>(commandBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;viewport);<br><br>VkRect2D scissor&#123;&#125;;<br>scissor.offset = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>scissor.extent = swapChainExtent;<br><span class="hljs-built_in">vkCmdSetScissor</span>(commandBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;scissor);<br></code></pre></td></tr></table></figure><p>现在渲染管线和渲染通道都已经就绪，我们就可以录制最终的绘制命令了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdDraw</span>(commandBuffer, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDraw.html"><code>vkCmdDraw</code></a>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdDraw</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    vertexCount,<span class="hljs-comment">//顶点数</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    instanceCount,<span class="hljs-comment">//实例数</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    firstVertex,<span class="hljs-comment">//首顶点偏移</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    firstInstance<span class="hljs-comment">//首实例偏移);</span></span><br></code></pre></td></tr></table></figure><p>所有参数的含义都是一目了然的。我们的应用程序并不使用实例渲染，因此第三个参数指定为1即可。对实例渲染不熟的读者可以参考<a href="https://learnopengl.com/Advanced-OpenGL/Instancing">这篇文章</a>。</p><p>现在我们已经完成了绘制一个基本的三角形所有命令的录制，最后结束渲染管线与命令录制即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdEndRenderPass</span>(commandBuffer);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkEndCommandBuffer</span>(commandBuffer) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to record command buffer!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%B8%A7%E7%BC%93%E5%86%B2/">上一篇：帧缓冲</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/">下一篇：渲染和显示</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>帧缓冲</title>
    <link href="/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%B8%A7%E7%BC%93%E5%86%B2/"/>
    <url>/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%B8%A7%E7%BC%93%E5%86%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在之前的章节中我们已经提到多次帧缓冲了，但直到现在我们也还没有创建一个真正的帧缓冲对象。本节就来创建相应的帧缓冲对象。</p><p>帧缓冲对象可以看成是对渲染通道中指定的附件以及之前创建的图像视图的收纳箱。对于每一个交换链中的图像，我们都将创建一个与之相对应的帧缓冲对象。因此，我们需要在类内添加一个向量成员：<i><font color="Orange">std::vector<VkFramebuffer>swapChainFramebuffers</VkFramebuffer></font></i>，并且添加一个成员函数<i><font color="Green">voidcreateFramebuffers()</font></i>来完成帧缓冲的构建。</p><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Framebuffers">Framebuffers</a>章节。</p><hr><h2 id="创建帧缓冲对象">创建帧缓冲对象</h2><p>首先，我们还是需要将帧缓冲向量大小调整为图像视图向量的大小：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createFramebuffers</span><span class="hljs-params">()</span> </span>&#123;<br>    swapChainFramebuffers.<span class="hljs-built_in">resize</span>(swapChainImageViews.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们需要循环填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFramebufferCreateInfo.html"><code>VkFramebufferCreateInfo</code></a>，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkFramebufferCreateInfo</span> &#123;</span><br>    VkStructureType             sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                 pNext;<br>    VkFramebufferCreateFlags    flags;<br>    VkRenderPass                renderPass;     <span class="hljs-comment">//兼容的渲染管线</span><br>    <span class="hljs-type">uint32_t</span>                    attachmentCount;<span class="hljs-comment">//图像视图数量</span><br>    <span class="hljs-type">const</span> VkImageView*          pAttachments;<span class="hljs-comment">//图像视图</span><br>    <span class="hljs-type">uint32_t</span>                    width;<br>    <span class="hljs-type">uint32_t</span>                    height;<br>    <span class="hljs-type">uint32_t</span>                    layers;    <span class="hljs-comment">//图像层数</span><br>&#125; VkFramebufferCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>可以是下面列出的枚举值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkFramebufferCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//表示帧缓冲的附件不需要在创建帧缓冲时关联具体的图像视图。这意味着帧缓冲可以在创建时不直接指定图像，而是通过其他方式（如在渲染过程中）动态创建或绑定图像。</span><br>  <span class="hljs-comment">// Provided by VK_KHR_imageless_framebuffer</span><br>    VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR = VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT,<br>&#125; VkFramebufferCreateFlagBits;<br></code></pre></td></tr></table></figure><p>这里需要解释一下所谓“兼容的渲染管线”的意思：在 Vulkan中，判断一个帧缓冲和一个渲染通道是否兼容主要涉及以下几个方面：</p><ul><li><strong>颜色、深度和模板附件格式</strong>：帧缓冲中的每个附件的格式必须与渲染通道中定义的相应附件格式匹配。你可以通过检查帧缓冲创建时指定的图像视图的格式与渲染通道中附件描述符的格式是否一致来确认。</li><li><strong>样本数</strong>：帧缓冲中的每个附件的样本数必须与渲染通道中相应附件的样本数相同。这意味着，如果渲染通道中的某个附件是多重采样的，帧缓冲中的对应附件也必须是多重采样的，并且样本数必须一致。</li><li><strong>附件数量</strong>：帧缓冲中的附件数量必须与渲染通道中定义的附件数量相同。如果渲染通道定义了多个颜色附件，帧缓冲也必须提供相同数量的颜色附件。</li><li><strong>图像视图的维度</strong>：帧缓冲中的图像视图的维度（例如，2D、3D、立方体等）必须与渲染通道中相应的附件类型匹配。</li><li><strong>图像视图的大小</strong>：帧缓冲中每个图像视图的宽度和高度必须与渲染通道中的相应附件的宽度和高度匹配。</li></ul><p>于是，我们的帧缓冲创建过程如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainImageViews.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    VkImageView attachments[] = &#123;<br>        swapChainImageViews[i]<br>    &#125;;<br><br>    VkFramebufferCreateInfo framebufferInfo&#123;&#125;;<br>    framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;<br>    framebufferInfo.renderPass = renderPass;<br>    framebufferInfo.attachmentCount = <span class="hljs-number">1</span>;<br>    framebufferInfo.pAttachments = attachments;<br>    framebufferInfo.width = swapChainExtent.width;<br>    framebufferInfo.height = swapChainExtent.height;<br>    framebufferInfo.layers = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateFramebuffer</span>(device, &amp;framebufferInfo, <span class="hljs-literal">nullptr</span>, &amp;swapChainFramebuffers[i]) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create framebuffer!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/">上一篇：渲染管线</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/">下一篇：命令缓冲</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>渲染管线</title>
    <link href="/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
    <url>/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>现在我们已经准备好了一切创建渲染管线需要的信息，主要包括四大块：</p><ul><li>可编程管线阶段（我们只指定了顶点着色器和片段着色器）</li><li>固定管线阶段</li><li>管线布局</li><li>渲染通道</li></ul><p>下面我们在类内新增一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipeline.html"><code>VkPipeline</code></a>类型的成员<i><font color="Orange">graphicsPipeline</font></i>来保存渲染管线对象，并且在<i><font color="Green">createGraphicsPipeline</font></i>函数中创建该对象（注意创建代码要放在销毁着色器模型之前，因为在创建管线对象的时候还需要将着色器模型包含的字节码编译为机器码）。</p><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Conclusion">Conclusion</a>章节。</p><hr><h2 id="创建渲染管线">创建渲染管线</h2><p>首先填写创建信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkGraphicsPipelineCreateInfo.html"><code>VkGraphicsPipelineCreateInfo</code></a>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkGraphicsPipelineCreateInfo</span> &#123;</span><br>    VkStructureType                                  sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                      pNext;<br>    VkPipelineCreateFlags                            flags;<br>    <span class="hljs-type">uint32_t</span>                                         stageCount;<br>    <span class="hljs-type">const</span> VkPipelineShaderStageCreateInfo*           pStages;<br>    <span class="hljs-type">const</span> VkPipelineVertexInputStateCreateInfo*      pVertexInputState;<br>    <span class="hljs-type">const</span> VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;<br>    <span class="hljs-type">const</span> VkPipelineTessellationStateCreateInfo*     pTessellationState;<br>    <span class="hljs-type">const</span> VkPipelineViewportStateCreateInfo*         pViewportState;<br>    <span class="hljs-type">const</span> VkPipelineRasterizationStateCreateInfo*    pRasterizationState;<br>    <span class="hljs-type">const</span> VkPipelineMultisampleStateCreateInfo*      pMultisampleState;<br>    <span class="hljs-type">const</span> VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;<br>    <span class="hljs-type">const</span> VkPipelineColorBlendStateCreateInfo*       pColorBlendState;<br>    <span class="hljs-type">const</span> VkPipelineDynamicStateCreateInfo*          pDynamicState;<br>    VkPipelineLayout                                 layout;<br>    VkRenderPass                                     renderPass;<br>    <span class="hljs-type">uint32_t</span>                                         subpass;<br>    VkPipeline                                       basePipelineHandle;<br>    <span class="hljs-type">int32_t</span>                                          basePipelineIndex;<br>&#125; VkGraphicsPipelineCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>比较复杂，可以参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCreateFlagBits.html">这个页面</a>。我们这里并不需要额外的标志功能。</p><p>除了最后两个成员之外，其它的成员分别指定我们之前已经设定好的各个阶段的信息，我们只需引用那些我们已经设定好的信息和对象就好了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkGraphicsPipelineCreateInfo pipelineInfo&#123;&#125;;<br>pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;<br>pipelineInfo.stageCount = <span class="hljs-number">2</span>;<br>pipelineInfo.pStages = shaderStages;<br>pipelineInfo.pVertexInputState = &amp;vertexInputInfo;<br>pipelineInfo.pInputAssemblyState = &amp;inputAssembly;<br>pipelineInfo.pViewportState = &amp;viewportState;<br>pipelineInfo.pRasterizationState = &amp;rasterizer;<br>pipelineInfo.pMultisampleState = &amp;multisampling;<br>pipelineInfo.pDepthStencilState = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br>pipelineInfo.pColorBlendState = &amp;colorBlending;<br>pipelineInfo.pDynamicState = &amp;dynamicState;<br>pipelineInfo.layout = pipelineLayout;<br>pipelineInfo.renderPass = renderPass;<br>pipelineInfo.subpass = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>这里注意，每个渲染管线中只能指定一个子通道（即使指定的渲染通道有多个子通道也只能指定其中一个子通道）！这意味着如果有多个<code>subpass</code>，我们需要为每个子通道创建单独的图形管线。</p><p>最后，<i><font color="Orange">basePipelineHandle</font></i>指定一个构建好的渲染管线对象，新的渲染管线对象将会从这个对象衍生出来；同样，<i><font color="Orange">basePipelineIndex</font></i>指定某个基础管线的索引，新的管线将从它衍生相互来，如果指定一个负数，则代表不使用该衍生功能。注意，这两个成员是互斥的，也就是说我们不能同时指定这二者为一个有效的对象。我们这里并不需要派生，因此只需如下设置即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; <span class="hljs-comment">// Optional</span><br>pipelineInfo.basePipelineIndex = <span class="hljs-number">-1</span>; <span class="hljs-comment">// Optional</span><br></code></pre></td></tr></table></figure><p>最后我们可以创建渲染管线对象了！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateGraphicsPipelines</span>(device, VK_NULL_HANDLE, <span class="hljs-number">1</span>, &amp;pipelineInfo, <span class="hljs-literal">nullptr</span>, &amp;graphicsPipeline) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create graphics pipeline!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateGraphicsPipelines.html"><code>vkCreateGraphicsPipelines</code></a>比我们之前见过的一般的Vulkan构建函数多了两个参数。该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkCreateGraphicsPipelines</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDevice                                    device,</span><br><span class="hljs-params">    VkPipelineCache                             pipelineCache,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    createInfoCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkGraphicsPipelineCreateInfo*         pCreateInfos,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkAllocationCallbacks*                pAllocator,</span><br><span class="hljs-params">    VkPipeline*                                 pPipelines)</span>;<br></code></pre></td></tr></table></figure><p>第二个参数指定一个<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineCache.html"><code>VkPipelineCache</code></a>类型的管线缓冲对象。管线缓冲对象可以存储多次管线构造函数调用有关的数据和信息以便加速之后的管线构造过程。本教程不涉及该对象的使用。</p><p>下面的的<i><font color="Orange">createInfoCount</font></i>指定管线构建信息的个数。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateGraphicsPipelines.html"><code>vkCreateGraphicsPipelines</code></a>允许我们一次性构建多个渲染管线以提高效率，因此我们需要指定管线个数。</p><p>大功告成！接下来我们终于可以开始着手构建帧缓冲并且为最后的绘制做好准备了！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/">上一篇：渲染通道</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%B8%A7%E7%BC%93%E5%86%B2/">下一篇：帧缓冲</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>渲染通道</title>
    <link href="/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/"/>
    <url>/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在创建渲染管线对象之前，我们还需要指定渲染目标需要的颜色附件、深度附件、模板附件的数目，以及它们使用的采样数和被使用的方式。这些信息将通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRenderPass.html"><code>VkRenderPass</code></a>来指定。接下来我们将创建一个<i><font color="Green">voidcreateRenderPass()</font></i>函数来创建这个对象。主要的创建过程分三步：</p><ul><li>指定附件信息</li><li>指定子通道附件引用并创建子通道（subPass）</li><li>创建渲染通道</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes"><code>Render passes</code></a>章节。</p><hr><h2 id="指定附件描述">指定附件描述</h2><p>附件描述<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescription.html"><code>VkAttachmentDescription</code></a>结构体的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkAttachmentDescription</span> &#123;</span><br>    VkAttachmentDescriptionFlags    flags;<br>    VkFormat                        format;<br>    VkSampleCountFlagBits           samples;<br>    VkAttachmentLoadOp              loadOp;<br>    VkAttachmentStoreOp             storeOp;<br>    VkAttachmentLoadOp              stencilLoadOp;<br>    VkAttachmentStoreOp             stencilStoreOp;<br>    VkImageLayout                   initialLayout;<br>    VkImageLayout                   finalLayout;<br>&#125; VkAttachmentDescription;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>可以是如下枚举：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkAttachmentDescriptionFlagBits</span> &#123;</span><br>    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = <span class="hljs-number">0x00000001</span>,<br>&#125; VkAttachmentDescriptionFlagBits;<br></code></pre></td></tr></table></figure><p>若设置了这个唯一的枚举<i><font color="Red">VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT</font></i>，则Vulkan可以优化资源的使用，因为它可以假设某些附件可能会重用同一块内存。</p><p>对于我们的应用而言，我们只需要一个颜色附件，它的格式一定要和交换链的图像格式匹配。因此<i><font color="Orange">format</font></i>需要设置为之前在<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/">交换链</a>章节我们保存在类内的成员<i><font color="Orange">swapChainImageFormat</font></i>的值。</p><p>由于我们不进行多重采样，因此<i><font color="Orange">samples</font></i>设置为<i><font color="Red">VK_SAMPLE_COUNT_1_BIT</font></i>即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createRenderPass</span><span class="hljs-params">()</span> </span>&#123;<br>    VkAttachmentDescription colorAttachment&#123;&#125;;<br>    colorAttachment.format = swapChainImageFormat;<br>    colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来的<i><font color="Orange">loadOp</font></i>和<i><font color="Orange">storeOp</font></i>分别代表在渲染前后应该如何处理图像上的信息，它们针对的是颜色和深度附件。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAttachmentLoadOp.html"><code>VkAttachmentLoadOp</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkAttachmentLoadOp</span> &#123;</span><br>    VK_ATTACHMENT_LOAD_OP_LOAD = <span class="hljs-number">0</span>,<span class="hljs-comment">//保存图像信息不变</span><br>    VK_ATTACHMENT_LOAD_OP_CLEAR = <span class="hljs-number">1</span>,<span class="hljs-comment">//将图像内容重置为特定颜色值，该颜色值可以通过VkClearValue在VkRenderPassBeginInfo中指定</span><br>    VK_ATTACHMENT_LOAD_OP_DONT_CARE = <span class="hljs-number">2</span>,<span class="hljs-comment">//图像内容不会保存，处于未知的状态</span><br>  <span class="hljs-comment">// Provided by VK_KHR_load_store_op_none</span><br>    VK_ATTACHMENT_LOAD_OP_NONE_KHR = <span class="hljs-number">1000400000</span>,<span class="hljs-comment">//不加载附件，不进行任何操作</span><br>  <span class="hljs-comment">// Provided by VK_EXT_load_store_op_none</span><br>    VK_ATTACHMENT_LOAD_OP_NONE_EXT = VK_ATTACHMENT_LOAD_OP_NONE_KHR,<br>&#125; VkAttachmentLoadOp;<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAttachmentStoreOp.html"><code>VkAttachmentStoreOp</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkAttachmentStoreOp</span> &#123;</span><br>    VK_ATTACHMENT_STORE_OP_STORE = <span class="hljs-number">0</span>,<span class="hljs-comment">//渲染内容会被保存在内存中</span><br>    VK_ATTACHMENT_STORE_OP_DONT_CARE = <span class="hljs-number">1</span>,<span class="hljs-comment">//渲染后的内容不会被保存，将处于未知状态</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_ATTACHMENT_STORE_OP_NONE = <span class="hljs-number">1000301000</span>,<span class="hljs-comment">//如果附件没有写入操作，则不进行任何储存操作，否则效果等同于VK_ATTACHMENT_STORE_OP_DONT_CARE</span><br>  <span class="hljs-comment">// Provided by VK_KHR_dynamic_rendering, VK_KHR_load_store_op_none</span><br>    VK_ATTACHMENT_STORE_OP_NONE_KHR = VK_ATTACHMENT_STORE_OP_NONE,<br>  <span class="hljs-comment">// Provided by VK_QCOM_render_pass_store_ops</span><br>    VK_ATTACHMENT_STORE_OP_NONE_QCOM = VK_ATTACHMENT_STORE_OP_NONE,<br>  <span class="hljs-comment">// Provided by VK_EXT_load_store_op_none</span><br>    VK_ATTACHMENT_STORE_OP_NONE_EXT = VK_ATTACHMENT_STORE_OP_NONE,<br>&#125; VkAttachmentStoreOp;<br></code></pre></td></tr></table></figure><p>对于我们的程序，可以如下指定这两个成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;<br>colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;<br></code></pre></td></tr></table></figure><p>对于模板附件，我们通过<i><font color="Orange">stencilLoadOp</font></i>和<i><font color="Orange">stencilStoreOp</font></i>单独指定它的加载和保存操作。本教程并不会用到模板缓冲，因此我们始终将这两个成员设置为<i><font color="Red">VK_ATTACHMENT_LOAD_OP_DONT_CARE</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;<br>colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br></code></pre></td></tr></table></figure><p>关于模板测试的简单介绍和应用，可以参考<a href="https://learnopengl.com/Advanced-OpenGL/Stencil-testing">这篇文章</a>。</p><p>最后，我们需要指定附件图像的初始布局和最终布局。Vulkan中图像像素的布局是可以改变的，这允许我们针对接下来要进行的操作设置最优的像素布局以优化性能。这个布局是通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html"><code>VkImageLayout</code></a>指定的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkImageLayout</span> &#123;</span><br>    VK_IMAGE_LAYOUT_UNDEFINED = <span class="hljs-number">0</span>,<br>    VK_IMAGE_LAYOUT_GENERAL = <span class="hljs-number">1</span>,<br>    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = <span class="hljs-number">2</span>,<br>    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = <span class="hljs-number">3</span>,<br>    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = <span class="hljs-number">4</span>,<br>    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = <span class="hljs-number">5</span>,<br>    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = <span class="hljs-number">6</span>,<br>    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = <span class="hljs-number">7</span>,<br>    VK_IMAGE_LAYOUT_PREINITIALIZED = <span class="hljs-number">8</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = <span class="hljs-number">1000117000</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = <span class="hljs-number">1000117001</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = <span class="hljs-number">1000241000</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = <span class="hljs-number">1000241001</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = <span class="hljs-number">1000241002</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = <span class="hljs-number">1000241003</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL = <span class="hljs-number">1000314000</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL = <span class="hljs-number">1000314001</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br>    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = <span class="hljs-number">1000001002</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_decode_queue</span><br>    VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR = <span class="hljs-number">1000024000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_decode_queue</span><br>    VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR = <span class="hljs-number">1000024001</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_decode_queue</span><br>    VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR = <span class="hljs-number">1000024002</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_shared_presentable_image</span><br>    VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = <span class="hljs-number">1000111000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_fragment_density_map</span><br>    VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = <span class="hljs-number">1000218000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_fragment_shading_rate</span><br>    VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = <span class="hljs-number">1000164003</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_dynamic_rendering_local_read</span><br>    VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR = <span class="hljs-number">1000232000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_encode_queue</span><br>    VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR = <span class="hljs-number">1000299000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_encode_queue</span><br>    VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR = <span class="hljs-number">1000299001</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_encode_queue</span><br>    VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR = <span class="hljs-number">1000299002</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_attachment_feedback_loop_layout</span><br>    VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT = <span class="hljs-number">1000339000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_maintenance2</span><br>    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_KHR_maintenance2</span><br>    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_NV_shading_rate_image</span><br>    VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV = VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR,<br>  <span class="hljs-comment">// Provided by VK_KHR_separate_depth_stencil_layouts</span><br>    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_KHR_separate_depth_stencil_layouts</span><br>    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_KHR_separate_depth_stencil_layouts</span><br>    VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_KHR_separate_depth_stencil_layouts</span><br>    VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_KHR_synchronization2</span><br>    VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_KHR_synchronization2</span><br>    VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL,<br>&#125; VkImageLayout;<br></code></pre></td></tr></table></figure><p>可以看到布局方式有非常多种。我们在后续的学习中会陆续遇到其中的一些，在遇到这些布局方式的时候我们再对其加以解释。</p><p>在这里，我们希望如下指定布局：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;<br>colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">initialLayout</font></i>指定了图像在渲染通道开始之前应该是怎么布局的。我们并不关系渲染开始前图像的布局与内容，因为根据我们对<i><font color="Orange">loadOp</font></i>的设置，它的内容会在加载的时候被清空。<i><font color="Orange">finalLayout</font></i>指定图像在渲染通道结束后被自动转化为的布局类型。我们在渲染结束后希望将图像显示到屏幕上，因此该布局应该设置为<i><font color="Red">VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</font></i>以获取显示最优的布局。</p><p>至此附件描述填写完毕。</p><hr><h2 id="创建子通道">创建子通道</h2><p>一个渲染通道可以包含多个子通道。子通道指的是一系列的渲染操作，每一个子通道可以使用上一个子通道的渲染结果进行后处理等操作。我们可以将许多连续的渲染操作分为多个子通道并整合在一个渲染通道中，这样Vulkan可以适当地重排操作顺序以节省内存和带宽从而优化性能。不过对于我们绘制三角形的程序而言，创建一个子通道就足够了。</p><p>每一个子通道都需要引用一些创建好的附件描述信息。附件引用结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAttachmentReference.html"><code>VkAttachmentReference</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkAttachmentReference</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>         attachment;<br>    VkImageLayout    layout;<br>&#125; VkAttachmentReference;<br></code></pre></td></tr></table></figure><p>我们只需要指定它引用的附件索引以及在引用它的子通道的操作中它应该具有的布局即可。由于我们只创建了一个附件描述信息，因此<i><font color="Orange">attachment</font></i>设置为0即可。由于在子通道中进行渲染时，我们希望把上述附件作为颜色附件使用，因此<i><font color="Orange">layout</font></i>应该设置为<i><font color="Red">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</font></i>。</p><p>接下来我们就可以填写子通道的描述信息<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubpassDescription.html"><code>VkSubpassDescription</code></a>了，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSubpassDescription</span> &#123;</span><br>    VkSubpassDescriptionFlags       flags;<br>    VkPipelineBindPoint             pipelineBindPoint;<br>    <span class="hljs-type">uint32_t</span>                        inputAttachmentCount;<br>    <span class="hljs-type">const</span> VkAttachmentReference*    pInputAttachments;<br>    <span class="hljs-type">uint32_t</span>                        colorAttachmentCount;<br>    <span class="hljs-type">const</span> VkAttachmentReference*    pColorAttachments;<br>    <span class="hljs-type">const</span> VkAttachmentReference*    pResolveAttachments;<br>    <span class="hljs-type">const</span> VkAttachmentReference*    pDepthStencilAttachment;<br>    <span class="hljs-type">uint32_t</span>                        preserveAttachmentCount;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*                 pPreserveAttachments;<br>&#125; VkSubpassDescription;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>所有可能的取值及其含义可以参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubpassDescriptionFlagBits.html">这个页面</a>，这里我们并不需要指定任何特殊的标志。</p><p>由于未来Vulkan有可能会指定计算子通道，因此为了这个可能的拓展，我们必须指定我们在该渲染通道中使用的是哪种子通道。我们使用的是图形子通道，因此填写<i><font color="Red">VK_PIPELINE_BIND_POINT_GRAPHICS</font></i>即可。</p><p>接下来的所有参数指定了子通道对不同种类的附件的绑定情况。子通道可以引用的附件类型包括：</p><ul><li>输入附件（Inputattachments）：允许在渲染通道的子通道中读取来自其他子通道的附件内容，它主要用于实现多通道渲染和后处理效果</li><li>颜色附件（Color attachments）：存储渲染输出的颜色数据</li><li>多重采样附件（Resolveattachments）：主要作用是将多重采样的结果解析（resolve）到一个单一的颜色附件中，从而实现抗锯齿效果</li><li>深度模板附件（DepthStencilattachments）：储存渲染输出的深度和模板数据</li><li>保留附件（Preserveattachments）：主要用于在渲染过程中保持其内容不被修改。这种附件通常在多个渲染通道之间共享，允许在不同的渲染操作中保留数据，这有助于提高渲染效率，避免不必要的内存操作，因为它们不需要在每次渲染时进行加载和存储</li></ul><p>我们这里只需要颜色附件的位置绑上之前指定的附件引用就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSubpassDescription subpass&#123;&#125;;<br>subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;<br>subpass.colorAttachmentCount = <span class="hljs-number">1</span>;<br>subpass.pColorAttachments = &amp;colorAttachmentRef;<br></code></pre></td></tr></table></figure><hr><h2 id="创建渲染通道">创建渲染通道</h2><p>现在我们可以创建真正的渲染通道对象了。在类内新添一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRenderPass.html"><code>VkRenderPass</code></a>类型的成员<i><font color="Orange">renderPass</font></i>，接下来我们来填写创建信息<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateInfo.html"><code>VkRenderPassCreateInfo</code></a>，该结构体定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkRenderPassCreateInfo</span> &#123;</span><br>    VkStructureType                   sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                       pNext;<br>    VkRenderPassCreateFlags           flags;<br>    <span class="hljs-type">uint32_t</span>                          attachmentCount;<br>    <span class="hljs-type">const</span> VkAttachmentDescription*    pAttachments;<br>    <span class="hljs-type">uint32_t</span>                          subpassCount;<br>    <span class="hljs-type">const</span> VkSubpassDescription*       pSubpasses;<br>    <span class="hljs-type">uint32_t</span>                          dependencyCount;<br>    <span class="hljs-type">const</span> VkSubpassDependency*        pDependencies;<br>&#125; VkRenderPassCreateInfo;<br></code></pre></td></tr></table></figure></p><p><i><font color="Orange">flags</font></i>可能的取值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkRenderPassCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_QCOM_render_pass_transform</span><br>    VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//该标志允许开发者在创建渲染通道时对渲染目标进行几何变换。这意味着可以在渲染时对图像进行旋转、翻转或其他变换操作，而无需在应用程序中手动处理这些变换</span><br>&#125; VkRenderPassCreateFlagBits;<br></code></pre></td></tr></table></figure><p>接下来我们需要指定该渲染通道绑定的附件（注意此时指定的是附件本身而不是附件引用）以及子通道。</p><p>最后如果有多于一个的子通道，我们还需要指定它们之间的依赖关系（dependency）以确保在一个子通道完成之前，另一个子通道不会开始执行。这对于处理资源的读写冲突和同步至关重要。由于我们这里只有一个子通道，所以不需要指定这部分内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkRenderPassCreateInfo renderPassInfo&#123;&#125;;<br>renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;<br>renderPassInfo.attachmentCount = <span class="hljs-number">1</span>;<br>renderPassInfo.pAttachments = &amp;colorAttachment;<br>renderPassInfo.subpassCount = <span class="hljs-number">1</span>;<br>renderPassInfo.pSubpasses = &amp;subpass;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateRenderPass</span>(device, &amp;renderPassInfo, <span class="hljs-literal">nullptr</span>, &amp;renderPass) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create render pass!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就设置好了渲染通道的信息，下一章我们终于可以创建真正的渲染管线对象了！</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/">上一篇：固定管线</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/">下一篇：渲染管线</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>固定管线</title>
    <link href="/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/"/>
    <url>/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p><a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/">上一章</a>中我们已经构建好了渲染管线中的可编程阶段。本节将继续构建管线中的固定函数阶段。我们需要分别构建：</p><ul><li>顶点输入</li><li>输入汇编阶段</li><li>视口和裁剪</li><li>光栅化阶段</li><li>多重采样</li><li>深度模板测试</li><li>颜色混合阶段</li><li>管线布局</li></ul><p>下面我们依次构建所有的固定函数和阶段。</p><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions">Fixedfunctions</a>章节。</p><hr><h2 id="顶点输入">顶点输入</h2><p>首先我们需要指定顶点输入数据的格式。主要需要关注两部分：</p><ul><li>绑定方式：即数据之间的排列间隙以及数据是逐顶点的还是逐索引的</li><li>属性描述：即数据属性的类别以及它们对应的绑定点和在在数据块中的偏移</li></ul><p>指定数据输入格式是通过填写 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineVertexInputStateCreateInfo.html"><code>VkPipelineVertexInputStateCreateInfo</code></a>完成的，它的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineVertexInputStateCreateInfo</span> &#123;</span><br>    VkStructureType                             sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                 pNext;<br>    VkPipelineVertexInputStateCreateFlags       flags;<span class="hljs-comment">//暂时没有选项</span><br>    <span class="hljs-type">uint32_t</span>                                    vertexBindingDescriptionCount;<br>    <span class="hljs-type">const</span> VkVertexInputBindingDescription*      pVertexBindingDescriptions;<br>    <span class="hljs-type">uint32_t</span>                                    vertexAttributeDescriptionCount;<br>    <span class="hljs-type">const</span> VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;<br>&#125; VkPipelineVertexInputStateCreateInfo;<br></code></pre></td></tr></table></figure><p>其中<i><font color="Orange">pVertexBindingDescriptions</font></i>对应的就是绑定方式，<i><font color="Orange">pVertexAttributeDescriptions</font></i>对应的就是属性描述。</p><p>由于我们暂时是将顶点数据硬编码在顶点着色器中的，所以我们暂时不需要填写这些成员。在后续顶点缓冲章节我们会进行更详细得说明。</p><hr><h2 id="输入汇编阶段">输入汇编阶段</h2><p>输入汇编阶段通过 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineInputAssemblyStateCreateInfo.html"><code>VkPipelineInputAssemblyStateCreateInfo</code></a>指定。该结构体指定两方面的信息：</p><ul><li>顶点构成的图元种类</li><li>图元重启是否开启</li></ul><p>其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineInputAssemblyStateCreateInfo</span> &#123;</span><br>    VkStructureType                            sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                pNext;<br>    VkPipelineInputAssemblyStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    VkPrimitiveTopology                        topology;<br>    VkBool32                                   primitiveRestartEnable;<br>&#125; VkPipelineInputAssemblyStateCreateInfo;<br></code></pre></td></tr></table></figure><p>其中<i><font color="Orange">topology</font></i>指定的就是图元的种类，有关图元的所有种类可以参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPrimitiveTopology.html">这个页面</a>。</p><p><i><font color="Orange">primitiveRestartEnable</font></i>指定是否开启图元重启。图元重启（PrimitiveRestart）是图形渲染中的一种机制，用于在绘制图元（如三角形、线段等）时，允许在同一绘制调用中重启图元的绘制过程。这在处理复杂的几何体时非常有用，尤其是当使用索引缓冲区时。在绘制过程中，PrimitiveRestart 允许通过一个特殊的重启索引值（通常是一个特定的无效索引，如<code>0xFFFFFFFF</code>）来指示图元的重启。当遇到这个重启索引时，渲染管线会停止当前图元的绘制，并开始绘制一个新的图元。</p><p>为了绘制第一个三角形，这里我们只需如下指定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineInputAssemblyStateCreateInfo inputAssembly&#123;&#125;;<br>inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;<br>inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;<br>inputAssembly.primitiveRestartEnable = VK_FALSE;<br></code></pre></td></tr></table></figure><hr><h2 id="视口和裁剪">视口和裁剪</h2><p>视口和裁剪的设置比较特殊，它们既可以作为渲染管线的一部分被预先设置好并烘培至管线内，也可以在命令缓冲中动态设定以便在程序运行时动态改变而不重新建立渲染管线。</p><p>如果需要预先设置好，可以先分别填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkViewport.html"><code>VkViewport</code></a>和<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRect2D.html"><code>VkRect2D</code></a>结构体，它们的定义分别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkViewport</span> &#123;</span><br>    <span class="hljs-type">float</span>    x;<br>    <span class="hljs-type">float</span>    y;<br>    <span class="hljs-type">float</span>    width;<br>    <span class="hljs-type">float</span>    height;<br>    <span class="hljs-type">float</span>    minDepth;<br>    <span class="hljs-type">float</span>    maxDepth;<br>&#125; VkViewport;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkRect2D</span> &#123;</span><br>    VkOffset2D    offset;<br>    VkExtent2D    extent;<br>&#125; VkRect2D;<br></code></pre></td></tr></table></figure><p>先看<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkViewport.html"><code>VkViewport</code></a>：前两个坐标指定的是视口左上角的位置，最后两个值指定的是帧缓冲中坐标的深度范围，这个深度范围一定要在<strong>[0.0,1.0]</strong>中，但是最小深度允许在指定的时候大于最大深度。绝大多数情况下我们都希望视口范围和图像范围一样大，并且深度范围就是<strong>[0.0,1.0]</strong>，因此一般来讲可以这样填写该结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkViewport viewport&#123;&#125;;<br>viewport.x = <span class="hljs-number">0.0f</span>;<br>viewport.y = <span class="hljs-number">0.0f</span>;<br>viewport.width = (<span class="hljs-type">float</span>) swapChainExtent.width;<br>viewport.height = (<span class="hljs-type">float</span>) swapChainExtent.height;<br>viewport.minDepth = <span class="hljs-number">0.0f</span>;<br>viewport.maxDepth = <span class="hljs-number">1.0f</span>;<br></code></pre></td></tr></table></figure><p>对于裁剪范围，它由一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRect2D.html"><code>VkRect2D</code></a>结构体指定，它的两个成员分别指定偏移量和范围大小。如果不需要特殊的效果，一般来讲我们不需要裁剪图像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkRect2D scissor&#123;&#125;;<br>scissor.offset = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>scissor.extent = swapChainExtent;<br></code></pre></td></tr></table></figure><p>如果需要将视口和裁剪设置为动态阶段（dynamicstate），那么我们需要使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineDynamicStateCreateInfo.html"><code>VkPipelineDynamicStateCreateInfo</code></a>指定动态阶段的信息。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineDynamicStateCreateInfo</span> &#123;</span><br>    VkStructureType                      sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                          pNext;<br>    VkPipelineDynamicStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    <span class="hljs-type">uint32_t</span>                             dynamicStateCount;<br>    <span class="hljs-type">const</span> VkDynamicState*                pDynamicStates;<br>&#125; VkPipelineDynamicStateCreateInfo;<br></code></pre></td></tr></table></figure><p>因此我们需要如下填写该结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;VkDynamicState&gt; dynamicStates = &#123;<br>    VK_DYNAMIC_STATE_VIEWPORT,<br>    VK_DYNAMIC_STATE_SCISSOR<br>&#125;;<br><br>VkPipelineDynamicStateCreateInfo dynamicState&#123;&#125;;<br>dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;<br>dynamicState.dynamicStateCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(dynamicStates.<span class="hljs-built_in">size</span>());<br>dynamicState.pDynamicStates = dynamicStates.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>不管采取哪种方式，在指定好视口和裁剪的信息后，我们都需要通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportStateCreateInfo.html"><code>VkPipelineViewportStateCreateInfo</code></a>结构体告诉渲染管线我们使用的视口和裁剪，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineViewportStateCreateInfo</span> &#123;</span><br>    VkStructureType                       sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                           pNext;<br>    VkPipelineViewportStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    <span class="hljs-type">uint32_t</span>                              viewportCount;<br>    <span class="hljs-type">const</span> VkViewport*                     pViewports;<br>    <span class="hljs-type">uint32_t</span>                              scissorCount;<br>    <span class="hljs-type">const</span> VkRect2D*                       pScissors;<br>&#125; VkPipelineViewportStateCreateInfo;<br></code></pre></td></tr></table></figure><p>如果视口和裁剪使用动态阶段，那么我们无需填写<i><font color="Orange">pViewports</font></i>和<i><font color="Orange">pScissors</font></i>成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineViewportStateCreateInfo viewportState&#123;&#125;;<br>viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;<br>viewportState.viewportCount = <span class="hljs-number">1</span>;<br>viewportState.scissorCount = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>否则我们还需指定使用的视口和裁剪范围：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">viewportState.pViewports = &amp;viewport;<br>viewportState.pScissors = &amp;scissor;<br></code></pre></td></tr></table></figure><p>另外，从结构体的定义不难看出渲染管线是允许指定多视口和裁剪区域的，但是要这么做要求GPU具有相应的特性，这可以通过查询物理设备特性的函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures.html"><code>vkGetPhysicalDeviceFeatures</code></a>来查询，大致的查询结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPhysicalDeviceFeatures features;<br><span class="hljs-built_in">vkGetPhysicalDeviceFeatures</span>(physicalDevice, &amp;features);<br><br><span class="hljs-keyword">if</span> (features.multiViewport) &#123;<br>    <span class="hljs-comment">// 支持多视口</span><br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-keyword">if</span> (features.multiDrawIndirect) &#123;<br>    <span class="hljs-comment">// 支持多裁剪区域</span><br>    <span class="hljs-comment">///...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们解释一下视口区域和裁剪区域的区别。视口实际上可以看成是由图像到帧缓冲区的一个变换，它并不会导致图像上部分区域的丢失，只会拉伸或者压缩图像；而裁剪区域指定的是图像哪些像素会被保留，裁剪区域之外的部分会在光栅化阶段丢弃，它更像是一个过滤器。下面这张图很好地说明了这两者的区别与联系：</p><figure><img src="/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/视口裁剪.png" alt="视口和裁剪"><figcaption aria-hidden="true">视口和裁剪</figcaption></figure><hr><h2 id="光栅化阶段">光栅化阶段</h2><p>光栅化阶段将几何体分割为片段，并且执行提前深度测试、面剔除、裁剪测试等操作，它还决定了多边形绘制模式。这些信息都是通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateCreateInfo.html"><code>VkPipelineRasterizationStateCreateInfo</code></a>设定的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineRasterizationStateCreateInfo</span> &#123;</span><br>    VkStructureType                            sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                pNext;<br>    VkPipelineRasterizationStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    VkBool32                                   depthClampEnable;<br>    VkBool32                                   rasterizerDiscardEnable;<br>    VkPolygonMode                              polygonMode;<br>    VkCullModeFlags                            cullMode;<br>    VkFrontFace                                frontFace;<br>    VkBool32                                   depthBiasEnable;<br>    <span class="hljs-type">float</span>                                      depthBiasConstantFactor;<br>    <span class="hljs-type">float</span>                                      depthBiasClamp;<br>    <span class="hljs-type">float</span>                                      depthBiasSlopeFactor;<br>    <span class="hljs-type">float</span>                                      lineWidth;<br>&#125; VkPipelineRasterizationStateCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">depthClampEnable</font></i>指定深度值在<strong>[0.0,1.0]</strong>范围外的片段该如何处理，如果为<i><font color="Red">VK_TRUE</font></i>，那么相当于这些片段的深度值做clamp操作（这在阴影映射中有用，可以参考<a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">这篇文章</a>）；反之则简单地丢弃这些片段。启用该功能同样需要GPU特性<i><font color="Orange">VkPhysicalDeviceFeatures::depthClamp</font></i>为<i><font color="Red">VK_TRUE</font></i>。</p><p>接下来，如果<i><font color="Orange">rasterizerDiscardEnable</font></i>设置为<i><font color="Red">VK_TRUE</font></i>，那么意味着不会有任何几何形体通过光栅化阶段最终输出到帧缓冲上。为了得到渲染结果这个成员几乎总是设置为<i><font color="Red">VK_FALSE</font></i>。</p><p><i><font color="Orange">polygonMode</font></i>指定了多边形绘制模式，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPolygonMode.html"><code>VkPolygonMode</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkPolygonMode</span> &#123;</span><br>    VK_POLYGON_MODE_FILL = <span class="hljs-number">0</span>,<span class="hljs-comment">//以填充方式绘制多边形</span><br>    VK_POLYGON_MODE_LINE = <span class="hljs-number">1</span>,<span class="hljs-comment">//以线框方式绘制多边形</span><br>    VK_POLYGON_MODE_POINT = <span class="hljs-number">2</span>,<span class="hljs-comment">//以点模式绘制多边形</span><br>  <span class="hljs-comment">// Provided by VK_NV_fill_rectangle</span><br>    VK_POLYGON_MODE_FILL_RECTANGLE_NV = <span class="hljs-number">1000153000</span>,<span class="hljs-comment">//这是一个扩展的模式，专门用于填充矩形。这是由 VK_NV_fill_rectangle 扩展提供的，允许更高效地绘制矩形</span><br>&#125; VkPolygonMode;<br></code></pre></td></tr></table></figure><p>除了<i><font color="Red">VK_POLYGON_MODE_FILL</font></i>以外的模式都需要GPU具有相应的特性。</p><p><i><font color="Orange">lineWidth</font></i>成员指定多边形边界线宽度（以片段为单位）。一般来讲它设定为<strong>1.0</strong>，如果需要比这更宽的宽度则需要GPU具有特性<i><font color="Orange">wideLines</font></i>。</p><p>接下来的<i><font color="Orange">cullMode</font></i>和<i><font color="Orange">frontFace</font></i>指定了面剔除的方式。下面是它们可能的取值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkCullModeFlagBits</span> &#123;</span><br>    VK_CULL_MODE_NONE = <span class="hljs-number">0</span>,<br>    VK_CULL_MODE_FRONT_BIT = <span class="hljs-number">0x00000001</span>,<br>    VK_CULL_MODE_BACK_BIT = <span class="hljs-number">0x00000002</span>,<br>    VK_CULL_MODE_FRONT_AND_BACK = <span class="hljs-number">0x00000003</span>,<br>&#125; VkCullModeFlagBits;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkFrontFace</span> &#123;</span><br>    VK_FRONT_FACE_COUNTER_CLOCKWISE = <span class="hljs-number">0</span>,<br>    VK_FRONT_FACE_CLOCKWISE = <span class="hljs-number">1</span>,<br>&#125; VkFrontFace;<br></code></pre></td></tr></table></figure><p>这些枚举值的含义均易于理解，这里不再赘述。</p><p>最后的四个成员用于指定对深度值的一些操作，这些操作在阴影映射中有一定的运用，不过我们这里并不需要指定该功能。</p><p>最终，我们的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateCreateInfo.html"><code>VkPipelineRasterizationStateCreateInfo</code></a>结构体应该填写如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineRasterizationStateCreateInfo rasterizer&#123;&#125;;<br>rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;<br>rasterizer.depthClampEnable = VK_FALSE;<br>rasterizer.rasterizerDiscardEnable = VK_FALSE;<br>rasterizer.polygonMode = VK_POLYGON_MODE_FILL;<br>rasterizer.lineWidth = <span class="hljs-number">1.0f</span>;<br>rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;<br>rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;<br>rasterizer.depthBiasEnable = VK_FALSE;<br></code></pre></td></tr></table></figure><hr><h2 id="多重采样">多重采样</h2><p>对多重采样的指定通过填写 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineMultisampleStateCreateInfo.html"><code>VkPipelineMultisampleStateCreateInfo</code></a>来完成。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineMultisampleStateCreateInfo</span> &#123;</span><br>    VkStructureType                          sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                              pNext;<br>    VkPipelineMultisampleStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    VkSampleCountFlagBits                    rasterizationSamples;<br>    VkBool32                                 sampleShadingEnable;<br>    <span class="hljs-type">float</span>                                    minSampleShading;<br>    <span class="hljs-type">const</span> VkSampleMask*                      pSampleMask;<br>    VkBool32                                 alphaToCoverageEnable;<br>    VkBool32                                 alphaToOneEnable;<br>&#125; VkPipelineMultisampleStateCreateInfo;<br></code></pre></td></tr></table></figure><p>目前我们并不需要使用多重采样功能，所以只需禁用该功能即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineMultisampleStateCreateInfo multisampling&#123;&#125;;<br>multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;<br>multisampling.sampleShadingEnable = VK_FALSE;<br>multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;<br>multisampling.minSampleShading = <span class="hljs-number">1.0f</span>; <span class="hljs-comment">// Optional</span><br>multisampling.pSampleMask = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br>multisampling.alphaToCoverageEnable = VK_FALSE; <span class="hljs-comment">// Optional</span><br>multisampling.alphaToOneEnable = VK_FALSE; <span class="hljs-comment">// Optional</span><br></code></pre></td></tr></table></figure><p>多重采样是一种重要且高效的抗锯齿方式，它不需要像SSAA一样提高分辨率，而是只在边界上对一个像素的多个采样点运行多次片段着色器，最终对同一个像素中每个样本的颜色进行一个平均即可，可以大幅降低计算复杂度。关于MSAA原理的更详细的介绍可以阅读<a href="https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing">这篇文章</a>。</p><hr><h2 id="深度模板测试">深度模板测试</h2><p>由于我们目前希望渲染一个2D的三角形，这并不需要深度或者模板测试，因此我们暂时不需要填写相应的<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineDepthStencilStateCreateInfo.html"><code>VkPipelineDepthStencilStateCreateInfo</code></a>结构体，这部分会在之后开始绘制3维图像的时候介绍。</p><hr><h2 id="颜色混合阶段">颜色混合阶段</h2><p>在片段着色器计算出每个像素的颜色值之后，输出的颜色值需要和作为输出目标的帧缓冲中对应像素的颜色值进行混合。颜色混合有两种方式：</p><ul><li>直接混合两个颜色向量</li><li>对颜色值进行位运算</li></ul><p>设定颜色混合的信息结构体也有两个：<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>指定特定颜色附件的颜色混合设置，而<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendStateCreateInfo.html"><code>VkPipelineColorBlendStateCreateInfo</code></a>指定全局的颜色混合设置（适用于所有颜色附件）。它们的定义分别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineColorBlendAttachmentState</span> &#123;</span><br>    VkBool32                 blendEnable;<span class="hljs-comment">//如果为VK_FALSE，则着色器输出颜色直接覆盖帧缓冲对应像素上的颜色</span><br>    VkBlendFactor            srcColorBlendFactor;<br>    VkBlendFactor            dstColorBlendFactor;<br>    VkBlendOp                colorBlendOp;<br>    VkBlendFactor            srcAlphaBlendFactor;<br>    VkBlendFactor            dstAlphaBlendFactor;<br>    VkBlendOp                alphaBlendOp;<br>    VkColorComponentFlags    colorWriteMask;<span class="hljs-comment">//指定RGBA四通道分别是否可写</span><br>&#125; VkPipelineColorBlendAttachmentState;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">/ Provided by VK_VERSION_1_0<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineColorBlendStateCreateInfo</span> &#123;</span><br>    VkStructureType                               sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                   pNext;<br>    VkPipelineColorBlendStateCreateFlags          flags;<br>    VkBool32                                      logicOpEnable;<br>    VkLogicOp                                     logicOp;<br>    <span class="hljs-type">uint32_t</span>                                      attachmentCount;<br>    <span class="hljs-type">const</span> VkPipelineColorBlendAttachmentState*    pAttachments;<br>    <span class="hljs-type">float</span>                                         blendConstants[<span class="hljs-number">4</span>];<br>&#125; VkPipelineColorBlendStateCreateInfo;<br></code></pre></td></tr></table></figure><p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>允许我们指定每个颜色附件第一种混合方式的设置，该结构体除第一个成员和最后一个成员之外的所有成员均用于最后混合颜色的计算，计算的伪代码大致如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (blendEnable) &#123;<br>    finalColor.rgb = (srcColorBlendFactor * newColor.rgb) &lt;colorBlendOp&gt; (dstColorBlendFactor * oldColor.rgb);<br>    finalColor.a = (srcAlphaBlendFactor * newColor.a) &lt;alphaBlendOp&gt; (dstAlphaBlendFactor * oldColor.a);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    finalColor = newColor;<br>&#125;<br><br>finalColor = finalColor &amp; colorWriteMask;<br></code></pre></td></tr></table></figure><p>关于混合运算符<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBlendOp.html"><code>VkBlendOp</code></a>以及<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBlendFactor.html"><code>VkBlendFactor</code></a>，可以分别参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBlendOp.html"><code>这个页面</code></a>以及<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBlendFactor.html"><code>这个页面</code></a>，大多数的运算符以及运算因子的含义都是显而易见的，我们这里不再过多介绍。</p><p>接下来介绍一下全局设置结构体<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendStateCreateInfo.html"><code>VkPipelineColorBlendStateCreateInfo</code></a>。</p><p><i><font color="Orange">flags</font></i>是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendStateCreateFlagBits.html"><code>VkPipelineColorBlendStateCreateFlagBits</code></a>的位组合，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_rasterization_order_attachment_access</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkPipelineColorBlendStateCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_EXT_rasterization_order_attachment_access</span><br>    VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//指示颜色混合状态的创建将允许按照光栅化顺序访问附件。这意味着在处理多个颜色附件时，可以按照它们在渲染目标中的顺序进行访问，从而优化渲染性能。</span><br>  <span class="hljs-comment">// Provided by VK_ARM_rasterization_order_attachment_access</span><br>    VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM = VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT,<br>&#125; VkPipelineColorBlendStateCreateFlagBits;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">logicOpEnable</font></i>指定是否使用第二种方式混合颜色。这个成员设置为<i><font color="Red">VK_TRUE</font></i>的效果和所有颜色附件的<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>结构体中<i><font color="Orange">blendEnable</font></i>设置为<i><font color="Red">VK_FALSE</font></i>的效果是一样的，也就是说第一种颜色混合方式将被禁用。</p><p>逻辑运算符我们在这里也不过多介绍，可以参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkLogicOp.html">这个页面</a>。</p><p>下面的<i><font color="Orange">attachmentCount</font></i>和<i><font color="Orange">pAttachments</font></i>指定所有填写好的的颜色附件混合模式结构体<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>。最后的<i><font color="Orange">blendConstants</font></i>数组指定了<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>中指定的混合因子的具体值（<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>中指定的是一个抽象的混合因子，这个因子具体的值由<i><font color="Orange">blendConstants</font></i>数组指定）。</p><p>对于我们绘制三角形的程序，我们只有一个颜色附件，也不需要有特殊的混合操作，因此我们只需如下设置即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineColorBlendAttachmentState colorBlendAttachment&#123;&#125;;<br>colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;<br>colorBlendAttachment.blendEnable = VK_FALSE;<br>colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; <span class="hljs-comment">// Optional</span><br><br>VkPipelineColorBlendStateCreateInfo colorBlending&#123;&#125;;<br>colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;<br>colorBlending.logicOpEnable = VK_FALSE;<br>colorBlending.logicOp = VK_LOGIC_OP_COPY; <span class="hljs-comment">// Optional</span><br>colorBlending.attachmentCount = <span class="hljs-number">1</span>;<br>colorBlending.pAttachments = &amp;colorBlendAttachment;<br>colorBlending.blendConstants[<span class="hljs-number">0</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span><br>colorBlending.blendConstants[<span class="hljs-number">1</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span><br>colorBlending.blendConstants[<span class="hljs-number">2</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span><br>colorBlending.blendConstants[<span class="hljs-number">3</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span><br></code></pre></td></tr></table></figure><hr><h2 id="管线布局">管线布局</h2><p>在程序运行过程中我们往往需要动态地向着色器传入某些值，比如说uniform变量。尽管我们现在并不需要这么做，我们仍然需要创建一个空的<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineLayout.html"><code>VkPipelineLayout</code></a>来指定这些值。</p><p>在类内创建一个<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineLayout.html"><code>VkPipelineLayout</code></a>类型的成员<i><font color="Orange">pipelineLayout</font></i>，然后在<i><font color="Green">createGraphicsPipeline</font></i>函数中构建这个对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineLayoutCreateInfo pipelineLayoutInfo&#123;&#125;;<br>pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;<br>pipelineLayoutInfo.setLayoutCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>pipelineLayoutInfo.pSetLayouts = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br>pipelineLayoutInfo.pushConstantRangeCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>pipelineLayoutInfo.pPushConstantRanges = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreatePipelineLayout</span>(device, &amp;pipelineLayoutInfo, <span class="hljs-literal">nullptr</span>, &amp;pipelineLayout) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create pipeline layout!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineLayoutCreateInfo.html"><code>VkPipelineLayoutCreateInfo</code></a>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineLayoutCreateInfo</span> &#123;</span><br>    VkStructureType                 sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                     pNext;<br>    VkPipelineLayoutCreateFlags     flags;<br>    <span class="hljs-type">uint32_t</span>                        setLayoutCount;<br>    <span class="hljs-type">const</span> VkDescriptorSetLayout*    pSetLayouts;<br>    <span class="hljs-type">uint32_t</span>                        pushConstantRangeCount;<br>    <span class="hljs-type">const</span> VkPushConstantRange*      pPushConstantRanges;<br>&#125; VkPipelineLayoutCreateInfo;<br></code></pre></td></tr></table></figure><p>注意这个结构体可以指定两种传递给着色器的变量：<strong>uniformvalues</strong>和<strong>push constants</strong>。<strong>pushconstants</strong>实际上就是比较小型的数据块，它们直接嵌入到指令流中，因此在性能上优于使用缓冲区对象。不过它们的大小受到限制，一般为128字节。</p><p>大功告成！我们终于完成了所有固定管线阶段信息的填写。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/">上一篇：着色器模块</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/">下一篇：渲染通道</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>渲染管线简介</title>
    <link href="/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/"/>
    <url>/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>本节主要简单介绍一下渲染管线的各个阶段及其所做的工作，本节对应VulkanTutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Introduction">Graphicspipeline basics/Introduction</a>章节。</p><hr><h2 id="流程梳理">流程梳理</h2><p>下图给出了渲染管线的基本流程：</p><figure><img src="/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/pipeline.png" alt="渲染管线"><figcaption aria-hidden="true">渲染管线</figcaption></figure><ul><li><p>输入汇编器（inputassembler）阶段收集用户在缓冲区中指定的定点信息和顶点索引信息。</p></li><li><p>顶点着色器（vertexshader）阶段对各个顶点进行坐标变换并且向后传递逐顶点信息。</p></li><li><p>曲面细分（tessellation）阶段允许用户进一步细分几何以增加面片质量和精细度。</p></li><li><p>几何着色器（geometryshader）阶段作用于每个基本图元，增加或丢弃部分图元。</p></li><li><p>光栅化（rasterization）阶段将图元打散成片段并且丢弃在屏幕外面的那些片段。</p></li><li><p>片段着色器（fragmentshader）阶段决定每个片段的输出位置以及它们各自的输出结果。</p></li><li><p>颜色混合（colorblending）阶段采用指定的方式混合对应于同一像素的不同片段的值。</p></li></ul><p>图中绿色的阶段代表该阶段不可编程，也就是说我们只能设置与该阶段运作有关的一些参数，但不能自己编写该阶段的运行逻辑；而橙色阶段代表该阶段可编程，也就是说我们可以自己书写代码来指定该阶段的工作流程。</p><p>Vulkan中的渲染管线不同于OpenGL，绝大多数情况下我们不能在运行时改变管线的设置，一旦发生变化，我们一般会需要重新建立一个管线，这么做的好处是由于对管线的操作是提前预知且固定的，硬件就可以对管线进行一些优化。</p><p>接下来的章节，我们将建立一个<i><font color="Green">voidcreateGraphicsPipeline()</font></i>成员函数来建立起一个基本的渲染管线。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/">上一篇：图像视图</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/">下一篇：着色器模块</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>着色器模块</title>
    <link href="/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/"/>
    <url>/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>这一章节我们将完成渲染管线中可编程阶段的构建。目前我们只简单地考虑构建顶点着色器和片段着色器阶段。</p><p>与之前的图形API不同，Vulkan使用的着色器代码需要是<a href="https://www.khronos.org/spir">SPIR-V</a>格式的，它的优点是相比于易于我们阅读的GLSL和HLSL代码，<a href="https://www.khronos.org/spir">SPIR-V</a>代码更容易被转化为GPU使用的机器码，并且GLSL和HLSL代码可能会因为GPU产商所设定的不同标准产生在不同机器上的不兼容现象，<a href="https://www.khronos.org/spir">SPIR-V</a>代码就不会出现这种问题。</p><p>不过幸运的是，我们并不需要自己手写<a href="https://www.khronos.org/spir">SPIR-V</a>代码，这里我们将使用VulkanSDK自带的glslc.exe来将GLSL代码编译为<a href="https://www.khronos.org/spir">SPIR-V</a>代码。</p><p>创建着色器模块主要分为四步：</p><ul><li>编写着色器代码</li><li>将着色器文件编译为<a href="https://www.khronos.org/spir">SPIR-V</a>代码</li><li>加载着色器文件到程序中并包裹在<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html"><code>VkShaderModule</code></a>对象中</li><li>填写渲染管线着色器阶段信息</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules">Shadermodules</a>章节。</p><hr><h2 id="编写着色器代码">编写着色器代码</h2><p>假设读者已经对GLSL基本语法比较熟悉了。由于我们的第一个应用程序只需要简单地绘制一个三角形，所以顶点着色器代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-type">vec2</span> positions[<span class="hljs-number">3</span>] = <span class="hljs-type">vec2</span>[](<br>    <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">-0.5</span>),<br>    <span class="hljs-type">vec2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>),<br>    <span class="hljs-type">vec2</span>(<span class="hljs-number">-0.5</span>, <span class="hljs-number">0.5</span>)<br>);<br><br><span class="hljs-type">vec3</span> colors[<span class="hljs-number">3</span>] = <span class="hljs-type">vec3</span>[](<br>    <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>),<br>    <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>),<br>    <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>)<br>);<br><br><span class="hljs-type">void</span> main() &#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(positions[gl_VertexIndex], <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fragColor = colors[gl_VertexIndex];<br>&#125;<br></code></pre></td></tr></table></figure><p>目前我们还没有介绍顶点缓冲，因此我们暂时将顶点数据硬编码在着色器文件中。另外，每个顶点我们都赋予不同的颜色，以便在后续光栅化阶段插值该颜色以形成渐变色的效果。</p><p>注意，<i><font color="Orange">gl_VertexIndex</font></i>代表的是当前处理的顶点对应的索引，这是一个glsl内建变量。</p><p>片段着色器代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outColor;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> fragColor;<br><br><span class="hljs-type">void</span> main() &#123;<br>    outColor = <span class="hljs-type">vec4</span>(fragColor, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>片段着色器的输入数据并不需要和顶点着色器中对应的输出数据名称一致，但是需要指定它们的location一致，这样才能将对应的输出输入链接到一起。</p><hr><h2 id="编译为spir-v代码">编译为SPIR-V代码</h2><p>windows下编译为<a href="https://www.khronos.org/spir">SPIR-V</a>代码很简单，我们可以将上面的两个文件（分别命名为<font color="Purple">shader.vert</font>，<font color="Purple">shader,frag</font>）保存在项目根目录下的一个文件夹<font color="Purple">shaders</font>中，然后在该文件下创建一个批处理文件<font color="Purple">compile.bat</font>：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bat"><span class="hljs-built_in">path</span>/to/glslc.exe shader.vert -o vert.spv<br><span class="hljs-built_in">path</span>/to/glslc.exe shader.frag -o frag.spv<br><span class="hljs-built_in">pause</span><br></code></pre></td></tr></table></figure><p>将<i><font color="Orange">path/to/glslc.exe</font></i>替换为自己电脑上对应的glslc.exe文件路径即可。</p><p>双击bat文件运行即可在同一文件夹下创建对应的<a href="https://www.khronos.org/spir">SPIR-V</a>文件。</p><p>当然，这只是创建<a href="https://www.khronos.org/spir">SPIR-V</a>文件的一种方式，VulkanSDK还提供了<a href="https://github.com/google/shaderc">libshaderc</a>，它允许我们在程序代码中将glsl文件编译为<a href="https://www.khronos.org/spir">SPIR-V</a>文件。</p><hr><h2 id="创建vkshadermodule">创建VkShaderModule</h2><p>接下来我们需要将编译好的<a href="https://www.khronos.org/spir">SPIR-V</a>文件加载到程序中来。创建一个静态函数<i><font color="Green">staticstd::vector<char> readFile(const std::string&amp;filename)</char></font></i>来完成这个工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> std::vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">readFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename)</span> </span>&#123;<br>    <span class="hljs-function">std::ifstream <span class="hljs-title">file</span><span class="hljs-params">(filename, std::ios::ate | std::ios::binary)</span></span>;<br><span class="hljs-comment">//ate代表指针定位到文件末尾，这样可以通过tellg知道文件的大小；binary代表以二进制文件格式读取文件</span><br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">is_open</span>()) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to open file!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-type">size_t</span> fileSize = (<span class="hljs-type">size_t</span>) file.<span class="hljs-built_in">tellg</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(fileSize)</span></span>;<br>    <br>    file.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//定位到文件头，准备开始读取文件</span><br>    file.<span class="hljs-built_in">read</span>(buffer.<span class="hljs-built_in">data</span>(), fileSize);<br>    <br>    file.<span class="hljs-built_in">close</span>();<br><br><span class="hljs-keyword">return</span> buffer;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，在<i><font color="Green">crearteGraphicsPipeline</font></i>函数中，我们就可以使用这个函数来读取我们写好的顶点着色器和片段着色器文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createGraphicsPipeline</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> vertShaderCode = <span class="hljs-built_in">readFile</span>(<span class="hljs-string">&quot;shaders/vert.spv&quot;</span>);<br>    <span class="hljs-keyword">auto</span> fragShaderCode = <span class="hljs-built_in">readFile</span>(<span class="hljs-string">&quot;shaders/frag.spv&quot;</span>);<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>读取文件之后，我们需要使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html"><code>VkShaderModule</code></a>包裹住这个文件内容才能使用，因此我们创建一个<i><font color="Green">VkShaderModulecreateShaderModule(const std::vector<char>&amp;code)</char></font></i>来完成这项工作。</p><p>为了创建[<code>VkShaderModule</code><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html">id0</a>对象，我们当然也需要填写相关的信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModuleCreateInfo.html"><code>VkShaderModuleCreateInfo</code></a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkShaderModuleCreateInfo</span> &#123;</span><br>    VkStructureType              sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                  pNext;<br>    VkShaderModuleCreateFlags    flags;   <span class="hljs-comment">//目前还没有</span><br>    <span class="hljs-type">size_t</span>                       codeSize;<span class="hljs-comment">//文件大小</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*              pCode;  <span class="hljs-comment">//文件内容</span><br>&#125; VkShaderModuleCreateInfo;<br></code></pre></td></tr></table></figure><p>这里需要注意的是，我们传给<i><font color="Green">createShaderModule</font></i>的参数为字符向量，但是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModuleCreateInfo.html"><code>VkShaderModuleCreateInfo</code></a>需要的参数<i><font color="Orange">pCode</font></i>是字节码，也就是一个指向<i><font color="Orange">uint32_t</font></i>的指针，因此我们需要如下编写代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkShaderModule <span class="hljs-title">createShaderModule</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">char</span>&gt;&amp; code)</span> </span>&#123;<br>VkShaderModuleCreateInfo createInfo&#123;&#125;;<br>createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;<br>createInfo.codeSize = code.<span class="hljs-built_in">size</span>();<br>createInfo.pCode = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*&gt;(code.<span class="hljs-built_in">data</span>());<br>    <br>    VkShaderModule shaderModule;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateShaderModule</span>(device, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;shaderModule) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create shader module!&quot;</span>);<br>&#125;<br>    <br>    <span class="hljs-keyword">return</span> shaderModule;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以使用这个函数在<i><font color="Green">crearteGraphicsPipeline</font></i>函数中构建着色器文件相应的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html"><code>VkShaderModule</code></a>对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createGraphicsPipeline</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> vertShaderCode = <span class="hljs-built_in">readFile</span>(<span class="hljs-string">&quot;shaders/vert.spv&quot;</span>);<br>    <span class="hljs-keyword">auto</span> fragShaderCode = <span class="hljs-built_in">readFile</span>(<span class="hljs-string">&quot;shaders/frag.spv&quot;</span>);<br><br>    VkShaderModule vertShaderModule = <span class="hljs-built_in">createShaderModule</span>(vertShaderCode);<br>    VkShaderModule fragShaderModule = <span class="hljs-built_in">createShaderModule</span>(fragShaderCode);<br>    <span class="hljs-comment">//...</span><br>    <br>    <span class="hljs-built_in">vkDestroyShaderModule</span>(device, fragShaderModule, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">vkDestroyShaderModule</span>(device, vertShaderModule, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，在使用完着色器模块后要使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyShaderModule.html"><code>vkDestroyShaderModule</code></a>清理掉相应对象。注意，这里我们并没有将着色器模块保存为类的成员，因为着色器模块在渲染管线构建完成之后会被GPU编译链接为真正执行用的机器码，此后着色器模块对象就不再需要了，因此我们可以在<i><font color="Green">crearteGraphicsPipeline</font></i>函数最后将其销毁掉，没有保存的必要。</p><hr><h2 id="填写着色器阶段信息">填写着色器阶段信息</h2><p>创建好着色器模块后，我们需要将这个模块插入到渲染管线对应的着色器阶段中。为此我们需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateInfo.html"><code>VkPipelineShaderStageCreateInfo</code></a>以供后续创建渲染管线对象时使用。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateInfo.html"><code>VkPipelineShaderStageCreateInfo</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineShaderStageCreateInfo</span> &#123;</span><br>    VkStructureType                     sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                         pNext;<br>    VkPipelineShaderStageCreateFlags    flags;<br>    VkShaderStageFlagBits               stage;<br>    VkShaderModule                      module;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                         pName;              <span class="hljs-comment">//着色器入口函数名称</span><br>    <span class="hljs-type">const</span> VkSpecializationInfo*         pSpecializationInfo;<span class="hljs-comment">//特化常量信息</span><br>&#125; VkPipelineShaderStageCreateInfo;<br></code></pre></td></tr></table></figure><p><a href="https://zpc-dsg.github.io/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/"><code>VkPipelineShaderStageCreateFlags</code></a>是<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E5%87%BD%E6%95%B0/"><code>VkPipelineShaderStageCreateFlagBits</code></a>的位组合，后者定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkPipelineShaderStageCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//允许在该着色器阶段使用可变大小的子组（subgroup）。这意味着在执行过程中，子组的大小可以变化，从而提供更大的灵活性，适用于某些计算任务。</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//要求该着色器阶段使用完整的子组。即所有子组的大小必须是指定的最大子组大小，这通常用于保证性能和一致性，确保所有线程在子组内都能得到相同的执行路径。</span><br>  <span class="hljs-comment">// Provided by VK_EXT_subgroup_size_control</span><br>    VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT,<br>  <span class="hljs-comment">// Provided by VK_EXT_subgroup_size_control</span><br>    VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT,<br>&#125; VkPipelineShaderStageCreateFlagBits;<br></code></pre></td></tr></table></figure><p>首先需要解释的是<i><font color="Orange">pName</font></i>成员，该形参指定着色器代码的入口点。一般来讲我们的glsl着色器代码入口点为<i><font color="Green">main</font></i>函数，但是Vulkan允许我们指定其它函数名作为入口函数，这也意味着我们可以在一个着色器模块中绑定多个具有不同入口名的着色器文件。</p><p>另外，<i><font color="Orange">pSpecializationInfo</font></i>指定的是需要传给着色器的特化常量的信息。特化常量是在着色器编译时指定的常量值。它们在着色器代码中声明为特化常量，并在编译时被替换为具体的值。这使得可以在不同的管线实例中使用不同的常量值，提高了性能，因为编译器能够针对这些常量进行优化。在GLSL 中，特化常量通常使用 <code>const</code> 关键字来声明，但在 Vulkan中，需要使用特化常量的机制来定义和传递这些值。特化常量与C中的预编译命令<code>#define</code>类似，不过特化常量是有类型的，编译器能够进行类型检查，并且特化常量的作用域通常局限于声明它们的着色器阶段，因此相比来讲特化常量具有类型安全和更好的作用域控制。</p><p>现在我们在<i><font color="Green">crearteGraphicsPipeline</font></i>函数中填写顶点着色器和片段着色器对应的着色器阶段信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineShaderStageCreateInfo vertShaderStageInfo&#123;&#125;;<br>vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;<br>vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;<br>vertShaderStageInfo.<span class="hljs-keyword">module</span> = vertShaderModule;<br>vertShaderStageInfo.pName = <span class="hljs-string">&quot;main&quot;</span>;<br><br>VkPipelineShaderStageCreateInfo fragShaderStageInfo&#123;&#125;;<br>fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;<br>fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;<br>fragShaderStageInfo.<span class="hljs-keyword">module</span> = fragShaderModule;<br>fragShaderStageInfo.pName = <span class="hljs-string">&quot;main&quot;</span>;<br><br>VkPipelineShaderStageCreateInfo shaderStages[] = &#123;vertShaderStageInfo, fragShaderStageInfo&#125;;<br></code></pre></td></tr></table></figure><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/">上一篇：渲染管线简介</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E5%87%BD%E6%95%B0/">下一篇：固定管线</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图像视图</title>
    <link href="/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/"/>
    <url>/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>为了使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImage.html"><code>VkImage</code></a>，我们需要相应的视图<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageView.html"><code>VkImageView</code></a>。图像视图的作用是描述图像应该如何被使用以及图像的哪部分可以被使用。接下来我们将创建一个<i><font color="Green">voidcreateImageViews()</font></i>函数来创建所有的图像视图。创建图像视图的过程比较简单，主要分为两步：</p><ul><li>填写创建信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateInfo.html"><code>VkImageViewCreateInfo</code></a></li><li>创建图像视图对象</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Image_views">Imageviews</a>章节。</p><hr><h2 id="填写创建信息">填写创建信息</h2><p>由于对于每张图像我们都需要有对应的视图，因此我们在<i><font color="Green">createImageViews</font></i>函数中创建一个循环来填写每个视图的信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createImageViews</span><span class="hljs-params">()</span> </span>&#123;<br>    swapChainImageViews.<span class="hljs-built_in">resize</span>(swapChainImages.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainImages.<span class="hljs-built_in">size</span>(); i++) &#123;<br>VkImageViewCreateInfo createInfo&#123;&#125;;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateInfo.html"><code>VkImageViewCreateInfo</code></a>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkImageViewCreateInfo</span> &#123;</span><br>    VkStructureType            sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                pNext;<br>    VkImageViewCreateFlags     flags;<br>    VkImage                    image;<br>    VkImageViewType            viewType;<br>    VkFormat                   format;<br>    VkComponentMapping         components;<br>    VkImageSubresourceRange    subresourceRange;<br>&#125; VkImageViewCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateFlagBits.html"><code>VkImageViewCreateFlagBits</code></a>的位组合，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateFlagBits.html"><code>VkImageViewCreateFlagBits</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkImageViewCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_EXT_fragment_density_map</span><br>    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//此标志指示图像视图将用于动态片段密度映射（fragment density map）。动态片段密度映射允许在运行时调整每个像素的片段密度，以优化渲染性能和资源使用。</span><br>  <span class="hljs-comment">// Provided by VK_EXT_descriptor_buffer</span><br>    VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//表示图像视图将用于延迟片段密度映射。这种方式允许在后续渲染阶段处理片段密度，而不是在每个绘制调用中立即处理，从而提高效率。</span><br>  <span class="hljs-comment">// Provided by VK_EXT_fragment_density_map2</span><br>    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//此标志用于描述符缓冲区的捕获和重放。它指示图像视图可以在捕获和重放的上下文中使用，这对于调试和性能分析工具非常有用。</span><br>&#125; VkImageViewCreateFlagBits;<br></code></pre></td></tr></table></figure><p>我们在这里不指定任何标志。</p><p>接下来需要解释的是<i><font color="Orange">viewType</font></i>，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewType.html"><code>VkImageViewType</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkImageViewType</span> &#123;</span><br>    VK_IMAGE_VIEW_TYPE_1D = <span class="hljs-number">0</span>,<br>    VK_IMAGE_VIEW_TYPE_2D = <span class="hljs-number">1</span>,<br>    VK_IMAGE_VIEW_TYPE_3D = <span class="hljs-number">2</span>,<br>    VK_IMAGE_VIEW_TYPE_CUBE = <span class="hljs-number">3</span>,<br>    VK_IMAGE_VIEW_TYPE_1D_ARRAY = <span class="hljs-number">4</span>,<br>    VK_IMAGE_VIEW_TYPE_2D_ARRAY = <span class="hljs-number">5</span>,<br>    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = <span class="hljs-number">6</span>,<br>&#125; VkImageViewType;<br></code></pre></td></tr></table></figure><p>显然作为颜色缓冲的图像类型应该被指定为<i><font color="Red">VK_IMAGE_VIEW_TYPE_2D</font></i>。</p><p>之后的<i><font color="Orange">format</font></i>也应当和该视图对应的图像一致，因此我们将上一章保存在应用程序类内的成员<i><font color="Orange">swapChainImageFormat</font></i>为其赋值。</p><p><i><font color="Orange">components</font></i>指定了图像颜色通道的再映射。我们这里不需要任何特殊的映射，因此我们只需简单地指定映射为恒等变换即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;<br>createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;<br>createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;<br>createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;<br></code></pre></td></tr></table></figure><p>最后，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceRange.html"><code>VkImageSubresourceRange</code></a>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkImageSubresourceRange</span> &#123;</span><br>    VkImageAspectFlags    aspectMask;    <span class="hljs-comment">//图像的方面，即图像数据的不同特性或组成部分</span><br>    <span class="hljs-type">uint32_t</span>              baseMipLevel;  <span class="hljs-comment">//基础多级渐远级别</span><br>    <span class="hljs-type">uint32_t</span>              levelCount; <span class="hljs-comment">//多级渐远级数</span><br>    <span class="hljs-type">uint32_t</span>              baseArrayLayer;<span class="hljs-comment">//基础图像层</span><br>    <span class="hljs-type">uint32_t</span>              layerCount; <span class="hljs-comment">//图像层数目</span><br>&#125; VkImageSubresourceRange;<br></code></pre></td></tr></table></figure><p>我们希望交换链中的图像用作颜色缓冲，因此<i><font color="Orange">subresourceRange.aspectMask</font></i>应该指定为<i><font color="Red">VK_IMAGE_ASPECT_COLOR_BIT</font></i>。颜色缓冲不需要生成多级渐远纹理，因此<i><font color="Orange">subresourceRange.baseMipLevel</font></i>设为0，<i><font color="Orange">subresourceRange.levelCount</font></i>设为1。由于我们并非创建一个3D项目，因此并不需要多图像层，因此<i><font color="Orange">subresourceRange.baseArrayLayer</font></i>设为0，<i><font color="Orange">subresourceRange.layerCount</font></i>设为1即可。</p><p>这样我们就完成了信息的填写。</p><hr><h2 id="创建视图">创建视图</h2><p>创建过程一如以往：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateImageView</span>(device, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;swapChainImageViews[i]) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create image views!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，即使创建好了图像视图，也不意味着图像已经可以作为渲染目标使用了，我们还需要创建帧缓冲对象来存储图像视图才能进行渲染，后续章节会介绍这一部分内容。</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/">上一篇：交换链</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/">下一篇：渲染管线简介</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>交换链</title>
    <link href="/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/"/>
    <url>/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>Vulkan中并没有所谓的“默认帧缓冲”的概念，所以我们需要一个能够储存渲染后图像以便之后显示到屏幕上的设施，这个设施就是交换链（swapChain）。交换链本质上就是一列图像，我们的应用程序会不断获取其中的一张，显示到屏幕上，然后归还给交换链。</p><p>创建一个交换链主要分为三步：</p><ul><li>查询显卡是否支持交换链并启用相应拓展</li><li>填写创建交换链所需的必要信息</li><li>创建交换链并保存有关对象为类成员</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain#page_Surface-format">Swapchain</a>章节。</p><hr><h2 id="查询支持">查询支持</h2><p>查询硬件是否支持交换链可以分为两步：查询交换链是否可用，以及查询交换链是否完整地具有所需的功能。</p><h4 id="查询交换链可用性">查询交换链可用性</h4><p>首先来查询物理设备是否支持交换链。事实上，如果一个物理设备支持显示队列的话，那么它一定支持交换链拓展。不过，在Vulkan中清晰地展示出一切细节总不是件坏事。所以这里我们还是选择查询一下设备对交换链的支持。</p><p>交换链支持拓展名为<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_swapchain.html"><code>VK_KHR_swapchain</code></a>，它是一个设备层面的拓展。于是我们在类外创建一个全局变量保存我们可能需要的所有设备层面的拓展名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; deviceExtensions = &#123;<br>    VK_KHR_SWAPCHAIN_EXTENSION_NAME<span class="hljs-comment">//字符串&quot;VK_KHR_swapchain&quot;对应的宏，用它避免拼写错误</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>下面，我们需要查询物理设备是否支持这个拓展。于是添加一个<i><font color="Green">checkDeviceExtensionSupport</font></i>函数来统一处理设备层面拓展的支持查询：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkDeviceExtensionSupport</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> extensionCount;<br>    <span class="hljs-built_in">vkEnumerateDeviceExtensionProperties</span>(device, <span class="hljs-literal">nullptr</span>, &amp;extensionCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkExtensionProperties&gt; <span class="hljs-title">availableExtensions</span><span class="hljs-params">(extensionCount)</span></span>;<br>    <span class="hljs-built_in">vkEnumerateDeviceExtensionProperties</span>(device, <span class="hljs-literal">nullptr</span>, &amp;extensionCount, availableExtensions.<span class="hljs-built_in">data</span>());<br><br>    <span class="hljs-function">std::set&lt;std::string&gt; <span class="hljs-title">requiredExtensions</span><span class="hljs-params">(deviceExtensions.begin(), deviceExtensions.end())</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; extension : availableExtensions) &#123;<br>        requiredExtensions.<span class="hljs-built_in">erase</span>(extension.extensionName);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> requiredExtensions.<span class="hljs-built_in">empty</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是易于理解的。</p><p>接下来我们要做的就是在<i><font color="Green">isDeviceSuitable</font></i>函数中使用<i><font color="Green">checkDeviceExtensionSupport</font></i>检查给定的物理设备是否支持指定的拓展：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(device);<br><br>    <span class="hljs-type">bool</span> extensionsSupported = <span class="hljs-built_in">checkDeviceExtensionSupport</span>(device);<br><br>    <span class="hljs-keyword">return</span> indices.<span class="hljs-built_in">isComplete</span>() &amp;&amp; extensionsSupported;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，如果选择的物理设备支持交换链拓展，那么我们需要启用这个拓展。启用拓展只需略微修改逻辑设备的createInfo，将原来的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.enabledExtensionCount = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>改为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.enabledExtensionCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(deviceExtensions.<span class="hljs-built_in">size</span>());<br>createInfo.ppEnabledExtensionNames = deviceExtensions.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>即可。</p><h4 id="查询交换链完整性">查询交换链完整性</h4><p>仅仅查询交换链是否可用是不够的，我们还需要知道选定的支持交换链的物理设备是否具有所需的和显示有关的表面功能特性。我们需要查询的主要细节有三点：</p><ul><li>基本表面属性，包括交换链可以具有的最少/最多图像数目，图像的最小/最大尺寸等</li><li>表面格式，具体而言指的是像素格式和颜色空间</li><li>可用显示模式</li></ul><p>于是建立一个结构体<i><font color="Orange">SwapChainSupportDetails</font></i>来保存这些查询结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SwapChainSupportDetails</span> &#123;<br>    VkSurfaceCapabilitiesKHR capabilities;<br>    std::vector&lt;VkSurfaceFormatKHR&gt; formats;<br>    std::vector&lt;VkPresentModeKHR&gt; presentModes;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在类内建立一个成员函数<i><font color="Green">SwapChainSupportDetailsquerySwapChainSupport(VkPhysicalDevicedevice)</font></i>来负责具体的查询：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SwapChainSupportDetails <span class="hljs-title">querySwapChainSupport</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    SwapChainSupportDetails details;<br><br>    <span class="hljs-built_in">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</span>(device, surface, &amp;details.capabilities);<br>    <br>    <span class="hljs-type">uint32_t</span> formatCount;<br><span class="hljs-built_in">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(device, surface, &amp;formatCount, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-keyword">if</span> (formatCount != <span class="hljs-number">0</span>) &#123;<br>    details.formats.<span class="hljs-built_in">resize</span>(formatCount);<br>    <span class="hljs-built_in">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(device, surface, &amp;formatCount, details.formats.<span class="hljs-built_in">data</span>());<br>&#125;<br>    <br>    <span class="hljs-type">uint32_t</span> presentModeCount;<br><span class="hljs-built_in">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(device, surface, &amp;presentModeCount, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-keyword">if</span> (presentModeCount != <span class="hljs-number">0</span>) &#123;<br>    details.presentModes.<span class="hljs-built_in">resize</span>(presentModeCount);<br>    <span class="hljs-built_in">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(device, surface, &amp;presentModeCount, details.presentModes.<span class="hljs-built_in">data</span>());<br>&#125;<br>    <span class="hljs-keyword">return</span> details;<br>&#125;<br></code></pre></td></tr></table></figure><p>查询过程就是单纯地依次填充每个结构体成员。在这里我们只是简单地要求表面格式和显示模式均至少要有一种，这样就认为该物理设备的交换链是完整可用的。</p><p>现在我们需要再次修改一下<i><font color="Green">isDeviceSuitable</font></i>函数以添加检查交换链完整性的逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(device);<br><br>    <span class="hljs-type">bool</span> extensionsSupported = <span class="hljs-built_in">checkDeviceExtensionSupport</span>(device);<br><br>    <span class="hljs-type">bool</span> swapChainAdequate = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (extensionsSupported) &#123;<br>        SwapChainSupportDetails swapChainSupport = <span class="hljs-built_in">querySwapChainSupport</span>(device);<br>        swapChainAdequate = !swapChainSupport.formats.<span class="hljs-built_in">empty</span>() &amp;&amp; !swapChainSupport.presentModes.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> indices.<span class="hljs-built_in">isComplete</span>() &amp;&amp; extensionsSupported &amp;&amp; swapChainAdequate;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="填写创建信息">填写创建信息</h2><p>下面我们创建一个<i><font color="Green">voidcreateSwapChain()</font></i>函数来创建交换链。首先我们需要查询交换链有关的表面信息以方便后续交换链创建信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>的填写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createSwapChain</span><span class="hljs-params">()</span> </span>&#123;<br>    SwapChainSupportDetails swapChainSupport = <span class="hljs-built_in">querySwapChainSupport</span>(physicalDevice);<br><br>    VkSwapchainCreateInfoKHR createInfo&#123;&#125;;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>交换链创建信息需要指定的信息量相较于之前创建的对象要多得多，我们逐个填写。</p><p>首先总览一下交换链创建信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSwapchainCreateInfoKHR</span> &#123;</span><br>    VkStructureType                  sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                      pNext;<br>    VkSwapchainCreateFlagsKHR        flags;<br>    VkSurfaceKHR                     surface; <span class="hljs-comment">//对应的表面</span><br>    <span class="hljs-type">uint32_t</span>                         minImageCount;<br>    VkFormat                         imageFormat;<br>    VkColorSpaceKHR                  imageColorSpace;<br>    VkExtent2D                       imageExtent;<br>    <span class="hljs-type">uint32_t</span>                         imageArrayLayers;<br>    VkImageUsageFlags                imageUsage;<br>    VkSharingMode                    imageSharingMode;<br>    <span class="hljs-type">uint32_t</span>                         queueFamilyIndexCount;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*                  pQueueFamilyIndices;<br>    VkSurfaceTransformFlagBitsKHR    preTransform;<br>    VkCompositeAlphaFlagBitsKHR      compositeAlpha;<br>    VkPresentModeKHR                 presentMode;<br>    VkBool32                         clipped;<br>    VkSwapchainKHR                   oldSwapchain;<br>&#125; VkSwapchainCreateInfoKHR;<br></code></pre></td></tr></table></figure><p>首先看第三个成员<i><font color="Orange">flags</font></i>，它是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateFlagBitsKHR.html"><code>VkSwapchainCreateFlagBitsKHR</code></a>的位组合。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateFlagBitsKHR.html"><code>VkSwapchainCreateFlagBitsKHR</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkSwapchainCreateFlagBitsKHR</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1 with VK_KHR_swapchain, VK_KHR_device_group with VK_KHR_swapchain</span><br>    VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//表示交换链的图像可以在不同的实例中进行绑定，这对于多实例的设备组（Device Group）非常有用。它允许在不同的设备实例之间共享交换链图像</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1 with VK_KHR_swapchain</span><br>    VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//指定交换链中的图像是受保护的。这意味着这些图像的内容在某些情况下（例如，受保护的内容播放）不会被访问或修改。这个标志通常用于需要内容保护的应用程序，如播放受版权保护的媒体</span><br>  <span class="hljs-comment">// Provided by VK_KHR_swapchain_mutable_format</span><br>    VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//允许交换链的格式在创建后进行更改。这对于需要动态调整图像格式的应用程序非常有用，比如在不同的显示设备上使用不同的格式</span><br>  <span class="hljs-comment">// Provided by VK_EXT_swapchain_maintenance1</span><br>    VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//指示交换链的图像内存分配可以延迟到实际使用时。这有助于优化内存使用，特别是在不确定图像会被使用的情况下</span><br>&#125; VkSwapchainCreateFlagBitsKHR;<br></code></pre></td></tr></table></figure><p>我们这里不需要设置任何标志位;</p><p>接下来要填写<i><font color="Orange">minImageCount</font></i>成员。这可以通过查询我们之前自定义的结构体<i><font color="Orange">SwapChainSupportDetails</font></i>的成员<i><font color="Orange">capabilities</font></i>的<i><font color="Orange">minImageCount</font></i>和<i><font color="Orange">maxImageCount</font></i>成员来决定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> imageCount = swapChainSupport.capabilities.minImageCount + <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span> (swapChainSupport.capabilities.maxImageCount &gt; <span class="hljs-number">0</span> &amp;&amp; imageCount &gt; swapChainSupport.capabilities.maxImageCount) &#123;<br>    imageCount = swapChainSupport.capabilities.maxImageCount;<br>&#125;<br><br>createInfo.minImageCount = imageCount;<br></code></pre></td></tr></table></figure><p>这里有两个需要解释的地方：第一行中加1是因为如果仅仅使用最少数量的图像可能意味着我们有时可能需要等待驱动程序完成内部操作，才能获取另一个图像进行渲染，因此我们要求至少多一张图像；另外maxImageCount==0其实意味着交换链可以拥有的图像没有上界，因此当这个值大于0时，我们需要控制要求的交换链图像数目不超过其可能上界。</p><p>接下来，对于<i><font color="Orange">imageFormat</font></i>和<i><font color="Orange">imageColorSpace</font></i>成员，我们可以通过<i><font color="Orange">SwapChainSupportDetails</font></i>结构体的成员<i><font color="Orange">formats</font></i>成员来获取相关信息。<i><font color="Orange">formats</font></i>包含了交换链支持的所有表面图像格式信息，我们需要从中挑选最符合我们要求的那个格式。因此，我们创建一个<i><font color="Green">VkSurfaceFormatKHRchooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>&amp;availableFormats)</VkSurfaceFormatKHR></font></i>函数来达到上述目的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkSurfaceFormatKHR <span class="hljs-title">chooseSwapSurfaceFormat</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;VkSurfaceFormatKHR&gt;&amp; availableFormats)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; availableFormat : availableFormats) &#123;<br>        <span class="hljs-keyword">if</span> (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB &amp;&amp; availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) &#123;<br>            <span class="hljs-keyword">return</span> availableFormat;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> availableFormats[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>我们希望挑选的颜色格式是<i><font color="Red">VK_FORMAT_B8G8R8A8_SRGB</font></i>，希望图像所处的颜色空间为sRGB颜色空间<i><font color="Red">VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</font></i>（关于sRGB空间和伽马矫正的原理介绍，可以参考<a href="https://learnopengl.com/Introduction">LearnOpenGL</a>教程的<a href="https://learnopengl.com/Advanced-Lighting/Gamma-Correction">GammaCorrection</a>章节），如果不支持这种格式的图像的话，那就退而求其次，直接返回第一个支持的格式（当然我们可以自定义一些更复杂的选择逻辑）。</p><p>这样，我们就可以填写<i><font color="Orange">imageFormat</font></i>和<i><font color="Orange">imageColorSpace</font></i>成员的信息了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSurfaceFormatKHR surfaceFormat = <span class="hljs-built_in">chooseSwapSurfaceFormat</span>(swapChainSupport.formats);<br><br>createInfo.imageFormat = surfaceFormat.format;<br>createInfo.imageColorSpace = surfaceFormat.colorSpace;<br></code></pre></td></tr></table></figure><p>然后我们来填写<i><font color="Orange">imageExtent</font></i>成员。这个形参代表的是交换链图像的分辨率。一般来讲，这个分辨率要和屏幕的分辨率一致，此时我们可以直接通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilitiesKHR.html"><code>VkSurfaceCapabilitiesKHR</code></a>结构体的<i><font color="Orange">currentExtent</font></i>成员来获取图像的尺寸。但是有的窗口系统会允许交换链图像的分辨率与屏幕分辨率不一致，此时<i><font color="Orange">currentExtent</font></i>会被设置为<a href="https://en.cppreference.com/w/cpp/types/numeric_limits/max"><code>std::numeric_limits&lt;uint32_t&gt;::max()</code></a>，这种时候我们就必须自己决定最匹配屏幕的图像分辨率了。我们可以创建一个<i><font color="Green">VkExtent2DchooseSwapExtent(const VkSurfaceCapabilitiesKHR&amp;capabilities)</font></i>函数来决定图像分辨率：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkExtent2D <span class="hljs-title">chooseSwapExtent</span><span class="hljs-params">(<span class="hljs-type">const</span> VkSurfaceCapabilitiesKHR&amp; capabilities)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (capabilities.currentExtent.width != std::numeric_limits&lt;<span class="hljs-type">uint32_t</span>&gt;::<span class="hljs-built_in">max</span>()) &#123;<br>        <span class="hljs-keyword">return</span> capabilities.currentExtent;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> width, height;<br>        <span class="hljs-built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);<br><br>        VkExtent2D actualExtent = &#123;<br>            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(width),<br>            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(height)<br>        &#125;;<br><br>        actualExtent.width = std::<span class="hljs-built_in">clamp</span>(actualExtent.width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width);<br>        actualExtent.height = std::<span class="hljs-built_in">clamp</span>(actualExtent.height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height);<br><br>        <span class="hljs-keyword">return</span> actualExtent;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要注意，GLFW有两种分辨率单位，一种是屏幕坐标，另一种是像素个数，这二者未必总是相同的，例如在高DPI设备上实际像素数就要高于屏幕坐标范围。由于Vulkan指定的图像分辨率是通过像素个数指定的，所以我们需要使用<a href="https://www.glfw.org/docs/3.3/group__window.html#ga0e2637a4161afb283f5300c7f94785c9"><code>glfwGetFramebufferSize</code></a>来获取当前屏幕的像素数。另外，我们需要控制选取的图像像素数不超过[minImageExtent,maxImageExtent]的范围，这通过<a href="https://en.cppreference.com/w/cpp/algorithm/clamp"><code>std::clamp</code></a>实现。</p><p>这样我们就可以使用该函数得到createInfo中需要的图像尺寸了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkExtent2D extent = <span class="hljs-built_in">chooseSwapExtent</span>(swapChainSupport.capabilities);<br><br>createInfo.imageExtent = extent;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">VkSwapchainCreateInfoKHR</font></i>结构体中接下来的成员<i><font color="Orange">imageArrayLayers</font></i>是多视图/立体表面中的视图数量。对于非立体3D应用程序，这个值为1。我们直接将其设为1即可。</p><p>接下来我们需要指定交换链中图像的用途。我们目前希望交换链中的图像用作渲染目标，于是可以给<i><font color="Orange">imageUsage</font></i>成员赋予<i><font color="Red">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</font></i>，也就是指定图像作为渲染的颜色缓冲。之后我们会接触到更多的图像使用方式。</p><p>下面我们要指定交换链中的图像要怎么用于多个队列家族中。当我们之前选定的图像队列和显示队列不一致的时候，我们就有两个不同队列家族种的队列了，此时我们需要指定这两个队列共享图像的模式，这通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html"><code>VkSharingMode</code></a>来指定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkSharingMode</span> &#123;</span><br>    VK_SHARING_MODE_EXCLUSIVE = <span class="hljs-number">0</span>,<span class="hljs-comment">//不允许同时有多个队列家族的队列访问图像</span><br>    VK_SHARING_MODE_CONCURRENT = <span class="hljs-number">1</span>,<span class="hljs-comment">//可以同时有多个队列家族的队列访问图像</span><br>&#125; VkSharingMode;<br></code></pre></td></tr></table></figure><p>如果有多个队列家族都需要访问交换链图像，此时如果选择<i><font color="Red">VK_SHARING_MODE_EXCLUSIVE</font></i>，那么我们还需要处理图像所有权在不同队列之间的转移问题。因此在这种情况下我们就简单地使用<i><font color="Red">VK_SHARING_MODE_CONCURRENT</font></i>模式就好了。如果只有一个队列家族（图像队列和显示队列一致），那么直接使用<i><font color="Red">VK_SHARING_MODE_EXCLUSIVE</font></i>就可以了。当然，在指定了共享模式之后，我们还需要指定共享这些图像的队列家族个数和索引：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(physicalDevice);<br><span class="hljs-type">uint32_t</span> queueFamilyIndices[] = &#123;indices.graphicsFamily.<span class="hljs-built_in">value</span>(), indices.presentFamily.<span class="hljs-built_in">value</span>()&#125;;<br><br><span class="hljs-keyword">if</span> (indices.graphicsFamily != indices.presentFamily) &#123;<br>    createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;<br>    createInfo.queueFamilyIndexCount = <span class="hljs-number">2</span>;<br>    createInfo.pQueueFamilyIndices = queueFamilyIndices;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;<br>    createInfo.queueFamilyIndexCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>    createInfo.pQueueFamilyIndices = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们可以指定显示图像之前作用于交换链图像上的变换<i><font color="Orange">preTransform</font></i>。我们目前并不需要任何预变换，所以像下面这样设置就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.preTransform = swapChainSupport.capabilities.currentTransform;<br></code></pre></td></tr></table></figure><p>我们还需要填写<i><font color="Orange">compositeAlpha</font></i>成员，该成员指定alpha通道是否可以用来和窗口系统中的其它窗口混合，这几乎总是被忽略的，因此我们只需赋予它<i><font color="Red">VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR</font></i>即可。</p><p>接下来我们需要指定交换链的显示类型。通过<i><font color="Green">querySwapChainSupport</font></i>函数我们可以获得交换链所支持的所有显示类型，我们可以从其中选择所需的类型。</p><p>显示类型由一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html"><code>VkPresentModeKHR</code></a>枚举类型表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_surface</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkPresentModeKHR</span> &#123;</span><br>    VK_PRESENT_MODE_IMMEDIATE_KHR = <span class="hljs-number">0</span>,<br>    VK_PRESENT_MODE_MAILBOX_KHR = <span class="hljs-number">1</span>,<br>    VK_PRESENT_MODE_FIFO_KHR = <span class="hljs-number">2</span>,<br>    VK_PRESENT_MODE_FIFO_RELAXED_KHR = <span class="hljs-number">3</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_shared_presentable_image</span><br>    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = <span class="hljs-number">1000111000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_shared_presentable_image</span><br>    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = <span class="hljs-number">1000111001</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_present_mode_fifo_latest_ready</span><br>    VK_PRESENT_MODE_FIFO_LATEST_READY_EXT = <span class="hljs-number">1000361000</span>,<br>&#125; VkPresentModeKHR;<br></code></pre></td></tr></table></figure><p>我们不详细解释每种类型的含义，只具体解释两种经常使用的类型：<i><font color="Red">VK_PRESENT_MODE_FIFO_KHR</font></i>和<i><font color="Red">VK_PRESENT_MODE_MAILBOX_KHR</font></i>。前者指定当屏幕刷新的时候从队列头获取一张图像，同时程序将渲染好的图像放到队列的尾部，如果队列已经满了，那么程序就需要等待队列出现空间时再插入新图片。后者和前者基本相同，区别在于当队列满的时候，程序会直接使用新渲染的图像替代队列尾的图像，这可以提高渲染效率并降低延迟，但相应的开销也会更大。因此很多移动设备仍然会选择前者作为显示模式。另外，<i><font color="Red">VK_PRESENT_MODE_FIFO_KHR</font></i>被保证在任何支持交换链的设备上都是一定可用的，因此我们可以写一个选择显示模式的函数<i><font color="Green">VkPresentModeKHRchooseSwapPresentMode(const std::vector<VkPresentModeKHR>&amp;availablePresentModes)</VkPresentModeKHR></font></i>，它优先选择<i><font color="Red">VK_PRESENT_MODE_MAILBOX_KHR</font></i>，如果该模式不可用，那么再选择<i><font color="Red">VK_PRESENT_MODE_FIFO_KHR</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkPresentModeKHR <span class="hljs-title">chooseSwapPresentMode</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;VkPresentModeKHR&gt;&amp; availablePresentModes)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; availablePresentMode : availablePresentModes) &#123;<br>        <span class="hljs-keyword">if</span> (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) &#123;<br>            <span class="hljs-keyword">return</span> availablePresentMode;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> VK_PRESENT_MODE_FIFO_KHR;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>结构体的<i><font color="Orange">presentMode</font></i>成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.presentMode = presentMode;<br></code></pre></td></tr></table></figure><p>然后我们需要指定<i><font color="Orange">createInfo</font></i>的<i><font color="Orange">clipped</font></i>成员。这个成员如果为<i><font color="Red">VK_TRUE</font></i>，就表明我们不在乎那些被其它窗口挡住的应用程序窗口的像素，那部分可以不进行显示。为了性能起见这个选项一般会设为<i><font color="Red">VK_TRUE</font></i>。</p><p>最后，在Vulkan程序运行的过程中，交换链很有可能会变得不再有效或者不再是性能最优的，比如窗口缩放等操作都会造成这种问题。因此，我们可能需要经常从头构建一个新的交换链。因此在一个新交换链的构建信息中指定一个旧交换链可以有助于减少资源的重新分配，提高性能，还能保证在新交换链创建后，旧交换链的资源能够被正确管理和释放，避免资源泄漏。交换链的更新是一个比较复杂的主题，我们将在后面介绍。在这里我们仅简单地将最后一个成员<i><font color="Orange">oldSwapchain</font></i>设置为<i><font color="Red">VK_NULL_HANDLE</font></i>。</p><p>终于，我们完成了<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>结构体的填写！</p><hr><h2 id="创建交换链">创建交换链</h2><p>接下来我们终于可以创建交换链对象了。在类内新增一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainKHR.html"><code>VkSwapchainKHR</code></a>成员，构建过程我们已经非常熟悉：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateSwapchainKHR</span>(device, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;swapChain) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create swap chain!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，在后续章节涉及到渲染的时候我们还需要在代码中使用交换链中的图像，因此我们将这些图像也保存为类内成员<i><font color="Orange">std::vector<VkImage>swapChainImages</VkImage></font></i>，然后我们紧接着创建交换链之后来获取这些图像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkGetSwapchainImagesKHR</span>(device, swapChain, &amp;imageCount, <span class="hljs-literal">nullptr</span>);<br>swapChainImages.<span class="hljs-built_in">resize</span>(imageCount);<br><span class="hljs-built_in">vkGetSwapchainImagesKHR</span>(device, swapChain, &amp;imageCount, swapChainImages.<span class="hljs-built_in">data</span>());<br></code></pre></td></tr></table></figure><p>另外注意，在交换链销毁的时候这些交换链中的图像会被自动销毁，因此我们并不需要手动销毁它们。</p><p>我们在后续章节还会用到这些图像的图像格式以及图像尺寸，因此在类内再新增两个成员<i><font color="Orange">VkFormatswapChainImageFormat</font></i>以及<i><font color="Orange">VkExtent2DswapChainExtent</font></i>分别保存这两者，并且在设置<i><font color="Orange">VkSwapchainCreateInfoKHR</font></i>的相应形参的时候顺便保存这两个成员就可以了。</p><p>大功告成！可喜可贺~</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/">上一篇：窗口表面</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/">下一篇：图像视图</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>窗口表面</title>
    <link href="/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/"/>
    <url>/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述">概述</h2><p>因为Vulkan本身是平台无关的，所以它并不会直接和不同的窗口系统打交道，而是要通过所谓的WSI(WindowSystemIntegration)拓展来达到和窗口系统交互的目的。这一节我们将讨论该拓展提供的表面对象<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html"><code>VkSurfaceKHR</code></a>，该对象用于提供展示渲染结果所需的窗口表面。该对象将由我们使用的窗口系统GLFW负责创建。</p><p>值得一提的是，WSI拓展其实是一个Instance层面的拓展而非设备层面。之所以将这个Instance层面的拓展延后到本节来讲而不是在<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">创建Instance</a>章节讲是因为表面和接下来要讲的有关展示图像的内容部分关系紧密，所以将这些内容放在一起会更加自然。</p><p>另外，表面对象一定要在选择物理设备之前创建，因为表面其实会影响物理设备的选择。不过并非所有的应用程序都需要这样一个表面对象，因为有的程序只需要离屏渲染即可。对于这种应用程序，可以为它们创建一个不可见的窗口。</p><p>创建窗口表面分为三步：</p><ul><li>创建并保存<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html"><code>VkSurfaceKHR</code></a>对象</li><li>查询支持将图像显示到该表面的物理设备</li><li>构建该设备展示显示图像所需的显示队列</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Window_surface">Windowsurface</a>章节。</p><hr><h2 id="创建表面">创建表面</h2><p>在应用程序类内添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html"><code>VkSurfaceKHR</code></a>成员<i><font color="Orange">surface</font></i>用于保存表面对象。</p><p>创建一个表面对象很简单，首先我们需要启用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_surface.html"><code>VK_KHR_surface</code></a>拓展。幸运的是这个拓展已经包含在<a href="https://www.glfw.org/docs/3.3/group__vulkan.html#ga99ad342d82f4a3421e2864978cb6d1d6"><code>glfwGetRequiredInstanceExtensions</code></a>所返回的拓展中了，我们无需额外添加。接下来只需调用<a href="https://www.glfw.org/docs/3.3/group__vulkan.html#ga1a24536bec3f80b08ead18e28e6ae965"><code>glfwCreateWindowSurface</code></a>函数，GLFW就会帮我们处理好一切平台相关的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createSurface</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwCreateWindowSurface</span>(instance, window, <span class="hljs-literal">nullptr</span>, &amp;surface) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create window surface!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过虽然glfw负责创建该表面对象，销毁它仍然使用的是Vulkan的API：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkDestroySurfaceKHR</span>(instance, surface, <span class="hljs-literal">nullptr</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="查询支持设备">查询支持设备</h2><p>Vulkan本身是支持WSI的，但这并不意味着所有的显卡都可以支持这个拓展。为了保证选取的物理设备支持该拓展，我们需要拓展<i><font color="Green">isDeviceSuitable</font></i>函数以保证选择的物理设备支持将图像显示到创建的表面上。由于显示图像其实是一个和队列有关的特性，因此我们其实需要的是选择一个具有支持显示对象到指定表面功能的队列家族的物理设备。</p><p>因此，我们首先拓展一下<i><font color="Orange">QueueFamilyIndices</font></i>结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">QueueFamilyIndices</span> &#123;<br>    std::optional&lt;<span class="hljs-type">uint32_t</span>&gt; graphicsFamily;<br>    std::optional&lt;<span class="hljs-type">uint32_t</span>&gt; presentFamily;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isComplete</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> graphicsFamily.<span class="hljs-built_in">has_value</span>() &amp;&amp; presentFamily.<span class="hljs-built_in">has_value</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意，支持显示图像的队列家族和支持图像功能的的队列家族未必相同，虽然它们大概率一致，但保险起见我们还是使用两个队列家族分别存储。</p><p>接下来我们需要修改<i><font color="Green">findQueueFamilies</font></i>函数来寻找<i><font color="Orange">presentFamily</font></i>。为了寻找这样一个队列家族，我们使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceSupportKHR.html"><code>vkGetPhysicalDeviceSurfaceSupportKHR</code></a>函数。现在<i><font color="Green">findQueueFamilies</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QueueFamilyIndices <span class="hljs-title">findQueueFamilies</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices;<br><br>    <span class="hljs-type">uint32_t</span> queueFamilyCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkQueueFamilyProperties&gt; <span class="hljs-title">queueFamilies</span><span class="hljs-params">(queueFamilyCount)</span></span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, queueFamilies.<span class="hljs-built_in">data</span>());<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; queueFamily : queueFamilies) &#123;<br>        <span class="hljs-keyword">if</span> (queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) &#123;<br>            indices.graphicsFamily = i;<br>        &#125;<br><br>        VkBool32 presentSupport = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">vkGetPhysicalDeviceSurfaceSupportKHR</span>(device, i, surface, &amp;presentSupport);<br><br>        <span class="hljs-keyword">if</span> (presentSupport) &#123;<br>            indices.presentFamily = i;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (indices.<span class="hljs-built_in">isComplete</span>()) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        i++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> indices;<br>    &#125;<br></code></pre></td></tr></table></figure><p><i><font color="Green">isDeviceSuitable</font></i>函数的代码并不需要改动，因为它通过调用<i><font color="Orange">QueueFamilyIndices</font></i>结构体的成员函数<i><font color="Green">isComplete</font></i>来检查物理设备是否满足要求，而<font color="Green">isComplete</font>已经更新了并包含了目前一切需要检查的信息。</p><hr><h2 id="构建展示队列">构建展示队列</h2><p>接下来如同图形队列一样，设备对应的显示队列也应该保存在类内一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkQueue.html"><code>VkQueue</code></a>类型的成员<i><font color="Orange">presentQueue</font></i>中。</p><p>现在我们的逻辑设备已经有两个需要的队列了（如果它们不是同一个的话），因此在逻辑设备的创建信息<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateInfo.html"><code>VkDeviceCreateInfo</code></a>中我们需要两个对应的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html"><code>VkDeviceQueueCreateInfo</code></a>。因此我们需要更新<i><font color="Green">createLogicalDevice</font></i>函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createLogicalDevice</span><span class="hljs-params">()</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(physicalDevice);<br><br>    std::vector&lt;VkDeviceQueueCreateInfo&gt; queueCreateInfos;<br>    std::set&lt;<span class="hljs-type">uint32_t</span>&gt; uniqueQueueFamilies = &#123;indices.graphicsFamily.<span class="hljs-built_in">value</span>(), indices.presentFamily.<span class="hljs-built_in">value</span>()&#125;;<br><br>    <span class="hljs-type">float</span> queuePriority = <span class="hljs-number">1.0f</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> queueFamily : uniqueQueueFamilies) &#123;<br>        VkDeviceQueueCreateInfo queueCreateInfo&#123;&#125;;<br>        queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;<br>        queueCreateInfo.queueFamilyIndex = queueFamily;<br>        queueCreateInfo.queueCount = <span class="hljs-number">1</span>;<br>        queueCreateInfo.pQueuePriorities = &amp;queuePriority;<br>        queueCreateInfos.<span class="hljs-built_in">push_back</span>(queueCreateInfo);<br>    &#125;<br><br>    VkPhysicalDeviceFeatures deviceFeatures&#123;&#125;;<br><br>    VkDeviceCreateInfo createInfo&#123;&#125;;<br>    createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;<br><br>    createInfo.queueCreateInfoCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(queueCreateInfos.<span class="hljs-built_in">size</span>());<br>    createInfo.pQueueCreateInfos = queueCreateInfos.<span class="hljs-built_in">data</span>();<br><br>    createInfo.pEnabledFeatures = &amp;deviceFeatures;<br><br>    createInfo.enabledExtensionCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>        createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateDevice</span>(physicalDevice, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;device) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create logical device!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">vkGetDeviceQueue</span>(device, indices.graphicsFamily.<span class="hljs-built_in">value</span>(), <span class="hljs-number">0</span>, &amp;graphicsQueue);<br>    <span class="hljs-built_in">vkGetDeviceQueue</span>(device, indices.presentFamily.<span class="hljs-built_in">value</span>(), <span class="hljs-number">0</span>, &amp;presentQueue);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个函数的最后，如同对图形队列所做的那样，我们调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue.html"><code>vkGetDeviceQueue</code></a>来获得该逻辑设备对应的显示队列并保存到<i><font color="Orange">presentQueue</font></i>成员中。</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/">上一篇：逻辑设备和队列</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/">下一篇：交换链</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>逻辑设备和队列</title>
    <link href="/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>如果说Instance是Vulkan库的接口和抽象，那么逻辑设备就是物理设备的接口和抽象。可以认为逻辑设备是对物理设备功能的一个“定制化”视图，允许开发者选择所需的功能集。构建与物理设备关联的逻辑设备可以分为三步：</p><ul><li>从选定物理设备的队列家族中分配所需数目的队列供逻辑设备使用</li><li>指定逻辑设备所需要的物理设备特性和功能拓展等</li><li>创建逻辑设备</li></ul><p>接下来我们将创建一个<i><font color="Green">voidcreateLogicalDevice()</font></i>函数用于构建逻辑设备，并添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDevice.html"><code>VkDevice</code></a>成员<i><font color="Orange">device</font></i>来存储创建的逻辑设备。</p><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Logical_device_and_queues">Logicaldevice and queues</a>章节</p><hr><h2 id="指定队列">指定队列</h2><p>指定逻辑设备需要使用的队列很简单，我们只需要创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html"><code>VkDeviceQueueCreateInfo</code></a>并填写相应信息即可。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDeviceQueueCreateInfo</span> &#123;</span><br>    VkStructureType             sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                 pNext;<br>    VkDeviceQueueCreateFlags    flags;<br>    <span class="hljs-type">uint32_t</span>                    queueFamilyIndex;<span class="hljs-comment">//队列家族索引，上一章在QueueFamilyIndices结构体中已经存储好了</span><br>    <span class="hljs-type">uint32_t</span>                    queueCount;      <span class="hljs-comment">//需要从该队列家族分配的队列数</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span>*                pQueuePriorities;<span class="hljs-comment">//队列优先级</span><br>&#125; VkDeviceQueueCreateInfo;<br></code></pre></td></tr></table></figure><p>其中<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlags.html"><code>VkDeviceQueueCreateFlags</code></a>是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlagBits.html"><code>VkDeviceQueueCreateFlagBits</code></a>的位组合，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlagBits.html"><code>VkDeviceQueueCreateFlagBits</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDeviceQueueCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//受保护的队列，用于处理敏感数据或需要额外安全性的操作</span><br>&#125; VkDeviceQueueCreateFlagBits;<br></code></pre></td></tr></table></figure><p>另外，队列优先级是一个0.0到1.0之间的数，规定了队列中的命令被执行的顺序，优先级大的优先执行和访问资源。注意，即使只有一个队列也应该指定优先级。</p><p>在这里我们只需要一个队列就可以了，事实上，大多数的时候我们也不需要分配多个队列，因为Vulkan允许在多线程上创建命令然后在主线程上一次性提交所有命令到一个队列。填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html"><code>VkDeviceQueueCreateInfo</code></a>过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(physicalDevice);<br><br>VkDeviceQueueCreateInfo queueCreateInfo&#123;&#125;;<br>queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;<br>queueCreateInfo.queueFamilyIndex = indices.graphicsFamily.<span class="hljs-built_in">value</span>();<br>queueCreateInfo.queueCount = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">float</span> queuePriority = <span class="hljs-number">1.0f</span>;<br>queueCreateInfo.pQueuePriorities = &amp;queuePriority;<br></code></pre></td></tr></table></figure><hr><h2 id="指定物理设备特性">指定物理设备特性</h2><p>物理设备特性通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures.html"><code>vkGetPhysicalDeviceFeatures</code></a>得到。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkGetPhysicalDeviceFeatures</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkPhysicalDevice                            physicalDevice,</span><br><span class="hljs-params">    VkPhysicalDeviceFeatures*                   pFeatures)</span>;<br></code></pre></td></tr></table></figure><p>我们暂时还不需要指定任何特性，所以只需在<i><font color="Green">createLogicalDevice</font></i>函数中把<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html"><code>VkPhysicalDeviceFeatures</code></a>结构体留空即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPhysicalDeviceFeatures deviceFeatures&#123;&#125;;<br></code></pre></td></tr></table></figure><p>一如我们之前一直做的那样，创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDevice.html"><code>VkDevice</code></a>同样需要我们填写相应的信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateInfo.html"><code>VkDeviceCreateInfo</code></a>。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDeviceCreateInfo</span> &#123;</span><br>    VkStructureType                    sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                        pNext;<br>    VkDeviceCreateFlags                flags;<br>    <span class="hljs-type">uint32_t</span>                           queueCreateInfoCount;<br>    <span class="hljs-type">const</span> VkDeviceQueueCreateInfo*     pQueueCreateInfos;<br>    <span class="hljs-comment">// enabledLayerCount is deprecated and should not be used</span><br>    <span class="hljs-type">uint32_t</span>                           enabledLayerCount;<br>    <span class="hljs-comment">// ppEnabledLayerNames is deprecated and should not be used</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*                 ppEnabledLayerNames;<br>    <span class="hljs-type">uint32_t</span>                           enabledExtensionCount;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*                 ppEnabledExtensionNames;<br>    <span class="hljs-type">const</span> VkPhysicalDeviceFeatures*    pEnabledFeatures;<br>&#125; VkDeviceCreateInfo;<br></code></pre></td></tr></table></figure><p>可以看到为了填充该结构体，我们还需要指定逻辑设备需要的拓展以及层。在<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">验证层</a>章节已经提到，如今Vulkan已经不再使用devicespecific layers了，instance specificlayer适用于一切的Vulkan调用。然而，为了与旧代码兼容，显示地指定设备层仍然是一个好的选择。另外，当前我们对于设备所需要的拓展尚且没有什么要求，因此填充信息代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkDeviceCreateInfo createInfo&#123;&#125;;<br>createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;<br><br>createInfo.pQueueCreateInfos = &amp;queueCreateInfo;<br>createInfo.queueCreateInfoCount = <span class="hljs-number">1</span>;<br><br>createInfo.pEnabledFeatures = &amp;deviceFeatures;<br><br>createInfo.enabledExtensionCount = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>    createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>    createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="创建逻辑设备">创建逻辑设备</h2><p>一切就绪，我们可以构建逻辑设备对象了，构建过程一如我们之前构建对象时一直做的那样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateDevice</span>(physicalDevice, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;device) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create logical device!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑设备就此构建完成，但我们还有一些工作需要做。由于之后我们可能需要在代码中使用逻辑设备对应的队列对象，但目前在应用程序类中并没有保存这个对象，所以我们需要添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkQueue.html"><code>VkQueue</code></a>类型的成员<i><font color="Orange">graphicsQueue</font></i>来保存这个对象。可以使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue.html"><code>vkGetDeviceQueue</code></a>函数得到赋予该逻辑设备的队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkGetDeviceQueue</span>(device, indices.graphicsFamily.<span class="hljs-built_in">value</span>(), <span class="hljs-number">0</span>, &amp;graphicsQueue);<br><span class="hljs-comment">//0代表获取的队列在队列家族中的索引。由于我们只需要一个队列，所以该值为0。</span><br></code></pre></td></tr></table></figure><p>大功告成！设备层面的建立以及完成了，接下来的章节我们将处理和图像处理及展示有关的初始化流程。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97%E5%AE%B6%E6%97%8F/">上一篇：物理设备和队列家族</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/">下一篇：窗口表面</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>物理设备和队列家族</title>
    <link href="/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97%E5%AE%B6%E6%97%8F/"/>
    <url>/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97%E5%AE%B6%E6%97%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在创建好了Instance之后，我们需要选择一个合适的物理设备（显卡）来执行实际的操作。实际上我们可以选择多张显卡同时工作，不过简单起见本文只选择一张显卡进行操作。选择合适的显卡主要分为两步：</p><ul><li>决定应用程序需要显卡具有的功能和属性。</li><li>从所有显卡中选择合适的那个作为物理设备。</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Physical_devices_and_queue_families">Physicaldevices and queue families</a>章节。</p><hr><h2 id="显卡要求">显卡要求</h2><p>显卡在Vulkan中的对应句柄对象为<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html"><code>VkPhysicalDevice</code></a>，我们可以创建一个<i><font color="Green">boolisDeviceSuitable(VkPhysicalDevicedevice)</font></i>函数来决定一张显卡是否满足我们的需求。目前我们只需要显卡支持图形队列家族（Graphicsqueuefamilies），也就是能够接受图形有关命令的队列家族，于是对于一个给定的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html"><code>VkPhysicalDevice</code></a>，我们可以创建一个<i><font color="Green">QueueFamilyIndicesfindQueueFamilies(VkPhysicalDevicedevice)</font></i>函数来检查它是否支持该队列家族。其中，我们定义结构体<i><font color="Orange">QueueFamilyIndices</font></i>如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">QueueFamilyIndices</span> &#123;<br>    std::optional&lt;<span class="hljs-type">uint32_t</span>&gt; graphicsFamily;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isComplete</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> graphicsFamily.<span class="hljs-built_in">has_value</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>为c++17定义的一个模板类，它有一个成员函数<i><font color="Green">constexprbool has_value() const noexcept</font></i>，该函数在赋予了<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>包裹的对象值后返回true，否则返回false。如此设计是因为有时在考虑应用程序需要的队列家族的时候，有些队列家族是可选的，也就是说显卡有该家族的话更好，没有的话也不应该直接终止程序，而是选择别的替代品，因此我们可以通过<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>包裹对象是否存储了一个找到的值来做出决策。另外，该结构体目前只包含一个成员，随着应用程序的深入和复杂化，也会有更多的队列家族需求，也就会有更多的成员添加到这个结构体中来。</p><p>接下来看一下<i><font color="Green">findQueueFamilies</font></i>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QueueFamilyIndices <span class="hljs-title">findQueueFamilies</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices;<br><br>    <span class="hljs-type">uint32_t</span> queueFamilyCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkQueueFamilyProperties&gt; <span class="hljs-title">queueFamilies</span><span class="hljs-params">(queueFamilyCount)</span></span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, queueFamilies.<span class="hljs-built_in">data</span>());<br>    <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; queueFamily : queueFamilies) &#123;<br>        <span class="hljs-keyword">if</span> (queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) &#123;<br>            indices.graphicsFamily = i;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (indices.<span class="hljs-built_in">isComplete</span>()) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        i++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> indices;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数的代码是直观易懂的，这里不做过多解释了。</p><p>于是，接下来我们就可以在<i><font color="Green">isDeviceSuitable</font></i>函数中使用这个函数来判断一个物理设备是否符合要求（当前来讲就是是否具有图形队列家族）。当然，随着应用程序的复杂化，<i><font color="Green">isDeviceSuitable</font></i>函数还会逐渐地拓展：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(device);<br><br>    <span class="hljs-keyword">return</span> indices.graphicsFamily.<span class="hljs-built_in">has_value</span>();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="选择显卡">选择显卡</h2><p>在决定好对于设备的要求之后，是时候开始挑选符合要求的显卡了！首先我们当然要枚举出Instance所具有的所有物理设备，并且在类内创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html"><code>VkPhysicalDevice</code></a>成员<i><font color="Orange">physicalDevice</font></i>来存储满足需求的显卡对象（将这个成员初始化为<i><font color="Orange">VK_NULL_HANDLE</font></i>。我们创建一个<i><font color="Green">voidpickPhysicalDevice()</font></i>成员函数来挑选需要的显卡：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pickPhysicalDevice</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">uint32_t</span> deviceCount = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">vkEnumeratePhysicalDevices</span>(instance, &amp;deviceCount, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span> (deviceCount == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to find GPUs with Vulkan support!&quot;</span>);<br>&#125;<br>    <span class="hljs-function">std::vector&lt;VkPhysicalDevice&gt; <span class="hljs-title">devices</span><span class="hljs-params">(deviceCount)</span></span>;<br><span class="hljs-built_in">vkEnumeratePhysicalDevices</span>(instance, &amp;deviceCount, devices.<span class="hljs-built_in">data</span>());<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来对于每一个显卡，检查它是否满足需求，简单起见，我们这里采取的策略是一旦找到了一张满足要求的显卡，就直接使用它。当然你可以自定义更加复杂的选取策略以寻找最合适的那张显卡。测试显卡是否满足要求只需使用上文创建的<i><font color="Green">isDeviceSuitable</font></i>函数即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//接pickPhysicalDevice函数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; device : devices) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isDeviceSuitable</span>(device)) &#123;<br>        physicalDevice = device;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (physicalDevice == VK_NULL_HANDLE) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to find a suitable GPU!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，由于Instance被销毁时，对应的物理设备会被自动销毁，所以我们不需要在<i><font color="Green">cleanup</font></i>函数中显示销毁它。</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">上一篇：验证层</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/">下一篇：逻辑设备和队列</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>验证层</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>VulkanAPI本身几乎不自带任何错误检测功能，不过这并不意味着我们不能添加相应的错误检测功能。Vulkan的验证层（validationlayer）就是为此而生。验证层是可选的组件，它们会挂钩到 Vulkan函数调用中，以执行额外的操作，包括：</p><ul><li>检查参数类型以避免错误调用</li><li>跟踪对象的创建和销毁以防止内存泄漏</li><li>检查线程安全性</li><li>把调用信息以及其参数输出到标准输出</li><li>跟踪调用以便性能优化和复现</li></ul><p>Vulkan中有两种验证层：instance layer和devicelayer。最初的想法是instance layer用于检查全局的Vulkan调用，而devicelayer用于检查特定GPU相关的调用。不过现在devicelayer已经逐渐被废弃了，也就是说现在可以将instancelayer用于检查任何Vulkan调用。当然，如果是为了和旧代码兼容，仍然可以使用devicelayer。</p><p>验证层的使用主要分为以下三步：</p><ul><li>启用验证层</li><li>设置回调函数</li><li>创建debug messenger以使用回调函数控制输出验证层产生的信息</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Validation_layers#page_Message-callback">Validationlayers</a>章节</p><hr><h2 id="启用验证层">启用验证层</h2><p>我们需要启用的是Vulkan中几乎包含了所有有用验证功能的层，它的名称为<i><font color="Orange">VK_LAYER_KHRONOS_validation</font></i>。在启用之前，如同拓展一样，我们也需要检查层的可用性，检查的方式和拓展如出一辙。首先我们需要列举出硬件支持的所有层：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkValidationLayerSupport</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> layerCount;<br>    <span class="hljs-built_in">vkEnumerateInstanceLayerProperties</span>(&amp;layerCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkLayerProperties&gt; <span class="hljs-title">availableLayers</span><span class="hljs-params">(layerCount)</span></span>;<br>    <span class="hljs-built_in">vkEnumerateInstanceLayerProperties</span>(&amp;layerCount, availableLayers.<span class="hljs-built_in">data</span>());<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们需要的是<i><font color="Orange">VK_LAYER_KHRONOS_validation</font></i>，它由名称对应的字符串给出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; validationLayers = &#123;<br>    <span class="hljs-string">&quot;VK_LAYER_KHRONOS_validation&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>于是我们需要检查这个层是否可用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//接上述checkValidationLayerSupport函数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span>* layerName : validationLayers) &#123;<br>    <span class="hljs-type">bool</span> layerFound = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; layerProperties : availableLayers) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(layerName, layerProperties.layerName) == <span class="hljs-number">0</span>) &#123;<br>            layerFound = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!layerFound) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>检查完毕后，我们还需要决定什么时候启用这个验证层。由于验证层输出的调试信息应该只能被开发应用程序的程序员看见，因此调试模式下我们理应启用该验证层，而发布模式下我们当然应该关闭该验证层功能。这可以通过宏来做到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> NDEBUG</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> enableValidationLayers = <span class="hljs-literal">false</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> enableValidationLayers = <span class="hljs-literal">true</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>另外，<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">上一篇</a>中我们没有填上<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>结构体中的层信息，现在就可以填上我们选取的验证层信息了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>    createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>    createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//发布模式不需要启用验证层，因此结构体中层信息也不需要填写</span><br>    createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="设置回调函数">设置回调函数</h2><p>默认情况下验证层会将调试信息输出到标准输出。但是更多时候我们希望自己控制输出信息的种类以及详细程度等。因此我们需要设置一个回调函数来指定信息输出的方式。</p><p>为了设置回调函数，我们需要一个新的拓展：<i><font color="Orange">VK_EXT_debug_utils</font></i>，因此我们可以创建一个<i><font color="Green">getRequiredExtensions</font></i>函数来统一处理所有需要的拓展：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; <span class="hljs-title">getRequiredExtensions</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> glfwExtensionCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>** glfwExtensions;<br>    glfwExtensions = <span class="hljs-built_in">glfwGetRequiredInstanceExtensions</span>(&amp;glfwExtensionCount);<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; <span class="hljs-title">extensions</span><span class="hljs-params">(glfwExtensions, glfwExtensions + glfwExtensionCount)</span></span>;<br><br>    <span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>        extensions.<span class="hljs-built_in">push_back</span>(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);<br>        <span class="hljs-comment">//VK_EXT_DEBUG_UTILS_EXTENSION_NAME是字符串&quot;VK_EXT_debug_utils&quot;等价的宏，使用宏可以避免拼写错误问题</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> extensions;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到的拓展用于Instance的创建：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> extensions = <span class="hljs-built_in">getRequiredExtensions</span>();<br>createInfo.enabledExtensionCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(extensions.<span class="hljs-built_in">size</span>());<br>createInfo.ppEnabledExtensionNames = extensions.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>在启用了回调函数所需要的拓展之后，就可以创建回调函数本身了。Vulkan通过函数指针<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/PFN_vkDebugUtilsMessengerCallbackEXT.html"><code>PFN_vkDebugUtilsMessengerCallbackEXT</code></a>指明了一个回调函数所应该具有的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">VkBool32</span> <span class="hljs-params">(VKAPI_PTR *PFN_vkDebugUtilsMessengerCallbackEXT)</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDebugUtilsMessageSeverityFlagBitsEXT           messageSeverity,</span><br><span class="hljs-params">    VkDebugUtilsMessageTypeFlagsEXT                  messageTypes,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkDebugUtilsMessengerCallbackDataEXT*      pCallbackData,</span><br><span class="hljs-params">    <span class="hljs-type">void</span>*                                            pUserData)</span>;<br></code></pre></td></tr></table></figure><p>第一个成员通过[<code>VkDebugUtilsMessageSeverityFlagBitsEXT</code><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessageSeverityFlagBitsEXT.html">id4</a>的位掩码指定输出信息的严重性，该枚举定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDebugUtilsMessageSeverityFlagBitsEXT</span> &#123;</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//所有诊断信息</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = <span class="hljs-number">0x00000010</span>, <span class="hljs-comment">//信息性消息，如资源细节</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = <span class="hljs-number">0x00000100</span>,<span class="hljs-comment">//警告信息</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = <span class="hljs-number">0x00001000</span>,  <span class="hljs-comment">//错误信息</span><br>&#125; VkDebugUtilsMessageSeverityFlagBitsEXT;<br></code></pre></td></tr></table></figure><p>第二个成员通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessageTypeFlagBitsEXT.html"><code>VkDebugUtilsMessageTypeFlagsBitsEXT</code></a>的位掩码指定输出信息的种类，该枚举定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDebugUtilsMessageTypeFlagBitsEXT</span> &#123;</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = <span class="hljs-number">0x00000001</span>,    <span class="hljs-comment">//与使用规范或性能无关的一般事件消息</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = <span class="hljs-number">0x00000002</span>, <span class="hljs-comment">//未遵循Vulkan使用规则</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//性能浪费</span><br>  <span class="hljs-comment">// Provided by VK_EXT_device_address_binding_report</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//地址绑定信息</span><br>&#125; VkDebugUtilsMessageTypeFlagBitsEXT;<br></code></pre></td></tr></table></figure><p>第三个成员指向一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCallbackDataEXT.html"><code>VkDebugUtilsMessengerCallbackDataEXT</code></a>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDebugUtilsMessengerCallbackDataEXT</span> &#123;</span><br>    VkStructureType                              sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                  pNext;<br>    VkDebugUtilsMessengerCallbackDataFlagsEXT    flags; <span class="hljs-comment">//目前只有0</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                                  pMessageIdName;  <span class="hljs-comment">//消息相关名称标识符</span><br>    <span class="hljs-type">int32_t</span>                                      messageIdNumber; <span class="hljs-comment">//该名称对应ID</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                                  pMessage;  <span class="hljs-comment">//具体调试信息</span><br>    <span class="hljs-type">uint32_t</span>                                     queueLabelCount; <span class="hljs-comment">//队列标签数</span><br>    <span class="hljs-type">const</span> VkDebugUtilsLabelEXT*                  pQueueLabels;    <span class="hljs-comment">//队列标签</span><br>    <span class="hljs-type">uint32_t</span>                                     cmdBufLabelCount;<span class="hljs-comment">//命令缓冲标签数</span><br>    <span class="hljs-type">const</span> VkDebugUtilsLabelEXT*                  pCmdBufLabels;  <span class="hljs-comment">//命令缓冲标签</span><br>    <span class="hljs-type">uint32_t</span>                                     objectCount;  <span class="hljs-comment">//消息相关对象数</span><br>    <span class="hljs-type">const</span> VkDebugUtilsObjectNameInfoEXT*         pObjects;  <span class="hljs-comment">//消息相关对象</span><br>&#125; VkDebugUtilsMessengerCallbackDataEXT;<br></code></pre></td></tr></table></figure><p>该成员包含了回调函数输出信息的具体方式和细节。</p><p>最后一个成员指定用户自己提供的额外信息，一般为nullptr。</p><p>回调函数返回一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBool32.html"><code>VkBool32</code></a>类型的值，如果它返回<i><font color="Red">VK_TRUE</font></i>，则意味着产生验证层信息的函数应该被终止，这一般只用于验证调试层是否生效，因此我们一般返回<i><font color="Red">VK_FALSE</font></i>。</p><p>于是，我们可以创建一个自己的回调函数（注意要把它设置为静态函数）。<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Validation_layers#page_Message-callback">验证层</a>章节给出的一个简单的例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> VKAPI_ATTR VkBool32 VKAPI_CALL <span class="hljs-title">debugCallback</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,</span></span><br><span class="hljs-params"><span class="hljs-function">    VkDebugUtilsMessageTypeFlagsEXT messageType,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">void</span>* pUserData)</span> </span>&#123;<br><br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;validation layer: &quot;</span> &lt;&lt; pCallbackData-&gt;pMessage &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> VK_FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VKAPI_CALL.html"><code>VKAPI_CALL</code></a>和<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VKAPI_ATTR.html"><code>VKAPI_ATTR</code></a>宏用于指定和编译器有关的调用方式，前者指定MSVC-style的编译器调用方式，后者指定GCC/Clang-style的编译器调用方式。</p><hr><h2 id="创建debug-messenger">创建Debug Messenger</h2><p>设置好回调函数的形式后，现在我们需要告知Vulkan我们设置了一个回调函数。这可以通过创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerEXT.html"><code>VkDebugUtilsMessengerEXT</code></a>句柄对象来实现。</p><p>创建该对象同样需要填写相应的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>信息，我们可以创建一个<i><font color="Green">voidsetupDebugMessenger()</font></i>函数来处理该对象的构建。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VkDebugUtilsMessengerCreateInfoEXT</span> &#123;<br>    VkStructureType                         sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                             pNext;<br>    VkDebugUtilsMessengerCreateFlagsEXT     flags;    <span class="hljs-comment">//目前只有0</span><br>    VkDebugUtilsMessageSeverityFlagsEXT     messageSeverity;<br>    VkDebugUtilsMessageTypeFlagsEXT         messageType;<br>    PFN_vkDebugUtilsMessengerCallbackEXT    pfnUserCallback;<br>    <span class="hljs-type">void</span>*                                   pUserData;<br>&#125; VkDebugUtilsMessengerCreateInfoEXT;<br></code></pre></td></tr></table></figure><p>容易注意到后四个成员中倒数第二个成员就是我们需要指定的回调函数，其它三个成员是我们需要传递给该回调函数的实参。</p><p>于是<i><font color="Green">voidsetupDebugMessenger()</font></i>函数可以如下编写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setupDebugMessenger</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!enableValidationLayers) <span class="hljs-keyword">return</span>;<br><br>    VkDebugUtilsMessengerCreateInfoEXT createInfo&#123;&#125;;<br>    <br>    createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;<br>    createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |   VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;<br>    createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;<br>    createInfo.pfnUserCallback = debugCallback;<br>    createInfo.pUserData = <span class="hljs-literal">nullptr</span>;<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来只需要创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerEXT.html"><code>VkDebugUtilsMessengerEXT</code></a>对象即可。但是到这里还有一个小问题，那就是创建对象的函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>是一个拓展函数，它不是自动加载的，而是需要我们手动使用[<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetInstanceProcAddr.html"><code>vkGetInstanceProcAddr</code></a>去寻找它的地址后才能使用。因此我们可以创建一个（全局的）工具函数VkResultCreateDebugUtilsMessengerEXT(VkInstance instance, constVkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, constVkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT*pDebugMessenger)函数来加载<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetInstanceProcAddr.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>进行加载。于是我们可以创建一个（全局的）<i><font color="Green">VkResultCreateDebugUtilsMessengerEXT(VkInstance instance, constVkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, constVkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT*pDebugMessenger)</font></i>函数加载<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>并在加载成功后使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>创建DebugMessenger对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkResult <span class="hljs-title">CreateDebugUtilsMessengerEXT</span><span class="hljs-params">(VkInstance instance, <span class="hljs-type">const</span> VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, <span class="hljs-type">const</span> VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pDebugMessenger)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> func = (PFN_vkCreateDebugUtilsMessengerEXT) <span class="hljs-built_in">vkGetInstanceProcAddr</span>(instance, <span class="hljs-string">&quot;vkCreateDebugUtilsMessengerEXT&quot;</span>);<br>    <span class="hljs-keyword">if</span> (func != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(instance, pCreateInfo, pAllocator, pDebugMessenger);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> VK_ERROR_EXTENSION_NOT_PRESENT;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，只需要在<i><font color="Green">setupDebugMessenger</font></i>函数末尾使用该函数来创建句柄对象即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//接setupDebugMessenger函数</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">CreateDebugUtilsMessengerEXT</span>(instance, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;debugMessenger) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to set up debug messenger!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>另外注意，销毁<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerEXT.html"><code>VkDebugUtilsMessengerEXT</code></a>对象的函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyDebugUtilsMessengerEXT.html"><code>vkDestroyDebugUtilsMessengerEXT</code></a>也是一个拓展函数，同样需要我们手动加载，我们也写一个工具函数来完成加载该函数和销毁的工作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyDebugUtilsMessengerEXT</span><span class="hljs-params">(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, <span class="hljs-type">const</span> VkAllocationCallbacks* pAllocator)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> func = (PFN_vkDestroyDebugUtilsMessengerEXT) <span class="hljs-built_in">vkGetInstanceProcAddr</span>(instance, <span class="hljs-string">&quot;vkDestroyDebugUtilsMessengerEXT&quot;</span>);<br>    <span class="hljs-keyword">if</span> (func != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-built_in">func</span>(instance, debugMessenger, pAllocator);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后只需在应用程序类的<i><font color="Green">cleanup()</font></i>函数中调用该加载函数即可。</p><hr><h2 id="instance创建和销毁函数内部的调试">Instance创建和销毁函数内部的调试</h2><p>大功告成了吗？其实还没有。注意到<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>函数需要创建的Instance作为参数，这也就意味着Instance的创建函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html"><code>vkCreateInstance</code></a>和销毁函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyInstance.html"><code>vkDestroyInstance</code></a>是在DebugMessenger的作用范围之外的，它们的调试信息无法被显示出来。</p><p>解决办法是将<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>信息传递给<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>结构体的pNext成员指针。具体而言，我们可以创建一个<i><font color="Green">voidpopulateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT&amp;createInfo)</font></i>函数来抽象出填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>的代码以便在<i><font color="Green">createInstance</font></i>函数和<i><font color="Green">setupDebugMessenger</font></i>函数中复用，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++|">void populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT&amp; createInfo) &#123;<br>    createInfo = &#123;&#125;;<br>    <br>    createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;<br>    createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;<br>    createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;<br>    createInfo.pfnUserCallback = debugCallback;<br>&#125;<br></code></pre></td></tr></table></figure><p><i><font color="Green">setupDebugMessenger</font></i>函数现在改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setupDebugMessenger</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!enableValidationLayers) <span class="hljs-keyword">return</span>;<br><br>    VkDebugUtilsMessengerCreateInfoEXT createInfo;<br>    <span class="hljs-built_in">populateDebugMessengerCreateInfo</span>(createInfo);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CreateDebugUtilsMessengerEXT</span>(instance, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;debugMessenger) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to set up debug messenger!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><i><font color="Green">createInstance</font></i>函数添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br><br>    VkInstanceCreateInfo createInfo&#123;&#125;;<br>    createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;<br>    createInfo.pApplicationInfo = &amp;appInfo;<br><br>    ...<br><br>    VkDebugUtilsMessengerCreateInfoEXT debugCreateInfo&#123;&#125;;<br>    <span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>        createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br><br>        <span class="hljs-built_in">populateDebugMessengerCreateInfo</span>(debugCreateInfo);<br>        createInfo.pNext = (VkDebugUtilsMessengerCreateInfoEXT*) &amp;debugCreateInfo;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br><br>        createInfo.pNext = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateInstance</span>(&amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;instance) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create instance!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以实现在Instance的构造和销毁函数中也能输出调试信息。现在终于是大功告成了！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">上一篇：创建Instance</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/">下一篇：物理设备和队列家族</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>创建Instance</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>是沟通应用程序和vulkan库的桥梁，它将你的应用程序的信息提供给图形驱动。创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>主要分为三步：</p><ul><li>检查instance所需的拓展是否可用</li><li>填写包含了创建instance所需信息的结构体</li><li>将该结构体传递给<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html"><code>vkCreateInstance</code></a>函数创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>实例</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Instance">Instance</a>章节。</p><hr><h2 id="检查拓展">检查拓展</h2><p>使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html"><code>vkEnumerateInstanceExtensionProperties</code></a>函数分两步检查拓展：</p><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html"><code>vkEnumerateInstanceExtensionProperties</code></a>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkEnumerateInstanceExtensionProperties</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                                 pLayerName,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>*                                   pPropertyCount,</span><br><span class="hljs-params">    VkExtensionProperties*                      pProperties)</span>;<br></code></pre></td></tr></table></figure><p>需要解释的是该函数第一个参数，该参数指定层名，如果为nullptr则则查询全局可用的扩展属性，否则查询指定层提供的额外拓展属性。</p><p>具体使用上，一般分两步进行，也就是先查询拓展个数再查询具体拓展，许多vulkan查询操作都分为这两步进行（假设这里不需要具体层名）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> extensionCount = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="hljs-literal">nullptr</span>, &amp;extensionCount, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-function">std::vector&lt;VkExtensionProperties&gt; <span class="hljs-title">extensions</span><span class="hljs-params">(extensionCount)</span></span>;<br><span class="hljs-built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="hljs-literal">nullptr</span>, &amp;extensionCount, extensions.<span class="hljs-built_in">data</span>());<span class="hljs-comment">// T* std::vector&lt;T,Allocator&gt;::data()返回指向vector底部数组元素的指针</span><br></code></pre></td></tr></table></figure><hr><h2 id="填写创建信息">填写创建信息</h2><p>为了创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>实例，需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>。Vulkan中很多创建实例的函数都需要一个createInfo结构体作为参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkInstanceCreateInfo</span> &#123;</span><br>    VkStructureType             sType;                  <span class="hljs-comment">//类型</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                 pNext;     <span class="hljs-comment">//拓展结构体，此教程均为nullptr</span><br>    VkInstanceCreateFlags       flags;  <br>    <span class="hljs-type">const</span> VkApplicationInfo*    pApplicationInfo;<br>    <span class="hljs-type">uint32_t</span>                    enabledLayerCount;    <span class="hljs-comment">//层数</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*          ppEnabledLayerNames;  <span class="hljs-comment">//层名</span><br>    <span class="hljs-type">uint32_t</span>                    enabledExtensionCount;  <span class="hljs-comment">//拓展数</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*          ppEnabledExtensionNames;<span class="hljs-comment">//拓展名</span><br>&#125; VkInstanceCreateInfo;<br></code></pre></td></tr></table></figure><p>第三个成员代表一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateFlagBits.html"><code>VkInstanceCreateFlagBits</code></a>的位掩码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkInstanceCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_KHR_portability_enumeration</span><br>    VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR = <span class="hljs-number">0x00000001</span>,<br>&#125; VkInstanceCreateFlagBits;<br></code></pre></td></tr></table></figure><p>其中只有一个标志位<i><font color="Red">VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR</font></i>，当设置这个标志时，表示应用程序希望能够在不同的设备和平台上更好地支持Vulkan的可移植性扩展。这对于那些希望在多种硬件和操作系统上运行的应用程序尤其重要。</p><p>第四个成员是一个指向<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkApplicationInfo.html"><code>VkApplicationInfo</code></a>结构体的指针，该结构体代表一个可选的应用程序信息，提供该信息可能有助于驱动优化应用程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkApplicationInfo</span> &#123;</span><br>    VkStructureType    sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*        pNext;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*        pApplicationName;<br>    <span class="hljs-type">uint32_t</span>           applicationVersion;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*        pEngineName;<br>    <span class="hljs-type">uint32_t</span>           engineVersion;<br>    <span class="hljs-type">uint32_t</span>           apiVersion;<br>&#125; VkApplicationInfo;<br></code></pre></td></tr></table></figure><p>该结构体每个成员都很好理解，<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Instance">Instance</a>章节中的使用范例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkApplicationInfo appInfo&#123;&#125;;<br>VkApplicationInfo appInfo&#123;&#125;;<br>appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;<br>appInfo.pApplicationName = <span class="hljs-string">&quot;Hello Triangle&quot;</span>;<br>appInfo.applicationVersion = <span class="hljs-built_in">VK_MAKE_VERSION</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>appInfo.pEngineName = <span class="hljs-string">&quot;No Engine&quot;</span>;<br>appInfo.engineVersion = <span class="hljs-built_in">VK_MAKE_VERSION</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>appInfo.apiVersion = VK_API_VERSION_1_0;<br></code></pre></td></tr></table></figure><p>解释完所有成员代表的意思之后，正式开始填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkInstanceCreateInfo createInfo&#123;&#125;;<br>createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;<br>createInfo.pApplicationInfo = &amp;appInfo;<br><br><span class="hljs-type">uint32_t</span> glfwExtensionCount = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>** glfwExtensions;<br><br><span class="hljs-comment">//获取glfw窗口系统所需的拓展，可以在获取前先使用步骤1检查以下拓展是否可用</span><br>glfwExtensions = <span class="hljs-built_in">glfwGetRequiredInstanceExtensions</span>(&amp;glfwExtensionCount);<br><br>createInfo.enabledExtensionCount = glfwExtensionCount;<br>createInfo.ppEnabledExtensionNames = glfwExtensions;<br><br><span class="hljs-comment">//这部分会在之后的设置验证层章节中填写</span><br>createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>注意这里并没有填写层数和层名，这部分会在下一章<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">验证层</a>中进行填写</p><hr><h2 id="创建vkinstance实例">创建VkInstance实例</h2><p>最后，一切就绪，可以使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html"><code>VkCreateInstance</code></a>创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>实例了，由于Vulkan中大多数创建实例的函数都会返回一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkResult.html"><code>VkResult</code></a>，于是我们一般通过下述方式创建实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateInstance</span>(&amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;instance) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create instance!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>很多Vulkan中的create函数都会具有一个可以传递用户自定义分配器的参数，在VulkanTutorial教程中该参数始终设为nullptr。</p><p>大功告成！我们可以将第二、三步的代码放到一个成员函数<i><font color="Green">voidcreateInstance()</font></i>中</p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/">上一篇：绘制基本流程梳理</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">下一篇：验证层</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>绘制基本流程梳理</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="写在前面">写在前面</h3><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Overview">Overview</a>章节</p><hr><h2 id="初始化及绘制的基本流程">初始化及绘制的基本流程</h2><p>下面按步骤给出绘制一个三角形所需的基本流程，这也构成了一个vulkan渲染程序最基础的框架</p><ul><li><p>创建一个用以描述你所创建的应用以及所需使用的API拓展的VkInstance。</p></li><li><p>查询硬件属性以挑选合适的物理设备VkPhysicalDevice。</p></li><li><p>从物理设备抽象出对应的逻辑设备VkDevice，并且创建用于接受提交命令的VkQueue。</p></li><li><p>创建用于显示渲染结果的窗口，以及一个处理跨平台窗口兼容性的的抽象层VkSurfaceKHR，然后创建用于提供渲染和展示画面的VkSwapchainKHR。</p></li><li><p>创建交换链中真正用于渲染和展示的VkImage,并且把这些图片包裹进用于指示图片的具体使用部分的VkImageView中。</p></li><li><p>创建用于指示渲染目标的类型用法等信息的VkRenderPass</p></li><li><p>在指定好渲染目标以及相应信息后，创建对应的载体VkFramebuffer，将创建好的VkImage用作它的颜色、深度或模板缓冲。</p></li><li><p>建立好包含整个渲染流程各个阶段信息的渲染管线对象VkPipeline。</p></li><li><p>准备好渲染所需的一切目标和信息后，从VkCommandPool分配出VkCommandBuffer，用于录制渲染流程中需要执行的命令。</p></li><li><p>开始主渲染循环，循环流程主要为从交换链获取图像，然后将录制好的命令提交给VkQueue执行，执行完毕后将图像归还交换链并展示渲染结果。</p><p>接下来的三角形绘制章节会详细解释每个步骤的具体流程和执行方式。</p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%BA%8F%E8%A8%80/">上一篇：序言</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">下一篇：创建Instance</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>序言</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%BA%8F%E8%A8%80/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%BA%8F%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="写在前面的话">写在前面的话</h2><p>刚学完<a href="https://vulkan-tutorial.com/Introduction">vulkantutorial</a>教程不久，感觉自己对其中的很多细节理解还不是很透彻，同时也不能很好地理清vulkan复杂的初始化流程，于是准备再学一遍教程，并且记录下自己的理解和梳理思路，希望能对vulkan的工作机制有更深入的理解。</p><h2 id="主要内容概要">主要内容概要</h2><p>本系列文章主要以梳理概括vulkan搭建的渲染流程为主，不多涉及对于图形硬件底层或者api工作原理的深入理解（苯萌新尚未进化至如此境界~~</p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/">下一篇：绘制基本流程梳理</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 847:访问所有节点的最短路径</title>
    <link href="/2024/09/19/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/Leetcode-847-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2024/09/19/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/Leetcode-847-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述">题目描述</h2><h3 id="题干">题干</h3><p>存在一个由 <code>n</code> 个节点组成的无向连通图，图中的节点按从<code>0</code> 到 <code>n - 1</code> 编号。</p><p>给你一个数组 <code>graph</code>表示这个图。其中，<code>graph[i]</code> 是一个列表，由所有与节点<code>i</code> 直接相连的节点组成。</p><p>返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。</p><h3 id="条件限制">条件限制</h3><ul><li><code>n == graph.length</code></li><li><code>1 &lt;= n &lt;= 12</code></li><li><code>0 &lt;= graph[i].length &lt; n</code></li><li><code>graph[i]</code> 不包含 <code>i</code></li><li>如果 <code>graph[a]</code> 包含 <code>b</code> ，那么<code>graph[b]</code> 也包含 <code>a</code></li><li>输入的图总是连通图</li></ul><h3 id="示例">示例</h3><figure><img src="/2024/09/19/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/Leetcode-847-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/example.png" alt="示例"><figcaption aria-hidden="true">示例</figcaption></figure><p><strong>输入</strong>：graph = [[1, 2, 3], [0], [0], [0]]</p><p><strong>输出</strong>：4</p><p><strong>解释</strong>：一种可能路径为[1, 0, 2, 0, 3]</p><hr><h2 id="错误解题思路">错误解题思路</h2><h3 id="思路">思路</h3><p>定义f[s][i]为位掩码为s且最后到达的节点为i时所走过的最短路径（如果在前述条件下不能遍历位掩码中的节点则记为INT_MAX，并且下面认为INT_MAX+1=INT_MAX)，简单地认为状态转移方程为：<span class="math display">\[f[s][i]\ =\mathop{min}\limits_{x\in graph[i]}(f[s\ \land\(1&lt;&lt;i)][x])\ +\ 1\]</span></p><h3 id="错误原因">错误原因</h3><p>事实上，位掩码为s且最后到达的节点为i时所走过的最短路径未必由除去i之后的位掩码下最后到达i的相邻节点x的最短路径转移而来，原因很简单，如果<span class="math inline">\(f[s\ \land\(1&lt;&lt;i)][x]\)</span>并非INT_MAX，那么这么转移是没有问题的，<u><mark><strong>但是，如果<span class="math inline">\(f[s\ \land\(1&lt;&lt;i)][x]\)</span>是INT_MAX呢？这是不是就意味着f[s][i]同样无法遍历得到了呢？当然不是</strong>。</mark></u>考虑上面示例，例如当位掩码为0111（即选择了0,1,2这三个节点），最后到达的节点为0时，如果按照上面错误的转移方程，我们有<span class="math display">\[f[0111][0]\ =\mathop{min}\{f[0110][1],\ f][0110][2]\}\ +\ 1\]</span>但是当位掩码仅为0110，也就是说要仅经过1,2两个节点的情况下遍历这两个节点都是不可能的，上面min的结果应该为INT_MAX，也就是说这么转移得到的f[0111][0]为INT_MAX，但是显然1-0-2-0为一条满足要求的路径，因此f[0111][0]最多也是3，因此这样的状态转移是不全面的。</p><hr><h2 id="正确解答">正确解答</h2><h3 id="思路一floyd最短路状压dp">思路一（Floyd最短路+状压dp）</h3><p>思路一延续前文错误思路的想法，只不过将状态转移方程改为 <span class="math display">\[f[s][i]\ =\mathop{min}\limits_{x\in \{0,1,\cdots,n-1\}}(f[s\ \land\(1&lt;&lt;i)][x])\ +\ dist(x,i)\]</span>其中dist(x,i)是节点x与i之间的最短距离，这个距离可以使用Floyd最短路径算法预计算出来。这样就不会出现漏掉一些状态转移方式的问题。</p><h4 id="floyd最短路径算法">Floyd最短路径算法</h4><p>算法原理以及描述这里不再赘述，读者可以在<a href="https://oi-wiki.org/graph/shortest-path/#floyd-%E7%AE%97%E6%B3%95">这里</a>找到关于该算法的具体描述和原理说明</p><p>Floyd算法的核心代码不过三层循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>  <span class="hljs-keyword">for</span> (x = <span class="hljs-number">1</span>; x &lt;= n; x++) &#123;<br>    <span class="hljs-keyword">for</span> (y = <span class="hljs-number">1</span>; y &lt;= n; y++) &#123;<br>      dist[k][x][y] = <span class="hljs-built_in">min</span>(dist[k - <span class="hljs-number">1</span>][x][y], dist[k - <span class="hljs-number">1</span>][x][k] + dist[k - <span class="hljs-number">1</span>][k][y]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中dist[k][x][y]表示只允许经过前k个节点的情况下由x到y的最短路径长度。由于外层状态k仅仅与k-1有关，所以实现的时候其实可以压缩掉一维：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>  <span class="hljs-keyword">for</span> (x = <span class="hljs-number">1</span>; x &lt;= n; x++) &#123;<br>    <span class="hljs-keyword">for</span> (y = <span class="hljs-number">1</span>; y &lt;= n; y++) &#123;<br>      dist[x][y] = <span class="hljs-built_in">min</span>(dist[x][y], dist[x][k] + dist[k][y]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中dist[x][y]直接定义为由x到y的最短路径长度。</p><h4 id="整体实现">整体实现</h4><p>首先预处理出任意两个节点之间的最短路径，然后使用上述正确状态转移方程求解，c++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestPathLength</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector <span class="hljs-title">dist</span><span class="hljs-params">(n, vector&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">1e9</span>))</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : graph[i]) &#123;<br>                dist[i][j] = dist[j][i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) dist[i][i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 预处理：floyd 求最短路</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                    dist[i][j] = <span class="hljs-built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//状压dp实现</span><br>        <span class="hljs-function">vector <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; n, vector&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">1e9</span>))</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) f[<span class="hljs-number">1</span> &lt;&lt; i][i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; (<span class="hljs-number">1</span> &lt;&lt; n); ++s) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (s &gt;&gt; i &amp; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                        <span class="hljs-keyword">if</span> ((s &gt;&gt; j &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>                            f[s | (<span class="hljs-number">1</span> &lt;&lt; j)][j] = <span class="hljs-built_in">min</span>(f[s | (<span class="hljs-number">1</span> &lt;&lt; j)][j], f[s][i] + dist[i][j]);<span class="hljs-comment">//转移方程形式上和前文略有差别，但本质上是一样的，这种写法会更方便</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//返回最终值</span><br>        <span class="hljs-keyword">return</span> *ranges::<span class="hljs-built_in">min_element</span>(f.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">begin</span>(),f.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">end</span>());<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="思路二bfs状压dp">思路二（BFS+状压dp）</h3><p>由于苯人还没有系统练习过BFS+队列存储的题目，这里暂时贴上leetcode上的<a href="https://leetcode.cn/problems/shortest-path-visiting-all-nodes/solutions/918634/gtalgorithm-tu-jie-fa-ba-hardbian-cheng-v5knb/">解答</a>，并且简述一下自己的一些理解，详细的思路说明留待之后补充~</p><h4 id="代码">代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestPathLength</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">// 1.初始化队列及标记数组，存入起点</span><br>        queue&lt; tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; q; <span class="hljs-comment">// 三个属性分别为 idx, mask, dist</span><br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">vis</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-number">1</span> &lt;&lt; n)); <span class="hljs-comment">// 节点编号及当前状态</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            q.<span class="hljs-built_in">push</span>(&#123;i, <span class="hljs-number">1</span> &lt;&lt; i, <span class="hljs-number">0</span>&#125;); <span class="hljs-comment">// 存入起点，起始距离0，标记</span><br>            vis[i][<span class="hljs-number">1</span> &lt;&lt; i] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 开始搜索</span><br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> [cur, mask, dist] = q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 弹出队头元素</span><br>            q.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-comment">// 找到答案，返回结果</span><br>            <span class="hljs-keyword">if</span>(mask == (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> dist;<br><br>            <span class="hljs-comment">// 扩展</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : graph[cur]) &#123;<br>                <span class="hljs-type">int</span> nextmask = mask | (<span class="hljs-number">1</span> &lt;&lt; x);<br>                <span class="hljs-keyword">if</span>(!vis[x][nextmask]) &#123;<br>                    q.<span class="hljs-built_in">push</span>(&#123;x, nextmask, dist + <span class="hljs-number">1</span>&#125;);<br>                    vis[x][nextmask] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="个人理解">个人理解</h4><p>q中每个tuple的三个元素存储的是当前位掩码mask，遍历mask中所有节点并最后到达的节点idx，以及满足前述两个条件的最短路径长度dist，vis[idx][mask]记录在当前位掩码为mask的状态下，最后到达节点idx的路径是否已经经过计算了，事实上，在下面的while循环过程中，我们可以保证只要vis[idx][mask]经过了一次计算（也就是设置为true了），这次计算算得的路径就是相应的最短路径，因此后续无需再次计算该状态下的最短路径。首先初始状态下，我们将所有仅含1个节点的状态(i,1&lt;&lt;i,0)入队，并且更改vis[i][1&lt;&lt;i]为true，然后开始正式搜索。观察while循环中的代码可以非常直观地得出一个重要的结论，就是每次循环入队的tuple元素的dist分量是单调递增的，因此在循环内部注释拓展部分，只有在vis[idx][mask]还没有计算得到的时候才将相应元素入队，如果它已经计算过了（也就是vis[idx][mask]已经设置为true了），那么根据前文所述单调递增的性质，第一次计算之后的计算得到的dist只会比第一次计算得到的更大，因此这种情况下相应的tuple不能入队。最终随着搜索的进行，当第一次发现搜索已经遍历了所有的节点之后，我们就可以立即返回相应的dist了，这还是源于dist在每层循环单调递增的特性，因为这意味着第一次遍历之后的遍历所对应tuple中的dist元素肯定至少大于等于第一次的dist，所以第一次的dist就是我们寻找的最短距离。另外，由于题目保证该图是连通的，也就是说一定可以求出这样的最短距离，所以其实最后的return0是用不上的，但必须加上这句代码以确保所有分支情况都有数返回（不然会报错）。</p><h2 id="补充">补充</h2><p>对于不熟悉状压dp及其写法的读者，可以参考OI Wiki中的<a href="https://oi-wiki.org/dp/state/">简介</a>，基础写法可以参考灵茶山艾府大神的几篇<a href="https://leetcode.cn/problems/find-the-minimum-cost-array-permutation/solutions/2775272/zhuang-ya-dpcong-ji-yi-hua-sou-suo-dao-d-s9t5/">题解</a>。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>状态压缩dp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
