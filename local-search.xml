<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Leetcode 847:访问所有节点的最短路径</title>
    <link href="/2024/09/19/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/Leetcode-847-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2024/09/19/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/Leetcode-847-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述">题目描述</h2><h3 id="题干">题干</h3><p>存在一个由 <code>n</code> 个节点组成的无向连通图，图中的节点按从<code>0</code> 到 <code>n - 1</code> 编号。</p><p>给你一个数组 <code>graph</code>表示这个图。其中，<code>graph[i]</code> 是一个列表，由所有与节点<code>i</code> 直接相连的节点组成。</p><p>返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。</p><h3 id="条件限制">条件限制</h3><ul><li><code>n == graph.length</code></li><li><code>1 &lt;= n &lt;= 12</code></li><li><code>0 &lt;= graph[i].length &lt; n</code></li><li><code>graph[i]</code> 不包含 <code>i</code></li><li>如果 <code>graph[a]</code> 包含 <code>b</code> ，那么<code>graph[b]</code> 也包含 <code>a</code></li><li>输入的图总是连通图</li></ul><h3 id="示例">示例</h3><figure><img src="/2024/09/19/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/Leetcode-847-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/example.png" alt="示例"><figcaption aria-hidden="true">示例</figcaption></figure><p><strong>输入</strong>：graph = [[1, 2, 3], [0], [0], [0]]</p><p><strong>输出</strong>：4</p><p><strong>解释</strong>：一种可能路径为[1, 0, 2, 0, 3]</p><hr><h2 id="错误解题思路">错误解题思路</h2><h3 id="思路">思路</h3><p>定义f[s][i]为位掩码为s且最后到达的节点为i时所走过的最短路径（如果在前述条件下不能遍历位掩码中的节点则记为INT_MAX，并且下面认为INT_MAX+1=INT_MAX)，简单地认为状态转移方程为：<span class="math display">\[f[s][i]\ =\mathop{min}\limits_{x\in graph[i]}(f[s\ \land\(1&lt;&lt;i)][x])\ +\ 1\]</span></p><h3 id="错误原因">错误原因</h3><p>事实上，位掩码为s且最后到达的节点为i时所走过的最短路径未必由除去i之后的位掩码下最后到达i的相邻节点x的最短路径转移而来，原因很简单，如果<span class="math inline">\(f[s\ \text{\^{}}\(1&lt;&lt;i)][x]\)</span>并非INT_MAX，那么这么转移是没有问题的，<u><mark><strong>但是，如果<span class="math inline">\(f[s\ \land\(1&lt;&lt;i)][x]\)</span>是INT_MAX呢？这是不是就意味着f[s][i]同样无法遍历得到了呢？当然不是</strong>。</mark></u>考虑上面示例，例如当位掩码为0111（即选择了0,1,2这三个节点），最后到达的节点为0时，如果按照上面错误的转移方程，我们有<span class="math display">\[f[0111][0]\ =\mathop{min}\{f[0110][1],\ f][0110][2]\}\ +\ 1\]</span>但是当位掩码仅为0110，也就是说要仅经过1,2两个节点的情况下遍历这两个节点都是不可能的，上面min的结果应该为INT_MAX，也就是说这么转移得到的f[0111][0]为INT_MAX，但是显然1-0-2-0为一条满足要求的路径，因此f[0111][0]最多也是3，因此这样的状态转移是不全面的。</p><hr><h2 id="正确解答">正确解答</h2><h3 id="思路一floyd最短路状压dp">思路一（Floyd最短路+状压dp）</h3><p>思路一延续前文错误思路的想法，只不过将状态转移方程改为 <span class="math display">\[f[s][i]\ =\mathop{min}\limits_{x\in \{0,1,\cdots,n-1\}}(f[s\ \land\(1&lt;&lt;i)][x])\ +\ dist(x,i)\]</span>其中dist(x,i)是节点x与i之间的最短距离，这个距离可以使用Floyd最短路径算法预计算出来。这样就不会出现漏掉一些状态转移方式的问题。</p><h4 id="floyd最短路径算法">Floyd最短路径算法</h4><p>算法原理以及描述这里不再赘述，读者可以在<a href="https://oi-wiki.org/graph/shortest-path/#floyd-%E7%AE%97%E6%B3%95">这里</a>找到关于该算法的具体描述和原理说明</p><p>Floyd算法的核心代码不过三层循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>  <span class="hljs-keyword">for</span> (x = <span class="hljs-number">1</span>; x &lt;= n; x++) &#123;<br>    <span class="hljs-keyword">for</span> (y = <span class="hljs-number">1</span>; y &lt;= n; y++) &#123;<br>      dist[k][x][y] = <span class="hljs-built_in">min</span>(dist[k - <span class="hljs-number">1</span>][x][y], dist[k - <span class="hljs-number">1</span>][x][k] + dist[k - <span class="hljs-number">1</span>][k][y]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中dist[k][x][y]表示只允许经过前k个节点的情况下由x到y的最短路径长度。由于外层状态k仅仅与k-1有关，所以实现的时候其实可以压缩掉一维：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>  <span class="hljs-keyword">for</span> (x = <span class="hljs-number">1</span>; x &lt;= n; x++) &#123;<br>    <span class="hljs-keyword">for</span> (y = <span class="hljs-number">1</span>; y &lt;= n; y++) &#123;<br>      dist[x][y] = <span class="hljs-built_in">min</span>(dist[x][y], dist[x][k] + dist[k][y]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中dist[x][y]直接定义为由x到y的最短路径长度。</p><h4 id="整体实现">整体实现</h4><p>首先预处理出任意两个节点之间的最短路径，然后使用上述正确状态转移方程求解，c++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestPathLength</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector <span class="hljs-title">dist</span><span class="hljs-params">(n, vector&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">1e9</span>))</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : graph[i]) &#123;<br>                dist[i][j] = dist[j][i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) dist[i][i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 预处理：floyd 求最短路</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                    dist[i][j] = <span class="hljs-built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//状压dp实现</span><br>        <span class="hljs-function">vector <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; n, vector&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">1e9</span>))</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) f[<span class="hljs-number">1</span> &lt;&lt; i][i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; (<span class="hljs-number">1</span> &lt;&lt; n); ++s) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (s &gt;&gt; i &amp; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                        <span class="hljs-keyword">if</span> ((s &gt;&gt; j &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>                            f[s | (<span class="hljs-number">1</span> &lt;&lt; j)][j] = <span class="hljs-built_in">min</span>(f[s | (<span class="hljs-number">1</span> &lt;&lt; j)][j], f[s][i] + dist[i][j]);<span class="hljs-comment">//转移方程形式上和前文略有差别，但本质上是一样的，这种写法会更方便</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//返回最终值</span><br>        <span class="hljs-keyword">return</span> *ranges::<span class="hljs-built_in">min_element</span>(f.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">begin</span>(),f.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">end</span>());<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="思路二bfs状压dp">思路二（BFS+状压dp）</h3><p>由于苯人还没有系统练习过BFS+队列存储的题目，这里暂时贴上leetcode上的<a href="https://leetcode.cn/problems/shortest-path-visiting-all-nodes/solutions/918634/gtalgorithm-tu-jie-fa-ba-hardbian-cheng-v5knb/">解答</a>，并且简述一下自己的一些理解，详细的思路说明留待之后补充~</p><h4 id="代码">代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestPathLength</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">// 1.初始化队列及标记数组，存入起点</span><br>        queue&lt; tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; q; <span class="hljs-comment">// 三个属性分别为 idx, mask, dist</span><br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">vis</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-number">1</span> &lt;&lt; n)); <span class="hljs-comment">// 节点编号及当前状态</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            q.<span class="hljs-built_in">push</span>(&#123;i, <span class="hljs-number">1</span> &lt;&lt; i, <span class="hljs-number">0</span>&#125;); <span class="hljs-comment">// 存入起点，起始距离0，标记</span><br>            vis[i][<span class="hljs-number">1</span> &lt;&lt; i] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 开始搜索</span><br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> [cur, mask, dist] = q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 弹出队头元素</span><br>            q.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-comment">// 找到答案，返回结果</span><br>            <span class="hljs-keyword">if</span>(mask == (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> dist;<br><br>            <span class="hljs-comment">// 扩展</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : graph[cur]) &#123;<br>                <span class="hljs-type">int</span> nextmask = mask | (<span class="hljs-number">1</span> &lt;&lt; x);<br>                <span class="hljs-keyword">if</span>(!vis[x][nextmask]) &#123;<br>                    q.<span class="hljs-built_in">push</span>(&#123;x, nextmask, dist + <span class="hljs-number">1</span>&#125;);<br>                    vis[x][nextmask] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="个人理解">个人理解</h4><p>q中每个tuple的三个元素存储的是当前位掩码mask，遍历mask中所有节点并最后到达的节点idx，以及满足前述两个条件的最短路径长度dist，vis[idx][mask]记录在当前位掩码为mask的状态下，最后到达节点idx的路径是否已经经过计算了，事实上，在下面的while循环过程中，我们可以保证只要vis[idx][mask]经过了一次计算（也就是设置为true了），这次计算算得的路径就是相应的最短路径，因此后续无需再次计算该状态下的最短路径。首先初始状态下，我们将所有仅含1个节点的状态(i,1&lt;&lt;i,0)入队，并且更改vis[i][1&lt;&lt;i]为true，然后开始正式搜索。观察while循环中的代码可以非常直观地得出一个重要的结论，就是每次循环入队的tuple元素的dist分量是单调递增的，因此在循环内部注释拓展部分，只有在vis[idx][mask]还没有计算得到的时候才将相应元素入队，如果它已经计算过了（也就是vis[idx][mask]已经设置为true了），那么根据前文所述单调递增的性质，第一次计算之后的计算得到的dist只会比第一次计算得到的更大，因此这种情况下相应的tuple不能入队。最终随着搜索的进行，当第一次发现搜索已经遍历了所有的节点之后，我们就可以立即返回相应的dist了，这还是源于dist在每层循环单调递增的特性，因为这意味着第一次遍历之后的遍历所对应tuple中的dist元素肯定至少大于等于第一次的dist，所以第一次的dist就是我们寻找的最短距离。另外，由于题目保证该图是连通的，也就是说一定可以求出这样的最短距离，所以其实最后的return0是用不上的，但必须加上这句代码以确保所有分支情况都有数返回（不然会报错）。</p><h2 id="补充">补充</h2><p>对于不熟悉状压dp及其写法的读者，可以参考OI Wiki中的<a href="https://oi-wiki.org/dp/state/">简介</a>，基础写法可以参考灵茶山艾府大神的几篇<a href="https://leetcode.cn/problems/find-the-minimum-cost-array-permutation/solutions/2775272/zhuang-ya-dpcong-ji-yi-hua-sou-suo-dao-d-s9t5/">题解</a>。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>状态压缩dp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
