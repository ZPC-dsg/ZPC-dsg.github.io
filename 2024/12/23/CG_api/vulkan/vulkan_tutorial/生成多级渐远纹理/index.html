<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/icon/mikuicon.jpg"><link rel="icon" href="/images/icon/mikuicon.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="ZPC-dsg"><meta name="keywords" content=""><meta name="description" content="概要 我们的程序现在已经可以渲染3D模型了。不过，在上一章的最终效果图中，如果我们仔细观察，还是可以发现模型墙上的文字有些会呈现出锯齿状的生硬边界，这种缺陷叫做摩尔纹。本节中，我们将实现之前多次提及的多级渐远纹理，这将有助于解决摩尔纹的问题。 所谓多级渐远纹理，就是从一张初始图像合成出一系列像素更少的图像（一般来讲下一张图像宽高均是上一张的一半），这样在采样近处物体的纹理时我们可以使用分辨率高"><meta property="og:type" content="article"><meta property="og:title" content="生成多级渐远纹理"><meta property="og:url" content="http://example.com/2024/12/23/CG_api/vulkan/vulkan_tutorial/%E7%94%9F%E6%88%90%E5%A4%9A%E7%BA%A7%E6%B8%90%E8%BF%9C%E7%BA%B9%E7%90%86/index.html"><meta property="og:site_name" content="ZPC の Blog"><meta property="og:description" content="概要 我们的程序现在已经可以渲染3D模型了。不过，在上一章的最终效果图中，如果我们仔细观察，还是可以发现模型墙上的文字有些会呈现出锯齿状的生硬边界，这种缺陷叫做摩尔纹。本节中，我们将实现之前多次提及的多级渐远纹理，这将有助于解决摩尔纹的问题。 所谓多级渐远纹理，就是从一张初始图像合成出一系列像素更少的图像（一般来讲下一张图像宽高均是上一张的一半），这样在采样近处物体的纹理时我们可以使用分辨率高"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/images/textbg/CG_api/vk_tuto_mipmap.jpg"><meta property="article:published_time" content="2024-12-23T07:17:33.000Z"><meta property="article:modified_time" content="2024-12-26T01:41:03.566Z"><meta property="article:author" content="ZPC-dsg"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/images/textbg/CG_api/vk_tuto_mipmap.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>生成多级渐远纹理 - ZPC の Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:"measurement_id:G-X8N3TZCB57",tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>ZPC の Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/images/textbg/CG_api/vk_tuto_mipmap.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="生成多级渐远纹理"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> ZPC-dsg </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-12-23 15:17" pubdate>2024年12月23日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 2.9k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 25 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">生成多级渐远纹理</h1><div class="markdown-body"><h2 id="概要">概要</h2><p>我们的程序现在已经可以渲染3D模型了。不过，在<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/12/21/CG_api/vulkan/vulkan_tutorial/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/">上一章</a>的最终效果图中，如果我们仔细观察，还是可以发现模型墙上的文字有些会呈现出锯齿状的生硬边界，这种缺陷叫做<strong>摩尔纹</strong>。本节中，我们将实现之前多次提及的多级渐远纹理，这将有助于解决摩尔纹的问题。</p><p>所谓多级渐远纹理，就是从一张初始图像合成出一系列像素更少的图像（一般来讲下一张图像宽高均是上一张的一半），这样在采样近处物体的纹理时我们可以使用分辨率高的图像，采样远处物体的时候可以使用分辨率低的图像，这样既不会对视觉体验造成较大的影响，又可以防止远处物体纹理采样点的不准确导致的一系列问题（摩尔纹等）。关于摩尔纹等问题和多级渐远纹理的详细介绍，以及更多关于纹理采样的细节，可以参考<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1X7411F744?vd_source=96b763f75b621baa119e5118b6164aee&amp;spm_id_from=333.788.videopod.episodes&amp;p=9">games101</a>有关课程，这里不再赘述。</p><p>本节创建并使用多级渐远纹理的过程可以分为以下两步：</p><ul><li>生成纹理对应的多级渐远纹理</li><li>更改图像采样器以使用多级渐远纹理</li></ul><p>本节对应Vulkan Tutorial的<a target="_blank" rel="noopener" href="https://vulkan-tutorial.com/Generating_Mipmaps#page_Sampler">Generating Mipmaps</a>章节。</p><hr><h2 id="生成多级渐远纹理">生成多级渐远纹理</h2><p>首先要明确我们只有纹理需要使用多级渐远纹理，帧缓冲的颜色附件和深度附件是不需要的，因为我们并不会对这些附件进行采样。</p><p>为了使用多级渐远纹理，我们需要知道纹理需要的多级渐远层级数，这可以通过纹理本身的分辨率计算出来。在类内新添一个<i><font color="Orange">uint32_t mipLevels</font></i>来存储该层级数，然后在加载纹理的时候获取该层级数的具体值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> texWidth, texHeight, texChannels;<br>stbi_uc* pixels = <span class="hljs-built_in">stbi_load</span>(TEXTURE_PATH.<span class="hljs-built_in">c_str</span>(), &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);<br>...<br>mipLevels = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(std::<span class="hljs-built_in">floor</span>(std::<span class="hljs-built_in">log2</span>(std::<span class="hljs-built_in">max</span>(texWidth, texHeight)))) + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p></p><p>可以看到，这里我们采取的策略是通过宽、高中较大的那个是2的多少次方来确定有多少层，每一层的宽、高就是上一层除以2（如果宽、高中较小的那个在某一层是1了，那么在后续的所有层中它保持大小为1）。</p><p>现在我们需要修改所有图像创建和布局转换函数来添加上对多级渐远层级的使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createImage</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> width, <span class="hljs-type">uint32_t</span> height, <span class="hljs-type">uint32_t</span> mipLevels, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage&amp; image, VkDeviceMemory&amp; imageMemory)</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    imageInfo.mipLevels = mipLevels;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...</span><br><span class="hljs-function">VkImageView <span class="hljs-title">createImageView</span><span class="hljs-params">(VkImage image, VkFormat format, VkImageAspectFlags aspectFlags, <span class="hljs-type">uint32_t</span> mipLevels)</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    viewInfo.subresourceRange.levelCount = mipLevels;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transitionImageLayout</span><span class="hljs-params">(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout, <span class="hljs-type">uint32_t</span> mipLevels)</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    barrier.subresourceRange.levelCount = mipLevels;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同时我们需要更新所有使用到这些函数的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">createImage</span>(swapChainExtent.width, swapChainExtent.height, <span class="hljs-number">1</span>, depthFormat, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, depthImage, depthImageMemory);<br><span class="hljs-comment">//...</span><br><span class="hljs-built_in">createImage</span>(texWidth, texHeight, mipLevels, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);<br><span class="hljs-comment">//...</span><br>swapChainImageViews[i] = <span class="hljs-built_in">createImageView</span>(swapChainImages[i], swapChainImageFormat, VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">1</span>);<br><span class="hljs-comment">//...</span><br>depthImageView = <span class="hljs-built_in">createImageView</span>(depthImage, depthFormat, VK_IMAGE_ASPECT_DEPTH_BIT, <span class="hljs-number">1</span>);<br><span class="hljs-comment">//...</span><br>textureImageView = <span class="hljs-built_in">createImageView</span>(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_ASPECT_COLOR_BIT, mipLevels);<br><span class="hljs-comment">//...</span><br><span class="hljs-built_in">transitionImageLayout</span>(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, mipLevels);<br></code></pre></td></tr></table></figure><p>现在我们的图像已经具备了多个渐远层级，但是目前除了基础层级之外，其它的层级还没有任何内容，因为我们还没有将图像数据填充到这些新的层级中，接下来我们就来手动生成这些层级的图像内容。</p><p>为了填充每个层级的图像，我们可以使用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage.html"><code>vkCmdBlitImage</code></a>函数将某一个层级的内容经过滤后复制到另一个层级上。该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdBlitImage</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    VkImage                                     srcImage,</span><br><span class="hljs-params">    VkImageLayout                               srcImageLayout,</span><br><span class="hljs-params">    VkImage                                     dstImage,</span><br><span class="hljs-params">    VkImageLayout                               dstImageLayout,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    regionCount,<span class="hljs-comment">//过滤传输的区域数</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkImageBlit*                          pRegions,<span class="hljs-comment">//过滤传输的区域</span></span><br><span class="hljs-params">    VkFilter                                    filter)</span>;<br></code></pre></td></tr></table></figure><p>可以看到，我们可以将图像的多块数据分别进行过滤传输。其中，我们需要使用[<code>VkImageBlit</code>][id]类型的成员来指定每个传输区域的范围。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkImageBlit</span> &#123;</span><br>    VkImageSubresourceLayers    srcSubresource;<br>    VkOffset3D                  srcOffsets[<span class="hljs-number">2</span>];<br>    VkImageSubresourceLayers    dstSubresource;<br>    VkOffset3D                  dstOffsets[<span class="hljs-number">2</span>];<br>&#125; VkImageBlit;<br></code></pre></td></tr></table></figure><p>每个成员都是易于理解的。</p><p><i><font color="Orange">filter</font></i>用于指定如果传输源和目标图像的大小不同，那么在缩放的时候应该采取怎样的颜色过滤模式。</p><p>另外可以看到，在使用该函数时我们需要指定源图像和目标图像的布局。我们当然需要源图像布局是<i><font color="Red">VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</font></i>而目标图像的布局为<i><font color="Red">VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</font></i>。因此在生成多级渐远纹理的每个层级的时候，我们在使用该函数之前还需要将每个层级的图像转换到合适的布局。</p><p>总的来讲，生成某张纹理的多级渐远纹理的整个流程应该是这样的：首先创建存储纹理数据的图像和它的所有渐远层级，然后使用<i><font color="Green">transitionImageLayout</font></i>将所有层级的图像布局均设置为<i><font color="Red">VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</font></i>以接收临时缓冲中的图像数据。现在基础层图像已经有了相应的纹理数据，然后我们把该层数据通过<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage.html"><code>vkCmdBlitImage</code></a>函数传输给下一个层级，在传输之前，我们当然需要先将基础层的图像布局转换为<i><font color="Red">VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</font></i>。在传输结束后，我们可以立刻将基础层的图像布局转化为<i><font color="Red">VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</font></i>以供后续着色器读取。这样我们的第二层图像就具有了相应的纹理数据，循环进行这一步骤，直到所有的层级都填充好了纹理数据即可。</p><p>下面来实现这样的代码逻辑。我们需要将原来的<i><font color="Green">createTextureImage</font></i>修改为如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createTextureImage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> texWidth, texHeight, texChannels;<br>    stbi_uc* pixels = <span class="hljs-built_in">stbi_load</span>(TEXTURE_PATH.<span class="hljs-built_in">c_str</span>(), &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);<br>    VkDeviceSize imageSize = texWidth * texHeight * <span class="hljs-number">4</span>;<br>    mipLevels = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(std::<span class="hljs-built_in">floor</span>(std::<span class="hljs-built_in">log2</span>(std::<span class="hljs-built_in">max</span>(texWidth, texHeight)))) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (!pixels) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to load texture image!&quot;</span>);<br>    &#125;<br><br>    VkBuffer stagingBuffer;<br>    VkDeviceMemory stagingBufferMemory;<br>    <span class="hljs-built_in">createBuffer</span>(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);<br><br>    <span class="hljs-type">void</span>* data;<br>    <span class="hljs-built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="hljs-number">0</span>, imageSize, <span class="hljs-number">0</span>, &amp;data);<br>    <span class="hljs-built_in">memcpy</span>(data, pixels, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(imageSize));<br>    <span class="hljs-built_in">vkUnmapMemory</span>(device, stagingBufferMemory);<br><br>    <span class="hljs-built_in">stbi_image_free</span>(pixels);<br><br>    <span class="hljs-built_in">createImage</span>(texWidth, texHeight, mipLevels, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);<br><br>    <span class="hljs-built_in">transitionImageLayout</span>(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, mipLevels);<br>    <span class="hljs-built_in">copyBufferToImage</span>(stagingBuffer, textureImage, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(texWidth), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(texHeight));<br>    <br>    <span class="hljs-built_in">vkDestroyBuffer</span>(device, stagingBuffer, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">vkFreeMemory</span>(device, stagingBufferMemory, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-built_in">generateMipmaps</span>(textureImage, VK_FORMAT_R8G8B8A8_SRGB, texWidth, texHeight, mipLevels);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们添加了一个<i><font color="Green">generateMipmaps</font></i>函数来处理从图像生成它的所有多级渐远纹理的代码逻辑。按照我们之前的叙述，这段代码应该如下编写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">generateMipmaps</span><span class="hljs-params">(VkImage image, VkFormat imageFormat, <span class="hljs-type">int32_t</span> texWidth, <span class="hljs-type">int32_t</span> texHeight, <span class="hljs-type">uint32_t</span> mipLevels)</span> </span>&#123;<br>    VkFormatProperties formatProperties;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceFormatProperties</span>(physicalDevice, imageFormat, &amp;formatProperties);<br><br>    <span class="hljs-keyword">if</span> (!(formatProperties.optimalTilingFeatures &amp; VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT)) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;texture image format does not support linear blitting!&quot;</span>);<br>    &#125;<br><br>    VkCommandBuffer commandBuffer = <span class="hljs-built_in">beginSingleTimeCommands</span>();<br><br>    VkImageMemoryBarrier barrier&#123;&#125;;<br>    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;<br>    barrier.image = image;<br>    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;<br>    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;<br>    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br>    barrier.subresourceRange.baseArrayLayer = <span class="hljs-number">0</span>;<br>    barrier.subresourceRange.layerCount = <span class="hljs-number">1</span>;<br>    barrier.subresourceRange.levelCount = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">int32_t</span> mipWidth = texWidth;<br>    <span class="hljs-type">int32_t</span> mipHeight = texHeight;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">1</span>; i &lt; mipLevels; i++) &#123;<br>        barrier.subresourceRange.baseMipLevel = i - <span class="hljs-number">1</span>;<br>        barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;<br>        barrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;<br>        barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;<br>        barrier.dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;<br><br>        <span class="hljs-built_in">vkCmdPipelineBarrier</span>(commandBuffer,<br>            VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, <span class="hljs-number">0</span>,<br>            <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>            <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>            <span class="hljs-number">1</span>, &amp;barrier);<br><br>        VkImageBlit blit&#123;&#125;;<br>        blit.srcOffsets[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        blit.srcOffsets[<span class="hljs-number">1</span>] = &#123;mipWidth, mipHeight, <span class="hljs-number">1</span>&#125;;<br>        blit.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br>        blit.srcSubresource.mipLevel = i - <span class="hljs-number">1</span>;<br>        blit.srcSubresource.baseArrayLayer = <span class="hljs-number">0</span>;<br>        blit.srcSubresource.layerCount = <span class="hljs-number">1</span>;<br>        blit.dstOffsets[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        blit.dstOffsets[<span class="hljs-number">1</span>] = &#123; mipWidth &gt; <span class="hljs-number">1</span> ? mipWidth / <span class="hljs-number">2</span> : <span class="hljs-number">1</span>, mipHeight &gt; <span class="hljs-number">1</span> ? mipHeight / <span class="hljs-number">2</span> : <span class="hljs-number">1</span>, <span class="hljs-number">1</span> &#125;;<br>        blit.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br>        blit.dstSubresource.mipLevel = i;<br>        blit.dstSubresource.baseArrayLayer = <span class="hljs-number">0</span>;<br>        blit.dstSubresource.layerCount = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-built_in">vkCmdBlitImage</span>(commandBuffer,<br>            image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,<br>            image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,<br>            <span class="hljs-number">1</span>, &amp;blit,<br>            VK_FILTER_LINEAR);<br><br>        barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;<br>        barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;<br>        barrier.srcAccessMask = VK_ACCESS_TRANSFER_READ_BIT;<br>        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;<br><br>        <span class="hljs-built_in">vkCmdPipelineBarrier</span>(commandBuffer,<br>            VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, <span class="hljs-number">0</span>,<br>            <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>            <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>            <span class="hljs-number">1</span>, &amp;barrier);<br><br>        <span class="hljs-keyword">if</span> (mipWidth &gt; <span class="hljs-number">1</span>) mipWidth /= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (mipHeight &gt; <span class="hljs-number">1</span>) mipHeight /= <span class="hljs-number">2</span>;<br>    &#125;<br><br>    barrier.subresourceRange.baseMipLevel = mipLevels - <span class="hljs-number">1</span>;<br>    barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;<br>    barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;<br>    barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;<br>    barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;<br><br>    <span class="hljs-built_in">vkCmdPipelineBarrier</span>(commandBuffer,<br>        VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, <span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>        <span class="hljs-number">1</span>, &amp;barrier);<br><br>    <span class="hljs-built_in">endSingleTimeCommands</span>(commandBuffer); &#125;<br><br></code></pre></td></tr></table></figure><p>下面我们来逐步解释代码细节：</p><p>这段代码首先检查了硬件是否支持线性过滤功能。事实上，如果需要使用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage.html"><code>vkCmdBlitImage</code></a>函数，那么所处理的图像格式一定需要支持线性过滤，这可以通过查询物理设备支持的格式特性来完成，我们在<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/">深度缓冲</a>章节中已经看到相应的做法，这里不再赘述。</p><p>接下来我们需要创建一个图像内存屏障来显式同步和各层图像布局转换有关的操作。由于有多层图像需要生成，我们会创建一个for循环来生成所有的层级，并且在这些层级的生成过程中重用同一个内存屏障以提高效率。循环的开始，我们首先将当前处理层级的图像布局从一开始的传输目的地转变为传输源。注意，如果当前层是第一层，那么该层会作为从缓冲区复制图像数据的目的地；如果不是第一层，那么该层会是前一层传输过滤后图像数据的目的地（也就是[]<code>vkCmdBlitImage</code>]<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage.html">id4</a>操作的目的地），不管是哪种情况，当前层图像布局一开始都会是<i><font color="Red">VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</font></i>（因为<i><font color="Green">transitionImageLayout</font></i>将每一层布局都变成了这个），我们都需要将当前层布局转化为<i><font color="Red">VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</font></i>以执行后续操作（即将当前层数据传输给下一层的操作）。</p><p>在当前层布局转换完成后，我们就可以开始向下一层传输数据了。通过<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage.html"><code>vkCmdBlitImage</code></a>函数原型可知我们需要填写一个[<code>VkImageBlit</code>][id]结构体来指定传输范围。这一段的代码比较直观。</p><p>在循环的最后，我们已经完成了当前层数据的传输，接下来不再需要在传输中使用当前层了，我们可以将其布局转换为适合之后着色器读取的布局<i><font color="Red">VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</font></i>。</p><p>不过可以发现，在该函数的末尾我们还单独对最后一层进行了处理，将它的布局转换为<i><font color="Red">VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</font></i>。这是因为最后一层不会作为传输源将数据传输给下一层了，我们的for循环中实际上没有处理最后一层的图像布局转换。因此最后我们需要在循环外单独将最后一层的布局转换为需要的布局。</p><p>这样我们就完成了生成多级渐远纹理的各个层级的操作！</p><hr><h2 id="更改图像采样器">更改图像采样器</h2><p>还记得在<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/">图像视图和采样器</a>章节中我们在填写创建采样器的信息结构体<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerCreateInfo.html"><code>VkSamplerCreateInfo</code></a>时没有填写和多级渐远有关的成员<i><font color="Orange">minLod</font></i>，<i><font color="Orange">maxLod</font></i>，<i><font color="Orange">mipLodBias</font></i>和<i><font color="Orange">mipmapMode</font></i>吗？这几个成员用于控制着色器将如何使用多级渐远纹理以及采样器在什么时候选择哪个层级的纹理。事实上，在指定了这几个成员后，采样器选择层级以及着色器渲染得到最终颜色的伪代码大概是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">lod = <span class="hljs-built_in">getLodLevelFromScreenSize</span>(); <br>lod = <span class="hljs-built_in">clamp</span>(lod + mipLodBias, minLod, maxLod);<br><br>level = <span class="hljs-built_in">clamp</span>(<span class="hljs-built_in">floor</span>(lod), <span class="hljs-number">0</span>, texture.mipLevels - <span class="hljs-number">1</span>);  <br><br><span class="hljs-keyword">if</span> (mipmapMode == VK_SAMPLER_MIPMAP_MODE_NEAREST) &#123;<br>    color = <span class="hljs-built_in">sample</span>(level);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    color = <span class="hljs-built_in">blend</span>(<span class="hljs-built_in">sample</span>(level), <span class="hljs-built_in">sample</span>(level + <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，在采样过程中，采样使用的过滤方式也会受到<strong>Lod(Level of Detail)</strong>的影响，大致原理用伪代码表示如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (lod &lt;= <span class="hljs-number">0</span>) &#123;<br>    color = <span class="hljs-built_in">readTexture</span>(uv, magFilter);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    color = <span class="hljs-built_in">readTexture</span>(uv, minFilter);<br>&#125;<br></code></pre></td></tr></table></figure><p>于是在我们的程序中，为了使用多级渐远纹理，我们需要正确设置采样器对纹理层级的采样方式。设置代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createTextureSampler</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <br>    samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;<br>    samplerInfo.minLod = <span class="hljs-number">0.0f</span>; <br>    samplerInfo.maxLod = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(mipLevels);<br>    samplerInfo.mipLodBias = <span class="hljs-number">0.0f</span>; <br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以使用所有层级的渐远纹理了。</p><p>下图对比了使用多级渐远纹理和不使用多级渐远纹理得到图像的区别：</p><figure><img src="/2024/12/23/CG_api/vulkan/vulkan_tutorial/%E7%94%9F%E6%88%90%E5%A4%9A%E7%BA%A7%E6%B8%90%E8%BF%9C%E7%BA%B9%E7%90%86/mipmap.png" srcset="/img/loading.gif" lazyload alt="有无渐远纹理（左无右有）"><figcaption aria-hidden="true">有无渐远纹理（左无右有）</figcaption></figure><p>乍一看没有什么区别，不过仔细观察上图中斧子的边缘还是可以发现多级渐远纹理的使用使得斧头的边缘有了一定程度的平滑和模糊。</p><p>大功告成！</p><hr><p>--<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/12/21/CG_api/vulkan/vulkan_tutorial/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/">上一篇：加载模型</a></p><p>--<a href>下一篇：多重采样</a></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/CG-api/" class="category-chain-item">CG_api</a> <span>></span> <a href="/categories/CG-api/vulkan/" class="category-chain-item">vulkan</a> <span>></span> <a href="/categories/CG-api/vulkan/vulkan-tutorial/" class="category-chain-item">vulkan_tutorial</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>生成多级渐远纹理</div><div>http://example.com/2024/12/23/CG_api/vulkan/vulkan_tutorial/生成多级渐远纹理/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>ZPC-dsg</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年12月23日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/12/26/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7/" title="多重采样"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">多重采样</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/12/21/CG_api/vulkan/vulkan_tutorial/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/" title="加载模型"><span class="hidden-mobile">加载模型</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>