<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>渲染通道</title>
    <link href="/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/"/>
    <url>/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>固定管线</title>
    <link href="/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/"/>
    <url>/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p><a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/">上一章</a>中我们已经构建好了渲染管线中的可编程阶段。本节将继续构建管线中的固定函数阶段。我们需要分别构建：</p><ul><li>顶点输入</li><li>输入汇编阶段</li><li>视口和裁剪</li><li>光栅化阶段</li><li>多重采样</li><li>深度模板测试</li><li>颜色混合阶段</li><li>管线布局</li></ul><p>下面我们依次构建所有的固定函数和阶段。</p><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions">Fixedfunctions</a>章节。</p><hr><h2 id="顶点输入">顶点输入</h2><p>首先我们需要指定顶点输入数据的格式。主要需要关注两部分：</p><ul><li>绑定方式：即数据之间的排列间隙以及数据是逐顶点的还是逐索引的</li><li>属性描述：即数据属性的类别以及它们对应的绑定点和在在数据块中的偏移</li></ul><p>指定数据输入格式是通过填写 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineVertexInputStateCreateInfo.html"><code>VkPipelineVertexInputStateCreateInfo</code></a>完成的，它的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineVertexInputStateCreateInfo</span> &#123;</span><br>    VkStructureType                             sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                 pNext;<br>    VkPipelineVertexInputStateCreateFlags       flags;<span class="hljs-comment">//暂时没有选项</span><br>    <span class="hljs-type">uint32_t</span>                                    vertexBindingDescriptionCount;<br>    <span class="hljs-type">const</span> VkVertexInputBindingDescription*      pVertexBindingDescriptions;<br>    <span class="hljs-type">uint32_t</span>                                    vertexAttributeDescriptionCount;<br>    <span class="hljs-type">const</span> VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;<br>&#125; VkPipelineVertexInputStateCreateInfo;<br></code></pre></td></tr></table></figure><p>其中<i><font color="Orange">pVertexBindingDescriptions</font></i>对应的就是绑定方式，<i><font color="Orange">pVertexAttributeDescriptions</font></i>对应的就是属性描述。</p><p>由于我们暂时是将顶点数据硬编码在顶点着色器中的，所以我们暂时不需要填写这些成员。在后续顶点缓冲章节我们会进行更详细得说明。</p><hr><h2 id="输入汇编阶段">输入汇编阶段</h2><p>输入汇编阶段通过 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineInputAssemblyStateCreateInfo.html"><code>VkPipelineInputAssemblyStateCreateInfo</code></a>指定。该结构体指定两方面的信息：</p><ul><li>顶点构成的图元种类</li><li>图元重启是否开启</li></ul><p>其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineInputAssemblyStateCreateInfo</span> &#123;</span><br>    VkStructureType                            sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                pNext;<br>    VkPipelineInputAssemblyStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    VkPrimitiveTopology                        topology;<br>    VkBool32                                   primitiveRestartEnable;<br>&#125; VkPipelineInputAssemblyStateCreateInfo;<br></code></pre></td></tr></table></figure><p>其中<i><font color="Orange">topology</font></i>指定的就是图元的种类，有关图元的所有种类可以参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPrimitiveTopology.html">这个页面</a>。</p><p><i><font color="Orange">primitiveRestartEnable</font></i>指定是否开启图元重启。图元重启（PrimitiveRestart）是图形渲染中的一种机制，用于在绘制图元（如三角形、线段等）时，允许在同一绘制调用中重启图元的绘制过程。这在处理复杂的几何体时非常有用，尤其是当使用索引缓冲区时。在绘制过程中，PrimitiveRestart 允许通过一个特殊的重启索引值（通常是一个特定的无效索引，如<code>0xFFFFFFFF</code>）来指示图元的重启。当遇到这个重启索引时，渲染管线会停止当前图元的绘制，并开始绘制一个新的图元。</p><p>为了绘制第一个三角形，这里我们只需如下指定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineInputAssemblyStateCreateInfo inputAssembly&#123;&#125;;<br>inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;<br>inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;<br>inputAssembly.primitiveRestartEnable = VK_FALSE;<br></code></pre></td></tr></table></figure><hr><h2 id="视口和裁剪">视口和裁剪</h2><p>视口和裁剪的设置比较特殊，它们既可以作为渲染管线的一部分被预先设置好并烘培至管线内，也可以在命令缓冲中动态设定以便在程序运行时动态改变而不重新建立渲染管线。</p><p>如果需要预先设置好，可以先分别填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkViewport.html"><code>VkViewport</code></a>和<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRect2D.html"><code>VkRect2D</code></a>结构体，它们的定义分别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkViewport</span> &#123;</span><br>    <span class="hljs-type">float</span>    x;<br>    <span class="hljs-type">float</span>    y;<br>    <span class="hljs-type">float</span>    width;<br>    <span class="hljs-type">float</span>    height;<br>    <span class="hljs-type">float</span>    minDepth;<br>    <span class="hljs-type">float</span>    maxDepth;<br>&#125; VkViewport;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkRect2D</span> &#123;</span><br>    VkOffset2D    offset;<br>    VkExtent2D    extent;<br>&#125; VkRect2D;<br></code></pre></td></tr></table></figure><p>先看<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkViewport.html"><code>VkViewport</code></a>：前两个坐标指定的是视口左上角的位置，最后两个值指定的是帧缓冲中坐标的深度范围，这个深度范围一定要在<strong>[0.0,1.0]</strong>中，但是最小深度允许在指定的时候大于最大深度。绝大多数情况下我们都希望视口范围和图像范围一样大，并且深度范围就是<strong>[0.0,1.0]</strong>，因此一般来讲可以这样填写该结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkViewport viewport&#123;&#125;;<br>viewport.x = <span class="hljs-number">0.0f</span>;<br>viewport.y = <span class="hljs-number">0.0f</span>;<br>viewport.width = (<span class="hljs-type">float</span>) swapChainExtent.width;<br>viewport.height = (<span class="hljs-type">float</span>) swapChainExtent.height;<br>viewport.minDepth = <span class="hljs-number">0.0f</span>;<br>viewport.maxDepth = <span class="hljs-number">1.0f</span>;<br></code></pre></td></tr></table></figure><p>对于裁剪范围，它由一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRect2D.html"><code>VkRect2D</code></a>结构体指定，它的两个成员分别指定偏移量和范围大小。如果不需要特殊的效果，一般来讲我们不需要裁剪图像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkRect2D scissor&#123;&#125;;<br>scissor.offset = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>scissor.extent = swapChainExtent;<br></code></pre></td></tr></table></figure><p>如果需要将视口和裁剪设置为动态阶段（dynamicstate），那么我们需要使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineDynamicStateCreateInfo.html"><code>VkPipelineDynamicStateCreateInfo</code></a>指定动态阶段的信息。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineDynamicStateCreateInfo</span> &#123;</span><br>    VkStructureType                      sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                          pNext;<br>    VkPipelineDynamicStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    <span class="hljs-type">uint32_t</span>                             dynamicStateCount;<br>    <span class="hljs-type">const</span> VkDynamicState*                pDynamicStates;<br>&#125; VkPipelineDynamicStateCreateInfo;<br></code></pre></td></tr></table></figure><p>因此我们需要如下填写该结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;VkDynamicState&gt; dynamicStates = &#123;<br>    VK_DYNAMIC_STATE_VIEWPORT,<br>    VK_DYNAMIC_STATE_SCISSOR<br>&#125;;<br><br>VkPipelineDynamicStateCreateInfo dynamicState&#123;&#125;;<br>dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;<br>dynamicState.dynamicStateCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(dynamicStates.<span class="hljs-built_in">size</span>());<br>dynamicState.pDynamicStates = dynamicStates.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>不管采取哪种方式，在指定好视口和裁剪的信息后，我们都需要通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportStateCreateInfo.html"><code>VkPipelineViewportStateCreateInfo</code></a>结构体告诉渲染管线我们使用的视口和裁剪，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineViewportStateCreateInfo</span> &#123;</span><br>    VkStructureType                       sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                           pNext;<br>    VkPipelineViewportStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    <span class="hljs-type">uint32_t</span>                              viewportCount;<br>    <span class="hljs-type">const</span> VkViewport*                     pViewports;<br>    <span class="hljs-type">uint32_t</span>                              scissorCount;<br>    <span class="hljs-type">const</span> VkRect2D*                       pScissors;<br>&#125; VkPipelineViewportStateCreateInfo;<br></code></pre></td></tr></table></figure><p>如果视口和裁剪使用动态阶段，那么我们无需填写<i><font color="Orange">pViewports</font></i>和<i><font color="Orange">pScissors</font></i>成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineViewportStateCreateInfo viewportState&#123;&#125;;<br>viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;<br>viewportState.viewportCount = <span class="hljs-number">1</span>;<br>viewportState.scissorCount = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>否则我们还需指定使用的视口和裁剪范围：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">viewportState.pViewports = &amp;viewport;<br>viewportState.pScissors = &amp;scissor;<br></code></pre></td></tr></table></figure><p>另外，从结构体的定义不难看出渲染管线是允许指定多视口和裁剪区域的，但是要这么做要求GPU具有相应的特性，这可以通过查询物理设备特性的函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures.html"><code>vkGetPhysicalDeviceFeatures</code></a>来查询，大致的查询结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPhysicalDeviceFeatures features;<br><span class="hljs-built_in">vkGetPhysicalDeviceFeatures</span>(physicalDevice, &amp;features);<br><br><span class="hljs-keyword">if</span> (features.multiViewport) &#123;<br>    <span class="hljs-comment">// 支持多视口</span><br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-keyword">if</span> (features.multiDrawIndirect) &#123;<br>    <span class="hljs-comment">// 支持多裁剪区域</span><br>    <span class="hljs-comment">///...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们解释一下视口区域和裁剪区域的区别。视口实际上可以看成是由图像到帧缓冲区的一个变换，它并不会导致图像上部分区域的丢失，只会拉伸或者压缩图像；而裁剪区域指定的是图像哪些像素会被保留，裁剪区域之外的部分会在光栅化阶段丢弃，它更像是一个过滤器。下面这张图很好地说明了这两者的区别与联系：</p><figure><img src="/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/视口裁剪.png" alt="视口和裁剪"><figcaption aria-hidden="true">视口和裁剪</figcaption></figure><hr><h2 id="光栅化阶段">光栅化阶段</h2><p>光栅化阶段将几何体分割为片段，并且执行提前深度测试、面剔除、裁剪测试等操作，它还决定了多边形绘制模式。这些信息都是通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateCreateInfo.html"><code>VkPipelineRasterizationStateCreateInfo</code></a>设定的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineRasterizationStateCreateInfo</span> &#123;</span><br>    VkStructureType                            sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                pNext;<br>    VkPipelineRasterizationStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    VkBool32                                   depthClampEnable;<br>    VkBool32                                   rasterizerDiscardEnable;<br>    VkPolygonMode                              polygonMode;<br>    VkCullModeFlags                            cullMode;<br>    VkFrontFace                                frontFace;<br>    VkBool32                                   depthBiasEnable;<br>    <span class="hljs-type">float</span>                                      depthBiasConstantFactor;<br>    <span class="hljs-type">float</span>                                      depthBiasClamp;<br>    <span class="hljs-type">float</span>                                      depthBiasSlopeFactor;<br>    <span class="hljs-type">float</span>                                      lineWidth;<br>&#125; VkPipelineRasterizationStateCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">depthClampEnable</font></i>指定深度值在<strong>[0.0,1.0]</strong>范围外的片段该如何处理，如果为<i><font color="Red">VK_TRUE</font></i>，那么相当于这些片段的深度值做clamp操作（这在阴影映射中有用，可以参考<a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">这篇文章</a>）；反之则简单地丢弃这些片段。启用该功能同样需要GPU特性<i><font color="Orange">VkPhysicalDeviceFeatures::depthClamp</font></i>为<i><font color="Red">VK_TRUE</font></i>。</p><p>接下来，如果<i><font color="Orange">rasterizerDiscardEnable</font></i>设置为<i><font color="Red">VK_TRUE</font></i>，那么意味着不会有任何几何形体通过光栅化阶段最终输出到帧缓冲上。为了得到渲染结果这个成员几乎总是设置为<i><font color="Red">VK_FALSE</font></i>。</p><p><i><font color="Orange">polygonMode</font></i>指定了多边形绘制模式，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPolygonMode.html"><code>VkPolygonMode</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkPolygonMode</span> &#123;</span><br>    VK_POLYGON_MODE_FILL = <span class="hljs-number">0</span>,<span class="hljs-comment">//以填充方式绘制多边形</span><br>    VK_POLYGON_MODE_LINE = <span class="hljs-number">1</span>,<span class="hljs-comment">//以线框方式绘制多边形</span><br>    VK_POLYGON_MODE_POINT = <span class="hljs-number">2</span>,<span class="hljs-comment">//以点模式绘制多边形</span><br>  <span class="hljs-comment">// Provided by VK_NV_fill_rectangle</span><br>    VK_POLYGON_MODE_FILL_RECTANGLE_NV = <span class="hljs-number">1000153000</span>,<span class="hljs-comment">//这是一个扩展的模式，专门用于填充矩形。这是由 VK_NV_fill_rectangle 扩展提供的，允许更高效地绘制矩形</span><br>&#125; VkPolygonMode;<br></code></pre></td></tr></table></figure><p>除了<i><font color="Red">VK_POLYGON_MODE_FILL</font></i>以外的模式都需要GPU具有相应的特性。</p><p><i><font color="Orange">lineWidth</font></i>成员指定多边形边界线宽度（以片段为单位）。一般来讲它设定为<strong>1.0</strong>，如果需要比这更宽的宽度则需要GPU具有特性<i><font color="Orange">wideLines</font></i>。</p><p>接下来的<i><font color="Orange">cullMode</font></i>和<i><font color="Orange">frontFace</font></i>指定了面剔除的方式。下面是它们可能的取值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkCullModeFlagBits</span> &#123;</span><br>    VK_CULL_MODE_NONE = <span class="hljs-number">0</span>,<br>    VK_CULL_MODE_FRONT_BIT = <span class="hljs-number">0x00000001</span>,<br>    VK_CULL_MODE_BACK_BIT = <span class="hljs-number">0x00000002</span>,<br>    VK_CULL_MODE_FRONT_AND_BACK = <span class="hljs-number">0x00000003</span>,<br>&#125; VkCullModeFlagBits;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkFrontFace</span> &#123;</span><br>    VK_FRONT_FACE_COUNTER_CLOCKWISE = <span class="hljs-number">0</span>,<br>    VK_FRONT_FACE_CLOCKWISE = <span class="hljs-number">1</span>,<br>&#125; VkFrontFace;<br></code></pre></td></tr></table></figure><p>这些枚举值的含义均易于理解，这里不再赘述。</p><p>最后的四个成员用于指定对深度值的一些操作，这些操作在阴影映射中有一定的运用，不过我们这里并不需要指定该功能。</p><p>最终，我们的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateCreateInfo.html"><code>VkPipelineRasterizationStateCreateInfo</code></a>结构体应该填写如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineRasterizationStateCreateInfo rasterizer&#123;&#125;;<br>rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;<br>rasterizer.depthClampEnable = VK_FALSE;<br>rasterizer.rasterizerDiscardEnable = VK_FALSE;<br>rasterizer.polygonMode = VK_POLYGON_MODE_FILL;<br>rasterizer.lineWidth = <span class="hljs-number">1.0f</span>;<br>rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;<br>rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;<br>rasterizer.depthBiasEnable = VK_FALSE;<br></code></pre></td></tr></table></figure><hr><h2 id="多重采样">多重采样</h2><p>对多重采样的指定通过填写 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineMultisampleStateCreateInfo.html"><code>VkPipelineMultisampleStateCreateInfo</code></a>来完成。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineMultisampleStateCreateInfo</span> &#123;</span><br>    VkStructureType                          sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                              pNext;<br>    VkPipelineMultisampleStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    VkSampleCountFlagBits                    rasterizationSamples;<br>    VkBool32                                 sampleShadingEnable;<br>    <span class="hljs-type">float</span>                                    minSampleShading;<br>    <span class="hljs-type">const</span> VkSampleMask*                      pSampleMask;<br>    VkBool32                                 alphaToCoverageEnable;<br>    VkBool32                                 alphaToOneEnable;<br>&#125; VkPipelineMultisampleStateCreateInfo;<br></code></pre></td></tr></table></figure><p>目前我们并不需要使用多重采样功能，所以只需禁用该功能即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineMultisampleStateCreateInfo multisampling&#123;&#125;;<br>multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;<br>multisampling.sampleShadingEnable = VK_FALSE;<br>multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;<br>multisampling.minSampleShading = <span class="hljs-number">1.0f</span>; <span class="hljs-comment">// Optional</span><br>multisampling.pSampleMask = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br>multisampling.alphaToCoverageEnable = VK_FALSE; <span class="hljs-comment">// Optional</span><br>multisampling.alphaToOneEnable = VK_FALSE; <span class="hljs-comment">// Optional</span><br></code></pre></td></tr></table></figure><p>多重采样是一种重要且高效的抗锯齿方式，它不需要像SSAA一样提高分辨率，而是只在边界上对一个像素的多个采样点运行多次片段着色器，最终对同一个像素中每个样本的颜色进行一个平均即可，可以大幅降低计算复杂度。关于MSAA原理的更详细的介绍可以阅读<a href="https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing">这篇文章</a>。</p><hr><h2 id="深度模板测试">深度模板测试</h2><p>由于我们目前希望渲染一个2D的三角形，这并不需要深度或者模板测试，因此我们暂时不需要填写相应的<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineDepthStencilStateCreateInfo.html"><code>VkPipelineDepthStencilStateCreateInfo</code></a>结构体，这部分会在之后开始绘制3维图像的时候介绍。</p><hr><h2 id="颜色混合阶段">颜色混合阶段</h2><p>在片段着色器计算出每个像素的颜色值之后，输出的颜色值需要和作为输出目标的帧缓冲中对应像素的颜色值进行混合。颜色混合有两种方式：</p><ul><li>直接混合两个颜色向量</li><li>对颜色值进行位运算</li></ul><p>设定颜色混合的信息结构体也有两个：<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>指定特定颜色附件的颜色混合设置，而<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendStateCreateInfo.html"><code>VkPipelineColorBlendStateCreateInfo</code></a>指定全局的颜色混合设置（适用于所有颜色附件）。它们的定义分别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineColorBlendAttachmentState</span> &#123;</span><br>    VkBool32                 blendEnable;<span class="hljs-comment">//如果为VK_FALSE，则着色器输出颜色直接覆盖帧缓冲对应像素上的颜色</span><br>    VkBlendFactor            srcColorBlendFactor;<br>    VkBlendFactor            dstColorBlendFactor;<br>    VkBlendOp                colorBlendOp;<br>    VkBlendFactor            srcAlphaBlendFactor;<br>    VkBlendFactor            dstAlphaBlendFactor;<br>    VkBlendOp                alphaBlendOp;<br>    VkColorComponentFlags    colorWriteMask;<span class="hljs-comment">//指定RGBA四通道分别是否可写</span><br>&#125; VkPipelineColorBlendAttachmentState;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">/ Provided by VK_VERSION_1_0<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineColorBlendStateCreateInfo</span> &#123;</span><br>    VkStructureType                               sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                   pNext;<br>    VkPipelineColorBlendStateCreateFlags          flags;<br>    VkBool32                                      logicOpEnable;<br>    VkLogicOp                                     logicOp;<br>    <span class="hljs-type">uint32_t</span>                                      attachmentCount;<br>    <span class="hljs-type">const</span> VkPipelineColorBlendAttachmentState*    pAttachments;<br>    <span class="hljs-type">float</span>                                         blendConstants[<span class="hljs-number">4</span>];<br>&#125; VkPipelineColorBlendStateCreateInfo;<br></code></pre></td></tr></table></figure><p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>允许我们指定每个颜色附件第一种混合方式的设置，该结构体除第一个成员和最后一个成员之外的所有成员均用于最后混合颜色的计算，计算的伪代码大致如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (blendEnable) &#123;<br>    finalColor.rgb = (srcColorBlendFactor * newColor.rgb) &lt;colorBlendOp&gt; (dstColorBlendFactor * oldColor.rgb);<br>    finalColor.a = (srcAlphaBlendFactor * newColor.a) &lt;alphaBlendOp&gt; (dstAlphaBlendFactor * oldColor.a);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    finalColor = newColor;<br>&#125;<br><br>finalColor = finalColor &amp; colorWriteMask;<br></code></pre></td></tr></table></figure><p>关于混合运算符<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBlendOp.html"><code>VkBlendOp</code></a>以及<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBlendFactor.html"><code>VkBlendFactor</code></a>，可以分别参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBlendOp.html"><code>这个页面</code></a>以及<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBlendFactor.html"><code>这个页面</code></a>，大多数的运算符以及运算因子的含义都是显而易见的，我们这里不再过多介绍。</p><p>接下来介绍一下全局设置结构体<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendStateCreateInfo.html"><code>VkPipelineColorBlendStateCreateInfo</code></a>。</p><p><i><font color="Orange">flags</font></i>是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendStateCreateFlagBits.html"><code>VkPipelineColorBlendStateCreateFlagBits</code></a>的位组合，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_rasterization_order_attachment_access</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkPipelineColorBlendStateCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_EXT_rasterization_order_attachment_access</span><br>    VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//指示颜色混合状态的创建将允许按照光栅化顺序访问附件。这意味着在处理多个颜色附件时，可以按照它们在渲染目标中的顺序进行访问，从而优化渲染性能。</span><br>  <span class="hljs-comment">// Provided by VK_ARM_rasterization_order_attachment_access</span><br>    VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM = VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT,<br>&#125; VkPipelineColorBlendStateCreateFlagBits;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">logicOpEnable</font></i>指定是否使用第二种方式混合颜色。这个成员设置为<i><font color="Red">VK_TRUE</font></i>的效果和所有颜色附件的<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>结构体中<i><font color="Orange">blendEnable</font></i>设置为<i><font color="Red">VK_FALSE</font></i>的效果是一样的，也就是说第一种颜色混合方式将被禁用。</p><p>逻辑运算符我们在这里也不过多介绍，可以参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkLogicOp.html">这个页面</a>。</p><p>下面的<i><font color="Orange">attachmentCount</font></i>和<i><font color="Orange">pAttachments</font></i>指定所有填写好的的颜色附件混合模式结构体<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>。最后的<i><font color="Orange">blendConstants</font></i>数组指定了<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>中指定的混合因子的具体值（<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>中指定的是一个抽象的混合因子，这个因子具体的值由<i><font color="Orange">blendConstants</font></i>数组指定）。</p><p>对于我们绘制三角形的程序，我们只有一个颜色附件，也不需要有特殊的混合操作，因此我们只需如下设置即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineColorBlendAttachmentState colorBlendAttachment&#123;&#125;;<br>colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;<br>colorBlendAttachment.blendEnable = VK_FALSE;<br>colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; <span class="hljs-comment">// Optional</span><br><br>VkPipelineColorBlendStateCreateInfo colorBlending&#123;&#125;;<br>colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;<br>colorBlending.logicOpEnable = VK_FALSE;<br>colorBlending.logicOp = VK_LOGIC_OP_COPY; <span class="hljs-comment">// Optional</span><br>colorBlending.attachmentCount = <span class="hljs-number">1</span>;<br>colorBlending.pAttachments = &amp;colorBlendAttachment;<br>colorBlending.blendConstants[<span class="hljs-number">0</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span><br>colorBlending.blendConstants[<span class="hljs-number">1</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span><br>colorBlending.blendConstants[<span class="hljs-number">2</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span><br>colorBlending.blendConstants[<span class="hljs-number">3</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span><br></code></pre></td></tr></table></figure><hr><h2 id="管线布局">管线布局</h2><p>在程序运行过程中我们往往需要动态地向着色器传入某些值，比如说uniform变量。尽管我们现在并不需要这么做，我们仍然需要创建一个空的<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineLayout.html"><code>VkPipelineLayout</code></a>来指定这些值。</p><p>在类内创建一个<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineLayout.html"><code>VkPipelineLayout</code></a>类型的成员<i><font color="Orange">pipelineLayout</font></i>，然后在<i><font color="Green">createGraphicsPipeline</font></i>函数中构建这个对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineLayoutCreateInfo pipelineLayoutInfo&#123;&#125;;<br>pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;<br>pipelineLayoutInfo.setLayoutCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>pipelineLayoutInfo.pSetLayouts = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br>pipelineLayoutInfo.pushConstantRangeCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>pipelineLayoutInfo.pPushConstantRanges = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreatePipelineLayout</span>(device, &amp;pipelineLayoutInfo, <span class="hljs-literal">nullptr</span>, &amp;pipelineLayout) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create pipeline layout!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineLayoutCreateInfo.html"><code>VkPipelineLayoutCreateInfo</code></a>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineLayoutCreateInfo</span> &#123;</span><br>    VkStructureType                 sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                     pNext;<br>    VkPipelineLayoutCreateFlags     flags;<br>    <span class="hljs-type">uint32_t</span>                        setLayoutCount;<br>    <span class="hljs-type">const</span> VkDescriptorSetLayout*    pSetLayouts;<br>    <span class="hljs-type">uint32_t</span>                        pushConstantRangeCount;<br>    <span class="hljs-type">const</span> VkPushConstantRange*      pPushConstantRanges;<br>&#125; VkPipelineLayoutCreateInfo;<br></code></pre></td></tr></table></figure><p>注意这个结构体可以指定两种传递给着色器的变量：<strong>uniformvalues</strong>和<strong>push constants</strong>。<strong>pushconstants</strong>实际上就是比较小型的数据块，它们直接嵌入到指令流中，因此在性能上优于使用缓冲区对象。不过它们的大小受到限制，一般为128字节。</p><p>大功告成！我们终于完成了所有固定管线阶段信息的填写。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/">上一篇：着色器模块</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/">下一篇：渲染通道</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>渲染管线简介</title>
    <link href="/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/"/>
    <url>/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>本节主要简单介绍一下渲染管线的各个阶段及其所做的工作，本节对应VulkanTutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Introduction">Graphicspipeline basics/Introduction</a>章节。</p><hr><h2 id="流程梳理">流程梳理</h2><p>下图给出了渲染管线的基本流程：</p><figure><img src="/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/pipeline.png" alt="渲染管线"><figcaption aria-hidden="true">渲染管线</figcaption></figure><ul><li><p>输入汇编器（inputassembler）阶段收集用户在缓冲区中指定的定点信息和顶点索引信息。</p></li><li><p>顶点着色器（vertexshader）阶段对各个顶点进行坐标变换并且向后传递逐顶点信息。</p></li><li><p>曲面细分（tessellation）阶段允许用户进一步细分几何以增加面片质量和精细度。</p></li><li><p>几何着色器（geometryshader）阶段作用于每个基本图元，增加或丢弃部分图元。</p></li><li><p>光栅化（rasterization）阶段将图元打散成片段并且丢弃在屏幕外面的那些片段。</p></li><li><p>片段着色器（fragmentshader）阶段决定每个片段的输出位置以及它们各自的输出结果。</p></li><li><p>颜色混合（colorblending）阶段采用指定的方式混合对应于同一像素的不同片段的值。</p></li></ul><p>图中绿色的阶段代表该阶段不可编程，也就是说我们只能设置与该阶段运作有关的一些参数，但不能自己编写该阶段的运行逻辑；而橙色阶段代表该阶段可编程，也就是说我们可以自己书写代码来指定该阶段的工作流程。</p><p>Vulkan中的渲染管线不同于OpenGL，绝大多数情况下我们不能在运行时改变管线的设置，一旦发生变化，我们一般会需要重新建立一个管线，这么做的好处是由于对管线的操作是提前预知且固定的，硬件就可以对管线进行一些优化。</p><p>接下来的章节，我们将建立一个<i><font color="Green">voidcreateGraphicsPipeline()</font></i>成员函数来建立起一个基本的渲染管线。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/">上一篇：图像视图</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/">下一篇：着色器模块</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>着色器模块</title>
    <link href="/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/"/>
    <url>/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>这一章节我们将完成渲染管线中可编程阶段的构建。目前我们只简单地考虑构建顶点着色器和片段着色器阶段。</p><p>与之前的图形API不同，Vulkan使用的着色器代码需要是<a href="https://www.khronos.org/spir">SPIR-V</a>格式的，它的优点是相比于易于我们阅读的GLSL和HLSL代码，<a href="https://www.khronos.org/spir">SPIR-V</a>代码更容易被转化为GPU使用的机器码，并且GLSL和HLSL代码可能会因为GPU产商所设定的不同标准产生在不同机器上的不兼容现象，<a href="https://www.khronos.org/spir">SPIR-V</a>代码就不会出现这种问题。</p><p>不过幸运的是，我们并不需要自己手写<a href="https://www.khronos.org/spir">SPIR-V</a>代码，这里我们将使用VulkanSDK自带的glslc.exe来将GLSL代码编译为<a href="https://www.khronos.org/spir">SPIR-V</a>代码。</p><p>创建着色器模块主要分为四步：</p><ul><li>编写着色器代码</li><li>将着色器文件编译为<a href="https://www.khronos.org/spir">SPIR-V</a>代码</li><li>加载着色器文件到程序中并包裹在<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html"><code>VkShaderModule</code></a>对象中</li><li>填写渲染管线着色器阶段信息</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules">Shadermodules</a>章节。</p><hr><h2 id="编写着色器代码">编写着色器代码</h2><p>假设读者已经对GLSL基本语法比较熟悉了。由于我们的第一个应用程序只需要简单地绘制一个三角形，所以顶点着色器代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-type">vec2</span> positions[<span class="hljs-number">3</span>] = <span class="hljs-type">vec2</span>[](<br>    <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">-0.5</span>),<br>    <span class="hljs-type">vec2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>),<br>    <span class="hljs-type">vec2</span>(<span class="hljs-number">-0.5</span>, <span class="hljs-number">0.5</span>)<br>);<br><br><span class="hljs-type">vec3</span> colors[<span class="hljs-number">3</span>] = <span class="hljs-type">vec3</span>[](<br>    <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>),<br>    <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>),<br>    <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>)<br>);<br><br><span class="hljs-type">void</span> main() &#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(positions[gl_VertexIndex], <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fragColor = colors[gl_VertexIndex];<br>&#125;<br></code></pre></td></tr></table></figure><p>目前我们还没有介绍顶点缓冲，因此我们暂时将顶点数据硬编码在着色器文件中。另外，每个顶点我们都赋予不同的颜色，以便在后续光栅化阶段插值该颜色以形成渐变色的效果。</p><p>注意，<i><font color="Orange">gl_VertexIndex</font></i>代表的是当前处理的顶点对应的索引，这是一个glsl内建变量。</p><p>片段着色器代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outColor;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> fragColor;<br><br><span class="hljs-type">void</span> main() &#123;<br>    outColor = <span class="hljs-type">vec4</span>(fragColor, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>片段着色器的输入数据并不需要和顶点着色器中对应的输出数据名称一致，但是需要指定它们的location一致，这样才能将对应的输出输入链接到一起。</p><hr><h2 id="编译为spir-v代码">编译为SPIR-V代码</h2><p>windows下编译为<a href="https://www.khronos.org/spir">SPIR-V</a>代码很简单，我们可以将上面的两个文件（分别命名为<font color="Purple">shader.vert</font>，<font color="Purple">shader,frag</font>）保存在项目根目录下的一个文件夹<font color="Purple">shaders</font>中，然后在该文件下创建一个批处理文件<font color="Purple">compile.bat</font>：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bat"><span class="hljs-built_in">path</span>/to/glslc.exe shader.vert -o vert.spv<br><span class="hljs-built_in">path</span>/to/glslc.exe shader.frag -o frag.spv<br><span class="hljs-built_in">pause</span><br></code></pre></td></tr></table></figure><p>将<i><font color="Orange">path/to/glslc.exe</font></i>替换为自己电脑上对应的glslc.exe文件路径即可。</p><p>双击bat文件运行即可在同一文件夹下创建对应的<a href="https://www.khronos.org/spir">SPIR-V</a>文件。</p><p>当然，这只是创建<a href="https://www.khronos.org/spir">SPIR-V</a>文件的一种方式，VulkanSDK还提供了<a href="https://github.com/google/shaderc">libshaderc</a>，它允许我们在程序代码中将glsl文件编译为<a href="https://www.khronos.org/spir">SPIR-V</a>文件。</p><hr><h2 id="创建vkshadermodule">创建VkShaderModule</h2><p>接下来我们需要将编译好的<a href="https://www.khronos.org/spir">SPIR-V</a>文件加载到程序中来。创建一个静态函数<i><font color="Green">staticstd::vector<char> readFile(const std::string&amp;filename)</char></font></i>来完成这个工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> std::vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">readFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename)</span> </span>&#123;<br>    <span class="hljs-function">std::ifstream <span class="hljs-title">file</span><span class="hljs-params">(filename, std::ios::ate | std::ios::binary)</span></span>;<br><span class="hljs-comment">//ate代表指针定位到文件末尾，这样可以通过tellg知道文件的大小；binary代表以二进制文件格式读取文件</span><br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">is_open</span>()) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to open file!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-type">size_t</span> fileSize = (<span class="hljs-type">size_t</span>) file.<span class="hljs-built_in">tellg</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(fileSize)</span></span>;<br>    <br>    file.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//定位到文件头，准备开始读取文件</span><br>    file.<span class="hljs-built_in">read</span>(buffer.<span class="hljs-built_in">data</span>(), fileSize);<br>    <br>    file.<span class="hljs-built_in">close</span>();<br><br><span class="hljs-keyword">return</span> buffer;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，在<i><font color="Green">crearteGraphicsPipeline</font></i>函数中，我们就可以使用这个函数来读取我们写好的顶点着色器和片段着色器文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createGraphicsPipeline</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> vertShaderCode = <span class="hljs-built_in">readFile</span>(<span class="hljs-string">&quot;shaders/vert.spv&quot;</span>);<br>    <span class="hljs-keyword">auto</span> fragShaderCode = <span class="hljs-built_in">readFile</span>(<span class="hljs-string">&quot;shaders/frag.spv&quot;</span>);<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>读取文件之后，我们需要使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html"><code>VkShaderModule</code></a>包裹住这个文件内容才能使用，因此我们创建一个<i><font color="Green">VkShaderModulecreateShaderModule(const std::vector<char>&amp;code)</char></font></i>来完成这项工作。</p><p>为了创建[<code>VkShaderModule</code><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html">id0</a>对象，我们当然也需要填写相关的信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModuleCreateInfo.html"><code>VkShaderModuleCreateInfo</code></a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkShaderModuleCreateInfo</span> &#123;</span><br>    VkStructureType              sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                  pNext;<br>    VkShaderModuleCreateFlags    flags;   <span class="hljs-comment">//目前还没有</span><br>    <span class="hljs-type">size_t</span>                       codeSize;<span class="hljs-comment">//文件大小</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*              pCode;  <span class="hljs-comment">//文件内容</span><br>&#125; VkShaderModuleCreateInfo;<br></code></pre></td></tr></table></figure><p>这里需要注意的是，我们传给<i><font color="Green">createShaderModule</font></i>的参数为字符向量，但是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModuleCreateInfo.html"><code>VkShaderModuleCreateInfo</code></a>需要的参数<i><font color="Orange">pCode</font></i>是字节码，也就是一个指向<i><font color="Orange">uint32_t</font></i>的指针，因此我们需要如下编写代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkShaderModule <span class="hljs-title">createShaderModule</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">char</span>&gt;&amp; code)</span> </span>&#123;<br>VkShaderModuleCreateInfo createInfo&#123;&#125;;<br>createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;<br>createInfo.codeSize = code.<span class="hljs-built_in">size</span>();<br>createInfo.pCode = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*&gt;(code.<span class="hljs-built_in">data</span>());<br>    <br>    VkShaderModule shaderModule;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateShaderModule</span>(device, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;shaderModule) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create shader module!&quot;</span>);<br>&#125;<br>    <br>    <span class="hljs-keyword">return</span> shaderModule;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以使用这个函数在<i><font color="Green">crearteGraphicsPipeline</font></i>函数中构建着色器文件相应的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html"><code>VkShaderModule</code></a>对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createGraphicsPipeline</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> vertShaderCode = <span class="hljs-built_in">readFile</span>(<span class="hljs-string">&quot;shaders/vert.spv&quot;</span>);<br>    <span class="hljs-keyword">auto</span> fragShaderCode = <span class="hljs-built_in">readFile</span>(<span class="hljs-string">&quot;shaders/frag.spv&quot;</span>);<br><br>    VkShaderModule vertShaderModule = <span class="hljs-built_in">createShaderModule</span>(vertShaderCode);<br>    VkShaderModule fragShaderModule = <span class="hljs-built_in">createShaderModule</span>(fragShaderCode);<br>    <span class="hljs-comment">//...</span><br>    <br>    <span class="hljs-built_in">vkDestroyShaderModule</span>(device, fragShaderModule, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">vkDestroyShaderModule</span>(device, vertShaderModule, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，在使用完着色器模块后要使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyShaderModule.html"><code>vkDestroyShaderModule</code></a>清理掉相应对象。注意，这里我们并没有将着色器模块保存为类的成员，因为着色器模块在渲染管线构建完成之后会被GPU编译链接为真正执行用的机器码，此后着色器模块对象就不再需要了，因此我们可以在<i><font color="Green">crearteGraphicsPipeline</font></i>函数最后将其销毁掉，没有保存的必要。</p><hr><h2 id="填写着色器阶段信息">填写着色器阶段信息</h2><p>创建好着色器模块后，我们需要将这个模块插入到渲染管线对应的着色器阶段中。为此我们需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateInfo.html"><code>VkPipelineShaderStageCreateInfo</code></a>以供后续创建渲染管线对象时使用。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateInfo.html"><code>VkPipelineShaderStageCreateInfo</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineShaderStageCreateInfo</span> &#123;</span><br>    VkStructureType                     sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                         pNext;<br>    VkPipelineShaderStageCreateFlags    flags;<br>    VkShaderStageFlagBits               stage;<br>    VkShaderModule                      module;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                         pName;              <span class="hljs-comment">//着色器入口函数名称</span><br>    <span class="hljs-type">const</span> VkSpecializationInfo*         pSpecializationInfo;<span class="hljs-comment">//特化常量信息</span><br>&#125; VkPipelineShaderStageCreateInfo;<br></code></pre></td></tr></table></figure><p><a href="https://zpc-dsg.github.io/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/"><code>VkPipelineShaderStageCreateFlags</code></a>是<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E5%87%BD%E6%95%B0/"><code>VkPipelineShaderStageCreateFlagBits</code></a>的位组合，后者定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkPipelineShaderStageCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//允许在该着色器阶段使用可变大小的子组（subgroup）。这意味着在执行过程中，子组的大小可以变化，从而提供更大的灵活性，适用于某些计算任务。</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//要求该着色器阶段使用完整的子组。即所有子组的大小必须是指定的最大子组大小，这通常用于保证性能和一致性，确保所有线程在子组内都能得到相同的执行路径。</span><br>  <span class="hljs-comment">// Provided by VK_EXT_subgroup_size_control</span><br>    VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT,<br>  <span class="hljs-comment">// Provided by VK_EXT_subgroup_size_control</span><br>    VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT,<br>&#125; VkPipelineShaderStageCreateFlagBits;<br></code></pre></td></tr></table></figure><p>首先需要解释的是<i><font color="Orange">pName</font></i>成员，该形参指定着色器代码的入口点。一般来讲我们的glsl着色器代码入口点为<i><font color="Green">main</font></i>函数，但是Vulkan允许我们指定其它函数名作为入口函数，这也意味着我们可以在一个着色器模块中绑定多个具有不同入口名的着色器文件。</p><p>另外，<i><font color="Orange">pSpecializationInfo</font></i>指定的是需要传给着色器的特化常量的信息。特化常量是在着色器编译时指定的常量值。它们在着色器代码中声明为特化常量，并在编译时被替换为具体的值。这使得可以在不同的管线实例中使用不同的常量值，提高了性能，因为编译器能够针对这些常量进行优化。在GLSL 中，特化常量通常使用 <code>const</code> 关键字来声明，但在 Vulkan中，需要使用特化常量的机制来定义和传递这些值。特化常量与C中的预编译命令<code>#define</code>类似，不过特化常量是有类型的，编译器能够进行类型检查，并且特化常量的作用域通常局限于声明它们的着色器阶段，因此相比来讲特化常量具有类型安全和更好的作用域控制。</p><p>现在我们在<i><font color="Green">crearteGraphicsPipeline</font></i>函数中填写顶点着色器和片段着色器对应的着色器阶段信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineShaderStageCreateInfo vertShaderStageInfo&#123;&#125;;<br>vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;<br>vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;<br>vertShaderStageInfo.<span class="hljs-keyword">module</span> = vertShaderModule;<br>vertShaderStageInfo.pName = <span class="hljs-string">&quot;main&quot;</span>;<br><br>VkPipelineShaderStageCreateInfo fragShaderStageInfo&#123;&#125;;<br>fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;<br>fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;<br>fragShaderStageInfo.<span class="hljs-keyword">module</span> = fragShaderModule;<br>fragShaderStageInfo.pName = <span class="hljs-string">&quot;main&quot;</span>;<br><br>VkPipelineShaderStageCreateInfo shaderStages[] = &#123;vertShaderStageInfo, fragShaderStageInfo&#125;;<br></code></pre></td></tr></table></figure><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/">上一篇：渲染管线简介</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E5%87%BD%E6%95%B0/">下一篇：固定管线</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图像视图</title>
    <link href="/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/"/>
    <url>/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>为了使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImage.html"><code>VkImage</code></a>，我们需要相应的视图<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageView.html"><code>VkImageView</code></a>。图像视图的作用是描述图像应该如何被使用以及图像的哪部分可以被使用。接下来我们将创建一个<i><font color="Green">voidcreateImageViews()</font></i>函数来创建所有的图像视图。创建图像视图的过程比较简单，主要分为两步：</p><ul><li>填写创建信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateInfo.html"><code>VkImageViewCreateInfo</code></a></li><li>创建图像视图对象</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Image_views">Imageviews</a>章节。</p><hr><h2 id="填写创建信息">填写创建信息</h2><p>由于对于每张图像我们都需要有对应的视图，因此我们在<i><font color="Green">createImageViews</font></i>函数中创建一个循环来填写每个视图的信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createImageViews</span><span class="hljs-params">()</span> </span>&#123;<br>    swapChainImageViews.<span class="hljs-built_in">resize</span>(swapChainImages.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainImages.<span class="hljs-built_in">size</span>(); i++) &#123;<br>VkImageViewCreateInfo createInfo&#123;&#125;;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateInfo.html"><code>VkImageViewCreateInfo</code></a>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkImageViewCreateInfo</span> &#123;</span><br>    VkStructureType            sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                pNext;<br>    VkImageViewCreateFlags     flags;<br>    VkImage                    image;<br>    VkImageViewType            viewType;<br>    VkFormat                   format;<br>    VkComponentMapping         components;<br>    VkImageSubresourceRange    subresourceRange;<br>&#125; VkImageViewCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateFlagBits.html"><code>VkImageViewCreateFlagBits</code></a>的位组合，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateFlagBits.html"><code>VkImageViewCreateFlagBits</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkImageViewCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_EXT_fragment_density_map</span><br>    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//此标志指示图像视图将用于动态片段密度映射（fragment density map）。动态片段密度映射允许在运行时调整每个像素的片段密度，以优化渲染性能和资源使用。</span><br>  <span class="hljs-comment">// Provided by VK_EXT_descriptor_buffer</span><br>    VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//表示图像视图将用于延迟片段密度映射。这种方式允许在后续渲染阶段处理片段密度，而不是在每个绘制调用中立即处理，从而提高效率。</span><br>  <span class="hljs-comment">// Provided by VK_EXT_fragment_density_map2</span><br>    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//此标志用于描述符缓冲区的捕获和重放。它指示图像视图可以在捕获和重放的上下文中使用，这对于调试和性能分析工具非常有用。</span><br>&#125; VkImageViewCreateFlagBits;<br></code></pre></td></tr></table></figure><p>我们在这里不指定任何标志。</p><p>接下来需要解释的是<i><font color="Orange">viewType</font></i>，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewType.html"><code>VkImageViewType</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkImageViewType</span> &#123;</span><br>    VK_IMAGE_VIEW_TYPE_1D = <span class="hljs-number">0</span>,<br>    VK_IMAGE_VIEW_TYPE_2D = <span class="hljs-number">1</span>,<br>    VK_IMAGE_VIEW_TYPE_3D = <span class="hljs-number">2</span>,<br>    VK_IMAGE_VIEW_TYPE_CUBE = <span class="hljs-number">3</span>,<br>    VK_IMAGE_VIEW_TYPE_1D_ARRAY = <span class="hljs-number">4</span>,<br>    VK_IMAGE_VIEW_TYPE_2D_ARRAY = <span class="hljs-number">5</span>,<br>    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = <span class="hljs-number">6</span>,<br>&#125; VkImageViewType;<br></code></pre></td></tr></table></figure><p>显然作为颜色缓冲的图像类型应该被指定为<i><font color="Red">VK_IMAGE_VIEW_TYPE_2D</font></i>。</p><p>之后的<i><font color="Orange">format</font></i>也应当和该视图对应的图像一致，因此我们将上一章保存在应用程序类内的成员<i><font color="Orange">swapChainImageFormat</font></i>为其赋值。</p><p><i><font color="Orange">components</font></i>指定了图像颜色通道的再映射。我们这里不需要任何特殊的映射，因此我们只需简单地指定映射为恒等变换即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;<br>createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;<br>createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;<br>createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;<br></code></pre></td></tr></table></figure><p>最后，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceRange.html"><code>VkImageSubresourceRange</code></a>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkImageSubresourceRange</span> &#123;</span><br>    VkImageAspectFlags    aspectMask;    <span class="hljs-comment">//图像的方面，即图像数据的不同特性或组成部分</span><br>    <span class="hljs-type">uint32_t</span>              baseMipLevel;  <span class="hljs-comment">//基础多级渐远级别</span><br>    <span class="hljs-type">uint32_t</span>              levelCount; <span class="hljs-comment">//多级渐远级数</span><br>    <span class="hljs-type">uint32_t</span>              baseArrayLayer;<span class="hljs-comment">//基础图像层</span><br>    <span class="hljs-type">uint32_t</span>              layerCount; <span class="hljs-comment">//图像层数目</span><br>&#125; VkImageSubresourceRange;<br></code></pre></td></tr></table></figure><p>我们希望交换链中的图像用作颜色缓冲，因此<i><font color="Orange">subresourceRange.aspectMask</font></i>应该指定为<i><font color="Red">VK_IMAGE_ASPECT_COLOR_BIT</font></i>。颜色缓冲不需要生成多级渐远纹理，因此<i><font color="Orange">subresourceRange.baseMipLevel</font></i>设为0，<i><font color="Orange">subresourceRange.levelCount</font></i>设为1。由于我们并非创建一个3D项目，因此并不需要多图像层，因此<i><font color="Orange">subresourceRange.baseArrayLayer</font></i>设为0，<i><font color="Orange">subresourceRange.layerCount</font></i>设为1即可。</p><p>这样我们就完成了信息的填写。</p><hr><h2 id="创建视图">创建视图</h2><p>创建过程一如以往：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateImageView</span>(device, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;swapChainImageViews[i]) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create image views!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，即使创建好了图像视图，也不意味着图像已经可以作为渲染目标使用了，我们还需要创建帧缓冲对象来存储图像视图才能进行渲染，后续章节会介绍这一部分内容。</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/">上一篇：交换链</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/">下一篇：渲染管线简介</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>交换链</title>
    <link href="/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/"/>
    <url>/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>Vulkan中并没有所谓的“默认帧缓冲”的概念，所以我们需要一个能够储存渲染后图像以便之后显示到屏幕上的设施，这个设施就是交换链（swapChain）。交换链本质上就是一列图像，我们的应用程序会不断获取其中的一张，显示到屏幕上，然后归还给交换链。</p><p>创建一个交换链主要分为三步：</p><ul><li>查询显卡是否支持交换链并启用相应拓展</li><li>填写创建交换链所需的必要信息</li><li>创建交换链并保存有关对象为类成员</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain#page_Surface-format">Swapchain</a>章节。</p><hr><h2 id="查询支持">查询支持</h2><p>查询硬件是否支持交换链可以分为两步：查询交换链是否可用，以及查询交换链是否完整地具有所需的功能。</p><h4 id="查询交换链可用性">查询交换链可用性</h4><p>首先来查询物理设备是否支持交换链。事实上，如果一个物理设备支持显示队列的话，那么它一定支持交换链拓展。不过，在Vulkan中清晰地展示出一切细节总不是件坏事。所以这里我们还是选择查询一下设备对交换链的支持。</p><p>交换链支持拓展名为<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_swapchain.html"><code>VK_KHR_swapchain</code></a>，它是一个设备层面的拓展。于是我们在类外创建一个全局变量保存我们可能需要的所有设备层面的拓展名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; deviceExtensions = &#123;<br>    VK_KHR_SWAPCHAIN_EXTENSION_NAME<span class="hljs-comment">//字符串&quot;VK_KHR_swapchain&quot;对应的宏，用它避免拼写错误</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>下面，我们需要查询物理设备是否支持这个拓展。于是添加一个<i><font color="Green">checkDeviceExtensionSupport</font></i>函数来统一处理设备层面拓展的支持查询：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkDeviceExtensionSupport</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> extensionCount;<br>    <span class="hljs-built_in">vkEnumerateDeviceExtensionProperties</span>(device, <span class="hljs-literal">nullptr</span>, &amp;extensionCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkExtensionProperties&gt; <span class="hljs-title">availableExtensions</span><span class="hljs-params">(extensionCount)</span></span>;<br>    <span class="hljs-built_in">vkEnumerateDeviceExtensionProperties</span>(device, <span class="hljs-literal">nullptr</span>, &amp;extensionCount, availableExtensions.<span class="hljs-built_in">data</span>());<br><br>    <span class="hljs-function">std::set&lt;std::string&gt; <span class="hljs-title">requiredExtensions</span><span class="hljs-params">(deviceExtensions.begin(), deviceExtensions.end())</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; extension : availableExtensions) &#123;<br>        requiredExtensions.<span class="hljs-built_in">erase</span>(extension.extensionName);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> requiredExtensions.<span class="hljs-built_in">empty</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是易于理解的。</p><p>接下来我们要做的就是在<i><font color="Green">isDeviceSuitable</font></i>函数中使用<i><font color="Green">checkDeviceExtensionSupport</font></i>检查给定的物理设备是否支持指定的拓展：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(device);<br><br>    <span class="hljs-type">bool</span> extensionsSupported = <span class="hljs-built_in">checkDeviceExtensionSupport</span>(device);<br><br>    <span class="hljs-keyword">return</span> indices.<span class="hljs-built_in">isComplete</span>() &amp;&amp; extensionsSupported;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，如果选择的物理设备支持交换链拓展，那么我们需要启用这个拓展。启用拓展只需略微修改逻辑设备的createInfo，将原来的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.enabledExtensionCount = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>改为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.enabledExtensionCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(deviceExtensions.<span class="hljs-built_in">size</span>());<br>createInfo.ppEnabledExtensionNames = deviceExtensions.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>即可。</p><h4 id="查询交换链完整性">查询交换链完整性</h4><p>仅仅查询交换链是否可用是不够的，我们还需要知道选定的支持交换链的物理设备是否具有所需的和显示有关的表面功能特性。我们需要查询的主要细节有三点：</p><ul><li>基本表面属性，包括交换链可以具有的最少/最多图像数目，图像的最小/最大尺寸等</li><li>表面格式，具体而言指的是像素格式和颜色空间</li><li>可用显示模式</li></ul><p>于是建立一个结构体<i><font color="Orange">SwapChainSupportDetails</font></i>来保存这些查询结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SwapChainSupportDetails</span> &#123;<br>    VkSurfaceCapabilitiesKHR capabilities;<br>    std::vector&lt;VkSurfaceFormatKHR&gt; formats;<br>    std::vector&lt;VkPresentModeKHR&gt; presentModes;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在类内建立一个成员函数<i><font color="Green">SwapChainSupportDetailsquerySwapChainSupport(VkPhysicalDevicedevice)</font></i>来负责具体的查询：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SwapChainSupportDetails <span class="hljs-title">querySwapChainSupport</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    SwapChainSupportDetails details;<br><br>    <span class="hljs-built_in">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</span>(device, surface, &amp;details.capabilities);<br>    <br>    <span class="hljs-type">uint32_t</span> formatCount;<br><span class="hljs-built_in">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(device, surface, &amp;formatCount, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-keyword">if</span> (formatCount != <span class="hljs-number">0</span>) &#123;<br>    details.formats.<span class="hljs-built_in">resize</span>(formatCount);<br>    <span class="hljs-built_in">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(device, surface, &amp;formatCount, details.formats.<span class="hljs-built_in">data</span>());<br>&#125;<br>    <br>    <span class="hljs-type">uint32_t</span> presentModeCount;<br><span class="hljs-built_in">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(device, surface, &amp;presentModeCount, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-keyword">if</span> (presentModeCount != <span class="hljs-number">0</span>) &#123;<br>    details.presentModes.<span class="hljs-built_in">resize</span>(presentModeCount);<br>    <span class="hljs-built_in">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(device, surface, &amp;presentModeCount, details.presentModes.<span class="hljs-built_in">data</span>());<br>&#125;<br>    <span class="hljs-keyword">return</span> details;<br>&#125;<br></code></pre></td></tr></table></figure><p>查询过程就是单纯地依次填充每个结构体成员。在这里我们只是简单地要求表面格式和显示模式均至少要有一种，这样就认为该物理设备的交换链是完整可用的。</p><p>现在我们需要再次修改一下<i><font color="Green">isDeviceSuitable</font></i>函数以添加检查交换链完整性的逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(device);<br><br>    <span class="hljs-type">bool</span> extensionsSupported = <span class="hljs-built_in">checkDeviceExtensionSupport</span>(device);<br><br>    <span class="hljs-type">bool</span> swapChainAdequate = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (extensionsSupported) &#123;<br>        SwapChainSupportDetails swapChainSupport = <span class="hljs-built_in">querySwapChainSupport</span>(device);<br>        swapChainAdequate = !swapChainSupport.formats.<span class="hljs-built_in">empty</span>() &amp;&amp; !swapChainSupport.presentModes.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> indices.<span class="hljs-built_in">isComplete</span>() &amp;&amp; extensionsSupported &amp;&amp; swapChainAdequate;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="填写创建信息">填写创建信息</h2><p>下面我们创建一个<i><font color="Green">voidcreateSwapChain()</font></i>函数来创建交换链。首先我们需要查询交换链有关的表面信息以方便后续交换链创建信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>的填写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createSwapChain</span><span class="hljs-params">()</span> </span>&#123;<br>    SwapChainSupportDetails swapChainSupport = <span class="hljs-built_in">querySwapChainSupport</span>(physicalDevice);<br><br>    VkSwapchainCreateInfoKHR createInfo&#123;&#125;;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>交换链创建信息需要指定的信息量相较于之前创建的对象要多得多，我们逐个填写。</p><p>首先总览一下交换链创建信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSwapchainCreateInfoKHR</span> &#123;</span><br>    VkStructureType                  sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                      pNext;<br>    VkSwapchainCreateFlagsKHR        flags;<br>    VkSurfaceKHR                     surface; <span class="hljs-comment">//对应的表面</span><br>    <span class="hljs-type">uint32_t</span>                         minImageCount;<br>    VkFormat                         imageFormat;<br>    VkColorSpaceKHR                  imageColorSpace;<br>    VkExtent2D                       imageExtent;<br>    <span class="hljs-type">uint32_t</span>                         imageArrayLayers;<br>    VkImageUsageFlags                imageUsage;<br>    VkSharingMode                    imageSharingMode;<br>    <span class="hljs-type">uint32_t</span>                         queueFamilyIndexCount;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*                  pQueueFamilyIndices;<br>    VkSurfaceTransformFlagBitsKHR    preTransform;<br>    VkCompositeAlphaFlagBitsKHR      compositeAlpha;<br>    VkPresentModeKHR                 presentMode;<br>    VkBool32                         clipped;<br>    VkSwapchainKHR                   oldSwapchain;<br>&#125; VkSwapchainCreateInfoKHR;<br></code></pre></td></tr></table></figure><p>首先看第三个成员<i><font color="Orange">flags</font></i>，它是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateFlagBitsKHR.html"><code>VkSwapchainCreateFlagBitsKHR</code></a>的位组合。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateFlagBitsKHR.html"><code>VkSwapchainCreateFlagBitsKHR</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkSwapchainCreateFlagBitsKHR</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1 with VK_KHR_swapchain, VK_KHR_device_group with VK_KHR_swapchain</span><br>    VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//表示交换链的图像可以在不同的实例中进行绑定，这对于多实例的设备组（Device Group）非常有用。它允许在不同的设备实例之间共享交换链图像</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1 with VK_KHR_swapchain</span><br>    VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//指定交换链中的图像是受保护的。这意味着这些图像的内容在某些情况下（例如，受保护的内容播放）不会被访问或修改。这个标志通常用于需要内容保护的应用程序，如播放受版权保护的媒体</span><br>  <span class="hljs-comment">// Provided by VK_KHR_swapchain_mutable_format</span><br>    VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//允许交换链的格式在创建后进行更改。这对于需要动态调整图像格式的应用程序非常有用，比如在不同的显示设备上使用不同的格式</span><br>  <span class="hljs-comment">// Provided by VK_EXT_swapchain_maintenance1</span><br>    VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//指示交换链的图像内存分配可以延迟到实际使用时。这有助于优化内存使用，特别是在不确定图像会被使用的情况下</span><br>&#125; VkSwapchainCreateFlagBitsKHR;<br></code></pre></td></tr></table></figure><p>我们这里不需要设置任何标志位;</p><p>接下来要填写<i><font color="Orange">minImageCount</font></i>成员。这可以通过查询我们之前自定义的结构体<i><font color="Orange">SwapChainSupportDetails</font></i>的成员<i><font color="Orange">capabilities</font></i>的<i><font color="Orange">minImageCount</font></i>和<i><font color="Orange">maxImageCount</font></i>成员来决定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> imageCount = swapChainSupport.capabilities.minImageCount + <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span> (swapChainSupport.capabilities.maxImageCount &gt; <span class="hljs-number">0</span> &amp;&amp; imageCount &gt; swapChainSupport.capabilities.maxImageCount) &#123;<br>    imageCount = swapChainSupport.capabilities.maxImageCount;<br>&#125;<br><br>createInfo.minImageCount = imageCount;<br></code></pre></td></tr></table></figure><p>这里有两个需要解释的地方：第一行中加1是因为如果仅仅使用最少数量的图像可能意味着我们有时可能需要等待驱动程序完成内部操作，才能获取另一个图像进行渲染，因此我们要求至少多一张图像；另外maxImageCount==0其实意味着交换链可以拥有的图像没有上界，因此当这个值大于0时，我们需要控制要求的交换链图像数目不超过其可能上界。</p><p>接下来，对于<i><font color="Orange">imageFormat</font></i>和<i><font color="Orange">imageColorSpace</font></i>成员，我们可以通过<i><font color="Orange">SwapChainSupportDetails</font></i>结构体的成员<i><font color="Orange">formats</font></i>成员来获取相关信息。<i><font color="Orange">formats</font></i>包含了交换链支持的所有表面图像格式信息，我们需要从中挑选最符合我们要求的那个格式。因此，我们创建一个<i><font color="Green">VkSurfaceFormatKHRchooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>&amp;availableFormats)</VkSurfaceFormatKHR></font></i>函数来达到上述目的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkSurfaceFormatKHR <span class="hljs-title">chooseSwapSurfaceFormat</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;VkSurfaceFormatKHR&gt;&amp; availableFormats)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; availableFormat : availableFormats) &#123;<br>        <span class="hljs-keyword">if</span> (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB &amp;&amp; availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) &#123;<br>            <span class="hljs-keyword">return</span> availableFormat;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> availableFormats[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>我们希望挑选的颜色格式是<i><font color="Red">VK_FORMAT_B8G8R8A8_SRGB</font></i>，希望图像所处的颜色空间为sRGB颜色空间<i><font color="Red">VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</font></i>（关于sRGB空间和伽马矫正的原理介绍，可以参考<a href="https://learnopengl.com/Introduction">LearnOpenGL</a>教程的<a href="https://learnopengl.com/Advanced-Lighting/Gamma-Correction">GammaCorrection</a>章节），如果不支持这种格式的图像的话，那就退而求其次，直接返回第一个支持的格式（当然我们可以自定义一些更复杂的选择逻辑）。</p><p>这样，我们就可以填写<i><font color="Orange">imageFormat</font></i>和<i><font color="Orange">imageColorSpace</font></i>成员的信息了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSurfaceFormatKHR surfaceFormat = <span class="hljs-built_in">chooseSwapSurfaceFormat</span>(swapChainSupport.formats);<br><br>createInfo.imageFormat = surfaceFormat.format;<br>createInfo.imageColorSpace = surfaceFormat.colorSpace;<br></code></pre></td></tr></table></figure><p>然后我们来填写<i><font color="Orange">imageExtent</font></i>成员。这个形参代表的是交换链图像的分辨率。一般来讲，这个分辨率要和屏幕的分辨率一致，此时我们可以直接通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilitiesKHR.html"><code>VkSurfaceCapabilitiesKHR</code></a>结构体的<i><font color="Orange">currentExtent</font></i>成员来获取图像的尺寸。但是有的窗口系统会允许交换链图像的分辨率与屏幕分辨率不一致，此时<i><font color="Orange">currentExtent</font></i>会被设置为<a href="https://en.cppreference.com/w/cpp/types/numeric_limits/max"><code>std::numeric_limits&lt;uint32_t&gt;::max()</code></a>，这种时候我们就必须自己决定最匹配屏幕的图像分辨率了。我们可以创建一个<i><font color="Green">VkExtent2DchooseSwapExtent(const VkSurfaceCapabilitiesKHR&amp;capabilities)</font></i>函数来决定图像分辨率：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkExtent2D <span class="hljs-title">chooseSwapExtent</span><span class="hljs-params">(<span class="hljs-type">const</span> VkSurfaceCapabilitiesKHR&amp; capabilities)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (capabilities.currentExtent.width != std::numeric_limits&lt;<span class="hljs-type">uint32_t</span>&gt;::<span class="hljs-built_in">max</span>()) &#123;<br>        <span class="hljs-keyword">return</span> capabilities.currentExtent;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> width, height;<br>        <span class="hljs-built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);<br><br>        VkExtent2D actualExtent = &#123;<br>            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(width),<br>            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(height)<br>        &#125;;<br><br>        actualExtent.width = std::<span class="hljs-built_in">clamp</span>(actualExtent.width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width);<br>        actualExtent.height = std::<span class="hljs-built_in">clamp</span>(actualExtent.height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height);<br><br>        <span class="hljs-keyword">return</span> actualExtent;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要注意，GLFW有两种分辨率单位，一种是屏幕坐标，另一种是像素个数，这二者未必总是相同的，例如在高DPI设备上实际像素数就要高于屏幕坐标范围。由于Vulkan指定的图像分辨率是通过像素个数指定的，所以我们需要使用<a href="https://www.glfw.org/docs/3.3/group__window.html#ga0e2637a4161afb283f5300c7f94785c9"><code>glfwGetFramebufferSize</code></a>来获取当前屏幕的像素数。另外，我们需要控制选取的图像像素数不超过[minImageExtent,maxImageExtent]的范围，这通过<a href="https://en.cppreference.com/w/cpp/algorithm/clamp"><code>std::clamp</code></a>实现。</p><p>这样我们就可以使用该函数得到createInfo中需要的图像尺寸了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkExtent2D extent = <span class="hljs-built_in">chooseSwapExtent</span>(swapChainSupport.capabilities);<br><br>createInfo.imageExtent = extent;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">VkSwapchainCreateInfoKHR</font></i>结构体中接下来的成员<i><font color="Orange">imageArrayLayers</font></i>是多视图/立体表面中的视图数量。对于非立体3D应用程序，这个值为1。我们直接将其设为1即可。</p><p>接下来我们需要指定交换链中图像的用途。我们目前希望交换链中的图像用作渲染目标，于是可以给<i><font color="Orange">imageUsage</font></i>成员赋予<i><font color="Red">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</font></i>，也就是指定图像作为渲染的颜色缓冲。之后我们会接触到更多的图像使用方式。</p><p>下面我们要指定交换链中的图像要怎么用于多个队列家族中。当我们之前选定的图像队列和显示队列不一致的时候，我们就有两个不同队列家族种的队列了，此时我们需要指定这两个队列共享图像的模式，这通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html"><code>VkSharingMode</code></a>来指定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkSharingMode</span> &#123;</span><br>    VK_SHARING_MODE_EXCLUSIVE = <span class="hljs-number">0</span>,<span class="hljs-comment">//不允许同时有多个队列家族的队列访问图像</span><br>    VK_SHARING_MODE_CONCURRENT = <span class="hljs-number">1</span>,<span class="hljs-comment">//可以同时有多个队列家族的队列访问图像</span><br>&#125; VkSharingMode;<br></code></pre></td></tr></table></figure><p>如果有多个队列家族都需要访问交换链图像，此时如果选择<i><font color="Red">VK_SHARING_MODE_EXCLUSIVE</font></i>，那么我们还需要处理图像所有权在不同队列之间的转移问题。因此在这种情况下我们就简单地使用<i><font color="Red">VK_SHARING_MODE_CONCURRENT</font></i>模式就好了。如果只有一个队列家族（图像队列和显示队列一致），那么直接使用<i><font color="Red">VK_SHARING_MODE_EXCLUSIVE</font></i>就可以了。当然，在指定了共享模式之后，我们还需要指定共享这些图像的队列家族个数和索引：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(physicalDevice);<br><span class="hljs-type">uint32_t</span> queueFamilyIndices[] = &#123;indices.graphicsFamily.<span class="hljs-built_in">value</span>(), indices.presentFamily.<span class="hljs-built_in">value</span>()&#125;;<br><br><span class="hljs-keyword">if</span> (indices.graphicsFamily != indices.presentFamily) &#123;<br>    createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;<br>    createInfo.queueFamilyIndexCount = <span class="hljs-number">2</span>;<br>    createInfo.pQueueFamilyIndices = queueFamilyIndices;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;<br>    createInfo.queueFamilyIndexCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>    createInfo.pQueueFamilyIndices = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们可以指定显示图像之前作用于交换链图像上的变换<i><font color="Orange">preTransform</font></i>。我们目前并不需要任何预变换，所以像下面这样设置就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.preTransform = swapChainSupport.capabilities.currentTransform;<br></code></pre></td></tr></table></figure><p>我们还需要填写<i><font color="Orange">compositeAlpha</font></i>成员，该成员指定alpha通道是否可以用来和窗口系统中的其它窗口混合，这几乎总是被忽略的，因此我们只需赋予它<i><font color="Red">VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR</font></i>即可。</p><p>接下来我们需要指定交换链的显示类型。通过<i><font color="Green">querySwapChainSupport</font></i>函数我们可以获得交换链所支持的所有显示类型，我们可以从其中选择所需的类型。</p><p>显示类型由一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html"><code>VkPresentModeKHR</code></a>枚举类型表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_surface</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkPresentModeKHR</span> &#123;</span><br>    VK_PRESENT_MODE_IMMEDIATE_KHR = <span class="hljs-number">0</span>,<br>    VK_PRESENT_MODE_MAILBOX_KHR = <span class="hljs-number">1</span>,<br>    VK_PRESENT_MODE_FIFO_KHR = <span class="hljs-number">2</span>,<br>    VK_PRESENT_MODE_FIFO_RELAXED_KHR = <span class="hljs-number">3</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_shared_presentable_image</span><br>    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = <span class="hljs-number">1000111000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_shared_presentable_image</span><br>    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = <span class="hljs-number">1000111001</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_present_mode_fifo_latest_ready</span><br>    VK_PRESENT_MODE_FIFO_LATEST_READY_EXT = <span class="hljs-number">1000361000</span>,<br>&#125; VkPresentModeKHR;<br></code></pre></td></tr></table></figure><p>我们不详细解释每种类型的含义，只具体解释两种经常使用的类型：<i><font color="Red">VK_PRESENT_MODE_FIFO_KHR</font></i>和<i><font color="Red">VK_PRESENT_MODE_MAILBOX_KHR</font></i>。前者指定当屏幕刷新的时候从队列头获取一张图像，同时程序将渲染好的图像放到队列的尾部，如果队列已经满了，那么程序就需要等待队列出现空间时再插入新图片。后者和前者基本相同，区别在于当队列满的时候，程序会直接使用新渲染的图像替代队列尾的图像，这可以提高渲染效率并降低延迟，但相应的开销也会更大。因此很多移动设备仍然会选择前者作为显示模式。另外，<i><font color="Red">VK_PRESENT_MODE_FIFO_KHR</font></i>被保证在任何支持交换链的设备上都是一定可用的，因此我们可以写一个选择显示模式的函数<i><font color="Green">VkPresentModeKHRchooseSwapPresentMode(const std::vector<VkPresentModeKHR>&amp;availablePresentModes)</VkPresentModeKHR></font></i>，它优先选择<i><font color="Red">VK_PRESENT_MODE_MAILBOX_KHR</font></i>，如果该模式不可用，那么再选择<i><font color="Red">VK_PRESENT_MODE_FIFO_KHR</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkPresentModeKHR <span class="hljs-title">chooseSwapPresentMode</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;VkPresentModeKHR&gt;&amp; availablePresentModes)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; availablePresentMode : availablePresentModes) &#123;<br>        <span class="hljs-keyword">if</span> (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) &#123;<br>            <span class="hljs-keyword">return</span> availablePresentMode;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> VK_PRESENT_MODE_FIFO_KHR;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>结构体的<i><font color="Orange">presentMode</font></i>成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.presentMode = presentMode;<br></code></pre></td></tr></table></figure><p>然后我们需要指定<i><font color="Orange">createInfo</font></i>的<i><font color="Orange">clipped</font></i>成员。这个成员如果为<i><font color="Red">VK_TRUE</font></i>，就表明我们不在乎那些被其它窗口挡住的应用程序窗口的像素，那部分可以不进行显示。为了性能起见这个选项一般会设为<i><font color="Red">VK_TRUE</font></i>。</p><p>最后，在Vulkan程序运行的过程中，交换链很有可能会变得不再有效或者不再是性能最优的，比如窗口缩放等操作都会造成这种问题。因此，我们可能需要经常从头构建一个新的交换链。因此在一个新交换链的构建信息中指定一个旧交换链可以有助于减少资源的重新分配，提高性能，还能保证在新交换链创建后，旧交换链的资源能够被正确管理和释放，避免资源泄漏。交换链的更新是一个比较复杂的主题，我们将在后面介绍。在这里我们仅简单地将最后一个成员<i><font color="Orange">oldSwapchain</font></i>设置为<i><font color="Red">VK_NULL_HANDLE</font></i>。</p><p>终于，我们完成了<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>结构体的填写！</p><hr><h2 id="创建交换链">创建交换链</h2><p>接下来我们终于可以创建交换链对象了。在类内新增一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainKHR.html"><code>VkSwapchainKHR</code></a>成员，构建过程我们已经非常熟悉：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateSwapchainKHR</span>(device, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;swapChain) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create swap chain!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，在后续章节涉及到渲染的时候我们还需要在代码中使用交换链中的图像，因此我们将这些图像也保存为类内成员<i><font color="Orange">std::vector<VkImage>swapChainImages</VkImage></font></i>，然后我们紧接着创建交换链之后来获取这些图像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkGetSwapchainImagesKHR</span>(device, swapChain, &amp;imageCount, <span class="hljs-literal">nullptr</span>);<br>swapChainImages.<span class="hljs-built_in">resize</span>(imageCount);<br><span class="hljs-built_in">vkGetSwapchainImagesKHR</span>(device, swapChain, &amp;imageCount, swapChainImages.<span class="hljs-built_in">data</span>());<br></code></pre></td></tr></table></figure><p>另外注意，在交换链销毁的时候这些交换链中的图像会被自动销毁，因此我们并不需要手动销毁它们。</p><p>我们在后续章节还会用到这些图像的图像格式以及图像尺寸，因此在类内再新增两个成员<i><font color="Orange">VkFormatswapChainImageFormat</font></i>以及<i><font color="Orange">VkExtent2DswapChainExtent</font></i>分别保存这两者，并且在设置<i><font color="Orange">VkSwapchainCreateInfoKHR</font></i>的相应形参的时候顺便保存这两个成员就可以了。</p><p>大功告成！可喜可贺~</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/">上一篇：窗口表面</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/">下一篇：图像视图</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>窗口表面</title>
    <link href="/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/"/>
    <url>/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述">概述</h2><p>因为Vulkan本身是平台无关的，所以它并不会直接和不同的窗口系统打交道，而是要通过所谓的WSI(WindowSystemIntegration)拓展来达到和窗口系统交互的目的。这一节我们将讨论该拓展提供的表面对象<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html"><code>VkSurfaceKHR</code></a>，该对象用于提供展示渲染结果所需的窗口表面。该对象将由我们使用的窗口系统GLFW负责创建。</p><p>值得一提的是，WSI拓展其实是一个Instance层面的拓展而非设备层面。之所以将这个Instance层面的拓展延后到本节来讲而不是在<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">创建Instance</a>章节讲是因为表面和接下来要讲的有关展示图像的内容部分关系紧密，所以将这些内容放在一起会更加自然。</p><p>另外，表面对象一定要在选择物理设备之前创建，因为表面其实会影响物理设备的选择。不过并非所有的应用程序都需要这样一个表面对象，因为有的程序只需要离屏渲染即可。对于这种应用程序，可以为它们创建一个不可见的窗口。</p><p>创建窗口表面分为三步：</p><ul><li>创建并保存<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html"><code>VkSurfaceKHR</code></a>对象</li><li>查询支持将图像显示到该表面的物理设备</li><li>构建该设备展示显示图像所需的显示队列</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Window_surface">Windowsurface</a>章节。</p><hr><h2 id="创建表面">创建表面</h2><p>在应用程序类内添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html"><code>VkSurfaceKHR</code></a>成员<i><font color="Orange">surface</font></i>用于保存表面对象。</p><p>创建一个表面对象很简单，首先我们需要启用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_surface.html"><code>VK_KHR_surface</code></a>拓展。幸运的是这个拓展已经包含在<a href="https://www.glfw.org/docs/3.3/group__vulkan.html#ga99ad342d82f4a3421e2864978cb6d1d6"><code>glfwGetRequiredInstanceExtensions</code></a>所返回的拓展中了，我们无需额外添加。接下来只需调用<a href="https://www.glfw.org/docs/3.3/group__vulkan.html#ga1a24536bec3f80b08ead18e28e6ae965"><code>glfwCreateWindowSurface</code></a>函数，GLFW就会帮我们处理好一切平台相关的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createSurface</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwCreateWindowSurface</span>(instance, window, <span class="hljs-literal">nullptr</span>, &amp;surface) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create window surface!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过虽然glfw负责创建该表面对象，销毁它仍然使用的是Vulkan的API：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkDestroySurfaceKHR</span>(instance, surface, <span class="hljs-literal">nullptr</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="查询支持设备">查询支持设备</h2><p>Vulkan本身是支持WSI的，但这并不意味着所有的显卡都可以支持这个拓展。为了保证选取的物理设备支持该拓展，我们需要拓展<i><font color="Green">isDeviceSuitable</font></i>函数以保证选择的物理设备支持将图像显示到创建的表面上。由于显示图像其实是一个和队列有关的特性，因此我们其实需要的是选择一个具有支持显示对象到指定表面功能的队列家族的物理设备。</p><p>因此，我们首先拓展一下<i><font color="Orange">QueueFamilyIndices</font></i>结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">QueueFamilyIndices</span> &#123;<br>    std::optional&lt;<span class="hljs-type">uint32_t</span>&gt; graphicsFamily;<br>    std::optional&lt;<span class="hljs-type">uint32_t</span>&gt; presentFamily;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isComplete</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> graphicsFamily.<span class="hljs-built_in">has_value</span>() &amp;&amp; presentFamily.<span class="hljs-built_in">has_value</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意，支持显示图像的队列家族和支持图像功能的的队列家族未必相同，虽然它们大概率一致，但保险起见我们还是使用两个队列家族分别存储。</p><p>接下来我们需要修改<i><font color="Green">findQueueFamilies</font></i>函数来寻找<i><font color="Orange">presentFamily</font></i>。为了寻找这样一个队列家族，我们使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceSupportKHR.html"><code>vkGetPhysicalDeviceSurfaceSupportKHR</code></a>函数。现在<i><font color="Green">findQueueFamilies</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QueueFamilyIndices <span class="hljs-title">findQueueFamilies</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices;<br><br>    <span class="hljs-type">uint32_t</span> queueFamilyCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkQueueFamilyProperties&gt; <span class="hljs-title">queueFamilies</span><span class="hljs-params">(queueFamilyCount)</span></span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, queueFamilies.<span class="hljs-built_in">data</span>());<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; queueFamily : queueFamilies) &#123;<br>        <span class="hljs-keyword">if</span> (queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) &#123;<br>            indices.graphicsFamily = i;<br>        &#125;<br><br>        VkBool32 presentSupport = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">vkGetPhysicalDeviceSurfaceSupportKHR</span>(device, i, surface, &amp;presentSupport);<br><br>        <span class="hljs-keyword">if</span> (presentSupport) &#123;<br>            indices.presentFamily = i;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (indices.<span class="hljs-built_in">isComplete</span>()) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        i++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> indices;<br>    &#125;<br></code></pre></td></tr></table></figure><p><i><font color="Green">isDeviceSuitable</font></i>函数的代码并不需要改动，因为它通过调用<i><font color="Orange">QueueFamilyIndices</font></i>结构体的成员函数<i><font color="Green">isComplete</font></i>来检查物理设备是否满足要求，而<font color="Green">isComplete</font>已经更新了并包含了目前一切需要检查的信息。</p><hr><h2 id="构建展示队列">构建展示队列</h2><p>接下来如同图形队列一样，设备对应的显示队列也应该保存在类内一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkQueue.html"><code>VkQueue</code></a>类型的成员<i><font color="Orange">presentQueue</font></i>中。</p><p>现在我们的逻辑设备已经有两个需要的队列了（如果它们不是同一个的话），因此在逻辑设备的创建信息<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateInfo.html"><code>VkDeviceCreateInfo</code></a>中我们需要两个对应的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html"><code>VkDeviceQueueCreateInfo</code></a>。因此我们需要更新<i><font color="Green">createLogicalDevice</font></i>函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createLogicalDevice</span><span class="hljs-params">()</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(physicalDevice);<br><br>    std::vector&lt;VkDeviceQueueCreateInfo&gt; queueCreateInfos;<br>    std::set&lt;<span class="hljs-type">uint32_t</span>&gt; uniqueQueueFamilies = &#123;indices.graphicsFamily.<span class="hljs-built_in">value</span>(), indices.presentFamily.<span class="hljs-built_in">value</span>()&#125;;<br><br>    <span class="hljs-type">float</span> queuePriority = <span class="hljs-number">1.0f</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> queueFamily : uniqueQueueFamilies) &#123;<br>        VkDeviceQueueCreateInfo queueCreateInfo&#123;&#125;;<br>        queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;<br>        queueCreateInfo.queueFamilyIndex = queueFamily;<br>        queueCreateInfo.queueCount = <span class="hljs-number">1</span>;<br>        queueCreateInfo.pQueuePriorities = &amp;queuePriority;<br>        queueCreateInfos.<span class="hljs-built_in">push_back</span>(queueCreateInfo);<br>    &#125;<br><br>    VkPhysicalDeviceFeatures deviceFeatures&#123;&#125;;<br><br>    VkDeviceCreateInfo createInfo&#123;&#125;;<br>    createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;<br><br>    createInfo.queueCreateInfoCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(queueCreateInfos.<span class="hljs-built_in">size</span>());<br>    createInfo.pQueueCreateInfos = queueCreateInfos.<span class="hljs-built_in">data</span>();<br><br>    createInfo.pEnabledFeatures = &amp;deviceFeatures;<br><br>    createInfo.enabledExtensionCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>        createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateDevice</span>(physicalDevice, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;device) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create logical device!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">vkGetDeviceQueue</span>(device, indices.graphicsFamily.<span class="hljs-built_in">value</span>(), <span class="hljs-number">0</span>, &amp;graphicsQueue);<br>    <span class="hljs-built_in">vkGetDeviceQueue</span>(device, indices.presentFamily.<span class="hljs-built_in">value</span>(), <span class="hljs-number">0</span>, &amp;presentQueue);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个函数的最后，如同对图形队列所做的那样，我们调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue.html"><code>vkGetDeviceQueue</code></a>来获得该逻辑设备对应的显示队列并保存到<i><font color="Orange">presentQueue</font></i>成员中。</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/">上一篇：逻辑设备和队列</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/">下一篇：交换链</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>逻辑设备和队列</title>
    <link href="/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>如果说Instance是Vulkan库的接口和抽象，那么逻辑设备就是物理设备的接口和抽象。可以认为逻辑设备是对物理设备功能的一个“定制化”视图，允许开发者选择所需的功能集。构建与物理设备关联的逻辑设备可以分为三步：</p><ul><li>从选定物理设备的队列家族中分配所需数目的队列供逻辑设备使用</li><li>指定逻辑设备所需要的物理设备特性和功能拓展等</li><li>创建逻辑设备</li></ul><p>接下来我们将创建一个<i><font color="Green">voidcreateLogicalDevice()</font></i>函数用于构建逻辑设备，并添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDevice.html"><code>VkDevice</code></a>成员<i><font color="Orange">device</font></i>来存储创建的逻辑设备。</p><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Logical_device_and_queues">Logicaldevice and queues</a>章节</p><hr><h2 id="指定队列">指定队列</h2><p>指定逻辑设备需要使用的队列很简单，我们只需要创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html"><code>VkDeviceQueueCreateInfo</code></a>并填写相应信息即可。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDeviceQueueCreateInfo</span> &#123;</span><br>    VkStructureType             sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                 pNext;<br>    VkDeviceQueueCreateFlags    flags;<br>    <span class="hljs-type">uint32_t</span>                    queueFamilyIndex;<span class="hljs-comment">//队列家族索引，上一章在QueueFamilyIndices结构体中已经存储好了</span><br>    <span class="hljs-type">uint32_t</span>                    queueCount;      <span class="hljs-comment">//需要从该队列家族分配的队列数</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span>*                pQueuePriorities;<span class="hljs-comment">//队列优先级</span><br>&#125; VkDeviceQueueCreateInfo;<br></code></pre></td></tr></table></figure><p>其中<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlags.html"><code>VkDeviceQueueCreateFlags</code></a>是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlagBits.html"><code>VkDeviceQueueCreateFlagBits</code></a>的位组合，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlagBits.html"><code>VkDeviceQueueCreateFlagBits</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDeviceQueueCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//受保护的队列，用于处理敏感数据或需要额外安全性的操作</span><br>&#125; VkDeviceQueueCreateFlagBits;<br></code></pre></td></tr></table></figure><p>另外，队列优先级是一个0.0到1.0之间的数，规定了队列中的命令被执行的顺序，优先级大的优先执行和访问资源。注意，即使只有一个队列也应该指定优先级。</p><p>在这里我们只需要一个队列就可以了，事实上，大多数的时候我们也不需要分配多个队列，因为Vulkan允许在多线程上创建命令然后在主线程上一次性提交所有命令到一个队列。填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html"><code>VkDeviceQueueCreateInfo</code></a>过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(physicalDevice);<br><br>VkDeviceQueueCreateInfo queueCreateInfo&#123;&#125;;<br>queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;<br>queueCreateInfo.queueFamilyIndex = indices.graphicsFamily.<span class="hljs-built_in">value</span>();<br>queueCreateInfo.queueCount = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">float</span> queuePriority = <span class="hljs-number">1.0f</span>;<br>queueCreateInfo.pQueuePriorities = &amp;queuePriority;<br></code></pre></td></tr></table></figure><hr><h2 id="指定物理设备特性">指定物理设备特性</h2><p>物理设备特性通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures.html"><code>vkGetPhysicalDeviceFeatures</code></a>得到。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkGetPhysicalDeviceFeatures</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkPhysicalDevice                            physicalDevice,</span><br><span class="hljs-params">    VkPhysicalDeviceFeatures*                   pFeatures)</span>;<br></code></pre></td></tr></table></figure><p>我们暂时还不需要指定任何特性，所以只需在<i><font color="Green">createLogicalDevice</font></i>函数中把<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html"><code>VkPhysicalDeviceFeatures</code></a>结构体留空即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPhysicalDeviceFeatures deviceFeatures&#123;&#125;;<br></code></pre></td></tr></table></figure><p>一如我们之前一直做的那样，创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDevice.html"><code>VkDevice</code></a>同样需要我们填写相应的信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateInfo.html"><code>VkDeviceCreateInfo</code></a>。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDeviceCreateInfo</span> &#123;</span><br>    VkStructureType                    sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                        pNext;<br>    VkDeviceCreateFlags                flags;<br>    <span class="hljs-type">uint32_t</span>                           queueCreateInfoCount;<br>    <span class="hljs-type">const</span> VkDeviceQueueCreateInfo*     pQueueCreateInfos;<br>    <span class="hljs-comment">// enabledLayerCount is deprecated and should not be used</span><br>    <span class="hljs-type">uint32_t</span>                           enabledLayerCount;<br>    <span class="hljs-comment">// ppEnabledLayerNames is deprecated and should not be used</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*                 ppEnabledLayerNames;<br>    <span class="hljs-type">uint32_t</span>                           enabledExtensionCount;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*                 ppEnabledExtensionNames;<br>    <span class="hljs-type">const</span> VkPhysicalDeviceFeatures*    pEnabledFeatures;<br>&#125; VkDeviceCreateInfo;<br></code></pre></td></tr></table></figure><p>可以看到为了填充该结构体，我们还需要指定逻辑设备需要的拓展以及层。在<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">验证层</a>章节已经提到，如今Vulkan已经不再使用devicespecific layers了，instance specificlayer适用于一切的Vulkan调用。然而，为了与旧代码兼容，显示地指定设备层仍然是一个好的选择。另外，当前我们对于设备所需要的拓展尚且没有什么要求，因此填充信息代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkDeviceCreateInfo createInfo&#123;&#125;;<br>createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;<br><br>createInfo.pQueueCreateInfos = &amp;queueCreateInfo;<br>createInfo.queueCreateInfoCount = <span class="hljs-number">1</span>;<br><br>createInfo.pEnabledFeatures = &amp;deviceFeatures;<br><br>createInfo.enabledExtensionCount = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>    createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>    createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="创建逻辑设备">创建逻辑设备</h2><p>一切就绪，我们可以构建逻辑设备对象了，构建过程一如我们之前构建对象时一直做的那样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateDevice</span>(physicalDevice, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;device) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create logical device!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑设备就此构建完成，但我们还有一些工作需要做。由于之后我们可能需要在代码中使用逻辑设备对应的队列对象，但目前在应用程序类中并没有保存这个对象，所以我们需要添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkQueue.html"><code>VkQueue</code></a>类型的成员<i><font color="Orange">graphicsQueue</font></i>来保存这个对象。可以使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue.html"><code>vkGetDeviceQueue</code></a>函数得到赋予该逻辑设备的队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkGetDeviceQueue</span>(device, indices.graphicsFamily.<span class="hljs-built_in">value</span>(), <span class="hljs-number">0</span>, &amp;graphicsQueue);<br><span class="hljs-comment">//0代表获取的队列在队列家族中的索引。由于我们只需要一个队列，所以该值为0。</span><br></code></pre></td></tr></table></figure><p>大功告成！设备层面的建立以及完成了，接下来的章节我们将处理和图像处理及展示有关的初始化流程。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97%E5%AE%B6%E6%97%8F/">上一篇：物理设备和队列家族</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/">下一篇：窗口表面</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>物理设备和队列家族</title>
    <link href="/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97%E5%AE%B6%E6%97%8F/"/>
    <url>/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97%E5%AE%B6%E6%97%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在创建好了Instance之后，我们需要选择一个合适的物理设备（显卡）来执行实际的操作。实际上我们可以选择多张显卡同时工作，不过简单起见本文只选择一张显卡进行操作。选择合适的显卡主要分为两步：</p><ul><li>决定应用程序需要显卡具有的功能和属性。</li><li>从所有显卡中选择合适的那个作为物理设备。</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Physical_devices_and_queue_families">Physicaldevices and queue families</a>章节。</p><hr><h2 id="显卡要求">显卡要求</h2><p>显卡在Vulkan中的对应句柄对象为<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html"><code>VkPhysicalDevice</code></a>，我们可以创建一个<i><font color="Green">boolisDeviceSuitable(VkPhysicalDevicedevice)</font></i>函数来决定一张显卡是否满足我们的需求。目前我们只需要显卡支持图形队列家族（Graphicsqueuefamilies），也就是能够接受图形有关命令的队列家族，于是对于一个给定的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html"><code>VkPhysicalDevice</code></a>，我们可以创建一个<i><font color="Green">QueueFamilyIndicesfindQueueFamilies(VkPhysicalDevicedevice)</font></i>函数来检查它是否支持该队列家族。其中，我们定义结构体<i><font color="Orange">QueueFamilyIndices</font></i>如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">QueueFamilyIndices</span> &#123;<br>    std::optional&lt;<span class="hljs-type">uint32_t</span>&gt; graphicsFamily;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isComplete</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> graphicsFamily.<span class="hljs-built_in">has_value</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>为c++17定义的一个模板类，它有一个成员函数<i><font color="Green">constexprbool has_value() const noexcept</font></i>，该函数在赋予了<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>包裹的对象值后返回true，否则返回false。如此设计是因为有时在考虑应用程序需要的队列家族的时候，有些队列家族是可选的，也就是说显卡有该家族的话更好，没有的话也不应该直接终止程序，而是选择别的替代品，因此我们可以通过<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>包裹对象是否存储了一个找到的值来做出决策。另外，该结构体目前只包含一个成员，随着应用程序的深入和复杂化，也会有更多的队列家族需求，也就会有更多的成员添加到这个结构体中来。</p><p>接下来看一下<i><font color="Green">findQueueFamilies</font></i>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QueueFamilyIndices <span class="hljs-title">findQueueFamilies</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices;<br><br>    <span class="hljs-type">uint32_t</span> queueFamilyCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkQueueFamilyProperties&gt; <span class="hljs-title">queueFamilies</span><span class="hljs-params">(queueFamilyCount)</span></span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, queueFamilies.<span class="hljs-built_in">data</span>());<br>    <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; queueFamily : queueFamilies) &#123;<br>        <span class="hljs-keyword">if</span> (queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) &#123;<br>            indices.graphicsFamily = i;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (indices.<span class="hljs-built_in">isComplete</span>()) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        i++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> indices;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数的代码是直观易懂的，这里不做过多解释了。</p><p>于是，接下来我们就可以在<i><font color="Green">isDeviceSuitable</font></i>函数中使用这个函数来判断一个物理设备是否符合要求（当前来讲就是是否具有图形队列家族）。当然，随着应用程序的复杂化，<i><font color="Green">isDeviceSuitable</font></i>函数还会逐渐地拓展：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(device);<br><br>    <span class="hljs-keyword">return</span> indices.graphicsFamily.<span class="hljs-built_in">has_value</span>();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="选择显卡">选择显卡</h2><p>在决定好对于设备的要求之后，是时候开始挑选符合要求的显卡了！首先我们当然要枚举出Instance所具有的所有物理设备，并且在类内创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html"><code>VkPhysicalDevice</code></a>成员<i><font color="Orange">physicalDevice</font></i>来存储满足需求的显卡对象（将这个成员初始化为<i><font color="Orange">VK_NULL_HANDLE</font></i>。我们创建一个<i><font color="Green">voidpickPhysicalDevice()</font></i>成员函数来挑选需要的显卡：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pickPhysicalDevice</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">uint32_t</span> deviceCount = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">vkEnumeratePhysicalDevices</span>(instance, &amp;deviceCount, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span> (deviceCount == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to find GPUs with Vulkan support!&quot;</span>);<br>&#125;<br>    <span class="hljs-function">std::vector&lt;VkPhysicalDevice&gt; <span class="hljs-title">devices</span><span class="hljs-params">(deviceCount)</span></span>;<br><span class="hljs-built_in">vkEnumeratePhysicalDevices</span>(instance, &amp;deviceCount, devices.<span class="hljs-built_in">data</span>());<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来对于每一个显卡，检查它是否满足需求，简单起见，我们这里采取的策略是一旦找到了一张满足要求的显卡，就直接使用它。当然你可以自定义更加复杂的选取策略以寻找最合适的那张显卡。测试显卡是否满足要求只需使用上文创建的<i><font color="Green">isDeviceSuitable</font></i>函数即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//接pickPhysicalDevice函数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; device : devices) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isDeviceSuitable</span>(device)) &#123;<br>        physicalDevice = device;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (physicalDevice == VK_NULL_HANDLE) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to find a suitable GPU!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，由于Instance被销毁时，对应的物理设备会被自动销毁，所以我们不需要在<i><font color="Green">cleanup</font></i>函数中显示销毁它。</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">上一篇：验证层</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/">下一篇：逻辑设备和队列</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>验证层</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>VulkanAPI本身几乎不自带任何错误检测功能，不过这并不意味着我们不能添加相应的错误检测功能。Vulkan的验证层（validationlayer）就是为此而生。验证层是可选的组件，它们会挂钩到 Vulkan函数调用中，以执行额外的操作，包括：</p><ul><li>检查参数类型以避免错误调用</li><li>跟踪对象的创建和销毁以防止内存泄漏</li><li>检查线程安全性</li><li>把调用信息以及其参数输出到标准输出</li><li>跟踪调用以便性能优化和复现</li></ul><p>Vulkan中有两种验证层：instance layer和devicelayer。最初的想法是instance layer用于检查全局的Vulkan调用，而devicelayer用于检查特定GPU相关的调用。不过现在devicelayer已经逐渐被废弃了，也就是说现在可以将instancelayer用于检查任何Vulkan调用。当然，如果是为了和旧代码兼容，仍然可以使用devicelayer。</p><p>验证层的使用主要分为以下三步：</p><ul><li>启用验证层</li><li>设置回调函数</li><li>创建debug messenger以使用回调函数控制输出验证层产生的信息</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Validation_layers#page_Message-callback">Validationlayers</a>章节</p><hr><h2 id="启用验证层">启用验证层</h2><p>我们需要启用的是Vulkan中几乎包含了所有有用验证功能的层，它的名称为<i><font color="Orange">VK_LAYER_KHRONOS_validation</font></i>。在启用之前，如同拓展一样，我们也需要检查层的可用性，检查的方式和拓展如出一辙。首先我们需要列举出硬件支持的所有层：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkValidationLayerSupport</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> layerCount;<br>    <span class="hljs-built_in">vkEnumerateInstanceLayerProperties</span>(&amp;layerCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkLayerProperties&gt; <span class="hljs-title">availableLayers</span><span class="hljs-params">(layerCount)</span></span>;<br>    <span class="hljs-built_in">vkEnumerateInstanceLayerProperties</span>(&amp;layerCount, availableLayers.<span class="hljs-built_in">data</span>());<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们需要的是<i><font color="Orange">VK_LAYER_KHRONOS_validation</font></i>，它由名称对应的字符串给出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; validationLayers = &#123;<br>    <span class="hljs-string">&quot;VK_LAYER_KHRONOS_validation&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>于是我们需要检查这个层是否可用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//接上述checkValidationLayerSupport函数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span>* layerName : validationLayers) &#123;<br>    <span class="hljs-type">bool</span> layerFound = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; layerProperties : availableLayers) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(layerName, layerProperties.layerName) == <span class="hljs-number">0</span>) &#123;<br>            layerFound = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!layerFound) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>检查完毕后，我们还需要决定什么时候启用这个验证层。由于验证层输出的调试信息应该只能被开发应用程序的程序员看见，因此调试模式下我们理应启用该验证层，而发布模式下我们当然应该关闭该验证层功能。这可以通过宏来做到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> NDEBUG</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> enableValidationLayers = <span class="hljs-literal">false</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> enableValidationLayers = <span class="hljs-literal">true</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>另外，<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">上一篇</a>中我们没有填上<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>结构体中的层信息，现在就可以填上我们选取的验证层信息了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>    createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>    createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//发布模式不需要启用验证层，因此结构体中层信息也不需要填写</span><br>    createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="设置回调函数">设置回调函数</h2><p>默认情况下验证层会将调试信息输出到标准输出。但是更多时候我们希望自己控制输出信息的种类以及详细程度等。因此我们需要设置一个回调函数来指定信息输出的方式。</p><p>为了设置回调函数，我们需要一个新的拓展：<i><font color="Orange">VK_EXT_debug_utils</font></i>，因此我们可以创建一个<i><font color="Green">getRequiredExtensions</font></i>函数来统一处理所有需要的拓展：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; <span class="hljs-title">getRequiredExtensions</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> glfwExtensionCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>** glfwExtensions;<br>    glfwExtensions = <span class="hljs-built_in">glfwGetRequiredInstanceExtensions</span>(&amp;glfwExtensionCount);<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; <span class="hljs-title">extensions</span><span class="hljs-params">(glfwExtensions, glfwExtensions + glfwExtensionCount)</span></span>;<br><br>    <span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>        extensions.<span class="hljs-built_in">push_back</span>(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);<br>        <span class="hljs-comment">//VK_EXT_DEBUG_UTILS_EXTENSION_NAME是字符串&quot;VK_EXT_debug_utils&quot;等价的宏，使用宏可以避免拼写错误问题</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> extensions;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到的拓展用于Instance的创建：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> extensions = <span class="hljs-built_in">getRequiredExtensions</span>();<br>createInfo.enabledExtensionCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(extensions.<span class="hljs-built_in">size</span>());<br>createInfo.ppEnabledExtensionNames = extensions.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>在启用了回调函数所需要的拓展之后，就可以创建回调函数本身了。Vulkan通过函数指针<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/PFN_vkDebugUtilsMessengerCallbackEXT.html"><code>PFN_vkDebugUtilsMessengerCallbackEXT</code></a>指明了一个回调函数所应该具有的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">VkBool32</span> <span class="hljs-params">(VKAPI_PTR *PFN_vkDebugUtilsMessengerCallbackEXT)</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDebugUtilsMessageSeverityFlagBitsEXT           messageSeverity,</span><br><span class="hljs-params">    VkDebugUtilsMessageTypeFlagsEXT                  messageTypes,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkDebugUtilsMessengerCallbackDataEXT*      pCallbackData,</span><br><span class="hljs-params">    <span class="hljs-type">void</span>*                                            pUserData)</span>;<br></code></pre></td></tr></table></figure><p>第一个成员通过[<code>VkDebugUtilsMessageSeverityFlagBitsEXT</code><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessageSeverityFlagBitsEXT.html">id4</a>的位掩码指定输出信息的严重性，该枚举定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDebugUtilsMessageSeverityFlagBitsEXT</span> &#123;</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//所有诊断信息</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = <span class="hljs-number">0x00000010</span>, <span class="hljs-comment">//信息性消息，如资源细节</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = <span class="hljs-number">0x00000100</span>,<span class="hljs-comment">//警告信息</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = <span class="hljs-number">0x00001000</span>,  <span class="hljs-comment">//错误信息</span><br>&#125; VkDebugUtilsMessageSeverityFlagBitsEXT;<br></code></pre></td></tr></table></figure><p>第二个成员通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessageTypeFlagBitsEXT.html"><code>VkDebugUtilsMessageTypeFlagsBitsEXT</code></a>的位掩码指定输出信息的种类，该枚举定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDebugUtilsMessageTypeFlagBitsEXT</span> &#123;</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = <span class="hljs-number">0x00000001</span>,    <span class="hljs-comment">//与使用规范或性能无关的一般事件消息</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = <span class="hljs-number">0x00000002</span>, <span class="hljs-comment">//未遵循Vulkan使用规则</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//性能浪费</span><br>  <span class="hljs-comment">// Provided by VK_EXT_device_address_binding_report</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//地址绑定信息</span><br>&#125; VkDebugUtilsMessageTypeFlagBitsEXT;<br></code></pre></td></tr></table></figure><p>第三个成员指向一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCallbackDataEXT.html"><code>VkDebugUtilsMessengerCallbackDataEXT</code></a>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDebugUtilsMessengerCallbackDataEXT</span> &#123;</span><br>    VkStructureType                              sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                  pNext;<br>    VkDebugUtilsMessengerCallbackDataFlagsEXT    flags; <span class="hljs-comment">//目前只有0</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                                  pMessageIdName;  <span class="hljs-comment">//消息相关名称标识符</span><br>    <span class="hljs-type">int32_t</span>                                      messageIdNumber; <span class="hljs-comment">//该名称对应ID</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                                  pMessage;  <span class="hljs-comment">//具体调试信息</span><br>    <span class="hljs-type">uint32_t</span>                                     queueLabelCount; <span class="hljs-comment">//队列标签数</span><br>    <span class="hljs-type">const</span> VkDebugUtilsLabelEXT*                  pQueueLabels;    <span class="hljs-comment">//队列标签</span><br>    <span class="hljs-type">uint32_t</span>                                     cmdBufLabelCount;<span class="hljs-comment">//命令缓冲标签数</span><br>    <span class="hljs-type">const</span> VkDebugUtilsLabelEXT*                  pCmdBufLabels;  <span class="hljs-comment">//命令缓冲标签</span><br>    <span class="hljs-type">uint32_t</span>                                     objectCount;  <span class="hljs-comment">//消息相关对象数</span><br>    <span class="hljs-type">const</span> VkDebugUtilsObjectNameInfoEXT*         pObjects;  <span class="hljs-comment">//消息相关对象</span><br>&#125; VkDebugUtilsMessengerCallbackDataEXT;<br></code></pre></td></tr></table></figure><p>该成员包含了回调函数输出信息的具体方式和细节。</p><p>最后一个成员指定用户自己提供的额外信息，一般为nullptr。</p><p>回调函数返回一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBool32.html"><code>VkBool32</code></a>类型的值，如果它返回<i><font color="Red">VK_TRUE</font></i>，则意味着产生验证层信息的函数应该被终止，这一般只用于验证调试层是否生效，因此我们一般返回<i><font color="Red">VK_FALSE</font></i>。</p><p>于是，我们可以创建一个自己的回调函数（注意要把它设置为静态函数）。<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Validation_layers#page_Message-callback">验证层</a>章节给出的一个简单的例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> VKAPI_ATTR VkBool32 VKAPI_CALL <span class="hljs-title">debugCallback</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,</span></span><br><span class="hljs-params"><span class="hljs-function">    VkDebugUtilsMessageTypeFlagsEXT messageType,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">void</span>* pUserData)</span> </span>&#123;<br><br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;validation layer: &quot;</span> &lt;&lt; pCallbackData-&gt;pMessage &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> VK_FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VKAPI_CALL.html"><code>VKAPI_CALL</code></a>和<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VKAPI_ATTR.html"><code>VKAPI_ATTR</code></a>宏用于指定和编译器有关的调用方式，前者指定MSVC-style的编译器调用方式，后者指定GCC/Clang-style的编译器调用方式。</p><hr><h2 id="创建debug-messenger">创建Debug Messenger</h2><p>设置好回调函数的形式后，现在我们需要告知Vulkan我们设置了一个回调函数。这可以通过创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerEXT.html"><code>VkDebugUtilsMessengerEXT</code></a>句柄对象来实现。</p><p>创建该对象同样需要填写相应的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>信息，我们可以创建一个<i><font color="Green">voidsetupDebugMessenger()</font></i>函数来处理该对象的构建。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VkDebugUtilsMessengerCreateInfoEXT</span> &#123;<br>    VkStructureType                         sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                             pNext;<br>    VkDebugUtilsMessengerCreateFlagsEXT     flags;    <span class="hljs-comment">//目前只有0</span><br>    VkDebugUtilsMessageSeverityFlagsEXT     messageSeverity;<br>    VkDebugUtilsMessageTypeFlagsEXT         messageType;<br>    PFN_vkDebugUtilsMessengerCallbackEXT    pfnUserCallback;<br>    <span class="hljs-type">void</span>*                                   pUserData;<br>&#125; VkDebugUtilsMessengerCreateInfoEXT;<br></code></pre></td></tr></table></figure><p>容易注意到后四个成员中倒数第二个成员就是我们需要指定的回调函数，其它三个成员是我们需要传递给该回调函数的实参。</p><p>于是<i><font color="Green">voidsetupDebugMessenger()</font></i>函数可以如下编写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setupDebugMessenger</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!enableValidationLayers) <span class="hljs-keyword">return</span>;<br><br>    VkDebugUtilsMessengerCreateInfoEXT createInfo&#123;&#125;;<br>    <br>    createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;<br>    createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |   VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;<br>    createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;<br>    createInfo.pfnUserCallback = debugCallback;<br>    createInfo.pUserData = <span class="hljs-literal">nullptr</span>;<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来只需要创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerEXT.html"><code>VkDebugUtilsMessengerEXT</code></a>对象即可。但是到这里还有一个小问题，那就是创建对象的函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>是一个拓展函数，它不是自动加载的，而是需要我们手动使用[<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetInstanceProcAddr.html"><code>vkGetInstanceProcAddr</code></a>去寻找它的地址后才能使用。因此我们可以创建一个（全局的）工具函数VkResultCreateDebugUtilsMessengerEXT(VkInstance instance, constVkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, constVkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT*pDebugMessenger)函数来加载<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetInstanceProcAddr.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>进行加载。于是我们可以创建一个（全局的）<i><font color="Green">VkResultCreateDebugUtilsMessengerEXT(VkInstance instance, constVkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, constVkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT*pDebugMessenger)</font></i>函数加载<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>并在加载成功后使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>创建DebugMessenger对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkResult <span class="hljs-title">CreateDebugUtilsMessengerEXT</span><span class="hljs-params">(VkInstance instance, <span class="hljs-type">const</span> VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, <span class="hljs-type">const</span> VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pDebugMessenger)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> func = (PFN_vkCreateDebugUtilsMessengerEXT) <span class="hljs-built_in">vkGetInstanceProcAddr</span>(instance, <span class="hljs-string">&quot;vkCreateDebugUtilsMessengerEXT&quot;</span>);<br>    <span class="hljs-keyword">if</span> (func != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(instance, pCreateInfo, pAllocator, pDebugMessenger);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> VK_ERROR_EXTENSION_NOT_PRESENT;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，只需要在<i><font color="Green">setupDebugMessenger</font></i>函数末尾使用该函数来创建句柄对象即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//接setupDebugMessenger函数</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">CreateDebugUtilsMessengerEXT</span>(instance, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;debugMessenger) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to set up debug messenger!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>另外注意，销毁<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerEXT.html"><code>VkDebugUtilsMessengerEXT</code></a>对象的函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyDebugUtilsMessengerEXT.html"><code>vkDestroyDebugUtilsMessengerEXT</code></a>也是一个拓展函数，同样需要我们手动加载，我们也写一个工具函数来完成加载该函数和销毁的工作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyDebugUtilsMessengerEXT</span><span class="hljs-params">(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, <span class="hljs-type">const</span> VkAllocationCallbacks* pAllocator)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> func = (PFN_vkDestroyDebugUtilsMessengerEXT) <span class="hljs-built_in">vkGetInstanceProcAddr</span>(instance, <span class="hljs-string">&quot;vkDestroyDebugUtilsMessengerEXT&quot;</span>);<br>    <span class="hljs-keyword">if</span> (func != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-built_in">func</span>(instance, debugMessenger, pAllocator);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后只需在应用程序类的<i><font color="Green">cleanup()</font></i>函数中调用该加载函数即可。</p><hr><h2 id="instance创建和销毁函数内部的调试">Instance创建和销毁函数内部的调试</h2><p>大功告成了吗？其实还没有。注意到<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>函数需要创建的Instance作为参数，这也就意味着Instance的创建函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html"><code>vkCreateInstance</code></a>和销毁函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyInstance.html"><code>vkDestroyInstance</code></a>是在DebugMessenger的作用范围之外的，它们的调试信息无法被显示出来。</p><p>解决办法是将<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>信息传递给<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>结构体的pNext成员指针。具体而言，我们可以创建一个<i><font color="Green">voidpopulateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT&amp;createInfo)</font></i>函数来抽象出填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>的代码以便在<i><font color="Green">createInstance</font></i>函数和<i><font color="Green">setupDebugMessenger</font></i>函数中复用，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++|">void populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT&amp; createInfo) &#123;<br>    createInfo = &#123;&#125;;<br>    <br>    createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;<br>    createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;<br>    createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;<br>    createInfo.pfnUserCallback = debugCallback;<br>&#125;<br></code></pre></td></tr></table></figure><p><i><font color="Green">setupDebugMessenger</font></i>函数现在改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setupDebugMessenger</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!enableValidationLayers) <span class="hljs-keyword">return</span>;<br><br>    VkDebugUtilsMessengerCreateInfoEXT createInfo;<br>    <span class="hljs-built_in">populateDebugMessengerCreateInfo</span>(createInfo);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CreateDebugUtilsMessengerEXT</span>(instance, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;debugMessenger) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to set up debug messenger!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><i><font color="Green">createInstance</font></i>函数添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br><br>    VkInstanceCreateInfo createInfo&#123;&#125;;<br>    createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;<br>    createInfo.pApplicationInfo = &amp;appInfo;<br><br>    ...<br><br>    VkDebugUtilsMessengerCreateInfoEXT debugCreateInfo&#123;&#125;;<br>    <span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>        createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br><br>        <span class="hljs-built_in">populateDebugMessengerCreateInfo</span>(debugCreateInfo);<br>        createInfo.pNext = (VkDebugUtilsMessengerCreateInfoEXT*) &amp;debugCreateInfo;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br><br>        createInfo.pNext = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateInstance</span>(&amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;instance) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create instance!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以实现在Instance的构造和销毁函数中也能输出调试信息。现在终于是大功告成了！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">上一篇：创建Instance</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/">下一篇：物理设备和队列家族</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>创建Instance</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>是沟通应用程序和vulkan库的桥梁，它将你的应用程序的信息提供给图形驱动。创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>主要分为三步：</p><ul><li>检查instance所需的拓展是否可用</li><li>填写包含了创建instance所需信息的结构体</li><li>将该结构体传递给<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html"><code>vkCreateInstance</code></a>函数创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>实例</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Instance">Instance</a>章节。</p><hr><h2 id="检查拓展">检查拓展</h2><p>使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html"><code>vkEnumerateInstanceExtensionProperties</code></a>函数分两步检查拓展：</p><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html"><code>vkEnumerateInstanceExtensionProperties</code></a>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkEnumerateInstanceExtensionProperties</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                                 pLayerName,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>*                                   pPropertyCount,</span><br><span class="hljs-params">    VkExtensionProperties*                      pProperties)</span>;<br></code></pre></td></tr></table></figure><p>需要解释的是该函数第一个参数，该参数指定层名，如果为nullptr则则查询全局可用的扩展属性，否则查询指定层提供的额外拓展属性。</p><p>具体使用上，一般分两步进行，也就是先查询拓展个数再查询具体拓展，许多vulkan查询操作都分为这两步进行（假设这里不需要具体层名）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> extensionCount = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="hljs-literal">nullptr</span>, &amp;extensionCount, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-function">std::vector&lt;VkExtensionProperties&gt; <span class="hljs-title">extensions</span><span class="hljs-params">(extensionCount)</span></span>;<br><span class="hljs-built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="hljs-literal">nullptr</span>, &amp;extensionCount, extensions.<span class="hljs-built_in">data</span>());<span class="hljs-comment">// T* std::vector&lt;T,Allocator&gt;::data()返回指向vector底部数组元素的指针</span><br></code></pre></td></tr></table></figure><hr><h2 id="填写创建信息">填写创建信息</h2><p>为了创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>实例，需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>。Vulkan中很多创建实例的函数都需要一个createInfo结构体作为参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkInstanceCreateInfo</span> &#123;</span><br>    VkStructureType             sType;                  <span class="hljs-comment">//类型</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                 pNext;     <span class="hljs-comment">//拓展结构体，此教程均为nullptr</span><br>    VkInstanceCreateFlags       flags;  <br>    <span class="hljs-type">const</span> VkApplicationInfo*    pApplicationInfo;<br>    <span class="hljs-type">uint32_t</span>                    enabledLayerCount;    <span class="hljs-comment">//层数</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*          ppEnabledLayerNames;  <span class="hljs-comment">//层名</span><br>    <span class="hljs-type">uint32_t</span>                    enabledExtensionCount;  <span class="hljs-comment">//拓展数</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*          ppEnabledExtensionNames;<span class="hljs-comment">//拓展名</span><br>&#125; VkInstanceCreateInfo;<br></code></pre></td></tr></table></figure><p>第三个成员代表一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateFlagBits.html"><code>VkInstanceCreateFlagBits</code></a>的位掩码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkInstanceCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_KHR_portability_enumeration</span><br>    VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR = <span class="hljs-number">0x00000001</span>,<br>&#125; VkInstanceCreateFlagBits;<br></code></pre></td></tr></table></figure><p>其中只有一个标志位<i><font color="Red">VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR</font></i>，当设置这个标志时，表示应用程序希望能够在不同的设备和平台上更好地支持Vulkan的可移植性扩展。这对于那些希望在多种硬件和操作系统上运行的应用程序尤其重要。</p><p>第四个成员是一个指向<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkApplicationInfo.html"><code>VkApplicationInfo</code></a>结构体的指针，该结构体代表一个可选的应用程序信息，提供该信息可能有助于驱动优化应用程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkApplicationInfo</span> &#123;</span><br>    VkStructureType    sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*        pNext;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*        pApplicationName;<br>    <span class="hljs-type">uint32_t</span>           applicationVersion;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*        pEngineName;<br>    <span class="hljs-type">uint32_t</span>           engineVersion;<br>    <span class="hljs-type">uint32_t</span>           apiVersion;<br>&#125; VkApplicationInfo;<br></code></pre></td></tr></table></figure><p>该结构体每个成员都很好理解，<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Instance">Instance</a>章节中的使用范例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkApplicationInfo appInfo&#123;&#125;;<br>VkApplicationInfo appInfo&#123;&#125;;<br>appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;<br>appInfo.pApplicationName = <span class="hljs-string">&quot;Hello Triangle&quot;</span>;<br>appInfo.applicationVersion = <span class="hljs-built_in">VK_MAKE_VERSION</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>appInfo.pEngineName = <span class="hljs-string">&quot;No Engine&quot;</span>;<br>appInfo.engineVersion = <span class="hljs-built_in">VK_MAKE_VERSION</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>appInfo.apiVersion = VK_API_VERSION_1_0;<br></code></pre></td></tr></table></figure><p>解释完所有成员代表的意思之后，正式开始填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkInstanceCreateInfo createInfo&#123;&#125;;<br>createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;<br>createInfo.pApplicationInfo = &amp;appInfo;<br><br><span class="hljs-type">uint32_t</span> glfwExtensionCount = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>** glfwExtensions;<br><br><span class="hljs-comment">//获取glfw窗口系统所需的拓展，可以在获取前先使用步骤1检查以下拓展是否可用</span><br>glfwExtensions = <span class="hljs-built_in">glfwGetRequiredInstanceExtensions</span>(&amp;glfwExtensionCount);<br><br>createInfo.enabledExtensionCount = glfwExtensionCount;<br>createInfo.ppEnabledExtensionNames = glfwExtensions;<br><br><span class="hljs-comment">//这部分会在之后的设置验证层章节中填写</span><br>createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>注意这里并没有填写层数和层名，这部分会在下一章<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">验证层</a>中进行填写</p><hr><h2 id="创建vkinstance实例">创建VkInstance实例</h2><p>最后，一切就绪，可以使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html"><code>VkCreateInstance</code></a>创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>实例了，由于Vulkan中大多数创建实例的函数都会返回一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkResult.html"><code>VkResult</code></a>，于是我们一般通过下述方式创建实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateInstance</span>(&amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;instance) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create instance!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>很多Vulkan中的create函数都会具有一个可以传递用户自定义分配器的参数，在VulkanTutorial教程中该参数始终设为nullptr。</p><p>大功告成！我们可以将第二、三步的代码放到一个成员函数<i><font color="Green">voidcreateInstance()</font></i>中</p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/">上一篇：绘制基本流程梳理</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">下一篇：验证层</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>绘制基本流程梳理</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="写在前面">写在前面</h3><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Overview">Overview</a>章节</p><hr><h2 id="初始化及绘制的基本流程">初始化及绘制的基本流程</h2><p>下面按步骤给出绘制一个三角形所需的基本流程，这也构成了一个vulkan渲染程序最基础的框架</p><ul><li><p>创建一个用以描述你所创建的应用以及所需使用的API拓展的VkInstance。</p></li><li><p>查询硬件属性以挑选合适的物理设备VkPhysicalDevice。</p></li><li><p>从物理设备抽象出对应的逻辑设备VkDevice，并且创建用于接受提交命令的VkQueue。</p></li><li><p>创建用于显示渲染结果的窗口，以及一个处理跨平台窗口兼容性的的抽象层VkSurfaceKHR，然后创建用于提供渲染和展示画面的VkSwapchainKHR。</p></li><li><p>创建交换链中真正用于渲染和展示的VkImage,并且把这些图片包裹进用于指示图片的具体使用部分的VkImageView中。</p></li><li><p>创建用于指示渲染目标的类型用法等信息的VkRenderPass</p></li><li><p>在指定好渲染目标以及相应信息后，创建对应的载体VkFramebuffer，将创建好的VkImage用作它的颜色、深度或模板缓冲。</p></li><li><p>建立好包含整个渲染流程各个阶段信息的渲染管线对象VkPipeline。</p></li><li><p>准备好渲染所需的一切目标和信息后，从VkCommandPool分配出VkCommandBuffer，用于录制渲染流程中需要执行的命令。</p></li><li><p>开始主渲染循环，循环流程主要为从交换链获取图像，然后将录制好的命令提交给VkQueue执行，执行完毕后将图像归还交换链并展示渲染结果。</p><p>接下来的三角形绘制章节会详细解释每个步骤的具体流程和执行方式。</p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%BA%8F%E8%A8%80/">上一篇：序言</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">下一篇：创建Instance</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>序言</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%BA%8F%E8%A8%80/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%BA%8F%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="写在前面的话">写在前面的话</h2><p>刚学完<a href="https://vulkan-tutorial.com/Introduction">vulkantutorial</a>教程不久，感觉自己对其中的很多细节理解还不是很透彻，同时也不能很好地理清vulkan复杂的初始化流程，于是准备再学一遍教程，并且记录下自己的理解和梳理思路，希望能对vulkan的工作机制有更深入的理解。</p><h2 id="主要内容概要">主要内容概要</h2><p>本系列文章主要以梳理概括vulkan搭建的渲染流程为主，不多涉及对于图形硬件底层或者api工作原理的深入理解（苯萌新尚未进化至如此境界~~</p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/">下一篇：绘制基本流程梳理</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 847:访问所有节点的最短路径</title>
    <link href="/2024/09/19/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/Leetcode-847-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2024/09/19/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/Leetcode-847-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述">题目描述</h2><h3 id="题干">题干</h3><p>存在一个由 <code>n</code> 个节点组成的无向连通图，图中的节点按从<code>0</code> 到 <code>n - 1</code> 编号。</p><p>给你一个数组 <code>graph</code>表示这个图。其中，<code>graph[i]</code> 是一个列表，由所有与节点<code>i</code> 直接相连的节点组成。</p><p>返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。</p><h3 id="条件限制">条件限制</h3><ul><li><code>n == graph.length</code></li><li><code>1 &lt;= n &lt;= 12</code></li><li><code>0 &lt;= graph[i].length &lt; n</code></li><li><code>graph[i]</code> 不包含 <code>i</code></li><li>如果 <code>graph[a]</code> 包含 <code>b</code> ，那么<code>graph[b]</code> 也包含 <code>a</code></li><li>输入的图总是连通图</li></ul><h3 id="示例">示例</h3><figure><img src="/2024/09/19/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/Leetcode-847-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/example.png" alt="示例"><figcaption aria-hidden="true">示例</figcaption></figure><p><strong>输入</strong>：graph = [[1, 2, 3], [0], [0], [0]]</p><p><strong>输出</strong>：4</p><p><strong>解释</strong>：一种可能路径为[1, 0, 2, 0, 3]</p><hr><h2 id="错误解题思路">错误解题思路</h2><h3 id="思路">思路</h3><p>定义f[s][i]为位掩码为s且最后到达的节点为i时所走过的最短路径（如果在前述条件下不能遍历位掩码中的节点则记为INT_MAX，并且下面认为INT_MAX+1=INT_MAX)，简单地认为状态转移方程为：<span class="math display">\[f[s][i]\ =\mathop{min}\limits_{x\in graph[i]}(f[s\ \land\(1&lt;&lt;i)][x])\ +\ 1\]</span></p><h3 id="错误原因">错误原因</h3><p>事实上，位掩码为s且最后到达的节点为i时所走过的最短路径未必由除去i之后的位掩码下最后到达i的相邻节点x的最短路径转移而来，原因很简单，如果<span class="math inline">\(f[s\ \land\(1&lt;&lt;i)][x]\)</span>并非INT_MAX，那么这么转移是没有问题的，<u><mark><strong>但是，如果<span class="math inline">\(f[s\ \land\(1&lt;&lt;i)][x]\)</span>是INT_MAX呢？这是不是就意味着f[s][i]同样无法遍历得到了呢？当然不是</strong>。</mark></u>考虑上面示例，例如当位掩码为0111（即选择了0,1,2这三个节点），最后到达的节点为0时，如果按照上面错误的转移方程，我们有<span class="math display">\[f[0111][0]\ =\mathop{min}\{f[0110][1],\ f][0110][2]\}\ +\ 1\]</span>但是当位掩码仅为0110，也就是说要仅经过1,2两个节点的情况下遍历这两个节点都是不可能的，上面min的结果应该为INT_MAX，也就是说这么转移得到的f[0111][0]为INT_MAX，但是显然1-0-2-0为一条满足要求的路径，因此f[0111][0]最多也是3，因此这样的状态转移是不全面的。</p><hr><h2 id="正确解答">正确解答</h2><h3 id="思路一floyd最短路状压dp">思路一（Floyd最短路+状压dp）</h3><p>思路一延续前文错误思路的想法，只不过将状态转移方程改为 <span class="math display">\[f[s][i]\ =\mathop{min}\limits_{x\in \{0,1,\cdots,n-1\}}(f[s\ \land\(1&lt;&lt;i)][x])\ +\ dist(x,i)\]</span>其中dist(x,i)是节点x与i之间的最短距离，这个距离可以使用Floyd最短路径算法预计算出来。这样就不会出现漏掉一些状态转移方式的问题。</p><h4 id="floyd最短路径算法">Floyd最短路径算法</h4><p>算法原理以及描述这里不再赘述，读者可以在<a href="https://oi-wiki.org/graph/shortest-path/#floyd-%E7%AE%97%E6%B3%95">这里</a>找到关于该算法的具体描述和原理说明</p><p>Floyd算法的核心代码不过三层循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>  <span class="hljs-keyword">for</span> (x = <span class="hljs-number">1</span>; x &lt;= n; x++) &#123;<br>    <span class="hljs-keyword">for</span> (y = <span class="hljs-number">1</span>; y &lt;= n; y++) &#123;<br>      dist[k][x][y] = <span class="hljs-built_in">min</span>(dist[k - <span class="hljs-number">1</span>][x][y], dist[k - <span class="hljs-number">1</span>][x][k] + dist[k - <span class="hljs-number">1</span>][k][y]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中dist[k][x][y]表示只允许经过前k个节点的情况下由x到y的最短路径长度。由于外层状态k仅仅与k-1有关，所以实现的时候其实可以压缩掉一维：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>  <span class="hljs-keyword">for</span> (x = <span class="hljs-number">1</span>; x &lt;= n; x++) &#123;<br>    <span class="hljs-keyword">for</span> (y = <span class="hljs-number">1</span>; y &lt;= n; y++) &#123;<br>      dist[x][y] = <span class="hljs-built_in">min</span>(dist[x][y], dist[x][k] + dist[k][y]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中dist[x][y]直接定义为由x到y的最短路径长度。</p><h4 id="整体实现">整体实现</h4><p>首先预处理出任意两个节点之间的最短路径，然后使用上述正确状态转移方程求解，c++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestPathLength</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector <span class="hljs-title">dist</span><span class="hljs-params">(n, vector&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">1e9</span>))</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : graph[i]) &#123;<br>                dist[i][j] = dist[j][i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) dist[i][i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 预处理：floyd 求最短路</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                    dist[i][j] = <span class="hljs-built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//状压dp实现</span><br>        <span class="hljs-function">vector <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; n, vector&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">1e9</span>))</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) f[<span class="hljs-number">1</span> &lt;&lt; i][i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; (<span class="hljs-number">1</span> &lt;&lt; n); ++s) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (s &gt;&gt; i &amp; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                        <span class="hljs-keyword">if</span> ((s &gt;&gt; j &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>                            f[s | (<span class="hljs-number">1</span> &lt;&lt; j)][j] = <span class="hljs-built_in">min</span>(f[s | (<span class="hljs-number">1</span> &lt;&lt; j)][j], f[s][i] + dist[i][j]);<span class="hljs-comment">//转移方程形式上和前文略有差别，但本质上是一样的，这种写法会更方便</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//返回最终值</span><br>        <span class="hljs-keyword">return</span> *ranges::<span class="hljs-built_in">min_element</span>(f.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">begin</span>(),f.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">end</span>());<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="思路二bfs状压dp">思路二（BFS+状压dp）</h3><p>由于苯人还没有系统练习过BFS+队列存储的题目，这里暂时贴上leetcode上的<a href="https://leetcode.cn/problems/shortest-path-visiting-all-nodes/solutions/918634/gtalgorithm-tu-jie-fa-ba-hardbian-cheng-v5knb/">解答</a>，并且简述一下自己的一些理解，详细的思路说明留待之后补充~</p><h4 id="代码">代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestPathLength</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">// 1.初始化队列及标记数组，存入起点</span><br>        queue&lt; tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; q; <span class="hljs-comment">// 三个属性分别为 idx, mask, dist</span><br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">vis</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-number">1</span> &lt;&lt; n)); <span class="hljs-comment">// 节点编号及当前状态</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            q.<span class="hljs-built_in">push</span>(&#123;i, <span class="hljs-number">1</span> &lt;&lt; i, <span class="hljs-number">0</span>&#125;); <span class="hljs-comment">// 存入起点，起始距离0，标记</span><br>            vis[i][<span class="hljs-number">1</span> &lt;&lt; i] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 开始搜索</span><br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> [cur, mask, dist] = q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 弹出队头元素</span><br>            q.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-comment">// 找到答案，返回结果</span><br>            <span class="hljs-keyword">if</span>(mask == (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> dist;<br><br>            <span class="hljs-comment">// 扩展</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : graph[cur]) &#123;<br>                <span class="hljs-type">int</span> nextmask = mask | (<span class="hljs-number">1</span> &lt;&lt; x);<br>                <span class="hljs-keyword">if</span>(!vis[x][nextmask]) &#123;<br>                    q.<span class="hljs-built_in">push</span>(&#123;x, nextmask, dist + <span class="hljs-number">1</span>&#125;);<br>                    vis[x][nextmask] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="个人理解">个人理解</h4><p>q中每个tuple的三个元素存储的是当前位掩码mask，遍历mask中所有节点并最后到达的节点idx，以及满足前述两个条件的最短路径长度dist，vis[idx][mask]记录在当前位掩码为mask的状态下，最后到达节点idx的路径是否已经经过计算了，事实上，在下面的while循环过程中，我们可以保证只要vis[idx][mask]经过了一次计算（也就是设置为true了），这次计算算得的路径就是相应的最短路径，因此后续无需再次计算该状态下的最短路径。首先初始状态下，我们将所有仅含1个节点的状态(i,1&lt;&lt;i,0)入队，并且更改vis[i][1&lt;&lt;i]为true，然后开始正式搜索。观察while循环中的代码可以非常直观地得出一个重要的结论，就是每次循环入队的tuple元素的dist分量是单调递增的，因此在循环内部注释拓展部分，只有在vis[idx][mask]还没有计算得到的时候才将相应元素入队，如果它已经计算过了（也就是vis[idx][mask]已经设置为true了），那么根据前文所述单调递增的性质，第一次计算之后的计算得到的dist只会比第一次计算得到的更大，因此这种情况下相应的tuple不能入队。最终随着搜索的进行，当第一次发现搜索已经遍历了所有的节点之后，我们就可以立即返回相应的dist了，这还是源于dist在每层循环单调递增的特性，因为这意味着第一次遍历之后的遍历所对应tuple中的dist元素肯定至少大于等于第一次的dist，所以第一次的dist就是我们寻找的最短距离。另外，由于题目保证该图是连通的，也就是说一定可以求出这样的最短距离，所以其实最后的return0是用不上的，但必须加上这句代码以确保所有分支情况都有数返回（不然会报错）。</p><h2 id="补充">补充</h2><p>对于不熟悉状压dp及其写法的读者，可以参考OI Wiki中的<a href="https://oi-wiki.org/dp/state/">简介</a>，基础写法可以参考灵茶山艾府大神的几篇<a href="https://leetcode.cn/problems/find-the-minimum-cost-array-permutation/solutions/2775272/zhuang-ya-dpcong-ji-yi-hua-sou-suo-dao-d-s9t5/">题解</a>。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>状态压缩dp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
