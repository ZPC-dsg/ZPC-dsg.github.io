<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/icon/mikuicon.jpg"><link rel="icon" href="/images/icon/mikuicon.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="ZPC-dsg"><meta name="keywords" content=""><meta name="description" content="概要 现在我们已经做好了绘制三角形所需要的所有准备工作，下面我们将创建一个 void drawFrame()函数用于渲染循环中来进行真正的绘制和显示三角形的工作。 一帧中需要进行的工作主要分为以下五步：  等待上一帧结束 从交换链获取一张图像用于渲染 录制命令 提交命令进行渲染 显示渲染好的图像  在这五步中，第二、四、五步的部分或全部工作在GPU上完成，但是Vulkan中"><meta property="og:type" content="article"><meta property="og:title" content="渲染和显示"><meta property="og:url" content="http://example.com/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/index.html"><meta property="og:site_name" content="ZPC の Blog"><meta property="og:description" content="概要 现在我们已经做好了绘制三角形所需要的所有准备工作，下面我们将创建一个 void drawFrame()函数用于渲染循环中来进行真正的绘制和显示三角形的工作。 一帧中需要进行的工作主要分为以下五步：  等待上一帧结束 从交换链获取一张图像用于渲染 录制命令 提交命令进行渲染 显示渲染好的图像  在这五步中，第二、四、五步的部分或全部工作在GPU上完成，但是Vulkan中"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/images/textbg/CG_api/vk_tuto_mainloop.jpg"><meta property="article:published_time" content="2024-11-16T08:47:36.000Z"><meta property="article:modified_time" content="2024-11-20T13:35:58.134Z"><meta property="article:author" content="ZPC-dsg"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/images/textbg/CG_api/vk_tuto_mainloop.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>渲染和显示 - ZPC の Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:"measurement_id:G-X8N3TZCB57",tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>ZPC の Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/images/textbg/CG_api/vk_tuto_mainloop.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="渲染和显示"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> ZPC-dsg </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-11-16 16:47" pubdate>2024年11月16日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 5.2k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 44 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">渲染和显示</h1><div class="markdown-body"><h2 id="概要">概要</h2><p>现在我们已经做好了绘制三角形所需要的所有准备工作，下面我们将创建一个<i><font color="Green"> void drawFrame()</font></i>函数用于渲染循环中来进行真正的绘制和显示三角形的工作。</p><p>一帧中需要进行的工作主要分为以下五步：</p><ul><li>等待上一帧结束</li><li>从交换链获取一张图像用于渲染</li><li>录制命令</li><li>提交命令进行渲染</li><li>显示渲染好的图像</li></ul><p>在这五步中，第二、四、五步的部分或全部工作在GPU上完成，但是Vulkan中许多在GPU上工作的函数都是异步的，也就是说这种函数返回时函数内部的指令可能仍然在运行。因此，我们需要适当的同步手段来保证这三步一定是按顺序进行的，后者只有在前者完成工作时才会继续执行。</p><p>另外，我们还希望在开始下一帧的渲染之前上一帧命令缓冲中的命令都已经执行完毕了，这样才能保证下一帧开始录制命令时不会重置或覆盖正在执行的命令。这种情形和上文描述的GPU同步略有不同，因为等待上一帧结束这个过程应该发生在CPU端，所以我们还希望能够有一种同步机制来调节GPU和CPU间的操作顺序。</p><p>本文将首先介绍为达到上述同步目的应该使用的同步机制与同步对象，然后再顺次介绍渲染一帧的完整流程。最后，我将给出一个对本章节自己百思不得其解的疑点，当作一个有待日后解答的开放性问题。</p><p>本文对应Vulkan Tutorial的<a target="_blank" rel="noopener" href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Rendering_and_presentation#page_What-to-choose">Rendering and presentation</a>章节。</p><hr><h2 id="同步操作概述">同步操作概述</h2><p>概述部分我们已经看到了，需要同步的操作可以分成两类：交换链上的操作（获取图像和显示图像）以及等待上一帧结束的操作。这两种操作需要两种不同的同步量，因为前者完全发生在GPU上，后者涉及GPU和CPU的通信。这里我们将分别使用<strong>信号量（Semaphore）</strong>和<strong>栅栏（Fence）</strong>作为这两种操作的同步工具，下面分别介绍这两种同步量并且创建需要的对应同步对象。</p><hr><h2 id="同步对象创建">同步对象创建</h2><p>我们将在类内创建一个<i><font color="Green">void createSyncObjects()</font></i>函数来创建所需的同步对象。</p><h4 id="信号量简介semaphore">信号量简介（Semaphore）</h4><p>事实上，Vulkan中的信号量包含两种：二进制信号量（Binary Semaphore）以及时间线信号量（Timeline Semaphore）。二进制信号量只能取两个值：0 或 1。它通常用于实现互斥锁或简单的资源访问控制，而时间线信号量是一种更复杂的信号量，允许多个值，并且可以用于更复杂的同步场景。它通常用于图形编程和 GPU 任务调度。我们之后仅使用二进制信号量，因此后文但凡涉及信号量指的都是二进制信号量。</p><p>如没有任何特殊设置，信号量一开始是未点亮的（unsignaled），它的使用方法一般是需要先完成的操作负责点亮这个信号量，该操作会在完成后点亮信号量，而需要后完成的操作等待这个信号量被点亮，一旦它发现该信号量被点亮，该操作就可以开始执行了，并且此时信号量自动复位为未点亮状态，这样它就可以被继续使用了。</p><h4 id="栅栏简介fence">栅栏简介（Fence）</h4><p>栅栏和信号量的作用类似，但是它是用来同步CPU，也就是所谓的<strong>host</strong>上操作的顺序的。简单来讲，当CPU端需要知道GPU端什么时候完成了指定工作时，我们就可以使用栅栏。</p><p>栅栏的使用方式一般是给GPU上某一项工作指定一个栅栏对象，该对象会在该工作完成时被点亮，CPU端会等待这个栅栏被点亮之后再执行下一步的工作。但是使用栅栏会阻塞CPU端的工作，也就是说GPU端的工作没有完成的话，CPU端是无法做任何工作的（这与信号量不同，信号量并不会阻塞GPU执行其它工作）。另外，栅栏也并不会自动复位为未点亮状态，而是需要CPU端手动复位。</p><h4 id="创建所需信号量">创建所需信号量</h4><p>前面我们提到了，我们需要在从交换链获取图像和在渲染完毕后准备显示这两个节点处设置信号量以固定它们的执行顺序。因此，我们在类内创建两个<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSemaphore.html"><code>VkSemaphore</code></a>成员<i><font color="Orange">imageAvailableSemaphore</font></i>和<i><font color="Orange">renderFinishedSemaphore</font></i>。为了创建信号量，我们同样需要填写<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSemaphoreCreateInfo.html"><code>VkSemaphoreCreateInfo</code></a>结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSemaphoreCreateInfo</span> &#123;</span><br>    VkStructureType           sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*               pNext;<br>    VkSemaphoreCreateFlags    flags;<span class="hljs-comment">//目前还没有</span><br>&#125; VkSemaphoreCreateInfo;<br></code></pre></td></tr></table></figure><p>这个信息结构体只包含最基本的几个成员，因此填写十分简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSemaphoreCreateInfo semaphoreInfo&#123;&#125;;<br>semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;<br></code></pre></td></tr></table></figure><p>接下来只需调用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateSemaphore.html"><code>vkCreateSemaphore</code></a>创建相应对象即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;imageAvailableSemaphore) != VK_SUCCESS ||<br>    <span class="hljs-built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;renderFinishedSemaphore) != VK_SUCCESS || &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create semaphores!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建所需栅栏">创建所需栅栏</h4><p>我们需要创建一个用于告知CPU端GPU上的命令缓冲中的命令已经执行完毕，可以开启下一帧了。因此，在类内添加一个<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFence.html"><code>VkFence</code></a>类型的对象<i><font color="Orange">inFlightFence</font></i>，然后在<i><font color="Green">createSyncObjects</font></i>函数中填写创建信息结构体<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFenceCreateInfo.html"><code>VkFenceCreateInfo</code></a>。其中<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFenceCreateInfo.html"><code>VkFenceCreateInfo</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkFenceCreateInfo</span> &#123;</span><br>    VkStructureType       sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*           pNext;<br>    VkFenceCreateFlags    flags;<br>&#125; VkFenceCreateInfo;<br></code></pre></td></tr></table></figure><p>这里<i><font color="Orange">flags</font></i>成员可能的取值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkFenceCreateFlagBits</span> &#123;</span><br>    VK_FENCE_CREATE_SIGNALED_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//指定栅栏在创建时为被点亮状态</span><br>&#125; VkFenceCreateFlagBits;<br></code></pre></td></tr></table></figure><p>于是填写栅栏信息和创建栅栏的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkFenceCreateInfo fenceInfo&#123;&#125;;<br>fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;<br>fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateFence</span>(device, &amp;fenceInfo, <span class="hljs-literal">nullptr</span>, &amp;inFlightFence) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create semaphores!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>至于这里为什么需要设置栅栏在创建时为点亮状态，我们将在<a href="#上一帧">等待上一帧小节</a>中 加以说明。</p><hr><h2 id="上一帧">## 等待上一帧</h2><p>在<i><font color="Green">drawFrame</font></i>函数的开头，我们首先需要等待上一帧的结束。为此，我们可以调用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html"><code>vkWaitForFences</code></a>函数来等待上一帧的<i><font color="Orange">inFlightFence</font></i>被点亮（点亮操作会在渲染完成后执行）。<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html"><code>vkWaitForFences</code></a>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkWaitForFences</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDevice                                    device,    <span class="hljs-comment">//栅栏所属逻辑设备</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    fenceCount,<span class="hljs-comment">//栅栏数目</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkFence*                              pFences,   <span class="hljs-comment">//栅栏</span></span><br><span class="hljs-params">    VkBool32                                    waitAll,   <span class="hljs-comment">//是否等待所有栅栏都被点亮</span></span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span>                                    timeout)</span>;  <span class="hljs-comment">//等待时长  </span><br></code></pre></td></tr></table></figure><p>可以看到，我们可以指定CPU端等待多个栅栏，<i><font color="Orange">waitAll</font></i>参数可以指定我们需要等待其中所有栅栏都被点亮还是等待其中任意一个被点亮。<i><font color="Orange">timeout</font></i>指定最长的等待时限，如果在该时限内等待的栅栏被点亮了，那么该函数将返回<i><font color="Red">VK_SUCCESS</font></i>，否则，该函数会返回<i><font color="Red">VK_TIMEOUT</font></i>。</p><p>在我们的应用程序中，我们只有一个栅栏，并且不需要设置等待时限，于是我们可以如下调用该函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">vkWaitForFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFence, VK_TRUE, UINT64_MAX);<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，在栅栏被成功点亮后，我们需要手动重置其为非点亮状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkResetFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFence);<br></code></pre></td></tr></table></figure><p>等待上一帧的操作就结束了。不过，细心的读者可能会注意到一个违和之处：每次进入下一帧的时候都要等待上一帧的栅栏被点亮，但如果是第一帧呢？它没办法等待上一帧点亮栅栏，因此在第一次循环进入到该函数时栅栏就处于未点亮的状态，那么<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html"><code>vkWaitForFences</code></a>永远无法成功返回！这个问题其实有很多的解决方案，在本教程中我们是通过上文创建栅栏时将其初始状态设置为点亮状态来实现的，这样就可以轻松解决这个问题~</p><hr><h2 id="获取交换链图像">获取交换链图像</h2><p>在上一帧命令执行结束后，我们就可以获取这一帧渲染需要的图像了。这通过<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html"><code>vkAcquireNextImageKHR</code></a>来完成。该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br>VkResult <span class="hljs-title function_">vkAcquireNextImageKHR</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDevice                                    device,      <span class="hljs-comment">//需要获取图片的逻辑设备</span></span><br><span class="hljs-params">    VkSwapchainKHR                              swapchain,   <span class="hljs-comment">//图片所在交换链</span></span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span>                                    timeout,     <span class="hljs-comment">//等待获取时长</span></span><br><span class="hljs-params">    VkSemaphore                                 semaphore,   <span class="hljs-comment">//等待操作完成后点亮的信号量</span></span><br><span class="hljs-params">    VkFence                                     fence,       <span class="hljs-comment">//等待操作完成后点亮的栅栏</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>*                                   pImageIndex)</span>;<span class="hljs-comment">//获取的图片的索引</span><br></code></pre></td></tr></table></figure><p></p><p>我们只需设置一个信号量<i><font color="Orange">imageAvailableSemaphore</font></i>用于等待获取图像操作的结束，因此获取交换链图像的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> imageIndex;<br><span class="hljs-built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphore, VK_NULL_HANDLE, &amp;imageIndex);<br></code></pre></td></tr></table></figure><p>另外需要注意的是，这个函数保证在返回<i><font color="Red">VK_SUCCESS</font></i>时，<i><font color="Orange">imageIndex</font></i>一定是有效且正确的，但是并不保证返回时该函数所进行的一切工作都结束了。</p><hr><h2 id="录制命令">录制命令</h2><p>接下来我们可以录制对获取到的图像所需要进行的命令了（之前提到了尽管先前的<i><font color="Green">vkAcquireNextImageKHR</font></i>可能还没有执行完所有工作，但是图像索引已经得到了，录制命令这步工作是在CPU端进行的，并且只需要用到图像的索引，GPU端还有其它的工作未完成并不影响继续录制命令），因此我们调用<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/"><code>命令缓冲</code></a>章节添加的<i><font color="Green">recordCommandBuffer</font></i>函数来完成所需命令的录制。当然，在此之前我们需要先使用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkResetCommandBuffer.html"><code>vkResetCommandBuffer</code></a>重置命令缓冲以清除上一帧录制的命令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkResetCommandBuffer</span>(commandBuffer, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">recordCommandBuffer</span>(commandBuffer, imageIndex);<br></code></pre></td></tr></table></figure><hr><h2 id="提交命令并渲染">提交命令并渲染</h2><p>录制好命令后我们就可以将命令缓冲中的命令提交给队列执行了。提交命令同样需要填写相应的信息<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo.html"><code>VkSubmitInfo</code></a>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSubmitInfo</span> &#123;</span><br>    VkStructureType                sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                    pNext;<br>    <span class="hljs-type">uint32_t</span>                       waitSemaphoreCount;<br>    <span class="hljs-type">const</span> VkSemaphore*             pWaitSemaphores;<br>    <span class="hljs-type">const</span> VkPipelineStageFlags*    pWaitDstStageMask;<br>    <span class="hljs-type">uint32_t</span>                       commandBufferCount;<br>    <span class="hljs-type">const</span> VkCommandBuffer*         pCommandBuffers;<br>    <span class="hljs-type">uint32_t</span>                       signalSemaphoreCount;<br>    <span class="hljs-type">const</span> VkSemaphore*             pSignalSemaphores;<br>&#125; VkSubmitInfo;<br></code></pre></td></tr></table></figure><p>这里唯一需要解释一下的参数就是<i><font color="Orange">pWaitDstStageMask</font></i>，它用于指定每个等待信号量对应在管线中等待的阶段，也就是管线中哪个阶段需要等待该信号量被点亮后才能继续执行。注意，如果渲染管线中对应阶段被执行了多次（比如一个渲染通道中有多个子通道），那么每个该阶段的执行都需要等待该信号量被点亮。</p><p>在我们的应用程序中，我们需要在绘制前等待图像获取完毕，于是我们需要等待的信号量为<i><font color="Orange">imageAvailableSemaphore</font></i>，等待的管线阶段可以设置为<i><font color="Red">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>（全部的管线阶段及其相关信息可以参考<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlagBits.html">这个页面</a>），这意味着我们只要求在绘制到帧缓冲之前图像必须获取完毕，而在之前的管线阶段，比如顶点着色器运行阶段等则并不要求图像获取完毕，这么做延长了图像获取操作的允许时长，提高了时间利用效率。在命令缓冲中的命令全部执行完毕后，我们还需要点亮<i><font color="Orange">renderFinishedSemaphore</font></i>以告知程序渲染已经完成，可以进行后续的显示操作了。因此，该信息结构体的填写代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSubmitInfo submitInfo&#123;&#125;;<br>submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;<br><br>VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphore&#125;;<br>VkPipelineStageFlags waitStages[] = &#123;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&#125;;<br>submitInfo.waitSemaphoreCount = <span class="hljs-number">1</span>;<br>submitInfo.pWaitSemaphores = waitSemaphores;<br>submitInfo.pWaitDstStageMask = waitStages;<br>submitInfo.commandBufferCount = <span class="hljs-number">1</span>;<br>submitInfo.pCommandBuffers = &amp;commandBuffer;<br>VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphore&#125;;<br>submitInfo.signalSemaphoreCount = <span class="hljs-number">1</span>;<br>submitInfo.pSignalSemaphores = signalSemaphores;<br></code></pre></td></tr></table></figure><p>接下来我们需要调用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit.html"><code>vkQueueSubmit</code></a>函数执行提交操作，该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkQueueSubmit</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkQueue                                     <span class="hljs-built_in">queue</span>,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    submitCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkSubmitInfo*                         pSubmits,</span><br><span class="hljs-params">    VkFence                                     fence)</span>;<br></code></pre></td></tr></table></figure><p>每一个参数都是易于理解的，其中最后一个参数代表一个可选的在提交的命令运行结束后会被点亮的栅栏。我们显然应该将<i><font color="Orange">inFlightFence</font></i>赋予这个参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkQueueSubmit</span>(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, inFlightFence) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to submit draw command buffer!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，命令提交结束，渲染可以开始了。但是事实上这里仍然存在一个很隐晦的问题：还记得我们的渲染通道中指定了一个子通道吗？事实上，除了这个我们显式设置的通道之外，还存在两个隐式的通道，一个位于渲染通道的开始处，一个位于渲染通道的结束处，这些子通道会通过一种叫做<strong>Subpass dependencies</strong>的结构控制子通道之间图像格式的转换。如果不显式设置这种依赖关系，那么默认的开始处的子通道到我们设置的子通道之间格式的转换将发生在渲染管线的开始阶段（该阶段对应Vulkan中管线阶段的枚举值为<i><font color="Red">VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</font></i>），但是问题是，我们之前设置的提交命令的等待阶段为输出到帧缓冲的阶段，也就是说在<i><font color="Red">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>之前，我们甚至不能保证图像获取操作已经完全结束了，也就是说我们不能保证在这个阶段之前图象是完全有效的，甚至渲染管线开始的时候图像可能还根本没有获取到！当然，我们可以将之前<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo.html"><code>VkSubmitInfo</code></a>中的<i><font color="Orange">pWaitDstStageMask</font></i>设置为<i><font color="Red">VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</font></i>，但是一来这样会使得时间利用率降低，二来我们也希望借此机会探索一下<strong>Subpass dependencies</strong>的结构和设置方式。因此，我们接下来就在<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/"><code>渲染通道</code></a>章节中创建的<i><font color="Green">createRenderPass</font></i>函数中添加手动设置<strong>Subpass dependencies</strong>的相关代码：</p><p>首先还是来看一下依赖关系结构体<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubpassDependency.html"><code>VkSubpassDependency</code></a>的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSubpassDependency</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>                srcSubpass;<span class="hljs-comment">//依赖关系的源子通道的索引。如果设置为 VK_SUBPASS_EXTERNAL，则表示依赖于外部命令（即在渲染通道开始之前的命令）</span><br>    <span class="hljs-type">uint32_t</span>                dstSubpass;<span class="hljs-comment">//依赖关系的目标子通道的索引。如果设置为 VK_SUBPASS_EXTERNAL，则表示依赖于外部命令（即在渲染通道结束之后的命令）。另外，该索引值一定要大于等于srcSubpass表示的索引值以避免循环依赖（除非dstSubpass为VK_SUBPASS_EXTERNAL）</span><br>    VkPipelineStageFlags    srcStageMask;<span class="hljs-comment">//指定源子通道中需要同步的管线阶段。这决定了哪些阶段的操作需要在目标子通道开始之前完成</span><br>    VkPipelineStageFlags    dstStageMask;<span class="hljs-comment">//指定目标子通道中需要同步的管线阶段。这决定了目标子通道中哪些阶段的操作需要等待源子通道的完成</span><br>    VkAccessFlags           srcAccessMask;<span class="hljs-comment">//指定在源子通道中访问的资源类型（如读取、写入等）。这用于确定在源子通道中需要等待的访问类型</span><br>    VkAccessFlags           dstAccessMask;<span class="hljs-comment">//指定在目标子通道中访问的资源类型。这用于确定目标子通道中需要等待的访问类型</span><br>    VkDependencyFlags       dependencyFlags;<span class="hljs-comment">//指定依赖关系的标志，控制依赖行为的特性</span><br>&#125; VkSubpassDependency;<br></code></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAccessFlagBits.html"><code>VkAccessFlagBits</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkAccessFlagBits</span> &#123;</span><br>    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = <span class="hljs-number">0x00000001</span>,<br>    VK_ACCESS_INDEX_READ_BIT = <span class="hljs-number">0x00000002</span>,<br>    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = <span class="hljs-number">0x00000004</span>,<br>    VK_ACCESS_UNIFORM_READ_BIT = <span class="hljs-number">0x00000008</span>,<br>    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = <span class="hljs-number">0x00000010</span>,<br>    VK_ACCESS_SHADER_READ_BIT = <span class="hljs-number">0x00000020</span>,<br>    VK_ACCESS_SHADER_WRITE_BIT = <span class="hljs-number">0x00000040</span>,<br>    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = <span class="hljs-number">0x00000080</span>,<br>    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = <span class="hljs-number">0x00000100</span>,<br>    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = <span class="hljs-number">0x00000200</span>,<br>    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = <span class="hljs-number">0x00000400</span>,<br>    VK_ACCESS_TRANSFER_READ_BIT = <span class="hljs-number">0x00000800</span>,<br>    VK_ACCESS_TRANSFER_WRITE_BIT = <span class="hljs-number">0x00001000</span>,<br>    VK_ACCESS_HOST_READ_BIT = <span class="hljs-number">0x00002000</span>,<br>    VK_ACCESS_HOST_WRITE_BIT = <span class="hljs-number">0x00004000</span>,<br>    VK_ACCESS_MEMORY_READ_BIT = <span class="hljs-number">0x00008000</span>,<br>    VK_ACCESS_MEMORY_WRITE_BIT = <span class="hljs-number">0x00010000</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_ACCESS_NONE = <span class="hljs-number">0</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_transform_feedback</span><br>    VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = <span class="hljs-number">0x02000000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_transform_feedback</span><br>    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = <span class="hljs-number">0x04000000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_transform_feedback</span><br>    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = <span class="hljs-number">0x08000000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_conditional_rendering</span><br>    VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = <span class="hljs-number">0x00100000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_blend_operation_advanced</span><br>    VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = <span class="hljs-number">0x00080000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br>    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = <span class="hljs-number">0x00200000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br>    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = <span class="hljs-number">0x00400000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_fragment_density_map</span><br>    VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = <span class="hljs-number">0x01000000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_fragment_shading_rate</span><br>    VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = <span class="hljs-number">0x00800000</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_device_generated_commands</span><br>    VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV = <span class="hljs-number">0x00020000</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_device_generated_commands</span><br>    VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV = <span class="hljs-number">0x00040000</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_shading_rate_image</span><br>    VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR,<br>  <span class="hljs-comment">// Provided by VK_NV_ray_tracing</span><br>    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR,<br>  <span class="hljs-comment">// Provided by VK_NV_ray_tracing</span><br>    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR,<br>  <span class="hljs-comment">// Provided by VK_KHR_synchronization2</span><br>    VK_ACCESS_NONE_KHR = VK_ACCESS_NONE,<br>  <span class="hljs-comment">// Provided by VK_EXT_device_generated_commands</span><br>    VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT = VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV,<br>  <span class="hljs-comment">// Provided by VK_EXT_device_generated_commands</span><br>    VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT = VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV,<br>&#125; VkAccessFlagBits;<br></code></pre></td></tr></table></figure><p>每一个枚举都代表一种资源访问类型，我们这里不做过多解释。</p><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/424430509/answer/1632072443"><code>VkDependencyFlagBits</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDependencyFlagBits</span> &#123;</span><br>    VK_DEPENDENCY_BY_REGION_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//表示依赖关系是基于区域的。这意味着在源和目标子通道之间的依赖关系是区域相关的，确保在访问同一区域时不会发生数据竞争</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_DEPENDENCY_DEVICE_GROUP_BIT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//表示依赖关系涉及设备组。这在使用多个 GPU 时特别有用，确保在设备组中的不同设备之间的操作顺序</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_DEPENDENCY_VIEW_LOCAL_BIT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//表示依赖关系是视图局部的。这通常用于多视图渲染，确保在不同视图之间的依赖关系是局部的，适合多视图场景的渲染</span><br>  <span class="hljs-comment">// Provided by VK_EXT_attachment_feedback_loop_layout</span><br>    VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//这是一个扩展标志，表示存在反馈循环的依赖关系。这通常用于处理需要在多个渲染通道之间进行反馈的场景</span><br>  <span class="hljs-comment">// Provided by VK_KHR_multiview</span><br>    VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = VK_DEPENDENCY_VIEW_LOCAL_BIT,<br>  <span class="hljs-comment">// Provided by VK_KHR_device_group</span><br>    VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = VK_DEPENDENCY_DEVICE_GROUP_BIT,<br>&#125; VkDependencyFlagBits;<br></code></pre></td></tr></table></figure><p>根据前文的叙述，我们需要重新设置开始处子通道和我们设置的子通道之间的依赖关系。相应的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSubpassDependency dependency&#123;&#125;;<br><br>dependency.srcSubpass = VK_SUBPASS_EXTERNAL;<br>dependency.dstSubpass = <span class="hljs-number">0</span>;<br>dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;<br>dependency.srcAccessMask = <span class="hljs-number">0</span>;<br>dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;<br>dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;<br></code></pre></td></tr></table></figure><p>我们将<i><font color="Orange">srcStageMask</font></i>设置为<i><font color="Red">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>，这样开始时的图像格式转换就会发生在该阶段之后，此时可以保证图像是存在有效的。另外，将<i><font color="Orange">srcAccessMask</font></i>设置为0意味着我们并不需要等待开始处子通道完成任何资源访问操作，事实上我们也没有在该子通道处有什么特别的操作要进行。之后<i><font color="Orange">dstStageMask</font></i>同样设置为<i><font color="Red">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>，资源访问操作<i><font color="Orange">dstAccessMask</font></i>设置为<i><font color="Red">VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</font></i>以指定将渲染结果写入帧缓冲的操作要在图像格式已经成功转换之后再执行。（不过知乎上的<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/424430509/answer/1632072443">一篇文章</a>里说这部分其实写的有问题，我也始终 感觉这一部分想得不明不白的。。。望高人指点</p><p>最后不要忘了在<i><font color="Orange">renderPassInfo</font></i>中指定依赖关系成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">renderPassInfo.dependencyCount = <span class="hljs-number">1</span>;<br>renderPassInfo.pDependencies = &amp;dependency;<br></code></pre></td></tr></table></figure><hr><h2 id="显示图像">显示图像</h2><p>最后，我们只需要将渲染好的图像显示到屏幕上即可。为此，我们需要首先填写<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPresentInfoKHR.html"><code>VkPresentInfoKHR</code></a>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPresentInfoKHR</span> &#123;</span><br>    VkStructureType          sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*              pNext;<br>    <span class="hljs-type">uint32_t</span>                 waitSemaphoreCount;<br>    <span class="hljs-type">const</span> VkSemaphore*       pWaitSemaphores;<br>    <span class="hljs-type">uint32_t</span>                 swapchainCount;<br>    <span class="hljs-type">const</span> VkSwapchainKHR*    pSwapchains;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*          pImageIndices;<br>    VkResult*                pResults;<br>&#125; VkPresentInfoKHR;<br></code></pre></td></tr></table></figure><p>这里只需要解释一下最后一个成员<i><font color="Orange">pResults</font></i>，该参数会返回每个对应交换链显示图像的结果是否成功。如果只有一个交换链（事实上绝大多数的情况也是如此），那么就没有必要指定这个成员，因为我们可以直接使用显示函数<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>的返回值来查看图像显示是否成功。</p><p>我们的填写代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPresentInfoKHR presentInfo&#123;&#125;;<br>presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;<br><br>presentInfo.waitSemaphoreCount = <span class="hljs-number">1</span>;<br>presentInfo.pWaitSemaphores = signalSemaphores;<br><br>VkSwapchainKHR swapChains[] = &#123;swapChain&#125;;<br>presentInfo.swapchainCount = <span class="hljs-number">1</span>;<br>presentInfo.pSwapchains = swapChains;<br>presentInfo.pImageIndices = &amp;imageIndex;<br></code></pre></td></tr></table></figure><p>由于我们需要等待渲染操作结束才能显示图像，因此<i><font color="Orange">pWaitSemaphores</font></i>应该设置为<i><font color="Orange">renderFinishedSemaphore</font></i>。</p><p>最后，使用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>显示图像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);<br></code></pre></td></tr></table></figure><p>注意到这里我们并没有使用这个函数调用的返回值，包括之前在调用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html"><code>vkAcquireNextImageKHR</code></a>的时候我们也没有这么做，因为和之前的函数不同，这两个函数即使返回错误值，也不意味着我们需要立即终止我们的程序，所以我们会在之后的章节中单独处理这两个函数的调试。</p><p>这样，我们终于成功绘制了Vulkan中的第一个三角形！天哪，这真是一段漫长的旅程。。。</p><figure><img src="/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/first_triangle.png" srcset="/img/loading.gif" lazyload alt="第一个三角形"><figcaption aria-hidden="true">第一个三角形</figcaption></figure><p>不过没有那么多时间沉浸在自我感动中了，因为接下来赶到战场的是验证层的报错。。。是的，心满意足地欣赏完近1000行代码编写出来的“鸿篇巨制”之后，准备退出程序的你此时却必然会受到验证层的最后一击：</p><figure><img src="/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/validation_error.png" srcset="/img/loading.gif" lazyload alt="不老实的验证层"><figcaption aria-hidden="true">不老实的验证层</figcaption></figure><p>这是为什么？</p><p>事实上原因在于我们在最后一帧结束程序时，退出循环后CPU会执行<i><font color="Green">cleanup</font></i>函数来清理掉所有Vulkan对象，但是还记得我们之前说GPU上的一些函数在返回后相应的工作还可能在运行吗？问题就出在这里！有些GPU上的工作还没执行完毕我们就清理掉了相应的资源！</p><p>解决方法也有很多，我们这里采取一种简单粗暴的方式即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mainLoop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">glfwWindowShouldClose</span>(window)) &#123;<br>        <span class="hljs-built_in">glfwPollEvents</span>();<br>        <span class="hljs-built_in">drawFrame</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">vkDeviceWaitIdle</span>(device);<br>&#125;<br></code></pre></td></tr></table></figure><p>在渲染循环之后加入<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDeviceWaitIdle.html"><code>vkDeviceWaitIdle</code></a>来等待所有的队列操作执行完毕再进行清理工作，这样我们终于可以安心退出程序而不用担心验证层的抱怨了！太棒了！</p><hr><h2 id="一个小疑点">一个小疑点</h2><p>关于这一节我仍然有一个疑问没有解决，那就是关于显示图像的同步问题。</p><p>假设这么一种情况：当前帧运行到了<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>，由于该函数运行在GPU上，它可能没有完成显示就已经返回了，此时<i><font color="Green">drawFrame</font></i>函数进入下一帧，由于此时所有的信号量、栅栏、命令缓冲等都处于可用状态，因此下一帧会畅通无阻地运行到<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>，那么万一此时上一帧的显示因为种种原因还没有完成呢？岂不是会同时显示两帧图像？</p><p>我发现Vulkan Tutorial的<a target="_blank" rel="noopener" href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Rendering_and_presentation#page_What-to-choose">Rendering and presentation</a>章节评论区中有人也提出了类似的问题：</p><figure><img src="/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/comments.png" srcset="/img/loading.gif" lazyload alt="疑点"><figcaption aria-hidden="true">疑点</figcaption></figure><p>可以看到有人给出了一些可能的解释，不过也并没有完全回答这种类似的问题。因此暂时保留该疑问，以待日后思考~</p><hr><p>--<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/">上一篇：命令缓冲</a></p><p>--<a href>下一篇：多帧同时渲染</a></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/CG-api/" class="category-chain-item">CG_api</a> <span>></span> <a href="/categories/CG-api/vulkan/" class="category-chain-item">vulkan</a> <span>></span> <a href="/categories/CG-api/vulkan/vulkan-tutorial/" class="category-chain-item">vulkan_tutorial</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>渲染和显示</div><div>http://example.com/2024/11/16/CG_api/vulkan/vulkan_tutorial/渲染和显示/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>ZPC-dsg</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年11月16日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/11/20/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E5%B8%A7%E5%90%8C%E6%97%B6%E6%B8%B2%E6%9F%93/" title="多帧同时渲染"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">多帧同时渲染</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/" title="命令缓冲"><span class="hidden-mobile">命令缓冲</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>