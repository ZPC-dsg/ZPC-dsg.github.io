<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/icon/mikuicon.jpg"><link rel="icon" href="/images/icon/mikuicon.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="ZPC-dsg"><meta name="keywords" content=""><meta name="description" content="前言 本示例将初步展示一个mesh shader需要如何使用。task shader-mesh shader的组合是传统渲染管线中的vertex shader-tessellation-geometry-shader的一个替代方案。这种着色器阶段组合将作用于以Meshlet（可以看成由一系列的基本图元构成的几何体，并且要求几何体内的最大顶点、图元数是一个定值）为单位的几何体，并且生成每个M"><meta property="og:type" content="article"><meta property="og:title" content="Gshader to Mshader"><meta property="og:url" content="http://example.com/2025/03/20/CG_api/vulkan/vulkan_samples/gshader_to_mshader/index.html"><meta property="og:site_name" content="ZPC の Blog"><meta property="og:description" content="前言 本示例将初步展示一个mesh shader需要如何使用。task shader-mesh shader的组合是传统渲染管线中的vertex shader-tessellation-geometry-shader的一个替代方案。这种着色器阶段组合将作用于以Meshlet（可以看成由一系列的基本图元构成的几何体，并且要求几何体内的最大顶点、图元数是一个定值）为单位的几何体，并且生成每个M"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/images/textbg/CG_api/vk_sample_gtom.jpg"><meta property="article:published_time" content="2025-03-20T02:39:09.000Z"><meta property="article:modified_time" content="2025-03-20T08:07:54.579Z"><meta property="article:author" content="ZPC-dsg"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/images/textbg/CG_api/vk_sample_gtom.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>Gshader to Mshader - ZPC の Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:"measurement_id:G-X8N3TZCB57",tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 7.3.0"><script src="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.css"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>ZPC の Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/images/textbg/CG_api/vk_sample_gtom.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Gshader to Mshader"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> ZPC-dsg </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-03-20 10:39" pubdate>2025年3月20日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.8k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 32 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">Gshader to Mshader</h1><div class="markdown-body"><h2 id="前言">前言</h2><p>本示例将初步展示一个<strong>mesh shader</strong>需要如何使用。<strong>task shader-mesh shader</strong>的组合是传统渲染管线中的<strong>vertex shader-tessellation-geometry-shader</strong>的一个替代方案。这种着色器阶段组合将作用于以<strong>Meshlet</strong>（可以看成由一系列的基本图元构成的几何体，并且要求几何体内的最大顶点、图元数是一个定值）为单位的几何体，并且生成每个<strong>Meshlet</strong>内的图元、顶点等信息。相较于传统的渲染管线阶段，使用mesh shader的优势在于可以减小内存带宽以提高性能，但缺点在于使用之前需要对场景内物体作进一步的处理（切分为以Meshlet为单位的几何体）。</p><p>下面就来跟随示例代码看看基本的mesh shader是如何使用的吧（本示例不涉及task shader的使用）。</p><hr><h2 id="效果">效果</h2><p>程序效果如下：</p><div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom:20px"></div><script>!function(){var e=new DPlayer({container:document.getElementById("dplayer3"),loop:"yes",screenshot:"yes",video:{url:"/2025/03/20/CG_api/vulkan/vulkan_samples/gshader_to_mshader/effect.mp4"},danmaku:{api:"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]),window.dplayers.push(e)}()</script><p></p><p>其中用户可以切换几何着色器和mesh shader来显示模型法线。</p><hr><h2 id="特性拓展支持">特性拓展支持</h2><p>该示例需要的特性拓展支持如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">GshaderToMshader::<span class="hljs-built_in">GshaderToMshader</span>()<br>&#123;<br>	title = <span class="hljs-string">&quot;task_mesh_migration&quot;</span>;<br><br>	<span class="hljs-built_in">set_api_version</span>(VK_API_VERSION_1_1);<br>	<span class="hljs-built_in">add_device_extension</span>(VK_EXT_MESH_SHADER_EXTENSION_NAME);<br>	<span class="hljs-built_in">add_device_extension</span>(VK_KHR_SPIRV_1_4_EXTENSION_NAME);<br>	<span class="hljs-built_in">add_device_extension</span>(VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME);<br>	vkb::GLSLCompiler::<span class="hljs-built_in">set_target_environment</span>(glslang::EShTargetSpv, glslang::EShTargetSpv_1_4);<br>&#125;<br></code></pre></td></tr></table></figure><p></p><p>可以看到为了使用mesh shader，需要开启<i><font color="Red">VK_EXT_MESH_SHADER_EXTENSION_NAME</font></i>拓展，而该拓展又需要开启<i><font color="Red">VK_KHR_SPIRV_1_4_EXTENSION_NAME</font></i>拓展以支持相应的着色器编译，而该拓展又需要使用到<i><font color="Red">VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME</font></i>拓展并且需要Vulkan API版本为1.1。</p><p>然后来看<i><font color="Green">request_gpu_features</font></i>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GshaderToMshader::request_gpu_features</span><span class="hljs-params">(vkb::PhysicalDevice &amp;gpu)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">REQUEST_REQUIRED_FEATURE</span>(gpu, VkPhysicalDeviceMeshShaderFeaturesEXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT, meshShader);<br><br>	<span class="hljs-keyword">if</span> (gpu.<span class="hljs-built_in">get_features</span>().geometryShader)<br>	&#123;<br>		gpu.<span class="hljs-built_in">get_mutable_requested_features</span>().geometryShader = VK_TRUE;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到还需要开启几何着色器和mesh shader的使用特性。</p><hr><h2 id="准备阶段">准备阶段</h2><p>准备阶段代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GshaderToMshader::prepare</span><span class="hljs-params">(<span class="hljs-type">const</span> vkb::ApplicationOptions &amp;options)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (!ApiVulkanSample::<span class="hljs-built_in">prepare</span>(options))<br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	camera.type = vkb::CameraType::LookAt;<br>	camera.<span class="hljs-built_in">set_position</span>(&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-10.0f</span>&#125;);<br>	camera.<span class="hljs-built_in">set_rotation</span>(&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;);<br>	camera.<span class="hljs-built_in">set_perspective</span>(<span class="hljs-number">60.0f</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(width) / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(height), <span class="hljs-number">256.f</span>, <span class="hljs-number">0.1f</span>);<br>	camera.translation_speed = <span class="hljs-number">20.0f</span>;<br><br>	<span class="hljs-built_in">load_assets</span>();<br>	<span class="hljs-built_in">prepare_uniform_buffers</span>();<br><br>	<span class="hljs-built_in">setup_descriptor_set_layout</span>();<br>	<span class="hljs-built_in">prepare_pipelines</span>();<br><br>	<span class="hljs-built_in">setup_descriptor_pool</span>();<br>	<span class="hljs-built_in">setup_descriptor_sets</span>();<br>	<span class="hljs-built_in">build_command_buffers</span>();<br>	prepared = <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>还是一步步来分析这个函数所做的工作。</p><h3 id="load_assets">load_assets</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 	@fn void VertexDynamicState::load_assets()</span><br><span class="hljs-comment"> *	@brief Loading extra models, textures from assets</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GshaderToMshader::load_assets</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">/* Models */</span><br><br>	object = <span class="hljs-built_in">load_model</span>(<span class="hljs-string">&quot;scenes/teapot.gltf&quot;</span>);<br><br>	storage_buffer_object = <span class="hljs-built_in">load_model</span>(<span class="hljs-string">&quot;scenes/teapot.gltf&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到该函数是向程序中加载了同一个物体两次，不过加载到的位置是不同的。第二个加载函数的第三个参数设置为true实际上表明该模型顶点索引有关的信息会被加载到SSBO中而非一个顶点缓冲和索引缓冲中。mesh shader使用的顶点数据不能来源于顶点缓冲和索引缓冲，因此只能使用SSBO并通过描述符的方式绑定到着色器中供相关代码使用。</p><h3 id="prepare_uniform_buffers">prepare_uniform_buffers</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 	@fn void VertexDynamicState::prepare_uniform_buffers()</span><br><span class="hljs-comment"> * 	@brief Preparing uniform buffer (setting bits) and updating UB data</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GshaderToMshader::prepare_uniform_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	uniform_buffer_vs = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), <span class="hljs-built_in">sizeof</span>(ubos[<span class="hljs-number">0</span>]), VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, VMA_MEMORY_USAGE_CPU_TO_GPU);<br>	uniform_buffer_gs = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), <span class="hljs-built_in">sizeof</span>(ubos[<span class="hljs-number">1</span>]), VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, VMA_MEMORY_USAGE_CPU_TO_GPU);<br>	uniform_buffer_ms = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), <span class="hljs-built_in">sizeof</span>(ubos[<span class="hljs-number">2</span>]), VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, VMA_MEMORY_USAGE_CPU_TO_GPU);<br>	<span class="hljs-built_in">update_uniform_buffers</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到程序是为顶点着色器阶段、几何着色器阶段和mesh shader阶段各创建了一个UBO，但实际上它们使用到的uniform数据都是相同的，都是以下结构体中所定义的数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UBOVS</span><br>&#123;<br>	glm::mat4 model;<br>	glm::mat4 view;<br>	glm::mat4 proj;<br>&#125;;<br></code></pre></td></tr></table></figure><p>为了清晰起见程序还是为这三个阶段各创建了一个常量缓冲。</p><h3 id="setup_descriptor_set_layout">setup_descriptor_set_layout</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 	@fn void VertexDynamicState::setup_descriptor_set_layout()</span><br><span class="hljs-comment"> * 	@brief Creating layout for descriptor sets</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GshaderToMshader::setup_descriptor_set_layout</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::vector&lt;VkDescriptorSetLayoutBinding&gt; set_layout_bindings = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_SHADER_STAGE_VERTEX_BIT, <span class="hljs-number">0</span>),<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_SHADER_STAGE_GEOMETRY_BIT, <span class="hljs-number">1</span>),<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_SHADER_STAGE_MESH_BIT_EXT, <span class="hljs-number">2</span>),<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, VK_SHADER_STAGE_MESH_BIT_EXT, <span class="hljs-number">3</span>),<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, VK_SHADER_STAGE_MESH_BIT_EXT, <span class="hljs-number">4</span>)&#125;;<br><br>	VkDescriptorSetLayoutCreateInfo descriptor_layout_create_info =<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_create_info</span>(set_layout_bindings.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(set_layout_bindings.<span class="hljs-built_in">size</span>()));<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorSetLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_layout_create_info, <span class="hljs-literal">nullptr</span>, &amp;descriptor_set_layout));<br><br>	VkPipelineLayoutCreateInfo pipeline_layout_create_info =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_layout_create_info</span>(<br>	        &amp;descriptor_set_layout,<br>	        <span class="hljs-number">1</span>);<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreatePipelineLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;pipeline_layout_create_info, <span class="hljs-literal">nullptr</span>, &amp;pipeline_layout));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到整个管线总共可能使用到的描述符有5个，除了之前提到的3个常量缓冲之外，还有mesh shader阶段会使用到的两个SSBO，后续在分析mesh shader代码的时候就可以看到这两个SSBO分别存储的是模型的所有meshlet信息和所有顶点信息。</p><h3 id="prepare_pipelines">prepare_pipelines</h3><p>该函数用于创建程序可能会用到的三个管线，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GshaderToMshader::prepare_pipelines</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::array&lt;VkPipelineShaderStageCreateInfo, 2&gt; model_stages;<br>	model_stages[<span class="hljs-number">0</span>] = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;gshader_to_mshader/gshader_to_mshader.vert&quot;</span>, VK_SHADER_STAGE_VERTEX_BIT);<br>	model_stages[<span class="hljs-number">1</span>] = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;gshader_to_mshader/gshader_to_mshader.frag&quot;</span>, VK_SHADER_STAGE_FRAGMENT_BIT);<br><br>	std::array&lt;VkPipelineShaderStageCreateInfo, 3&gt; geometry_stages;<br>	geometry_stages[<span class="hljs-number">0</span>] = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;gshader_to_mshader/gshader_to_mshader_base.vert&quot;</span>, VK_SHADER_STAGE_VERTEX_BIT);<br>	geometry_stages[<span class="hljs-number">1</span>] = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;gshader_to_mshader/gshader_to_mshader_base.frag&quot;</span>, VK_SHADER_STAGE_FRAGMENT_BIT);<br>	geometry_stages[<span class="hljs-number">2</span>] = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;gshader_to_mshader/gshader_to_mshader.geom&quot;</span>, VK_SHADER_STAGE_GEOMETRY_BIT);<br><br>	<span class="hljs-comment">// task shader is not used, the amount of spawned mesh shaders is determined by amount of meshlets stored in the storage_buffer_object-&gt;vertex_indices</span><br>	std::array&lt;VkPipelineShaderStageCreateInfo, 2&gt; mesh_stages;<br>	mesh_stages[<span class="hljs-number">0</span>] = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;gshader_to_mshader/gshader_to_mshader.mesh&quot;</span>, VK_SHADER_STAGE_MESH_BIT_EXT);<br>	mesh_stages[<span class="hljs-number">1</span>] = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;gshader_to_mshader/gshader_to_mshader_mesh.frag&quot;</span>, VK_SHADER_STAGE_FRAGMENT_BIT);<br><br>	<span class="hljs-comment">// Dynamic State</span><br>	std::vector&lt;VkDynamicState&gt; dynamic_state_enables = &#123;<br>	    VK_DYNAMIC_STATE_VIEWPORT,<br>	    VK_DYNAMIC_STATE_SCISSOR,<br>	    VK_DYNAMIC_STATE_LINE_WIDTH&#125;;<br><br>	VkPipelineDynamicStateCreateInfo dynamic_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_dynamic_state_create_info</span>(<br>	        dynamic_state_enables.<span class="hljs-built_in">data</span>(),<br>	        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(dynamic_state_enables.<span class="hljs-built_in">size</span>()),<br>	        <span class="hljs-number">0</span>);<br><br>	<span class="hljs-comment">// Vertex bindings an attributes for model rendering</span><br><br>	<span class="hljs-comment">// Binding description</span><br>	<span class="hljs-comment">// Vertex structure is used here for binding description, AlignedVertex is used only in the context of a mesh shader operations</span><br>	std::vector&lt;VkVertexInputBindingDescription&gt; vertex_input_bindings = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_binding_description</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Vertex), VK_VERTEX_INPUT_RATE_VERTEX)&#125;;<br><br>	<span class="hljs-comment">// Attribute descriptions</span><br>	std::vector&lt;VkVertexInputAttributeDescription&gt; vertex_input_attributes = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, VK_FORMAT_R32G32B32_SFLOAT, <span class="hljs-built_in">offsetof</span>(Vertex, pos)),<br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, VK_FORMAT_R32G32B32_SFLOAT, <span class="hljs-built_in">offsetof</span>(Vertex, normal))&#125;;<br><br>	<span class="hljs-comment">// Vertex Input</span><br>	VkPipelineVertexInputStateCreateInfo vertex_input_state = vkb::initializers::<span class="hljs-built_in">pipeline_vertex_input_state_create_info</span>();<br>	vertex_input_state.vertexBindingDescriptionCount        = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertex_input_bindings.<span class="hljs-built_in">size</span>());<br>	vertex_input_state.pVertexBindingDescriptions           = vertex_input_bindings.<span class="hljs-built_in">data</span>();<br>	vertex_input_state.vertexAttributeDescriptionCount      = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertex_input_attributes.<span class="hljs-built_in">size</span>());<br>	vertex_input_state.pVertexAttributeDescriptions         = vertex_input_attributes.<span class="hljs-built_in">data</span>();<br><br>	<span class="hljs-comment">// Input assembly</span><br>	VkPipelineInputAssemblyStateCreateInfo input_assembly_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_input_assembly_state_create_info</span>(<br>	        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,<br>	        <span class="hljs-number">0</span>,<br>	        VK_FALSE);<br><br>	<span class="hljs-comment">// Viewwport and scissors</span><br>	VkPipelineViewportStateCreateInfo viewport_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_viewport_state_create_info</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><br>	<span class="hljs-comment">// Rasterizer</span><br>	VkPipelineRasterizationStateCreateInfo rasterization_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_rasterization_state_create_info</span>(<br>	        VK_POLYGON_MODE_FILL,<br>	        VK_CULL_MODE_NONE,<br>	        VK_FRONT_FACE_CLOCKWISE,<br>	        <span class="hljs-number">0</span>);<br><br>	rasterization_state.depthBiasConstantFactor = <span class="hljs-number">1.0f</span>;<br>	rasterization_state.depthBiasSlopeFactor    = <span class="hljs-number">1.0f</span>;<br><br>	<span class="hljs-comment">// Multisampling</span><br>	VkPipelineMultisampleStateCreateInfo multisample_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_multisample_state_create_info</span>(<br>	        VK_SAMPLE_COUNT_1_BIT,<br>	        <span class="hljs-number">0</span>);<br>	multisample_state.minSampleShading = <span class="hljs-number">1.0f</span>;<br><br>	<span class="hljs-comment">// Color Blending</span><br>	VkPipelineColorBlendAttachmentState blend_attachment_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_color_blend_attachment_state</span>(<br>	        <span class="hljs-number">0xf</span>,<br>	        VK_FALSE);<br><br>	VkPipelineColorBlendStateCreateInfo color_blend_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_color_blend_state_create_info</span>(<br>	        <span class="hljs-number">1</span>,<br>	        &amp;blend_attachment_state);<br><br>	<span class="hljs-comment">// Depth Stencil</span><br>	VkPipelineDepthStencilStateCreateInfo depth_stencil_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_depth_stencil_state_create_info</span>(<br>	        VK_TRUE,<br>	        VK_TRUE,<br>	        VK_COMPARE_OP_GREATER);<br><br>	<span class="hljs-comment">// Pipeline layout made in descriptors layout</span><br><br>	<span class="hljs-comment">// Graphics Pipeline</span><br>	VkGraphicsPipelineCreateInfo pipeline_create_info =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_create_info</span>(<br>	        pipeline_layout,<br>	        render_pass,<br>	        <span class="hljs-number">0</span>);<br>	pipeline_create_info.pStages             = model_stages.<span class="hljs-built_in">data</span>();<br>	pipeline_create_info.stageCount          = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(model_stages.<span class="hljs-built_in">size</span>());<br>	pipeline_create_info.pVertexInputState   = &amp;vertex_input_state;<br>	pipeline_create_info.pInputAssemblyState = &amp;input_assembly_state;<br>	pipeline_create_info.pViewportState      = &amp;viewport_state;<br>	pipeline_create_info.pRasterizationState = &amp;rasterization_state;<br>	pipeline_create_info.pMultisampleState   = &amp;multisample_state;<br>	pipeline_create_info.pDepthStencilState  = &amp;depth_stencil_state;<br>	pipeline_create_info.pColorBlendState    = &amp;color_blend_state;<br>	pipeline_create_info.pDynamicState       = &amp;dynamic_state;<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateGraphicsPipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;model_pipeline));<br><br>	pipeline_create_info.pStages    = geometry_stages.<span class="hljs-built_in">data</span>();<br>	pipeline_create_info.stageCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(geometry_stages.<span class="hljs-built_in">size</span>());<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateGraphicsPipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;geometry_pipeline));<br><br>	pipeline_create_info.pStages    = mesh_stages.<span class="hljs-built_in">data</span>();<br>	pipeline_create_info.stageCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(mesh_stages.<span class="hljs-built_in">size</span>());<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateGraphicsPipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;mesh_pipeline));<br>&#125;<br></code></pre></td></tr></table></figure><p></p><p>首先指定了这三个管线分别会使用到的着色器。第一个管线用于渲染正常的场景，其着色器代码就是一个简单的Blinn-phong着色，这里不再放上有关代码，有兴趣的读者可以自行阅读相关材料。第二个管线是使用几何着色器来绘制物体的法线图，这部分内容在<a target="_blank" rel="noopener" href="https://learnopengl.com/Advanced-OpenGL/Geometry-Shader"><code>LearnOpenGL</code></a>中有十分详细的教程，对于几何着色器不太熟悉的读者可以辅助该教程进行着色器代码的阅读。法线绘制管线使用到的着色器代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//vertex shader</span><br><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inNormal;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> outNormal;<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>)<br>&#123;<br>	outNormal = inNormal;<br>	<span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(inPos.xyz, <span class="hljs-number">1.0</span>f);<br>&#125;<br><br><span class="hljs-comment">//geometry shader</span><br><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">triangles</span>) <span class="hljs-keyword">in</span>;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">line_strip</span>, <span class="hljs-keyword">max_vertices</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">out</span>;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">uniform</span> UniformBufferObject &#123;<br>    <span class="hljs-type">mat4</span> model;<br>    <span class="hljs-type">mat4</span> view;<br>    <span class="hljs-type">mat4</span> proj;<br>&#125; ubo;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inNormal[];<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> outColor;<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>)<br>&#123;<br>    <span class="hljs-type">float</span> normalLength = <span class="hljs-number">0.1</span>f;<br><br>    <span class="hljs-comment">//middle point of triangle</span><br>    <span class="hljs-type">vec3</span> pos = (<span class="hljs-built_in">gl_in</span>[<span class="hljs-number">0</span>].<span class="hljs-built_in">gl_Position</span>.xyz + <span class="hljs-built_in">gl_in</span>[<span class="hljs-number">1</span>].<span class="hljs-built_in">gl_Position</span>.xyz + <span class="hljs-built_in">gl_in</span>[<span class="hljs-number">2</span>].<span class="hljs-built_in">gl_Position</span>.xyz)/<span class="hljs-number">3.0</span>f;<br>    <span class="hljs-type">vec3</span> normal = inNormal[<span class="hljs-number">0</span>].xyz;<br><br>    <span class="hljs-comment">//line vertices</span><br>    <span class="hljs-built_in">gl_Position</span> = ubo.proj * ubo.view * ubo.model * <span class="hljs-type">vec4</span>(pos, <span class="hljs-number">1.0</span>f);<br>    outColor = <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>f, <span class="hljs-number">0.0</span>f, <span class="hljs-number">0.0</span>f);<br>    <span class="hljs-built_in">EmitVertex</span>();<br><br>    <span class="hljs-built_in">gl_Position</span> = ubo.proj * ubo.view * ubo.model * <span class="hljs-type">vec4</span>(pos + normal * normalLength, <span class="hljs-number">1.0</span>f);<br>    outColor = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>f, <span class="hljs-number">0.0</span>f, <span class="hljs-number">1.0</span>f);<br>    <span class="hljs-built_in">EmitVertex</span>();<br><br>    <span class="hljs-built_in">EndPrimitive</span>();<br>&#125;<br><br><span class="hljs-comment">//fragment shader</span><br><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inColor;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outFragColor;<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>)<br>&#123;<br>	outFragColor = <span class="hljs-type">vec4</span>(inColor, <span class="hljs-number">1.0</span>f);<br>&#125;<br></code></pre></td></tr></table></figure><p>顶点着色器的作用仅仅将法线和位置信息传递给几何着色器阶段处理。</p><p>几何着色器阶段的逻辑就是对于每个三角形面，输出该面的法线，法线可视化的步骤是确定法线的起点（三角形面中心）和终点（沿该面法线方向向外一段距离），然后连接成一条线段输出即可。该代码还输出逐顶点的颜色信息。</p><p>最后的片段着色器只是简单地将几何着色器传递给它的经过光栅化插值后的颜色信息输出到后台缓冲区上。</p><p>第三个管线使用mesh shader来进行法线的绘制，片段着色器代码和第二个管线的片段着色器代码几乎一致，都只是输出上一个着色器阶段确定好的颜色，这里不再放上有关代码，重点来看mesh shader的代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><span class="hljs-meta">#extension GL_EXT_mesh_shader : require</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">local_size_x</span> = <span class="hljs-number">1</span>, <span class="hljs-keyword">local_size_y</span> = <span class="hljs-number">1</span>, <span class="hljs-keyword">local_size_z</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span>;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">lines</span>, <span class="hljs-keyword">max_vertices</span> = <span class="hljs-number">64</span>, max_primitives = <span class="hljs-number">126</span>) <span class="hljs-keyword">out</span>;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">std140</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">uniform</span> UniformBufferObject <br>&#123;<br>    <span class="hljs-type">mat4</span> model;<br>    <span class="hljs-type">mat4</span> view;<br>    <span class="hljs-type">mat4</span> proj;<br>&#125; ubo;<br><br><br>struct s_vertex<br>&#123;<br>	<span class="hljs-type">vec4</span> position;<br>	<span class="hljs-type">vec4</span> normal;<br>&#125;;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">std430</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">4</span>) <span class="hljs-keyword">buffer</span> _vertices<br>&#123;<br>  s_vertex <span class="hljs-keyword">vertices</span>[];<br>&#125; vb;<br><br><br>struct s_meshlet<br>&#123;<br>  <span class="hljs-type">uint</span> <span class="hljs-keyword">vertices</span>[<span class="hljs-number">64</span>];<br>  <span class="hljs-type">uint</span> indices[<span class="hljs-number">126</span>];<br>  <span class="hljs-type">uint</span> vertex_count;<br>  <span class="hljs-type">uint</span> index_count;<br>&#125;;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">std430</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">buffer</span> _meshlets<br>&#123;<br>  s_meshlet meshlets[];<br>&#125; mbuf;<br><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> PerVertexData<br>&#123;<br>  <span class="hljs-type">vec4</span> color;<br>&#125; v_out[];<br><br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>)<br>&#123;<br>  <span class="hljs-type">uint</span> meshlet_index = <span class="hljs-built_in">gl_WorkGroupID</span>.x;<br>  <span class="hljs-type">uint</span> thread_id = <span class="hljs-built_in">gl_LocalInvocationID</span>.x;<br>  <span class="hljs-type">uint</span> vertex_count = mbuf.meshlets[meshlet_index].vertex_count;<br>  <span class="hljs-type">uint</span> index_count = mbuf.meshlets[meshlet_index].index_count;<br>  <span class="hljs-type">uint</span> primitive_count = index_count/<span class="hljs-number">3</span>;<br>  SetMeshOutputsEXT( primitive_count * <span class="hljs-number">2</span>, primitive_count);<br><br>  <span class="hljs-type">float</span> normalLength = <span class="hljs-number">0.1</span>f;<br><br>  <span class="hljs-type">mat4</span> MVP = ubo.proj * ubo.view * ubo.model;<br><br>  <span class="hljs-type">uint</span> j = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">uint</span> k = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint</span> i = <span class="hljs-number">0</span>; i &lt; primitive_count; ++i)<br>  &#123;<br>    <span class="hljs-comment">//triangle indices</span><br>    <span class="hljs-type">uint</span> vi1 = mbuf.meshlets[meshlet_index].indices[j];<br>    <span class="hljs-type">uint</span> vi2 = mbuf.meshlets[meshlet_index].indices[j + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">uint</span> vi3 = mbuf.meshlets[meshlet_index].indices[j + <span class="hljs-number">2</span>];<br><br>    <span class="hljs-comment">//middle point of triangle</span><br>    <span class="hljs-type">vec3</span> pos = (vb.<span class="hljs-keyword">vertices</span>[vi1].position.xyz + vb.<span class="hljs-keyword">vertices</span>[vi2].position.xyz + vb.<span class="hljs-keyword">vertices</span>[vi3].position.xyz)/<span class="hljs-number">3.0</span>f;<br>    <span class="hljs-type">vec3</span> normal = vb.<span class="hljs-keyword">vertices</span>[vi1].normal.xyz;<br>   <br>    <span class="hljs-comment">//line vertices</span><br>    gl_MeshVerticesEXT[k].<span class="hljs-built_in">gl_Position</span> = MVP * <span class="hljs-type">vec4</span>(pos ,<span class="hljs-number">1.0</span>f);<br>    v_out[k].color = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>f, <span class="hljs-number">0.0</span>f, <span class="hljs-number">1.0</span>f, <span class="hljs-number">1.0</span>f);<br><br>    gl_MeshVerticesEXT[k + <span class="hljs-number">1</span>].<span class="hljs-built_in">gl_Position</span> = MVP * <span class="hljs-type">vec4</span>(pos + normal * normalLength, <span class="hljs-number">1.0</span>f);<br>    v_out[k + <span class="hljs-number">1</span>].color = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>f, <span class="hljs-number">0.0</span>f, <span class="hljs-number">0.0</span>f, <span class="hljs-number">1.0</span>f);<br><br>    k = k + <span class="hljs-number">2</span>;<br>    j= j + <span class="hljs-number">3</span>;<br>  &#125;<br><br>  <span class="hljs-comment">//indices for line vertices</span><br>  k = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint</span> i = <span class="hljs-number">0</span>; i &lt; primitive_count; i++)<br>  &#123;<br>    gl_PrimitiveLineIndicesEXT[i] =  <span class="hljs-type">uvec2</span>(k,k+<span class="hljs-number">1</span>);<br>    k = k + <span class="hljs-number">2</span>;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>首先需要在开头指定启用拓展<code>GL_EXT_mesh_shader</code>，接下来需要指定该mesh shader工作组的大小。和compute shader一样，mesh shader和task shader也需要在调用的时候确定需要调用的工作组数目，然后在着色器中指定每个工作组的大小。一般来讲，同时使用task shader和mesh shader时，一个task shader的调用负责一个meshlet的处理，并且该invocation会启用一组mesh shader，这组mesh shader中的每个invocation又会负责meshlet中一个三角形或顶点数据的处理。不过本示例并没有使用到task shader，因此其逻辑就是每个mesh shader的调用直接处理一个meshlet，这也是代码中将三个维度的local size均设置为1的原因。</p><p>在mesh shader中还需要指定输出的几何图元类型（点、线段或三角形）以及一个工作组的最大输出顶点数以及图元数（一般这两个数推荐设置为64和126，之所以图元数比顶点数还要多，是因为顶点往往可以复用，比如绘制一个正方体，只需要8个顶点，却需要12个三角形图元）。之后，着色器代码指定了绑定的UBO以及包含顶点和meshlet数据的SSBO，其中meshlet数据中包含了该meshlet包含的顶点和索引数据以及它们的总数。最后，着色器指定输出逐顶点的颜色。由于mesh shader的一次调用输出的往往是一系列的构成图元的顶点，所以它输出的顶点属性也应该是一个数组的形式。</p><p>然后来看着色器的主函数代码：首先，每个工作组内都必须至少有一个mesh shader的调用通过<code>SetMeshOutputsEXT</code>指定该工作组输出的顶点总数和图元总数，这个数量一定不能大于之前设置的最大顶点和最大图元的数目。可以看到代码中将图元总数设置为该次调用处理的meshlet顶点索引总数除以3（因为每3个顶点构成一个三角形），并且由于输出的是法线，是线段图元，因此顶点总数设置为该图元数乘以2。另外需要注意，只有使用<code>SetMeshOutputsEXT</code>指定了输出顶点和图元数量之后，才能使用着色器内置的一些输出结构体（如之后的<code>gl_MeshVerticesEXT</code>、<code>gl_PrimitiveLineIndicesEXT</code>结构体等）。</p><p>接下来就是常规的法线顶点位置计算过程。不过需要注意的是这里需要将顶点的NDC位置传递到<code>gl_MeshVerticesEXT</code>结构体中，这个结构体用于存储该meshlet中的逐顶点信息，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">out gl_MeshVerticesEXT &#123;<br>        vec4  gl_Position;<br>        <span class="hljs-type">float</span> gl_PointSize;<br>        <span class="hljs-type">float</span> gl_ClipDistance[];<br>        <span class="hljs-type">float</span> gl_CullDistance[];<br>      &#125; gl_MeshVerticesEXT[];<br></code></pre></td></tr></table></figure><p>最后，着色器还需要通过<code>gl_Primitive*IndicesEXT</code>输出数组来指定每个输出图元的顶点索引（这里的*可以是Point、Line或者Triangle），这个输出数组的每个元素都是一个索引向量，其中的索引就对应于<code>gl_MeshVerticesEXT</code>数组中的元素索引。</p><p>更详细的mesh shader拓展介绍可以阅读<a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_mesh_shader.txt#L999"><code>官方文档</code></a>。</p><p>回到<i><font color="Green">prepare_pipelines</font></i>函数。在指定好每个管线的着色器阶段之后，代码指定了管线动态阶段信息，其中除了常见的视口和裁剪矩形动态区域之外，还指定了线段宽度状态为动态阶段，这就意味着在录制命令的时候可以直接通过<code>vkCmdSetLineWidth</code>来指定线段的粗细。</p><p>接下来就是常规的设置管线的所有固定阶段，需要注意的是，尽管使用mesh shader的管线也指定了顶点输入和布局，但事实上这个信息会被GPU驱动直接忽略掉。</p><h3 id="setup_descriptor_pool">setup_descriptor_pool</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 	@fn void VertexDynamicState::create_descriptor_pool()</span><br><span class="hljs-comment"> * 	@brief Creating descriptor pool with size adjusted to use uniform buffer and image sampler</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GshaderToMshader::setup_descriptor_pool</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::vector&lt;VkDescriptorPoolSize&gt; pool_sizes = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_pool_size</span>(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">3</span>),<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_pool_size</span>(VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, <span class="hljs-number">2</span>)&#125;;<br><br>	VkDescriptorPoolCreateInfo descriptor_pool_create_info =<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_pool_create_info</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(pool_sizes.<span class="hljs-built_in">size</span>()), pool_sizes.<span class="hljs-built_in">data</span>(), <span class="hljs-number">1</span>);<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorPool</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_pool_create_info, <span class="hljs-literal">nullptr</span>, &amp;descriptor_pool));<br>&#125;<br></code></pre></td></tr></table></figure><p>所有管线总共需要使用到三个uniform buffer和两个storage buffer，只需要指定一个描述符集就可以了，这个描述符集将绑定的所有的着色器资源，然后每个管线的着色器都会绑定这个描述符集中的一部分描述符。</p><h3 id="setup_descriptor_sets">setup_descriptor_sets</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 	@fn void VertexDynamicState::create_descriptor_sets()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GshaderToMshader::setup_descriptor_sets</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	VkDescriptorSetAllocateInfo alloc_info =<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_allocate_info</span>(<br>	        descriptor_pool,<br>	        &amp;descriptor_set_layout,<br>	        <span class="hljs-number">1</span>);<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;alloc_info, &amp;descriptor_set));<br><br>	VkDescriptorBufferInfo vs_ubo_descriptor   = <span class="hljs-built_in">create_descriptor</span>(*uniform_buffer_vs);<br>	VkDescriptorBufferInfo gs_ubo_descriptor   = <span class="hljs-built_in">create_descriptor</span>(*uniform_buffer_gs);<br>	VkDescriptorBufferInfo ms_ubo_descriptor   = <span class="hljs-built_in">create_descriptor</span>(*uniform_buffer_ms);<br>	VkDescriptorBufferInfo meshlet_descriptor  = <span class="hljs-built_in">create_descriptor</span>(*storage_buffer_object-&gt;index_buffer);<br>	VkDescriptorBufferInfo vertices_descriptor = <span class="hljs-built_in">create_descriptor</span>(storage_buffer_object-&gt;vertex_buffers.<span class="hljs-built_in">at</span>(<span class="hljs-string">&quot;vertex_buffer&quot;</span>));<br><br>	std::vector&lt;VkWriteDescriptorSet&gt; write_descriptor_sets = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_set, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">0</span>, &amp;vs_ubo_descriptor),<br>	    vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_set, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">1</span>, &amp;gs_ubo_descriptor),<br>	    vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_set, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">2</span>, &amp;ms_ubo_descriptor),<br>	    vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_set, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, <span class="hljs-number">3</span>, &amp;meshlet_descriptor),<br>	    vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_set, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, <span class="hljs-number">4</span>, &amp;vertices_descriptor)&#125;;<br><br>	<span class="hljs-built_in">vkUpdateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(write_descriptor_sets.<span class="hljs-built_in">size</span>()), write_descriptor_sets.<span class="hljs-built_in">data</span>(), <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数就是指定描述符集绑定的所有资源，逻辑十分常规，不再赘述。</p><h3 id="build_command_buffers">build_command_buffers</h3><p>录制命令代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GshaderToMshader::build_command_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	VkCommandBufferBeginInfo command_buffer_begin_info = vkb::initializers::<span class="hljs-built_in">command_buffer_begin_info</span>();<br><br>	VkClearValue clear_values[<span class="hljs-number">2</span>];<br>	clear_values[<span class="hljs-number">0</span>].color        = default_clear_color;<br>	clear_values[<span class="hljs-number">1</span>].depthStencil = &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0</span>&#125;;<br><br>	VkRenderPassBeginInfo render_pass_begin_info    = vkb::initializers::<span class="hljs-built_in">render_pass_begin_info</span>();<br>	render_pass_begin_info.renderPass               = render_pass;<br>	render_pass_begin_info.renderArea.offset.x      = <span class="hljs-number">0</span>;<br>	render_pass_begin_info.renderArea.offset.y      = <span class="hljs-number">0</span>;<br>	render_pass_begin_info.renderArea.extent.width  = width;<br>	render_pass_begin_info.renderArea.extent.height = height;<br>	render_pass_begin_info.clearValueCount          = <span class="hljs-number">2</span>;<br>	render_pass_begin_info.pClearValues             = clear_values;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int32_t</span>&gt;(draw_cmd_buffers.<span class="hljs-built_in">size</span>()); ++i)<br>	&#123;<br>		render_pass_begin_info.framebuffer = framebuffers[i];<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBeginCommandBuffer</span>(draw_cmd_buffers[i], &amp;command_buffer_begin_info));<br><br>		<span class="hljs-built_in">vkCmdBeginRenderPass</span>(draw_cmd_buffers[i], &amp;render_pass_begin_info, VK_SUBPASS_CONTENTS_INLINE);<br><br>		VkViewport viewport = vkb::initializers::<span class="hljs-built_in">viewport</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(height), <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br>		<span class="hljs-built_in">vkCmdSetViewport</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;viewport);<br><br>		VkRect2D scissor = vkb::initializers::<span class="hljs-built_in">rect2D</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(height), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>		<span class="hljs-built_in">vkCmdSetScissor</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;scissor);<br><br>		<span class="hljs-built_in">vkCmdSetLineWidth</span>(draw_cmd_buffers[i], <span class="hljs-number">1.0f</span>);<br><br>		<span class="hljs-built_in">vkCmdBindDescriptorSets</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline_layout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;descriptor_set, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br><br>		<span class="hljs-built_in">vkCmdBindPipeline</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, model_pipeline);<br><br>		<span class="hljs-built_in">draw_model</span>(object, draw_cmd_buffers[i]);<br><br>		<span class="hljs-keyword">if</span> (showNormalsGeo)<br>		&#123;<br>			<span class="hljs-built_in">vkCmdBindPipeline</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, geometry_pipeline);<br>			<span class="hljs-built_in">draw_model</span>(object, draw_cmd_buffers[i]);<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> (showNormalsMesh)<br>		&#123;<br>			<span class="hljs-built_in">vkCmdBindPipeline</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, mesh_pipeline);<br>			<span class="hljs-type">uint32_t</span> num_workgroups_x = storage_buffer_object-&gt;vertex_indices;        <span class="hljs-comment">// meshlets count</span><br>			<span class="hljs-type">uint32_t</span> num_workgroups_y = <span class="hljs-number">1</span>;<br>			<span class="hljs-type">uint32_t</span> num_workgroups_z = <span class="hljs-number">1</span>;<br>			<span class="hljs-built_in">vkCmdDrawMeshTasksEXT</span>(draw_cmd_buffers[i], num_workgroups_x, num_workgroups_y, num_workgroups_z);<br>		&#125;<br><br>		<span class="hljs-built_in">draw_ui</span>(draw_cmd_buffers[i]);<br><br>		<span class="hljs-built_in">vkCmdEndRenderPass</span>(draw_cmd_buffers[i]);<br><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkEndCommandBuffer</span>(draw_cmd_buffers[i]));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p></p><p>整个命令录制就是常规的渲染录制流程，先绘制正常的物体，再根据用户的选择决定是否通过几何着色器或者mesh shader来绘制物体法线图，最后绘制UI界面。这里只需要注意使用mesh shader的绘制命令要通过<code>vkCmdDrawMeshTasksEXT</code>指定，该函数会指定各个维度工作组的数量。</p><hr><h2 id="绘制阶段">绘制阶段</h2><p>该阶段的代码十分常规，在我之前的分析文章中也已经屡见不鲜，这里不再赘述，仅放上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 	@fn void VertexDynamicState::render(float delta_time)</span><br><span class="hljs-comment"> * 	@brief Drawing frames and/or updating uniform buffers when camera position/rotation was changed</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GshaderToMshader::render</span><span class="hljs-params">(<span class="hljs-type">float</span> delta_time)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (!prepared)<br>	&#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-built_in">draw</span>();<br>	<span class="hljs-keyword">if</span> (camera.updated)<br>	&#123;<br>		<span class="hljs-built_in">update_uniform_buffers</span>();<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 	@fn void VertexDynamicState::draw()</span><br><span class="hljs-comment"> *  @brief Preparing frame and submitting it to the present queue</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GshaderToMshader::draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	ApiVulkanSample::<span class="hljs-built_in">prepare_frame</span>();<br>	submit_info.commandBufferCount = <span class="hljs-number">1</span>;<br>	submit_info.pCommandBuffers    = &amp;draw_cmd_buffers[current_buffer];<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkQueueSubmit</span>(queue, <span class="hljs-number">1</span>, &amp;submit_info, VK_NULL_HANDLE));<br>	ApiVulkanSample::<span class="hljs-built_in">submit_frame</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>整个示例的分析到此结束！</p><hr></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/CG-api/" class="category-chain-item">CG_api</a> <span>></span> <a href="/categories/CG-api/vulkan/" class="category-chain-item">vulkan</a> <span>></span> <a href="/categories/CG-api/vulkan/vulkan-samples/" class="category-chain-item">vulkan_samples</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>Gshader to Mshader</div><div>http://example.com/2025/03/20/CG_api/vulkan/vulkan_samples/gshader_to_mshader/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>ZPC-dsg</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年3月20日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2025/03/20/CG_api/vulkan/vulkan_samples/mesh_shader_culling/" title="Mesh shader culling"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Mesh shader culling</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2025/03/16/CG_api/vulkan/vulkan_samples/fragment_shading_rate_dynamic/" title="Fragment shading rate dynamic"><span class="hidden-mobile">Fragment shading rate dynamic</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>