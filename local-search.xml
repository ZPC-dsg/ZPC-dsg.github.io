<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>post</title>
    <link href="/2025/03/07/CG_api/d3d12/directX_samples/D3D12Multithreading/"/>
    <url>/2025/03/07/CG_api/d3d12/directX_samples/D3D12Multithreading/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言">前言</h2><p>从本篇文章开始，我将逐一梳理D3D12官方示例集中的示例，并且开始<strong>miniengine</strong>的分析。这是该系列的第一篇文章，主题是D3D12中的多线程渲染。</p><p>本示例以及其它示例的代码读者可以在微软的<a href="https://github.com/microsoft/DirectX-Graphics-Samples"><code>DirectX-Graphics-Samples</code></a>中找到。</p><p>下面闲话少说，开始我们的探索！</p><hr><h2 id="效果">效果</h2><p>首先看一下程序的运行效果（不知道为啥录出来有黑框，将就着看看。。。）：</p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"loop":"yes","screenshot":"yes","video":{"url":"/2025/03/07/CG_api/d3d12/directX_samples/D3D12Multithreading/multithreading.mp4"},"danmaku":{"api":"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><hr><h2 id="程序入口">程序入口</h2><p>程序入口点位于<strong>Main.cpp</strong>中，启动代码十分简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;D3D12Multithreading.h&quot;</span></span><br><br><span class="hljs-function">_Use_decl_annotations_</span><br><span class="hljs-function"><span class="hljs-type">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE, LPSTR, <span class="hljs-type">int</span> nCmdShow)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">D3D12Multithreading <span class="hljs-title">sample</span><span class="hljs-params">(<span class="hljs-number">1280</span>, <span class="hljs-number">720</span>, <span class="hljs-string">L&quot;D3D12 Multithreading Sample&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> Win32Application::<span class="hljs-built_in">Run</span>(&amp;sample, hInstance, nCmdShow);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>WinMain</strong>是Windows图形窗口程序的入口点，<i><font color="Red">WINAPI</font></i>是该函数调用必须使用的关键字，一般定义为**__stdcall<strong>，指定了函数参数在调用堆栈中的顺序，它指定参数传递顺序为从右到左，不过在ARM和x64处理器上，该关键字会被编译器忽略，这些架构上是统一采用</strong>__fastcall**约定的。有关这部分的细节可以参考微软的<a href="https://learn.microsoft.com/zh-cn/cpp/cpp/stdcall?view=msvc-170"><code>官方文档</code></a>。</p><p>可以看到主函数的逻辑就是创建一个应用程序类对象，然后调用该程序类基类<strong>Win32Application</strong>的<i><font color="Green">Run</font></i>静态函数执行渲染主逻辑以及处理一切窗口信息。首先来看应用程序类<code>D3D12Multithreading</code>的构造函数做了什么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">D3D12Multithreading::<span class="hljs-built_in">D3D12Multithreading</span>(UINT width, UINT height, std::wstring name) :<br>    <span class="hljs-built_in">DXSample</span>(width, height, name),<br>    <span class="hljs-built_in">m_frameIndex</span>(<span class="hljs-number">0</span>),<br>    <span class="hljs-built_in">m_viewport</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(height)),<br>    <span class="hljs-built_in">m_scissorRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">static_cast</span>&lt;LONG&gt;(width), <span class="hljs-built_in">static_cast</span>&lt;LONG&gt;(height)),<br>    <span class="hljs-built_in">m_keyboardInput</span>(),<br>    <span class="hljs-built_in">m_titleCount</span>(<span class="hljs-number">0</span>),<br>    <span class="hljs-built_in">m_cpuTime</span>(<span class="hljs-number">0</span>),<br>    <span class="hljs-built_in">m_fenceValue</span>(<span class="hljs-number">0</span>),<br>    <span class="hljs-built_in">m_rtvDescriptorSize</span>(<span class="hljs-number">0</span>),<br>    <span class="hljs-built_in">m_currentFrameResourceIndex</span>(<span class="hljs-number">0</span>),<br>    <span class="hljs-built_in">m_pCurrentFrameResource</span>(<span class="hljs-literal">nullptr</span>)<br>&#123;<br>    s_app = <span class="hljs-keyword">this</span>;<br><br>    m_keyboardInput.animate = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">DXGIDeclareAdapterRemovalSupport</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">s_app</font></i>是一个指向该类的静态指针成员，将其初始化为指向当前创建的类实例。之后设置动画效果为开启状态，具体而言在该示例中开启动画效果会使得场景内灯光处于不断变化的状态，代码对应于<i><font color="Orange">OnUpdate</font></i>函数中的这一段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (m_keyboardInput.animate)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NumLights; i++)<br>    &#123;<br>        <span class="hljs-type">float</span> direction = frameChange * <span class="hljs-built_in">pow</span>(<span class="hljs-number">-1.0f</span>, i);<br>        <span class="hljs-built_in">XMStoreFloat4</span>(&amp;m_lights[i].position, <span class="hljs-built_in">XMVector4Transform</span>(<span class="hljs-built_in">XMLoadFloat4</span>(&amp;m_lights[i].position), <span class="hljs-built_in">XMMatrixRotationY</span>(direction)));<br><br>        XMVECTOR eye = <span class="hljs-built_in">XMLoadFloat4</span>(&amp;m_lights[i].position);<br>        XMVECTOR at = <span class="hljs-built_in">XMVectorSet</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">8.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>);<br>        <span class="hljs-built_in">XMStoreFloat4</span>(&amp;m_lights[i].direction, <span class="hljs-built_in">XMVector3Normalize</span>(<span class="hljs-built_in">XMVectorSubtract</span>(at, eye)));<br>        XMVECTOR up = <span class="hljs-built_in">XMVectorSet</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>);<br>        m_lightCameras[i].<span class="hljs-built_in">Set</span>(eye, at, up);<br><br>        m_lightCameras[i].<span class="hljs-built_in">Get3DViewProjMatrices</span>(&amp;m_lights[i].view, &amp;m_lights[i].projection, <span class="hljs-number">90.0f</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(m_width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(m_height));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后调用<strong>DXGIDeclareAdapterRemovalSupport</strong>函数，该函数一般用于应用程序初始化阶段，用于声明适配器的移除支持，该函数允许应用程序声明它支持适配器移除。这在使用<strong>可热插拔的图形硬件</strong>（热插拔的图形硬件是指能够在计算机运行时动态连接或断开，而无需重启系统或关闭应用程序的图形处理单元）时尤其重要，比如在某些笔记本电脑或外部GPU 设备上。</p><p>那么接下来就开始探究主渲染函数<i><font color="Green">Run</font></i>的逻辑。首先上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Win32Application::Run</span><span class="hljs-params">(DXSample* pSample, HINSTANCE hInstance, <span class="hljs-type">int</span> nCmdShow)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Parse the command line parameters</span><br>    <span class="hljs-type">int</span> argc;<br>    LPWSTR* argv = <span class="hljs-built_in">CommandLineToArgvW</span>(<span class="hljs-built_in">GetCommandLineW</span>(), &amp;argc);<br>    pSample-&gt;<span class="hljs-built_in">ParseCommandLineArgs</span>(argv, argc);<br>    <span class="hljs-built_in">LocalFree</span>(argv);<br><br>    <span class="hljs-comment">// Initialize the window class.</span><br>    WNDCLASSEX windowClass = &#123; <span class="hljs-number">0</span> &#125;;<br>    windowClass.cbSize = <span class="hljs-built_in">sizeof</span>(WNDCLASSEX);<br>    windowClass.style = CS_HREDRAW | CS_VREDRAW;<br>    windowClass.lpfnWndProc = WindowProc;<br>    windowClass.hInstance = hInstance;<br>    windowClass.hCursor = <span class="hljs-built_in">LoadCursor</span>(<span class="hljs-literal">NULL</span>, IDC_ARROW);<br>    windowClass.lpszClassName = <span class="hljs-string">L&quot;DXSampleClass&quot;</span>;<br>    <span class="hljs-built_in">RegisterClassEx</span>(&amp;windowClass);<br><br>    RECT windowRect = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">static_cast</span>&lt;LONG&gt;(pSample-&gt;<span class="hljs-built_in">GetWidth</span>()), <span class="hljs-built_in">static_cast</span>&lt;LONG&gt;(pSample-&gt;<span class="hljs-built_in">GetHeight</span>()) &#125;;<br>    <span class="hljs-built_in">AdjustWindowRect</span>(&amp;windowRect, WS_OVERLAPPEDWINDOW, FALSE);<br><br>    <span class="hljs-comment">// Create the window and store a handle to it.</span><br>    m_hwnd = <span class="hljs-built_in">CreateWindow</span>(<br>        windowClass.lpszClassName,<br>        pSample-&gt;<span class="hljs-built_in">GetTitle</span>(),<br>        WS_OVERLAPPEDWINDOW,<br>        CW_USEDEFAULT,<br>        CW_USEDEFAULT,<br>        windowRect.right - windowRect.left,<br>        windowRect.bottom - windowRect.top,<br>        <span class="hljs-literal">nullptr</span>,        <span class="hljs-comment">// We have no parent window.</span><br>        <span class="hljs-literal">nullptr</span>,        <span class="hljs-comment">// We aren&#x27;t using menus.</span><br>        hInstance,<br>        pSample);<br><br>    <span class="hljs-comment">// Initialize the sample. OnInit is defined in each child-implementation of DXSample.</span><br>    pSample-&gt;<span class="hljs-built_in">OnInit</span>();<br><br>    <span class="hljs-built_in">ShowWindow</span>(m_hwnd, nCmdShow);<br><br>    <span class="hljs-comment">// Main sample loop.</span><br>    MSG msg = &#123;&#125;;<br>    <span class="hljs-keyword">while</span> (msg.message != WM_QUIT)<br>    &#123;<br>        <span class="hljs-comment">// Process any messages in the queue.</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">PeekMessage</span>(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, PM_REMOVE))<br>        &#123;<br>            <span class="hljs-built_in">TranslateMessage</span>(&amp;msg);<br>            <span class="hljs-built_in">DispatchMessage</span>(&amp;msg);<br>        &#125;<br>    &#125;<br><br>    pSample-&gt;<span class="hljs-built_in">OnDestroy</span>();<br><br>    <span class="hljs-comment">// Return this part of the WM_QUIT message to Windows.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(msg.wParam);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先调用WinAPI函数<code>GetCommandLineW</code>获取命令行字符串（返回结果为宽字符<strong>LPCWSTR</strong>，这里C代表只读，即constant），然后调用<code>CommandLineToArgvW</code>将命令行字符串解析为一个参数数组，并且填写参数数组中的元素个数<i><font color="Orange">argc</font></i>。接下来调用应用程序类基类<code>DXSample</code>的<i><font color="Green">ParseCommandLineArgs</font></i>方法解析命令行输入的字符串，解析部分代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Helper function for parsing any supplied command line args.</span><br><span class="hljs-function">_Use_decl_annotations_</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DXSample::ParseCommandLineArgs</span><span class="hljs-params">(WCHAR* argv[], <span class="hljs-type">int</span> argc)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (_wcsnicmp(argv[i], <span class="hljs-string">L&quot;-warp&quot;</span>, <span class="hljs-built_in">wcslen</span>(argv[i])) == <span class="hljs-number">0</span> || <br>            _wcsnicmp(argv[i], <span class="hljs-string">L&quot;/warp&quot;</span>, <span class="hljs-built_in">wcslen</span>(argv[i])) == <span class="hljs-number">0</span>)<br>        &#123;<br>            m_useWarpDevice = <span class="hljs-literal">true</span>;<br>            m_title = m_title + <span class="hljs-string">L&quot; (WARP)&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见解析函数会查询命令行是否输入了<strong>-warp</strong>或<strong>/warp</strong>参数，如果输入了该参数将意味着本示例的渲染将使用软件适配器。</p><p>解析命令行参数完毕后使用<code>LocalFree</code>释放分配给命令行参数数组的内存（<code>LocalAlloc</code>分配的内存需要使用<code>LocalFree</code>释放）。</p><p>接下来就是Windows应用程序窗口的创建逻辑，这里着重来看该窗口设置的回调函数<i><font color="Green">WindowProc</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Main message handler for the sample.</span><br><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">Win32Application::WindowProc</span><span class="hljs-params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span><br><span class="hljs-function"></span>&#123;<br>    DXSample* pSample = <span class="hljs-built_in">reinterpret_cast</span>&lt;DXSample*&gt;(<span class="hljs-built_in">GetWindowLongPtr</span>(hWnd, GWLP_USERDATA));<br><br>    <span class="hljs-keyword">switch</span> (message)<br>    &#123;<br>    <span class="hljs-keyword">case</span> WM_CREATE:<br>        &#123;<br>            <span class="hljs-comment">// Save the DXSample* passed in to CreateWindow.</span><br>            LPCREATESTRUCT pCreateStruct = <span class="hljs-built_in">reinterpret_cast</span>&lt;LPCREATESTRUCT&gt;(lParam);<br>            <span class="hljs-built_in">SetWindowLongPtr</span>(hWnd, GWLP_USERDATA, <span class="hljs-built_in">reinterpret_cast</span>&lt;LONG_PTR&gt;(pCreateStruct-&gt;lpCreateParams));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">case</span> WM_KEYDOWN:<br>        <span class="hljs-keyword">if</span> (pSample)<br>        &#123;<br>            pSample-&gt;<span class="hljs-built_in">OnKeyDown</span>(<span class="hljs-built_in">static_cast</span>&lt;UINT8&gt;(wParam));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">case</span> WM_KEYUP:<br>        <span class="hljs-keyword">if</span> (pSample)<br>        &#123;<br>            pSample-&gt;<span class="hljs-built_in">OnKeyUp</span>(<span class="hljs-built_in">static_cast</span>&lt;UINT8&gt;(wParam));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">case</span> WM_PAINT:<br>        <span class="hljs-keyword">if</span> (pSample)<br>        &#123;<br>            pSample-&gt;<span class="hljs-built_in">OnUpdate</span>();<br>            pSample-&gt;<span class="hljs-built_in">OnRender</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">case</span> WM_DESTROY:<br>        <span class="hljs-built_in">PostQuitMessage</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Handle any messages the switch statement didn&#x27;t.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">DefWindowProc</span>(hWnd, message, wParam, lParam);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数利用在Windows窗口创建的时候会发出<i><font color="Red">WM_CREATE</font></i>信号，在处理该信号的逻辑中将传递给窗口的<i><font color="Orange">lpParam</font></i>参数的应用程序类指针保存到用户数据中，这样该回调函数之后每次被调用的时候第一行代码都会从用户数据中获取该类的指针以执行后续处理逻辑。</p><p>之后函数处理用户按键逻辑。这里可以自行发挥，比如实现移动效果等，不过该示例为了简洁起见将<i><font color="Green">OnKeyDown</font></i>和<i><font color="Green">OnKeyUp</font></i>两个函数函数体均设置为空，不执行任何逻辑。</p><p>如果系统发送了<i><font color="Red">WM_PAINT</font></i>消息，那么回调函数就会调用应用程序类的<i><font color="Green">OnUpdate</font></i>和<i><font color="Green">OnRender</font></i>函数，这两个函数是整个渲染逻辑的核心部分，我们稍后分析。</p><p>回到<i><font color="Green">Run</font></i>函数，在初始化窗口结束后，首先调用应用程序类的<i><font color="Green">OnInit</font></i>函数进行资源的初始化，之后进入到渲染主循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Main sample loop.</span><br>MSG msg = &#123;&#125;;<br><span class="hljs-keyword">while</span> (msg.message != WM_QUIT)<br>&#123;<br>    <span class="hljs-comment">// Process any messages in the queue.</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">PeekMessage</span>(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, PM_REMOVE))<br>    &#123;<br>        <span class="hljs-built_in">TranslateMessage</span>(&amp;msg);<br>        <span class="hljs-built_in">DispatchMessage</span>(&amp;msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是一个不断处理消息循环的过程。</p><p>最后如果发送了退出信号（<i><font color="Red">WM_QUIT</font></i>），那么程序需要调用应用程序类的<i><font color="Green">OnDestroy</font></i>函数来进行资源的销毁释放。</p><p>下面开始渲染逻辑的分析。首先是<i><font color="Green">OnInit</font></i>函数。</p><hr><h2 id="oninit">OnInit</h2><p>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::OnInit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">LoadPipeline</span>();<br>    <span class="hljs-built_in">LoadAssets</span>();<br>    <span class="hljs-built_in">LoadContexts</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>先来看<i><font color="Green">LoadPipeline</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Load the rendering pipeline dependencies.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::LoadPipeline</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UINT dxgiFactoryFlags = <span class="hljs-number">0</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_DEBUG)</span><br>    <span class="hljs-comment">// Enable the debug layer (requires the Graphics Tools &quot;optional feature&quot;).</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Enabling the debug layer after device creation will invalidate the active device.</span><br>    &#123;<br>        ComPtr&lt;ID3D12Debug&gt; debugController;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SUCCEEDED</span>(<span class="hljs-built_in">D3D12GetDebugInterface</span>(<span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;debugController))))<br>        &#123;<br>            debugController-&gt;<span class="hljs-built_in">EnableDebugLayer</span>();<br><br>            <span class="hljs-comment">// Enable additional debug layers.</span><br>            dxgiFactoryFlags |= DXGI_CREATE_FACTORY_DEBUG;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    ComPtr&lt;IDXGIFactory4&gt; factory;<br>    <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">CreateDXGIFactory2</span>(dxgiFactoryFlags, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;factory)));<br><br>    <span class="hljs-keyword">if</span> (m_useWarpDevice)<br>    &#123;<br>        ComPtr&lt;IDXGIAdapter&gt; warpAdapter;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(factory-&gt;<span class="hljs-built_in">EnumWarpAdapter</span>(<span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;warpAdapter)));<br><br>        <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">D3D12CreateDevice</span>(<br>            warpAdapter.<span class="hljs-built_in">Get</span>(),<br>            D3D_FEATURE_LEVEL_11_0,<br>            <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_device)<br>            ));<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        ComPtr&lt;IDXGIAdapter1&gt; hardwareAdapter;<br>        <span class="hljs-built_in">GetHardwareAdapter</span>(factory.<span class="hljs-built_in">Get</span>(), &amp;hardwareAdapter, <span class="hljs-literal">true</span>);<br><br>        <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">D3D12CreateDevice</span>(<br>            hardwareAdapter.<span class="hljs-built_in">Get</span>(),<br>            D3D_FEATURE_LEVEL_11_0,<br>            <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_device)<br>            ));<br>    &#125;<br><br>    <span class="hljs-comment">// Describe and create the command queue.</span><br>    D3D12_COMMAND_QUEUE_DESC queueDesc = &#123;&#125;;<br>    queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;<br>    queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;<br><br>    <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommandQueue</span>(&amp;queueDesc, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_commandQueue)));<br>    <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_commandQueue);<br><br>    <span class="hljs-comment">// Describe and create the swap chain.</span><br>    DXGI_SWAP_CHAIN_DESC1 swapChainDesc = &#123;&#125;;<br>    swapChainDesc.BufferCount = FrameCount;<br>    swapChainDesc.Width = m_width;<br>    swapChainDesc.Height = m_height;<br>    swapChainDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;<br>    swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;<br>    swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;<br>    swapChainDesc.SampleDesc.Count = <span class="hljs-number">1</span>;<br><br>    ComPtr&lt;IDXGISwapChain1&gt; swapChain;<br>    <span class="hljs-built_in">ThrowIfFailed</span>(factory-&gt;<span class="hljs-built_in">CreateSwapChainForHwnd</span>(<br>        m_commandQueue.<span class="hljs-built_in">Get</span>(),        <span class="hljs-comment">// Swap chain needs the queue so that it can force a flush on it.</span><br>        Win32Application::<span class="hljs-built_in">GetHwnd</span>(),<br>        &amp;swapChainDesc,<br>        <span class="hljs-literal">nullptr</span>,<br>        <span class="hljs-literal">nullptr</span>,<br>        &amp;swapChain<br>        ));<br><br>    <span class="hljs-comment">// This sample does not support fullscreen transitions.</span><br>    <span class="hljs-built_in">ThrowIfFailed</span>(factory-&gt;<span class="hljs-built_in">MakeWindowAssociation</span>(Win32Application::<span class="hljs-built_in">GetHwnd</span>(), DXGI_MWA_NO_ALT_ENTER));<br><br>    <span class="hljs-built_in">ThrowIfFailed</span>(swapChain.<span class="hljs-built_in">As</span>(&amp;m_swapChain));<br>    m_frameIndex = m_swapChain-&gt;<span class="hljs-built_in">GetCurrentBackBufferIndex</span>();<br><br>    <span class="hljs-comment">// Create descriptor heaps.</span><br>    &#123;<br>        <span class="hljs-comment">// Describe and create a render target view (RTV) descriptor heap.</span><br>        D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc = &#123;&#125;;<br>        rtvHeapDesc.NumDescriptors = FrameCount;<br>        rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;<br>        rtvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateDescriptorHeap</span>(&amp;rtvHeapDesc, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_rtvHeap)));<br><br>        <span class="hljs-comment">// Describe and create a depth stencil view (DSV) descriptor heap.</span><br>        <span class="hljs-comment">// Each frame has its own depth stencils (to write shadows onto) </span><br>        <span class="hljs-comment">// and then there is one for the scene itself.</span><br>        D3D12_DESCRIPTOR_HEAP_DESC dsvHeapDesc = &#123;&#125;;<br>        dsvHeapDesc.NumDescriptors = <span class="hljs-number">1</span> + FrameCount * <span class="hljs-number">1</span>;<br>        dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;<br>        dsvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateDescriptorHeap</span>(&amp;dsvHeapDesc, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_dsvHeap)));<br><br>        <span class="hljs-comment">// Describe and create a shader resource view (SRV) and constant </span><br>        <span class="hljs-comment">// buffer view (CBV) descriptor heap.  Heap layout: null views, </span><br>        <span class="hljs-comment">// object diffuse + normal textures views, frame 1&#x27;s shadow buffer, </span><br>        <span class="hljs-comment">// frame 1&#x27;s 2x constant buffer, frame 2&#x27;s shadow buffer, frame 2&#x27;s </span><br>        <span class="hljs-comment">// 2x constant buffers, etc...</span><br>        <span class="hljs-type">const</span> UINT nullSrvCount = <span class="hljs-number">2</span>;        <span class="hljs-comment">// Null descriptors are needed for out of bounds behavior reads.</span><br>        <span class="hljs-type">const</span> UINT cbvCount = FrameCount * <span class="hljs-number">2</span>;<br>        <span class="hljs-type">const</span> UINT srvCount = _countof(SampleAssets::Textures) + (FrameCount * <span class="hljs-number">1</span>);<br>        D3D12_DESCRIPTOR_HEAP_DESC cbvSrvHeapDesc = &#123;&#125;;<br>        cbvSrvHeapDesc.NumDescriptors = nullSrvCount + cbvCount + srvCount;<br>        cbvSrvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;<br>        cbvSrvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateDescriptorHeap</span>(&amp;cbvSrvHeapDesc, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_cbvSrvHeap)));<br>        <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_cbvSrvHeap);<br><br>        <span class="hljs-comment">// Describe and create a sampler descriptor heap.</span><br>        D3D12_DESCRIPTOR_HEAP_DESC samplerHeapDesc = &#123;&#125;;<br>        samplerHeapDesc.NumDescriptors = <span class="hljs-number">2</span>;        <span class="hljs-comment">// One clamp and one wrap sampler.</span><br>        samplerHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER;<br>        samplerHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateDescriptorHeap</span>(&amp;samplerHeapDesc, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_samplerHeap)));<br>        <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_samplerHeap);<br><br>        m_rtvDescriptorSize = m_device-&gt;<span class="hljs-built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);<br>    &#125;<br><br>    <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommandAllocator</span>(D3D12_COMMAND_LIST_TYPE_DIRECT, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_commandAllocator)));<br>&#125;<br></code></pre></td></tr></table></figure><p>为了创建显示适配器以及交换链，需要首先创建<code>IDXGIFactory</code>对象。这里要注意的是如果是调试模式，需要添加<i><font color="Red">DXGI_CREATE_FACTORY_DEBUG</font></i>标志以帮助开发者在调试过程中获取更多的错误信息和诊断信息，并且可以开启调试层。这里注释中提到如果在创建好设备后再启用调试层会导致设备失效，这点需要注意。</p><p>创建好工厂后，开始枚举挑选显示适配器。前文提到如果用户在命令行传入<strong>-warp</strong>或<strong>/warp</strong>参数，那么<i><font color="Orange">m_useWarpDevice</font></i>就会被设置为true，于是代码就会枚举软件适配器（通过<code>EnumWarpAdapter</code>），然后使用该软件适配器进行设备的创建；反之代码就会枚举一般的硬件适配器然后创建设备。枚举硬件适配器函数<i><font color="Green">GetHardwareAdapter</font></i>实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Helper function for acquiring the first available hardware adapter that supports Direct3D 12.</span><br><span class="hljs-comment">// If no such adapter can be found, *ppAdapter will be set to nullptr.</span><br><span class="hljs-function">_Use_decl_annotations_</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DXSample::GetHardwareAdapter</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    IDXGIFactory1* pFactory,</span></span><br><span class="hljs-params"><span class="hljs-function">    IDXGIAdapter1** ppAdapter,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">bool</span> requestHighPerformanceAdapter)</span></span><br><span class="hljs-function"></span>&#123;<br>    *ppAdapter = <span class="hljs-literal">nullptr</span>;<br><br>    ComPtr&lt;IDXGIAdapter1&gt; adapter;<br><br>    ComPtr&lt;IDXGIFactory6&gt; factory6;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SUCCEEDED</span>(pFactory-&gt;<span class="hljs-built_in">QueryInterface</span>(<span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;factory6))))<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<br>            UINT adapterIndex = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">SUCCEEDED</span>(factory6-&gt;<span class="hljs-built_in">EnumAdapterByGpuPreference</span>(<br>                adapterIndex,<br>                requestHighPerformanceAdapter == <span class="hljs-literal">true</span> ? DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE : DXGI_GPU_PREFERENCE_UNSPECIFIED,<br>                <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;adapter)));<br>            ++adapterIndex)<br>        &#123;<br>            DXGI_ADAPTER_DESC1 desc;<br>            adapter-&gt;<span class="hljs-built_in">GetDesc1</span>(&amp;desc);<br><br>            <span class="hljs-keyword">if</span> (desc.Flags &amp; DXGI_ADAPTER_FLAG_SOFTWARE)<br>            &#123;<br>                <span class="hljs-comment">// Don&#x27;t select the Basic Render Driver adapter.</span><br>                <span class="hljs-comment">// If you want a software adapter, pass in &quot;/warp&quot; on the command line.</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// Check to see whether the adapter supports Direct3D 12, but don&#x27;t create the</span><br>            <span class="hljs-comment">// actual device yet.</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SUCCEEDED</span>(<span class="hljs-built_in">D3D12CreateDevice</span>(adapter.<span class="hljs-built_in">Get</span>(), D3D_FEATURE_LEVEL_11_0, _uuidof(ID3D12Device), <span class="hljs-literal">nullptr</span>)))<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(adapter.<span class="hljs-built_in">Get</span>() == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (UINT adapterIndex = <span class="hljs-number">0</span>; <span class="hljs-built_in">SUCCEEDED</span>(pFactory-&gt;<span class="hljs-built_in">EnumAdapters1</span>(adapterIndex, &amp;adapter)); ++adapterIndex)<br>        &#123;<br>            DXGI_ADAPTER_DESC1 desc;<br>            adapter-&gt;<span class="hljs-built_in">GetDesc1</span>(&amp;desc);<br><br>            <span class="hljs-keyword">if</span> (desc.Flags &amp; DXGI_ADAPTER_FLAG_SOFTWARE)<br>            &#123;<br>                <span class="hljs-comment">// Don&#x27;t select the Basic Render Driver adapter.</span><br>                <span class="hljs-comment">// If you want a software adapter, pass in &quot;/warp&quot; on the command line.</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// Check to see whether the adapter supports Direct3D 12, but don&#x27;t create the</span><br>            <span class="hljs-comment">// actual device yet.</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SUCCEEDED</span>(<span class="hljs-built_in">D3D12CreateDevice</span>(adapter.<span class="hljs-built_in">Get</span>(), D3D_FEATURE_LEVEL_11_0, _uuidof(ID3D12Device), <span class="hljs-literal">nullptr</span>)))<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    *ppAdapter = adapter.<span class="hljs-built_in">Detach</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总体逻辑就是逐一枚举适配器，然后查询它是否支持D3D12（通过使用<code>D3D12CreateDevice</code>函数并且将最后需要创建的设备项设置为空来实现仅查询能否创建而不具体创建设备的效果）。</p><p>接下来代码创建一个全局的命令队列用于执行各线程提交的命令，并且创建一个三缓冲的交换链（这里<i><font color="Orange">FrameCount</font></i>定义为常量3。），并且将当前后备缓冲区的索引存储到程序中。然后代码创建了整个场景需要使用到的描述符堆：首先需要一个至少具有三个描述符的渲染目标视图描述符堆以及具有四个深度模板视图的描述符堆，这里之所以需要四个深度模板视图，是因为本示例是一个两趟的渲染，第一趟是渲染阴影的shadowpass，第二趟是渲染场景的scene pass，因此除了需要一个用于scenepass的深度图外，还需要每帧一个用作shadowpass深度缓冲的资源（该资源在shadow pass用作深度缓冲，在scenepass用作着色器纹理资源，所以需要为该资源分别创建两个视图）；然后本示例每帧会使用两个常量缓冲区存储两趟pass中各自的场景信息如MVP矩阵、灯光信息等，用于存储常量缓冲区数据的结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LightState</span><br>&#123;<br>    XMFLOAT4 position;<br>    XMFLOAT4 direction;<br>    XMFLOAT4 color;<br>    XMFLOAT4 falloff;<br><br>    XMFLOAT4X4 view;<br>    XMFLOAT4X4 projection;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SceneConstantBuffer</span><br>&#123;<br>    XMFLOAT4X4 model;<br>    XMFLOAT4X4 view;<br>    XMFLOAT4X4 projection;<br>    XMFLOAT4 ambientColor;<br>    BOOL sampleShadowMap;<br>    BOOL padding[<span class="hljs-number">3</span>];        <span class="hljs-comment">// Must be aligned to be made up of N float4s.</span><br>    LightState lights[NumLights];<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里需要注意两点：首先结构体中<i><font color="Orange">sampleShadowMap</font></i>成员用于决定着色器在进行场景光照计算的时候是否需要计算阴影；齐次该成员后加入了三个padding，其目的是使得该结构体在c++中的内存布局和hlsl中相应常量缓冲区布局保持一致，因为hlsl常量缓冲区中任意一个数据成员必须按4字节对齐，也就是说如果一个数据没有4字节，而紧随其后的数据成员与该数据成员大小之和又超过了4字节，那么hlsl不会拆分后一个数据成员使它的一部分和前一个数据成员一同构成4字节，而是会在前一个数据成员后插入padding来补齐4字节。更多有关hlsl打包原则的细节可以参考[<code>这篇文章</code>]。</p><p>回到<i><font color="Green">LoadPipeline</font></i>函数。除了每帧需要两个常量缓冲区描述符，由于每帧scenepass可能会渲染阴影，所以还需要一个ShadowMap的着色器资源视图。此外，当然需要为场景中使用的模型的所有纹理各创建一个着色器资源视图，这里纹理就包括了diffusemap和normalmap，它们事实上会被打包在一个描述符表中。另外，事实上代码还额外创建了两个不会绑定任何资源的空视图，这是为了当着色器采样资源不存在时绑定该空视图以保证hlsl代码中的采样操作正常进行不报错。</p><p>最后，着色器还需要使用两种采样器对纹理进行采样，其中wrap模式采样器用于采样一般的纹理，而clamp模式的采样器用于采样Shadowmap（这样可以保证采样点超出阴影图范围的部分也位于阴影内，如果使用wrap模式会导致阴影采样结果明显不正确，具体可以参考<a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping"><code>这篇文章</code></a>的讲解）。</p><p>函数的最后还需要创建一个用于分配命令列表的命令分配器。该命令分配器负责主线程中一些临时命令的录制。事实上后面还会看到每个线程各自都会创建自己的命令分配器和命令列表来并行录制绘制命令（命令分配器和命令列表并不是线程自由的对象，因此每个线程都理应要有自己的分配器和列表）。</p><p>接下来分析<i><font color="Green">loadAssets</font></i>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Load the sample assets.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::LoadAssets</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Create the root signature.</span><br>    &#123;<br>        D3D12_FEATURE_DATA_ROOT_SIGNATURE featureData = &#123;&#125;;<br><br>        <span class="hljs-comment">// This is the highest version the sample supports. If CheckFeatureSupport succeeds, the HighestVersion returned will not be greater than this.</span><br>        featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_1;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FAILED</span>(m_device-&gt;<span class="hljs-built_in">CheckFeatureSupport</span>(D3D12_FEATURE_ROOT_SIGNATURE, &amp;featureData, <span class="hljs-built_in">sizeof</span>(featureData))))<br>        &#123;<br>            featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_0;<br>        &#125;<br><br>        CD3DX12_DESCRIPTOR_RANGE1 ranges[<span class="hljs-number">4</span>]; <span class="hljs-comment">// Perfomance TIP: Order from most frequent to least frequent.</span><br>        ranges[<span class="hljs-number">0</span>].<span class="hljs-built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC);    <span class="hljs-comment">// 2 frequently changed diffuse + normal textures - using registers t1 and t2.</span><br>        ranges[<span class="hljs-number">1</span>].<span class="hljs-built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC);    <span class="hljs-comment">// 1 frequently changed constant buffer.</span><br>        ranges[<span class="hljs-number">2</span>].<span class="hljs-built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);                                                <span class="hljs-comment">// 1 infrequently changed shadow texture - starting in register t0.</span><br>        ranges[<span class="hljs-number">3</span>].<span class="hljs-built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_SAMPLER, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);                                            <span class="hljs-comment">// 2 static samplers.</span><br><br>        CD3DX12_ROOT_PARAMETER1 rootParameters[<span class="hljs-number">4</span>];<br>        rootParameters[<span class="hljs-number">0</span>].<span class="hljs-built_in">InitAsDescriptorTable</span>(<span class="hljs-number">1</span>, &amp;ranges[<span class="hljs-number">0</span>], D3D12_SHADER_VISIBILITY_PIXEL);<br>        rootParameters[<span class="hljs-number">1</span>].<span class="hljs-built_in">InitAsDescriptorTable</span>(<span class="hljs-number">1</span>, &amp;ranges[<span class="hljs-number">1</span>], D3D12_SHADER_VISIBILITY_ALL);<br>        rootParameters[<span class="hljs-number">2</span>].<span class="hljs-built_in">InitAsDescriptorTable</span>(<span class="hljs-number">1</span>, &amp;ranges[<span class="hljs-number">2</span>], D3D12_SHADER_VISIBILITY_PIXEL);<br>        rootParameters[<span class="hljs-number">3</span>].<span class="hljs-built_in">InitAsDescriptorTable</span>(<span class="hljs-number">1</span>, &amp;ranges[<span class="hljs-number">3</span>], D3D12_SHADER_VISIBILITY_PIXEL);<br><br>        CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;<br>        rootSignatureDesc.<span class="hljs-built_in">Init_1_1</span>(_countof(rootParameters), rootParameters, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);<br><br>        ComPtr&lt;ID3DBlob&gt; signature;<br>        ComPtr&lt;ID3DBlob&gt; error;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">D3DX12SerializeVersionedRootSignature</span>(&amp;rootSignatureDesc, featureData.HighestVersion, &amp;signature, &amp;error));<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateRootSignature</span>(<span class="hljs-number">0</span>, signature-&gt;<span class="hljs-built_in">GetBufferPointer</span>(), signature-&gt;<span class="hljs-built_in">GetBufferSize</span>(), <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_rootSignature)));<br>        <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_rootSignature);<br>    &#125;<br><br>    <span class="hljs-comment">// Create the pipeline state, which includes loading shaders.</span><br>    &#123;<br>        ComPtr&lt;ID3DBlob&gt; vertexShader;<br>        ComPtr&lt;ID3DBlob&gt; pixelShader;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_DEBUG)</span><br>        <span class="hljs-comment">// Enable better shader debugging with the graphics debugging tools.</span><br>        UINT compileFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        UINT compileFlags = D3DCOMPILE_OPTIMIZATION_LEVEL3;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">D3DCompileFromFile</span>(<span class="hljs-built_in">GetAssetFullPath</span>(<span class="hljs-string">L&quot;shaders.hlsl&quot;</span>).<span class="hljs-built_in">c_str</span>(), <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;VSMain&quot;</span>, <span class="hljs-string">&quot;vs_5_0&quot;</span>, compileFlags, <span class="hljs-number">0</span>, &amp;vertexShader, <span class="hljs-literal">nullptr</span>));<br>        <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">D3DCompileFromFile</span>(<span class="hljs-built_in">GetAssetFullPath</span>(<span class="hljs-string">L&quot;shaders.hlsl&quot;</span>).<span class="hljs-built_in">c_str</span>(), <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;PSMain&quot;</span>, <span class="hljs-string">&quot;ps_5_0&quot;</span>, compileFlags, <span class="hljs-number">0</span>, &amp;pixelShader, <span class="hljs-literal">nullptr</span>));<br><br>        D3D12_INPUT_LAYOUT_DESC inputLayoutDesc;<br>        inputLayoutDesc.pInputElementDescs = SampleAssets::StandardVertexDescription;<br>        inputLayoutDesc.NumElements = _countof(SampleAssets::StandardVertexDescription);<br><br>        <span class="hljs-function">CD3DX12_DEPTH_STENCIL_DESC <span class="hljs-title">depthStencilDesc</span><span class="hljs-params">(D3D12_DEFAULT)</span></span>;<br>        depthStencilDesc.DepthEnable = <span class="hljs-literal">true</span>;<br>        depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;<br>        depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;<br>        depthStencilDesc.StencilEnable = FALSE;<br><br>        <span class="hljs-comment">// Describe and create the PSO for rendering the scene.</span><br>        D3D12_GRAPHICS_PIPELINE_STATE_DESC psoDesc = &#123;&#125;;<br>        psoDesc.InputLayout = inputLayoutDesc;<br>        psoDesc.pRootSignature = m_rootSignature.<span class="hljs-built_in">Get</span>();<br>        psoDesc.VS = <span class="hljs-built_in">CD3DX12_SHADER_BYTECODE</span>(vertexShader.<span class="hljs-built_in">Get</span>());<br>        psoDesc.PS = <span class="hljs-built_in">CD3DX12_SHADER_BYTECODE</span>(pixelShader.<span class="hljs-built_in">Get</span>());<br>        psoDesc.RasterizerState = <span class="hljs-built_in">CD3DX12_RASTERIZER_DESC</span>(D3D12_DEFAULT);<br>        psoDesc.BlendState = <span class="hljs-built_in">CD3DX12_BLEND_DESC</span>(D3D12_DEFAULT);<br>        psoDesc.DepthStencilState = depthStencilDesc;<br>        psoDesc.SampleMask = UINT_MAX;<br>        psoDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;<br>        psoDesc.NumRenderTargets = <span class="hljs-number">1</span>;<br>        psoDesc.RTVFormats[<span class="hljs-number">0</span>] = DXGI_FORMAT_R8G8B8A8_UNORM;<br>        psoDesc.DSVFormat = DXGI_FORMAT_D32_FLOAT;<br>        psoDesc.SampleDesc.Count = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateGraphicsPipelineState</span>(&amp;psoDesc, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_pipelineState)));<br>        <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_pipelineState);<br><br>        <span class="hljs-comment">// Alter the description and create the PSO for rendering</span><br>        <span class="hljs-comment">// the shadow map.  The shadow map does not use a pixel</span><br>        <span class="hljs-comment">// shader or render targets.</span><br>        psoDesc.PS = <span class="hljs-built_in">CD3DX12_SHADER_BYTECODE</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        psoDesc.RTVFormats[<span class="hljs-number">0</span>] = DXGI_FORMAT_UNKNOWN;<br>        psoDesc.NumRenderTargets = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateGraphicsPipelineState</span>(&amp;psoDesc, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_pipelineStateShadowMap)));<br>        <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_pipelineStateShadowMap);<br>    &#125;<br><br>    <span class="hljs-comment">// Create temporary command list for initial GPU setup.</span><br>    ComPtr&lt;ID3D12GraphicsCommandList&gt; commandList;<br>    <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommandList</span>(<span class="hljs-number">0</span>, D3D12_COMMAND_LIST_TYPE_DIRECT, m_commandAllocator.<span class="hljs-built_in">Get</span>(), m_pipelineState.<span class="hljs-built_in">Get</span>(), <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;commandList)));<br><br>    <span class="hljs-comment">// Create render target views (RTVs).</span><br>    <span class="hljs-function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="hljs-title">rtvHandle</span><span class="hljs-params">(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart())</span></span>;<br>    <span class="hljs-keyword">for</span> (UINT i = <span class="hljs-number">0</span>; i &lt; FrameCount; i++)<br>    &#123;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_swapChain-&gt;<span class="hljs-built_in">GetBuffer</span>(i, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_renderTargets[i])));<br>        m_device-&gt;<span class="hljs-built_in">CreateRenderTargetView</span>(m_renderTargets[i].<span class="hljs-built_in">Get</span>(), <span class="hljs-literal">nullptr</span>, rtvHandle);<br>        rtvHandle.<span class="hljs-built_in">Offset</span>(<span class="hljs-number">1</span>, m_rtvDescriptorSize);<br><br>        <span class="hljs-built_in">NAME_D3D12_OBJECT_INDEXED</span>(m_renderTargets, i);<br>    &#125;<br><br>    <span class="hljs-comment">// Create the depth stencil.</span><br>    &#123;<br>        <span class="hljs-function">CD3DX12_RESOURCE_DESC <span class="hljs-title">shadowTextureDesc</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            D3D12_RESOURCE_DIMENSION_TEXTURE2D,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">static_cast</span>&lt;UINT&gt;(m_viewport.Width), </span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">static_cast</span>&lt;UINT&gt;(m_viewport.Height), </span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-number">1</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-number">1</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            DXGI_FORMAT_D32_FLOAT,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-number">1</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            D3D12_TEXTURE_LAYOUT_UNKNOWN,</span></span><br><span class="hljs-params"><span class="hljs-function">            D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL | D3D12_RESOURCE_FLAG_DENY_SHADER_RESOURCE)</span></span>;<br><br>        D3D12_CLEAR_VALUE clearValue;    <span class="hljs-comment">// Performance tip: Tell the runtime at resource creation the desired clear value.</span><br>        clearValue.Format = DXGI_FORMAT_D32_FLOAT;<br>        clearValue.DepthStencil.Depth = <span class="hljs-number">1.0f</span>;<br>        clearValue.DepthStencil.Stencil = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>            &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_DEFAULT),<br>            D3D12_HEAP_FLAG_NONE,<br>            &amp;shadowTextureDesc,<br>            D3D12_RESOURCE_STATE_DEPTH_WRITE,<br>            &amp;clearValue,<br>            <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_depthStencil)));<br><br>        <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_depthStencil);<br><br>        <span class="hljs-comment">// Create the depth stencil view.</span><br>        m_device-&gt;<span class="hljs-built_in">CreateDepthStencilView</span>(m_depthStencil.<span class="hljs-built_in">Get</span>(), <span class="hljs-literal">nullptr</span>, m_dsvHeap-&gt;<span class="hljs-built_in">GetCPUDescriptorHandleForHeapStart</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// Load scene assets.</span><br>    UINT fileSize = <span class="hljs-number">0</span>;<br>    UINT8* pAssetData;<br>    <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">ReadDataFromFile</span>(<span class="hljs-built_in">GetAssetFullPath</span>(SampleAssets::DataFileName).<span class="hljs-built_in">c_str</span>(), &amp;pAssetData, &amp;fileSize));<br><br>    <span class="hljs-comment">// Create the vertex buffer.</span><br>    &#123;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>            &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_DEFAULT),<br>            D3D12_HEAP_FLAG_NONE,<br>            &amp;CD3DX12_RESOURCE_DESC::<span class="hljs-built_in">Buffer</span>(SampleAssets::VertexDataSize),<br>            D3D12_RESOURCE_STATE_COPY_DEST,<br>            <span class="hljs-literal">nullptr</span>,<br>            <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_vertexBuffer)));<br><br>        <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_vertexBuffer);<br><br>        &#123;<br>            <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>                &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_UPLOAD),<br>                D3D12_HEAP_FLAG_NONE,<br>                &amp;CD3DX12_RESOURCE_DESC::<span class="hljs-built_in">Buffer</span>(SampleAssets::VertexDataSize),<br>                D3D12_RESOURCE_STATE_GENERIC_READ,<br>                <span class="hljs-literal">nullptr</span>,<br>                <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_vertexBufferUpload)));<br><br>            <span class="hljs-comment">// Copy data to the upload heap and then schedule a copy </span><br>            <span class="hljs-comment">// from the upload heap to the vertex buffer.</span><br>            D3D12_SUBRESOURCE_DATA vertexData = &#123;&#125;;<br>            vertexData.pData = pAssetData + SampleAssets::VertexDataOffset;<br>            vertexData.RowPitch = SampleAssets::VertexDataSize;<br>            vertexData.SlicePitch = vertexData.RowPitch;<br><br>            <span class="hljs-built_in">PIXBeginEvent</span>(commandList.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;Copy vertex buffer data to default resource...&quot;</span>);<br><br>            <span class="hljs-built_in">UpdateSubresources</span>&lt;<span class="hljs-number">1</span>&gt;(commandList.<span class="hljs-built_in">Get</span>(), m_vertexBuffer.<span class="hljs-built_in">Get</span>(), m_vertexBufferUpload.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;vertexData);<br>            commandList-&gt;<span class="hljs-built_in">ResourceBarrier</span>(<span class="hljs-number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="hljs-built_in">Transition</span>(m_vertexBuffer.<span class="hljs-built_in">Get</span>(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER));<br><br>            <span class="hljs-built_in">PIXEndEvent</span>(commandList.<span class="hljs-built_in">Get</span>());<br>        &#125;<br><br>        <span class="hljs-comment">// Initialize the vertex buffer view.</span><br>        m_vertexBufferView.BufferLocation = m_vertexBuffer-&gt;<span class="hljs-built_in">GetGPUVirtualAddress</span>();<br>        m_vertexBufferView.SizeInBytes = SampleAssets::VertexDataSize;<br>        m_vertexBufferView.StrideInBytes = SampleAssets::StandardVertexStride;<br>    &#125;<br><br>    <span class="hljs-comment">// Create the index buffer.</span><br>    &#123;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>            &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_DEFAULT),<br>            D3D12_HEAP_FLAG_NONE,<br>            &amp;CD3DX12_RESOURCE_DESC::<span class="hljs-built_in">Buffer</span>(SampleAssets::IndexDataSize),<br>            D3D12_RESOURCE_STATE_COPY_DEST,<br>            <span class="hljs-literal">nullptr</span>,<br>            <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_indexBuffer)));<br><br>        <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_indexBuffer);<br><br>        &#123;<br>            <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>                &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_UPLOAD),<br>                D3D12_HEAP_FLAG_NONE,<br>                &amp;CD3DX12_RESOURCE_DESC::<span class="hljs-built_in">Buffer</span>(SampleAssets::IndexDataSize),<br>                D3D12_RESOURCE_STATE_GENERIC_READ,<br>                <span class="hljs-literal">nullptr</span>,<br>                <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_indexBufferUpload)));<br><br>            <span class="hljs-comment">// Copy data to the upload heap and then schedule a copy </span><br>            <span class="hljs-comment">// from the upload heap to the index buffer.</span><br>            D3D12_SUBRESOURCE_DATA indexData = &#123;&#125;;<br>            indexData.pData = pAssetData + SampleAssets::IndexDataOffset;<br>            indexData.RowPitch = SampleAssets::IndexDataSize;<br>            indexData.SlicePitch = indexData.RowPitch;<br><br>            <span class="hljs-built_in">PIXBeginEvent</span>(commandList.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;Copy index buffer data to default resource...&quot;</span>);<br><br>            <span class="hljs-built_in">UpdateSubresources</span>&lt;<span class="hljs-number">1</span>&gt;(commandList.<span class="hljs-built_in">Get</span>(), m_indexBuffer.<span class="hljs-built_in">Get</span>(), m_indexBufferUpload.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;indexData);<br>            commandList-&gt;<span class="hljs-built_in">ResourceBarrier</span>(<span class="hljs-number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="hljs-built_in">Transition</span>(m_indexBuffer.<span class="hljs-built_in">Get</span>(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_INDEX_BUFFER));<br><br>            <span class="hljs-built_in">PIXEndEvent</span>(commandList.<span class="hljs-built_in">Get</span>());<br>        &#125;<br><br>        <span class="hljs-comment">// Initialize the index buffer view.</span><br>        m_indexBufferView.BufferLocation = m_indexBuffer-&gt;<span class="hljs-built_in">GetGPUVirtualAddress</span>();<br>        m_indexBufferView.SizeInBytes = SampleAssets::IndexDataSize;<br>        m_indexBufferView.Format = SampleAssets::StandardIndexFormat;<br>    &#125;<br><br>    <span class="hljs-comment">// Create shader resources.</span><br>    &#123;<br>        <span class="hljs-comment">// Get the CBV SRV descriptor size for the current device.</span><br>        <span class="hljs-type">const</span> UINT cbvSrvDescriptorSize = m_device-&gt;<span class="hljs-built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);<br><br>        <span class="hljs-comment">// Get a handle to the start of the descriptor heap.</span><br>        <span class="hljs-function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="hljs-title">cbvSrvHandle</span><span class="hljs-params">(m_cbvSrvHeap-&gt;GetCPUDescriptorHandleForHeapStart())</span></span>;<br><br>        &#123;<br>            <span class="hljs-comment">// Describe and create 2 null SRVs. Null descriptors are needed in order </span><br>            <span class="hljs-comment">// to achieve the effect of an &quot;unbound&quot; resource.</span><br>            D3D12_SHADER_RESOURCE_VIEW_DESC nullSrvDesc = &#123;&#125;;<br>            nullSrvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;<br>            nullSrvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;<br>            nullSrvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;<br>            nullSrvDesc.Texture2D.MipLevels = <span class="hljs-number">1</span>;<br>            nullSrvDesc.Texture2D.MostDetailedMip = <span class="hljs-number">0</span>;<br>            nullSrvDesc.Texture2D.ResourceMinLODClamp = <span class="hljs-number">0.0f</span>;<br><br>            m_device-&gt;<span class="hljs-built_in">CreateShaderResourceView</span>(<span class="hljs-literal">nullptr</span>, &amp;nullSrvDesc, cbvSrvHandle);<br>            cbvSrvHandle.<span class="hljs-built_in">Offset</span>(cbvSrvDescriptorSize);<br><br>            m_device-&gt;<span class="hljs-built_in">CreateShaderResourceView</span>(<span class="hljs-literal">nullptr</span>, &amp;nullSrvDesc, cbvSrvHandle);<br>            cbvSrvHandle.<span class="hljs-built_in">Offset</span>(cbvSrvDescriptorSize);<br>        &#125;<br><br>        <span class="hljs-comment">// Create each texture and SRV descriptor.</span><br>        <span class="hljs-type">const</span> UINT srvCount = _countof(SampleAssets::Textures);<br>        <span class="hljs-built_in">PIXBeginEvent</span>(commandList.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;Copy diffuse and normal texture data to default resources...&quot;</span>);<br>        <span class="hljs-keyword">for</span> (UINT i = <span class="hljs-number">0</span>; i &lt; srvCount; i++)<br>        &#123;<br>            <span class="hljs-comment">// Describe and create a Texture2D.</span><br>            <span class="hljs-type">const</span> SampleAssets::TextureResource &amp;tex = SampleAssets::Textures[i];<br>            <span class="hljs-function">CD3DX12_RESOURCE_DESC <span class="hljs-title">texDesc</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">                D3D12_RESOURCE_DIMENSION_TEXTURE2D,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                tex.Width, </span></span><br><span class="hljs-params"><span class="hljs-function">                tex.Height, </span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-number">1</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">static_cast</span>&lt;UINT16&gt;(tex.MipLevels),</span></span><br><span class="hljs-params"><span class="hljs-function">                tex.Format,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-number">1</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                D3D12_TEXTURE_LAYOUT_UNKNOWN,</span></span><br><span class="hljs-params"><span class="hljs-function">                D3D12_RESOURCE_FLAG_NONE)</span></span>;<br><br>            <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>                &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_DEFAULT),<br>                D3D12_HEAP_FLAG_NONE,<br>                &amp;texDesc,<br>                D3D12_RESOURCE_STATE_COPY_DEST,<br>                <span class="hljs-literal">nullptr</span>,<br>                <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_textures[i])));<br><br>            <span class="hljs-built_in">NAME_D3D12_OBJECT_INDEXED</span>(m_textures, i);<br><br>            &#123;<br>                <span class="hljs-type">const</span> UINT subresourceCount = texDesc.DepthOrArraySize * texDesc.MipLevels;<br>                UINT64 uploadBufferSize = <span class="hljs-built_in">GetRequiredIntermediateSize</span>(m_textures[i].<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, subresourceCount);<br>                <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>                    &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_UPLOAD),<br>                    D3D12_HEAP_FLAG_NONE,<br>                    &amp;CD3DX12_RESOURCE_DESC::<span class="hljs-built_in">Buffer</span>(uploadBufferSize),<br>                    D3D12_RESOURCE_STATE_GENERIC_READ,<br>                    <span class="hljs-literal">nullptr</span>,<br>                    <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_textureUploads[i])));<br><br>                <span class="hljs-comment">// Copy data to the intermediate upload heap and then schedule a copy</span><br>                <span class="hljs-comment">// from the upload heap to the Texture2D.</span><br>                D3D12_SUBRESOURCE_DATA textureData = &#123;&#125;;<br>                textureData.pData = pAssetData + tex.Data-&gt;Offset;<br>                textureData.RowPitch = tex.Data-&gt;Pitch;<br>                textureData.SlicePitch = tex.Data-&gt;Size;<br><br>                <span class="hljs-built_in">UpdateSubresources</span>(commandList.<span class="hljs-built_in">Get</span>(), m_textures[i].<span class="hljs-built_in">Get</span>(), m_textureUploads[i].<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, subresourceCount, &amp;textureData);<br>                commandList-&gt;<span class="hljs-built_in">ResourceBarrier</span>(<span class="hljs-number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="hljs-built_in">Transition</span>(m_textures[i].<span class="hljs-built_in">Get</span>(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE));<br>            &#125;<br><br>            <span class="hljs-comment">// Describe and create an SRV.</span><br>            D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = &#123;&#125;;<br>            srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;<br>            srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;<br>            srvDesc.Format = tex.Format;<br>            srvDesc.Texture2D.MipLevels = tex.MipLevels;<br>            srvDesc.Texture2D.MostDetailedMip = <span class="hljs-number">0</span>;<br>            srvDesc.Texture2D.ResourceMinLODClamp = <span class="hljs-number">0.0f</span>;<br>            m_device-&gt;<span class="hljs-built_in">CreateShaderResourceView</span>(m_textures[i].<span class="hljs-built_in">Get</span>(), &amp;srvDesc, cbvSrvHandle);<br><br>            <span class="hljs-comment">// Move to the next descriptor slot.</span><br>            cbvSrvHandle.<span class="hljs-built_in">Offset</span>(cbvSrvDescriptorSize);<br>        &#125;<br>        <span class="hljs-built_in">PIXEndEvent</span>(commandList.<span class="hljs-built_in">Get</span>());<br>    &#125;<br><br>    <span class="hljs-built_in">free</span>(pAssetData);<br><br>    <span class="hljs-comment">// Create the samplers.</span><br>    &#123;<br>        <span class="hljs-comment">// Get the sampler descriptor size for the current device.</span><br>        <span class="hljs-type">const</span> UINT samplerDescriptorSize = m_device-&gt;<span class="hljs-built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER);<br><br>        <span class="hljs-comment">// Get a handle to the start of the descriptor heap.</span><br>        <span class="hljs-function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="hljs-title">samplerHandle</span><span class="hljs-params">(m_samplerHeap-&gt;GetCPUDescriptorHandleForHeapStart())</span></span>;<br><br>        <span class="hljs-comment">// Describe and create the wrapping sampler, which is used for </span><br>        <span class="hljs-comment">// sampling diffuse/normal maps.</span><br>        D3D12_SAMPLER_DESC wrapSamplerDesc = &#123;&#125;;<br>        wrapSamplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;<br>        wrapSamplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;<br>        wrapSamplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;<br>        wrapSamplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;<br>        wrapSamplerDesc.MinLOD = <span class="hljs-number">0</span>;<br>        wrapSamplerDesc.MaxLOD = D3D12_FLOAT32_MAX;<br>        wrapSamplerDesc.MipLODBias = <span class="hljs-number">0.0f</span>;<br>        wrapSamplerDesc.MaxAnisotropy = <span class="hljs-number">1</span>;<br>        wrapSamplerDesc.ComparisonFunc = D3D12_COMPARISON_FUNC_ALWAYS;<br>        wrapSamplerDesc.BorderColor[<span class="hljs-number">0</span>] = wrapSamplerDesc.BorderColor[<span class="hljs-number">1</span>] = wrapSamplerDesc.BorderColor[<span class="hljs-number">2</span>] = wrapSamplerDesc.BorderColor[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;<br>        m_device-&gt;<span class="hljs-built_in">CreateSampler</span>(&amp;wrapSamplerDesc, samplerHandle);<br><br>        <span class="hljs-comment">// Move the handle to the next slot in the descriptor heap.</span><br>        samplerHandle.<span class="hljs-built_in">Offset</span>(samplerDescriptorSize);<br><br>        <span class="hljs-comment">// Describe and create the point clamping sampler, which is </span><br>        <span class="hljs-comment">// used for the shadow map.</span><br>        D3D12_SAMPLER_DESC clampSamplerDesc = &#123;&#125;;<br>        clampSamplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_POINT;<br>        clampSamplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;<br>        clampSamplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;<br>        clampSamplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;<br>        clampSamplerDesc.MipLODBias = <span class="hljs-number">0.0f</span>;<br>        clampSamplerDesc.MaxAnisotropy = <span class="hljs-number">1</span>;<br>        clampSamplerDesc.ComparisonFunc = D3D12_COMPARISON_FUNC_ALWAYS;<br>        clampSamplerDesc.BorderColor[<span class="hljs-number">0</span>] = clampSamplerDesc.BorderColor[<span class="hljs-number">1</span>] = clampSamplerDesc.BorderColor[<span class="hljs-number">2</span>] = clampSamplerDesc.BorderColor[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;<br>        clampSamplerDesc.MinLOD = <span class="hljs-number">0</span>;<br>        clampSamplerDesc.MaxLOD = D3D12_FLOAT32_MAX;<br>        m_device-&gt;<span class="hljs-built_in">CreateSampler</span>(&amp;clampSamplerDesc, samplerHandle);<br>    &#125;<br><br>    <span class="hljs-comment">// Create lights.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NumLights; i++)<br>    &#123;<br>        <span class="hljs-comment">// Set up each of the light positions and directions (they all start </span><br>        <span class="hljs-comment">// in the same place).</span><br>        m_lights[i].position = &#123; <span class="hljs-number">0.0f</span>, <span class="hljs-number">15.0f</span>, <span class="hljs-number">-30.0f</span>, <span class="hljs-number">1.0f</span> &#125;;<br>        m_lights[i].direction = &#123; <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span> &#125;;<br>        m_lights[i].falloff = &#123; <span class="hljs-number">800.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span> &#125;;<br>        m_lights[i].color = &#123; <span class="hljs-number">0.7f</span>, <span class="hljs-number">0.7f</span>, <span class="hljs-number">0.7f</span>, <span class="hljs-number">1.0f</span> &#125;;<br><br>        XMVECTOR eye = <span class="hljs-built_in">XMLoadFloat4</span>(&amp;m_lights[i].position);<br>        XMVECTOR at = <span class="hljs-built_in">XMVectorAdd</span>(eye, <span class="hljs-built_in">XMLoadFloat4</span>(&amp;m_lights[i].direction));<br>        XMVECTOR up = <span class="hljs-built_in">XMVectorSet</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>);<br><br>        m_lightCameras[i].<span class="hljs-built_in">Set</span>(eye, at, up);<br>    &#125;<br><br>    <span class="hljs-comment">// Close the command list and use it to execute the initial GPU setup.</span><br>    <span class="hljs-built_in">ThrowIfFailed</span>(commandList-&gt;<span class="hljs-built_in">Close</span>());<br>    ID3D12CommandList* ppCommandLists[] = &#123; commandList.<span class="hljs-built_in">Get</span>() &#125;;<br>    m_commandQueue-&gt;<span class="hljs-built_in">ExecuteCommandLists</span>(_countof(ppCommandLists), ppCommandLists);<br><br>    <span class="hljs-comment">// Create frame resources.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; FrameCount; i++)<br>    &#123;<br>        m_frameResources[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FrameResource</span>(m_device.<span class="hljs-built_in">Get</span>(), m_pipelineState.<span class="hljs-built_in">Get</span>(), m_pipelineStateShadowMap.<span class="hljs-built_in">Get</span>(), m_dsvHeap.<span class="hljs-built_in">Get</span>(), m_cbvSrvHeap.<span class="hljs-built_in">Get</span>(), &amp;m_viewport, i);<br>        m_frameResources[i]-&gt;<span class="hljs-built_in">WriteConstantBuffers</span>(&amp;m_viewport, &amp;m_camera, m_lightCameras, m_lights);<br>    &#125;<br>    m_currentFrameResourceIndex = <span class="hljs-number">0</span>;<br>    m_pCurrentFrameResource = m_frameResources[m_currentFrameResourceIndex];<br><br>    <span class="hljs-comment">// Create synchronization objects and wait until assets have been uploaded to the GPU.</span><br>    &#123;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_device-&gt;<span class="hljs-built_in">CreateFence</span>(m_fenceValue, D3D12_FENCE_FLAG_NONE, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_fence)));<br>        m_fenceValue++;<br><br>        <span class="hljs-comment">// Create an event handle to use for frame synchronization.</span><br>        m_fenceEvent = <span class="hljs-built_in">CreateEvent</span>(<span class="hljs-literal">nullptr</span>, FALSE, FALSE, <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">if</span> (m_fenceEvent == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">HRESULT_FROM_WIN32</span>(<span class="hljs-built_in">GetLastError</span>()));<br>        &#125;<br><br>        <span class="hljs-comment">// Wait for the command list to execute; we are reusing the same command </span><br>        <span class="hljs-comment">// list in our main loop but for now, we just want to wait for setup to </span><br>        <span class="hljs-comment">// complete before continuing.</span><br><br>        <span class="hljs-comment">// Signal and increment the fence value.</span><br>        <span class="hljs-type">const</span> UINT64 fenceToWaitFor = m_fenceValue;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_commandQueue-&gt;<span class="hljs-built_in">Signal</span>(m_fence.<span class="hljs-built_in">Get</span>(), fenceToWaitFor));<br>        m_fenceValue++;<br><br>        <span class="hljs-comment">// Wait until the fence is completed.</span><br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_fence-&gt;<span class="hljs-built_in">SetEventOnCompletion</span>(fenceToWaitFor, m_fenceEvent));<br>        <span class="hljs-built_in">WaitForSingleObject</span>(m_fenceEvent, INFINITE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数用于创建除了帧资源以外的一切场景所需资源。</p><p>首先函数创建管线所需的根签名。着色器中可能需要使用到一个Shadowmap、一个物体的diffuse map以及一个normalmap、一个常量缓冲区以及两个采样器。因此代码创建了四个描述符表分别用于指定上述四个资源（其中diffusemap和normalmap被打包在一个描述符表中，两个采样器也被打包在一个描述符表中）。</p><p>接下来，函数将着色器代码加载到程序中来并加以编译。如果在Debug模式下运行程序则需要指定<i><font color="Red">D3DCOMPILE_DEBUG|D3DCOMPILE_SKIP_OPTIMIZATION</font></i>标志以禁用编译器优化，如果在Release模式下运行则可以打开编译器优化选项。下面给出本示例使用的着色器代码。事实上，该着色器使用的代码就是简单的BlinnPhong着色模型以及PCF软阴影，关于PCF在<a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping"><code>LearnOpenGL</code></a>中有关于它的理论介绍以及相应的代码框架。<a href="https://www.bilibili.com/video/BV1YK4y1T7yY?vd_source=96b763f75b621baa119e5118b6164aee&amp;spm_id_from=333.788.videopod.episodes&amp;p=3"><code>games202</code></a>中也有关于这部分内容更深入的介绍（包括PCSS软阴影等），这里不再详细地分析该着色器代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><code class="hljs c">Texture2D shadowMap : <span class="hljs-keyword">register</span>(t0);<br>Texture2D diffuseMap : <span class="hljs-keyword">register</span>(t1);<br>Texture2D normalMap : <span class="hljs-keyword">register</span>(t2);<br><br>SamplerState sampleWrap : <span class="hljs-keyword">register</span>(s0);<br>SamplerState sampleClamp : <span class="hljs-keyword">register</span>(s1);<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_LIGHTS 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHADOW_DEPTH_BIAS 0.00005f</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LightState</span></span><br><span class="hljs-class">&#123;</span><br>    float3 position;<br>    float3 direction;<br>    float4 color;<br>    float4 falloff;<br>    float4x4 view;<br>    float4x4 projection;<br>&#125;;<br><br>cbuffer SceneConstantBuffer : <span class="hljs-keyword">register</span>(b0)<br>&#123;<br>    float4x4 model;<br>    float4x4 view;<br>    float4x4 projection;<br>    float4 ambientColor;<br>    <span class="hljs-type">bool</span> sampleShadowMap;<br>    LightState lights[NUM_LIGHTS];<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PSInput</span></span><br><span class="hljs-class">&#123;</span><br>    float4 position : SV_POSITION;<br>    float4 worldpos : POSITION;<br>    float2 uv : TEXCOORD0;<br>    float3 normal : NORMAL;<br>    float3 tangent : TANGENT;<br>&#125;;<br><br><br><span class="hljs-comment">//--------------------------------------------------------------------------------------</span><br><span class="hljs-comment">// Sample normal map, convert to signed, apply tangent-to-world space transform.</span><br><span class="hljs-comment">//--------------------------------------------------------------------------------------</span><br>float3 <span class="hljs-title function_">CalcPerPixelNormal</span><span class="hljs-params">(float2 vTexcoord, float3 vVertNormal, float3 vVertTangent)</span><br>&#123;<br>    <span class="hljs-comment">// Compute tangent frame.</span><br>    vVertNormal = normalize(vVertNormal);<br>    vVertTangent = normalize(vVertTangent);<br><br>    float3 vVertBinormal = normalize(cross(vVertTangent, vVertNormal));<br>    float3x3 mTangentSpaceToWorldSpace = float3x3(vVertTangent, vVertBinormal, vVertNormal);<br><br>    <span class="hljs-comment">// Compute per-pixel normal.</span><br>    float3 vBumpNormal = (float3)normalMap.Sample(sampleWrap, vTexcoord);<br>    vBumpNormal = <span class="hljs-number">2.0f</span> * vBumpNormal - <span class="hljs-number">1.0f</span>;<br><br>    <span class="hljs-keyword">return</span> mul(vBumpNormal, mTangentSpaceToWorldSpace);<br>&#125;<br><br><span class="hljs-comment">//--------------------------------------------------------------------------------------</span><br><span class="hljs-comment">// Diffuse lighting calculation, with angle and distance falloff.</span><br><span class="hljs-comment">//--------------------------------------------------------------------------------------</span><br>float4 <span class="hljs-title function_">CalcLightingColor</span><span class="hljs-params">(float3 vLightPos, float3 vLightDir, float4 vLightColor, float4 vFalloffs, float3 vPosWorld, float3 vPerPixelNormal)</span><br>&#123;<br>    float3 vLightToPixelUnNormalized = vPosWorld - vLightPos;<br><br>    <span class="hljs-comment">// Dist falloff = 0 at vFalloffs.x, 1 at vFalloffs.x - vFalloffs.y</span><br>    <span class="hljs-type">float</span> fDist = length(vLightToPixelUnNormalized);<br><br>    <span class="hljs-type">float</span> fDistFalloff = saturate((vFalloffs.x - fDist) / vFalloffs.y);<br><br>    <span class="hljs-comment">// Normalize from here on.</span><br>    float3 vLightToPixelNormalized = vLightToPixelUnNormalized / fDist;<br><br>    <span class="hljs-comment">// Angle falloff = 0 at vFalloffs.z, 1 at vFalloffs.z - vFalloffs.w</span><br>    <span class="hljs-type">float</span> fCosAngle = dot(vLightToPixelNormalized, vLightDir / length(vLightDir));<br>    <span class="hljs-type">float</span> fAngleFalloff = saturate((fCosAngle - vFalloffs.z) / vFalloffs.w);<br><br>    <span class="hljs-comment">// Diffuse contribution.</span><br>    <span class="hljs-type">float</span> fNDotL = saturate(-dot(vLightToPixelNormalized, vPerPixelNormal));<br><br>    <span class="hljs-keyword">return</span> vLightColor * fNDotL * fDistFalloff * fAngleFalloff;<br>&#125;<br><br><span class="hljs-comment">//--------------------------------------------------------------------------------------</span><br><span class="hljs-comment">// Test how much pixel is in shadow, using 2x2 percentage-closer filtering.</span><br><span class="hljs-comment">//--------------------------------------------------------------------------------------</span><br>float4 <span class="hljs-title function_">CalcUnshadowedAmountPCF2x2</span><span class="hljs-params">(<span class="hljs-type">int</span> lightIndex, float4 vPosWorld)</span><br>&#123;<br>    <span class="hljs-comment">// Compute pixel position in light space.</span><br>    float4 vLightSpacePos = vPosWorld;<br>    vLightSpacePos = mul(vLightSpacePos, lights[lightIndex].view);<br>    vLightSpacePos = mul(vLightSpacePos, lights[lightIndex].projection);<br><br>    vLightSpacePos.xyz /= vLightSpacePos.w;<br><br>    <span class="hljs-comment">// Translate from homogeneous coords to texture coords.</span><br>    float2 vShadowTexCoord = <span class="hljs-number">0.5f</span> * vLightSpacePos.xy + <span class="hljs-number">0.5f</span>;<br>    vShadowTexCoord.y = <span class="hljs-number">1.0f</span> - vShadowTexCoord.y;<br><br>    <span class="hljs-comment">// Depth bias to avoid pixel self-shadowing.</span><br>    <span class="hljs-type">float</span> vLightSpaceDepth = vLightSpacePos.z - SHADOW_DEPTH_BIAS;<br><br>    <span class="hljs-comment">// Find sub-pixel weights.</span><br>    float2 vShadowMapDims = float2(<span class="hljs-number">1280.0f</span>, <span class="hljs-number">720.0f</span>); <span class="hljs-comment">// need to keep in sync with .cpp file</span><br>    float4 vSubPixelCoords = float4(<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>);<br>    vSubPixelCoords.xy = frac(vShadowMapDims * vShadowTexCoord);<br>    vSubPixelCoords.zw = <span class="hljs-number">1.0f</span> - vSubPixelCoords.xy;<br>    float4 vBilinearWeights = vSubPixelCoords.zxzx * vSubPixelCoords.wwyy;<br><br>    <span class="hljs-comment">// 2x2 percentage closer filtering.</span><br>    float2 vTexelUnits = <span class="hljs-number">1.0f</span> / vShadowMapDims;<br>    float4 vShadowDepths;<br>    vShadowDepths.x = shadowMap.Sample(sampleClamp, vShadowTexCoord);<br>    vShadowDepths.y = shadowMap.Sample(sampleClamp, vShadowTexCoord + float2(vTexelUnits.x, <span class="hljs-number">0.0f</span>));<br>    vShadowDepths.z = shadowMap.Sample(sampleClamp, vShadowTexCoord + float2(<span class="hljs-number">0.0f</span>, vTexelUnits.y));<br>    vShadowDepths.w = shadowMap.Sample(sampleClamp, vShadowTexCoord + vTexelUnits);<br><br>    <span class="hljs-comment">// What weighted fraction of the 4 samples are nearer to the light than this pixel?</span><br>    float4 vShadowTests = (vShadowDepths &gt;= vLightSpaceDepth) ? <span class="hljs-number">1.0f</span> : <span class="hljs-number">0.0f</span>;<br>    <span class="hljs-keyword">return</span> dot(vBilinearWeights, vShadowTests);<br>&#125;<br><br>PSInput <span class="hljs-title function_">VSMain</span><span class="hljs-params">(float3 position : POSITION, float3 normal : NORMAL, float2 uv : TEXCOORD0, float3 tangent : TANGENT)</span><br>&#123;<br>    PSInput result;<br><br>    float4 newPosition = float4(position, <span class="hljs-number">1.0f</span>);<br><br>    normal.z *= <span class="hljs-number">-1.0f</span>;<br>    newPosition = mul(newPosition, model);<br><br>    result.worldpos = newPosition;<br><br>    newPosition = mul(newPosition, view);<br>    newPosition = mul(newPosition, projection);<br><br>    result.position = newPosition;<br>    result.uv = uv;<br>    result.normal = normal;<br>    result.tangent = tangent;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>float4 <span class="hljs-title function_">PSMain</span><span class="hljs-params">(PSInput input)</span> : SV_TARGET<br>&#123;<br>    float4 diffuseColor = diffuseMap.Sample(sampleWrap, input.uv);<br>    float3 pixelNormal = CalcPerPixelNormal(input.uv, input.normal, input.tangent);<br>    float4 totalLight = ambientColor;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_LIGHTS; i++)<br>    &#123;<br>        float4 lightPass = CalcLightingColor(lights[i].position, lights[i].direction, lights[i].color, lights[i].falloff, input.worldpos.xyz, pixelNormal);<br>        <span class="hljs-keyword">if</span> (sampleShadowMap &amp;&amp; i == <span class="hljs-number">0</span>)<br>        &#123;<br>            lightPass *= CalcUnshadowedAmountPCF2x2(i, input.worldpos);<br>        &#125;<br>        totalLight += lightPass;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> diffuseColor * saturate(totalLight);<br>&#125;<br></code></pre></td></tr></table></figure><p>回到<i><font color="Green">LoadAssets</font></i>函数，在编译完着色器代码之后，紧接着需要指定将要创建的渲染管线所需的一些状态。首先是管线的输入布局，从上文着色器代码中看到顶点数据包括了位置、发现、纹理坐标、切向量信息，于是这些信息都需要在顶点输入布局中指定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> D3D12_INPUT_ELEMENT_DESC StandardVertexDescription[] =<br>&#123;<br>    &#123; <span class="hljs-string">&quot;POSITION&quot;</span>, <span class="hljs-number">0</span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,  D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="hljs-number">0</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;NORMAL&quot;</span>,   <span class="hljs-number">0</span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="hljs-number">0</span>, <span class="hljs-number">12</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="hljs-number">0</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;TEXCOORD&quot;</span>, <span class="hljs-number">0</span>, DXGI_FORMAT_R32G32_FLOAT,    <span class="hljs-number">0</span>, <span class="hljs-number">24</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="hljs-number">0</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;TANGENT&quot;</span>,  <span class="hljs-number">0</span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="hljs-number">0</span>, <span class="hljs-number">32</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span class="hljs-number">0</span> &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后还需要指定深度模板状态，本示例只需要正常开启深度测试和写入即可。</p><p>下面就可以创建管线状态对象了。这部分也是常规的设置，需要的信息在前面已经生成好了。不过需要注意的是示例需要创建两个管线对象分别用于shadowpass和scene pass，其中shadowpass是不需要使用像素着色器的，只需要将深度值写入shadow map即可。</p><p>接下来就需要创建真正用于绑定的资源及其相应的视图了。首先创建一个临时的命令列表用于提交资源创建有关的命令。然后代码先是为所有的后台缓冲区创建了相应的RTV，并且创建了用于scenepass深度缓冲的2D纹理以及相应的视图。紧接着，函数将场景资源加载到程序中来（保存在一个uint8数组<i><font color="Orange">pAssetData</font></i>中），并且将其中的顶点信息上传到创建的顶点缓冲中去。顶点缓冲的创建需要借助一个上传堆中的临时缓冲区作为中介，因为顶点缓冲区是设置在默认堆中的，无法直接和CPU中的数据进行交互。另外还需要注意顶点缓冲创建初始的布局是指定为<i><font color="Red">D3D12_RESOURCE_STATE_COPY_DEST</font></i>以作为临时缓冲传输顶点数据的目的地，在数据传输完毕之后还需要将其布局转换为<i><font color="Red">D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER</font></i>以供顶点着色器读取顶点信息。之后的索引缓冲创建过程和顶点缓冲几乎一致，不再赘述。当然，不能忘了为顶点缓冲和索引缓冲创建相应的视图。</p><p>接下来就是创建着色器资源视图了。示例指定的描述符顺序是：cbv_srv_uav描述符堆的头两个是空SRV，在创建这两个空视图的时候指定其绑定资源为nullptr即可。空视图之后是所有的纹理着色器资源视图。为了创建纹理视图，首先当然需要先创建好所有的纹理资源，然后同样通过一个临时缓冲区将实际的纹理数据上传到实际的纹理缓冲区中。不过这里需要注意的是，纹理缓冲区所需的大小就不太容易如同顶点和索引缓冲区那样直接手动计算出来了，因为纹理缓冲中存储的可能是一个纹理数组，每个纹理也有可能具有多级渐远纹理，所以这里使用WINAPI<code>GetRequiredIntermediateSize</code>来辅助计算缓冲区大小。在创建好纹理资源之后，为每个资源指定一个视图即可。然后就是创建采样器所需的视图，示例需要一个wrap模式以及一个clamp模式的采样器，只需在描述结构体<code>D3D12_SAMPLER_DESC</code>中指定好相应信息即可。注意在这部分资源创建逻辑中，代码事实上并没有创建shadowmap实际的资源以及它对应的两个视图，常量缓冲区及其视图同样也还没有创建，这些资源会在<code>FrameResource</code>类的构造函数中创建，因为每帧都应该有自己的这些资源，所以放在帧资源类中创建对应于当前帧的资源是合理的。</p><p>事实上，在创建好全局的资源，设定好灯光信息之后，紧接着程序就开始创建帧资源了。那么下面就来看看帧资源类的构造函数代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><code class="hljs c++">FrameResource::<span class="hljs-built_in">FrameResource</span>(ID3D12Device* pDevice, ID3D12PipelineState* pPso, ID3D12PipelineState* pShadowMapPso, ID3D12DescriptorHeap* pDsvHeap, ID3D12DescriptorHeap* pCbvSrvHeap, D3D12_VIEWPORT* pViewport, UINT frameResourceIndex) :<br>    <span class="hljs-built_in">m_fenceValue</span>(<span class="hljs-number">0</span>),<br>    <span class="hljs-built_in">m_pipelineState</span>(pPso),<br>    <span class="hljs-built_in">m_pipelineStateShadowMap</span>(pShadowMapPso)<br>&#123;<br>    <span class="hljs-keyword">for</span> (UINT i = <span class="hljs-number">0</span>; i &lt; CommandListCount; i++)<br>    &#123;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(pDevice-&gt;<span class="hljs-built_in">CreateCommandAllocator</span>(D3D12_COMMAND_LIST_TYPE_DIRECT, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_commandAllocators[i])));<br>        <span class="hljs-built_in">ThrowIfFailed</span>(pDevice-&gt;<span class="hljs-built_in">CreateCommandList</span>(<span class="hljs-number">0</span>, D3D12_COMMAND_LIST_TYPE_DIRECT, m_commandAllocators[i].<span class="hljs-built_in">Get</span>(), m_pipelineState.<span class="hljs-built_in">Get</span>(), <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_commandLists[i])));<br><br>        <span class="hljs-built_in">NAME_D3D12_OBJECT_INDEXED</span>(m_commandLists, i);<br><br>        <span class="hljs-comment">// Close these command lists; don&#x27;t record into them for now.</span><br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_commandLists[i]-&gt;<span class="hljs-built_in">Close</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (UINT i = <span class="hljs-number">0</span>; i &lt; NumContexts; i++)<br>    &#123;<br>        <span class="hljs-comment">// Create command list allocators for worker threads. One alloc is </span><br>        <span class="hljs-comment">// for the shadow pass command list, and one is for the scene pass.</span><br>        <span class="hljs-built_in">ThrowIfFailed</span>(pDevice-&gt;<span class="hljs-built_in">CreateCommandAllocator</span>(D3D12_COMMAND_LIST_TYPE_DIRECT, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_shadowCommandAllocators[i])));<br>        <span class="hljs-built_in">ThrowIfFailed</span>(pDevice-&gt;<span class="hljs-built_in">CreateCommandAllocator</span>(D3D12_COMMAND_LIST_TYPE_DIRECT, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_sceneCommandAllocators[i])));<br><br>        <span class="hljs-built_in">ThrowIfFailed</span>(pDevice-&gt;<span class="hljs-built_in">CreateCommandList</span>(<span class="hljs-number">0</span>, D3D12_COMMAND_LIST_TYPE_DIRECT, m_shadowCommandAllocators[i].<span class="hljs-built_in">Get</span>(), m_pipelineStateShadowMap.<span class="hljs-built_in">Get</span>(), <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_shadowCommandLists[i])));<br>        <span class="hljs-built_in">ThrowIfFailed</span>(pDevice-&gt;<span class="hljs-built_in">CreateCommandList</span>(<span class="hljs-number">0</span>, D3D12_COMMAND_LIST_TYPE_DIRECT, m_sceneCommandAllocators[i].<span class="hljs-built_in">Get</span>(), m_pipelineState.<span class="hljs-built_in">Get</span>(), <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_sceneCommandLists[i])));<br><br>        <span class="hljs-built_in">NAME_D3D12_OBJECT_INDEXED</span>(m_shadowCommandLists, i);<br>        <span class="hljs-built_in">NAME_D3D12_OBJECT_INDEXED</span>(m_sceneCommandLists, i);<br><br>        <span class="hljs-comment">// Close these command lists; don&#x27;t record into them for now. We will </span><br>        <span class="hljs-comment">// reset them to a recording state when we start the render loop.</span><br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_shadowCommandLists[i]-&gt;<span class="hljs-built_in">Close</span>());<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_sceneCommandLists[i]-&gt;<span class="hljs-built_in">Close</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// Describe and create the shadow map texture.</span><br>    <span class="hljs-function">CD3DX12_RESOURCE_DESC <span class="hljs-title">shadowTexDesc</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        D3D12_RESOURCE_DIMENSION_TEXTURE2D,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">static_cast</span>&lt;UINT&gt;(pViewport-&gt;Width), </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">static_cast</span>&lt;UINT&gt;(pViewport-&gt;Height), </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-number">1</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-number">1</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        DXGI_FORMAT_R32_TYPELESS,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-number">1</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        D3D12_TEXTURE_LAYOUT_UNKNOWN,</span></span><br><span class="hljs-params"><span class="hljs-function">        D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL)</span></span>;<br><br>    D3D12_CLEAR_VALUE clearValue;        <span class="hljs-comment">// Performance tip: Tell the runtime at resource creation the desired clear value.</span><br>    clearValue.Format = DXGI_FORMAT_D32_FLOAT;<br>    clearValue.DepthStencil.Depth = <span class="hljs-number">1.0f</span>;<br>    clearValue.DepthStencil.Stencil = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">ThrowIfFailed</span>(pDevice-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>        &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_DEFAULT),<br>        D3D12_HEAP_FLAG_NONE,<br>        &amp;shadowTexDesc,<br>        D3D12_RESOURCE_STATE_DEPTH_WRITE,<br>        &amp;clearValue,<br>        <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_shadowTexture)));<br><br>    <span class="hljs-built_in">NAME_D3D12_OBJECT</span>(m_shadowTexture);<br><br>    <span class="hljs-comment">// Get a handle to the start of the descriptor heap then offset </span><br>    <span class="hljs-comment">// it based on the frame resource index.</span><br>    <span class="hljs-type">const</span> UINT dsvDescriptorSize = pDevice-&gt;<span class="hljs-built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_DSV);<br>    <span class="hljs-function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="hljs-title">depthHandle</span><span class="hljs-params">(pDsvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), <span class="hljs-number">1</span> + frameResourceIndex, dsvDescriptorSize)</span></span>; <span class="hljs-comment">// + 1 for the shadow map.</span><br><br>    <span class="hljs-comment">// Describe and create the shadow depth view and cache the CPU </span><br>    <span class="hljs-comment">// descriptor handle.</span><br>    D3D12_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc = &#123;&#125;;<br>    depthStencilViewDesc.Format = DXGI_FORMAT_D32_FLOAT;<br>    depthStencilViewDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;<br>    depthStencilViewDesc.Texture2D.MipSlice = <span class="hljs-number">0</span>;<br>    pDevice-&gt;<span class="hljs-built_in">CreateDepthStencilView</span>(m_shadowTexture.<span class="hljs-built_in">Get</span>(), &amp;depthStencilViewDesc, depthHandle);<br>    m_shadowDepthView = depthHandle;<br><br>    <span class="hljs-comment">// Get a handle to the start of the descriptor heap then offset it </span><br>    <span class="hljs-comment">// based on the existing textures and the frame resource index. Each </span><br>    <span class="hljs-comment">// frame has 1 SRV (shadow tex) and 2 CBVs.</span><br>    <span class="hljs-type">const</span> UINT nullSrvCount = <span class="hljs-number">2</span>;                                <span class="hljs-comment">// Null descriptors at the start of the heap.</span><br>    <span class="hljs-type">const</span> UINT textureCount = _countof(SampleAssets::Textures);    <span class="hljs-comment">// Diffuse + normal textures near the start of the heap.  Ideally, track descriptor heap contents/offsets at a higher level.</span><br>    <span class="hljs-type">const</span> UINT cbvSrvDescriptorSize = pDevice-&gt;<span class="hljs-built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);<br>    <span class="hljs-function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="hljs-title">cbvSrvCpuHandle</span><span class="hljs-params">(pCbvSrvHeap-&gt;GetCPUDescriptorHandleForHeapStart())</span></span>;<br>    <span class="hljs-function">CD3DX12_GPU_DESCRIPTOR_HANDLE <span class="hljs-title">cbvSrvGpuHandle</span><span class="hljs-params">(pCbvSrvHeap-&gt;GetGPUDescriptorHandleForHeapStart())</span></span>;<br>    m_nullSrvHandle = cbvSrvGpuHandle;<br>    cbvSrvCpuHandle.<span class="hljs-built_in">Offset</span>(nullSrvCount + textureCount + (frameResourceIndex * FrameCount), cbvSrvDescriptorSize);<br>    cbvSrvGpuHandle.<span class="hljs-built_in">Offset</span>(nullSrvCount + textureCount + (frameResourceIndex * FrameCount), cbvSrvDescriptorSize);<br><br>    <span class="hljs-comment">// Describe and create a shader resource view (SRV) for the shadow depth </span><br>    <span class="hljs-comment">// texture and cache the GPU descriptor handle. This SRV is for sampling </span><br>    <span class="hljs-comment">// the shadow map from our shader. It uses the same texture that we use </span><br>    <span class="hljs-comment">// as a depth-stencil during the shadow pass.</span><br>    D3D12_SHADER_RESOURCE_VIEW_DESC shadowSrvDesc = &#123;&#125;;<br>    shadowSrvDesc.Format = DXGI_FORMAT_R32_FLOAT;<br>    shadowSrvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;<br>    shadowSrvDesc.Texture2D.MipLevels = <span class="hljs-number">1</span>;<br>    shadowSrvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;<br>    pDevice-&gt;<span class="hljs-built_in">CreateShaderResourceView</span>(m_shadowTexture.<span class="hljs-built_in">Get</span>(), &amp;shadowSrvDesc, cbvSrvCpuHandle);<br>    m_shadowDepthHandle = cbvSrvGpuHandle;<br><br>    <span class="hljs-comment">// Increment the descriptor handles.</span><br>    cbvSrvCpuHandle.<span class="hljs-built_in">Offset</span>(cbvSrvDescriptorSize);<br>    cbvSrvGpuHandle.<span class="hljs-built_in">Offset</span>(cbvSrvDescriptorSize);<br><br>    <span class="hljs-comment">// Create the constant buffers.</span><br>    <span class="hljs-type">const</span> UINT constantBufferSize = (<span class="hljs-built_in">sizeof</span>(SceneConstantBuffer) + (D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT - <span class="hljs-number">1</span>)) &amp; ~(D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT - <span class="hljs-number">1</span>); <span class="hljs-comment">// must be a multiple 256 bytes</span><br>    <span class="hljs-built_in">ThrowIfFailed</span>(pDevice-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>        &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_UPLOAD),<br>        D3D12_HEAP_FLAG_NONE,<br>        &amp;CD3DX12_RESOURCE_DESC::<span class="hljs-built_in">Buffer</span>(constantBufferSize),<br>        D3D12_RESOURCE_STATE_GENERIC_READ,<br>        <span class="hljs-literal">nullptr</span>,<br>        <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_shadowConstantBuffer)));<br>    <span class="hljs-built_in">ThrowIfFailed</span>(pDevice-&gt;<span class="hljs-built_in">CreateCommittedResource</span>(<br>        &amp;<span class="hljs-built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_UPLOAD),<br>        D3D12_HEAP_FLAG_NONE,<br>        &amp;CD3DX12_RESOURCE_DESC::<span class="hljs-built_in">Buffer</span>(constantBufferSize),<br>        D3D12_RESOURCE_STATE_GENERIC_READ,<br>        <span class="hljs-literal">nullptr</span>,<br>        <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;m_sceneConstantBuffer)));<br><br>    <span class="hljs-comment">// Map the constant buffers and cache their heap pointers.</span><br>    <span class="hljs-function">CD3DX12_RANGE <span class="hljs-title">readRange</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;        <span class="hljs-comment">// We do not intend to read from this resource on the CPU.</span><br>    <span class="hljs-built_in">ThrowIfFailed</span>(m_shadowConstantBuffer-&gt;<span class="hljs-built_in">Map</span>(<span class="hljs-number">0</span>, &amp;readRange, <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>**&gt;(&amp;mp_shadowConstantBufferWO)));<br>    <span class="hljs-built_in">ThrowIfFailed</span>(m_sceneConstantBuffer-&gt;<span class="hljs-built_in">Map</span>(<span class="hljs-number">0</span>, &amp;readRange, <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>**&gt;(&amp;mp_sceneConstantBufferWO)));<br><br>    <span class="hljs-comment">// Create the constant buffer views: one for the shadow pass and</span><br>    <span class="hljs-comment">// another for the scene pass.</span><br>    D3D12_CONSTANT_BUFFER_VIEW_DESC cbvDesc = &#123;&#125;;<br>    cbvDesc.SizeInBytes = constantBufferSize;<br><br>    <span class="hljs-comment">// Describe and create the shadow constant buffer view (CBV) and </span><br>    <span class="hljs-comment">// cache the GPU descriptor handle.</span><br>    cbvDesc.BufferLocation = m_shadowConstantBuffer-&gt;<span class="hljs-built_in">GetGPUVirtualAddress</span>();<br>    pDevice-&gt;<span class="hljs-built_in">CreateConstantBufferView</span>(&amp;cbvDesc, cbvSrvCpuHandle);<br>    m_shadowCbvHandle = cbvSrvGpuHandle;<br><br>    <span class="hljs-comment">// Increment the descriptor handles.</span><br>    cbvSrvCpuHandle.<span class="hljs-built_in">Offset</span>(cbvSrvDescriptorSize);<br>    cbvSrvGpuHandle.<span class="hljs-built_in">Offset</span>(cbvSrvDescriptorSize);<br><br>    <span class="hljs-comment">// Describe and create the scene constant buffer view (CBV) and </span><br>    <span class="hljs-comment">// cache the GPU descriptor handle.</span><br>    cbvDesc.BufferLocation = m_sceneConstantBuffer-&gt;<span class="hljs-built_in">GetGPUVirtualAddress</span>();<br>    pDevice-&gt;<span class="hljs-built_in">CreateConstantBufferView</span>(&amp;cbvDesc, cbvSrvCpuHandle);<br>    m_sceneCbvHandle = cbvSrvGpuHandle;<br><br>    <span class="hljs-comment">// Batch up command lists for execution later.</span><br>    <span class="hljs-type">const</span> UINT batchSize = _countof(m_sceneCommandLists) + _countof(m_shadowCommandLists) + <span class="hljs-number">3</span>;<br>    m_batchSubmit[<span class="hljs-number">0</span>] = m_commandLists[CommandListPre].<span class="hljs-built_in">Get</span>();<br>    <span class="hljs-built_in">memcpy</span>(m_batchSubmit + <span class="hljs-number">1</span>, m_shadowCommandLists, _countof(m_shadowCommandLists) * <span class="hljs-built_in">sizeof</span>(ID3D12CommandList*));<br>    m_batchSubmit[_countof(m_shadowCommandLists) + <span class="hljs-number">1</span>] = m_commandLists[CommandListMid].<span class="hljs-built_in">Get</span>();<br>    <span class="hljs-built_in">memcpy</span>(m_batchSubmit + _countof(m_shadowCommandLists) + <span class="hljs-number">2</span>, m_sceneCommandLists, _countof(m_sceneCommandLists) * <span class="hljs-built_in">sizeof</span>(ID3D12CommandList*));<br>    m_batchSubmit[batchSize - <span class="hljs-number">1</span>] = m_commandLists[CommandListPost].<span class="hljs-built_in">Get</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，构造函数创建了用于构建并提交当前帧命令的命令队列以及命令分配器，总共是创建了2倍线程数加上3个队列和分配器对。由于渲染流程是先进行shadowpass的渲染，然后进行scenepass的渲染，因此在开启多线程录制命令之前，首先需要使用一个命令队列来提交一些开始渲染前的准备工作（清除渲染视图和深度视图等），然后开启多线程录制，录制用于shadowpass的命令。在录制结束之后，需要一个单独的命令队列来进行shadowpass渲染结束后shadow map布局的转换。在此之后就可以启动多线程录制scenepass的命令，最后在scenepass执行完毕后也需要一个单独的命令队列来进行一些收尾工作的提交（将shadowmap布局转换回去等），后续我们会详细地看到有关代码逻辑。</p><p>在此之后，构造函数创建了Shadow map资源。这里需要注意的是创建Shadowmap时图像格式指定为<i><font color="Red">DXGI_FORMAT_R32_TYPELESS</font></i>，这是因为后续Shadowmap会分别用作深度缓冲和着色器资源，其格式是会变换的，因此需要通过在对应的视图中指定其具体格式。</p><p>接下来成勋就创建了该Shadow map的深度视图，并且创建了当前帧的Shadowmap的着色器资源视图以及两个常量缓冲区视图。需要注意的是，常量缓冲区是在上传堆中生成的，这是因为常量缓冲区中的数据需要不断变换，直接放在上传堆上有助于数据的传递。另外，我们可以发现程序对常量缓冲区使用了<strong>persistentmap</strong>的手段，也就是映射该缓冲区到CPU内存并且在程序运行过程中不解除映射，这样可以节省映射过程带来的性能消耗。</p><p>最后，构造函数将所有的命令队列合批在一个队列列表中，这样就可以一次性执行各线程中录制好的命令的。</p><p>回到<i><font color="Green">LoadAssets</font></i>函数。在初始化帧资源之后，下一步就是初始化常量缓冲区的数据。这可以通过帧资源类成员函数<i><font color="Green">WriteConstantBuffers</font></i>来完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Builds and writes constant buffers from scratch to the proper slots for </span><br><span class="hljs-comment">// this frame resource.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FrameResource::WriteConstantBuffers</span><span class="hljs-params">(D3D12_VIEWPORT* pViewport, Camera* pSceneCamera, Camera lightCams[NumLights], LightState lights[NumLights])</span></span><br><span class="hljs-function"></span>&#123;<br>    SceneConstantBuffer sceneConsts = &#123;&#125;; <br>    SceneConstantBuffer shadowConsts = &#123;&#125;;<br>    <br>    <span class="hljs-comment">// Scale down the world a bit.</span><br>    ::<span class="hljs-built_in">XMStoreFloat4x4</span>(&amp;sceneConsts.model, <span class="hljs-built_in">XMMatrixScaling</span>(<span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>));<br>    ::<span class="hljs-built_in">XMStoreFloat4x4</span>(&amp;shadowConsts.model, <span class="hljs-built_in">XMMatrixScaling</span>(<span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>));<br><br>    <span class="hljs-comment">// The scene pass is drawn from the camera.</span><br>    pSceneCamera-&gt;<span class="hljs-built_in">Get3DViewProjMatrices</span>(&amp;sceneConsts.view, &amp;sceneConsts.projection, <span class="hljs-number">90.0f</span>, pViewport-&gt;Width, pViewport-&gt;Height);<br><br>    <span class="hljs-comment">// The light pass is drawn from the first light.</span><br>    lightCams[<span class="hljs-number">0</span>].<span class="hljs-built_in">Get3DViewProjMatrices</span>(&amp;shadowConsts.view, &amp;shadowConsts.projection, <span class="hljs-number">90.0f</span>, pViewport-&gt;Width, pViewport-&gt;Height);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NumLights; i++)<br>    &#123;<br>        <span class="hljs-built_in">memcpy</span>(&amp;sceneConsts.lights[i], &amp;lights[i], <span class="hljs-built_in">sizeof</span>(LightState));<br>        <span class="hljs-built_in">memcpy</span>(&amp;shadowConsts.lights[i], &amp;lights[i], <span class="hljs-built_in">sizeof</span>(LightState));<br>    &#125;<br><br>    <span class="hljs-comment">// The shadow pass won&#x27;t sample the shadow map, but rather write to it.</span><br>    shadowConsts.sampleShadowMap = FALSE;<br><br>    <span class="hljs-comment">// The scene pass samples the shadow map.</span><br>    sceneConsts.sampleShadowMap = TRUE;<br><br>    shadowConsts.ambientColor = sceneConsts.ambientColor = &#123; <span class="hljs-number">0.1f</span>, <span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">1.0f</span> &#125;;<br><br>    <span class="hljs-built_in">memcpy</span>(mp_sceneConstantBufferWO, &amp;sceneConsts, <span class="hljs-built_in">sizeof</span>(SceneConstantBuffer));<br>    <span class="hljs-built_in">memcpy</span>(mp_shadowConstantBufferWO, &amp;shadowConsts, <span class="hljs-built_in">sizeof</span>(SceneConstantBuffer));<br>&#125;<br></code></pre></td></tr></table></figure><p>在<i><font color="Green">LoadAssets</font></i>函数的最后，代码创建了用于CPU—GPU同步的栅栏对象，并且令其等待之前的GPU资源创建执行完毕。</p><p>那么接下来就来分析初始化函数<i><font color="Green">OnInit</font></i>中的最后一个函数调用：<i><font color="Green">LoadContexts</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Initialize threads and events.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::LoadContexts</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !SINGLETHREADED</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">threadwrapper</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> WINAPI <span class="hljs-title">thunk</span><span class="hljs-params">(LPVOID lpParameter)</span></span><br><span class="hljs-function">        </span>&#123;<br>            ThreadParameter* parameter = <span class="hljs-built_in">reinterpret_cast</span>&lt;ThreadParameter*&gt;(lpParameter);<br>            D3D12Multithreading::<span class="hljs-built_in">Get</span>()-&gt;<span class="hljs-built_in">WorkerThread</span>(parameter-&gt;threadIndex);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NumContexts; i++)<br>    &#123;<br>        m_workerBeginRenderFrame[i] = <span class="hljs-built_in">CreateEvent</span>(<br>            <span class="hljs-literal">NULL</span>,<br>            FALSE,<br>            FALSE,<br>            <span class="hljs-literal">NULL</span>);<br><br>        m_workerFinishedRenderFrame[i] = <span class="hljs-built_in">CreateEvent</span>(<br>            <span class="hljs-literal">NULL</span>,<br>            FALSE,<br>            FALSE,<br>            <span class="hljs-literal">NULL</span>);<br><br>        m_workerFinishShadowPass[i] = <span class="hljs-built_in">CreateEvent</span>(<br>            <span class="hljs-literal">NULL</span>,<br>            FALSE,<br>            FALSE,<br>            <span class="hljs-literal">NULL</span>);<br><br>        m_threadParameters[i].threadIndex = i;<br><br>        m_threadHandles[i] = <span class="hljs-built_in">reinterpret_cast</span>&lt;HANDLE&gt;(_beginthreadex(<br>            <span class="hljs-literal">nullptr</span>,<br>            <span class="hljs-number">0</span>,<br>            threadwrapper::thunk,<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;LPVOID&gt;(&amp;m_threadParameters[i]),<br>            <span class="hljs-number">0</span>,<br>            <span class="hljs-literal">nullptr</span>));<br><br>        <span class="hljs-built_in">assert</span>(m_workerBeginRenderFrame[i] != <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">assert</span>(m_workerFinishedRenderFrame[i] != <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">assert</span>(m_threadHandles[i] != <span class="hljs-literal">NULL</span>);<br><br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>该函数用于分配各个线程录制命令任务。</p><p>函数开始处首先定义了一个仅包含一个静态函数的结构体<code>threadwrapper</code>，该结构体内静态函数<i><font color="Green">WorkerThread</font></i>的作用就是录制绘制命令，该函数需要一个自定义结构体<code>ThreadParameter</code>对象作为其参数，该结构体定义十分简单，仅包含一个代表线程ID的整数值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThreadParameter</span><br>&#123;<br>    <span class="hljs-type">int</span> threadIndex;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面来看<i><font color="Green">WorkerThread</font></i>函数的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Worker thread body. workerIndex is an integer from 0 to NumContexts </span><br><span class="hljs-comment">// describing the worker&#x27;s thread index.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::WorkerThread</span><span class="hljs-params">(<span class="hljs-type">int</span> threadIndex)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(threadIndex &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">assert</span>(threadIndex &lt; NumContexts);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !SINGLETHREADED</span><br><br>    <span class="hljs-keyword">while</span> (threadIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; threadIndex &lt; NumContexts)<br>    &#123;<br>        <span class="hljs-comment">// Wait for main thread to tell us to draw.</span><br><br>        <span class="hljs-built_in">WaitForSingleObject</span>(m_workerBeginRenderFrame[threadIndex], INFINITE);<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        ID3D12GraphicsCommandList* pShadowCommandList = m_pCurrentFrameResource-&gt;m_shadowCommandLists[threadIndex].<span class="hljs-built_in">Get</span>();<br>        ID3D12GraphicsCommandList* pSceneCommandList = m_pCurrentFrameResource-&gt;m_sceneCommandLists[threadIndex].<span class="hljs-built_in">Get</span>();<br><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// Shadow pass</span><br>        <span class="hljs-comment">//</span><br><br>        <span class="hljs-comment">// Populate the command list.</span><br>        <span class="hljs-built_in">SetCommonPipelineState</span>(pShadowCommandList);<br>        m_pCurrentFrameResource-&gt;<span class="hljs-built_in">Bind</span>(pShadowCommandList, FALSE, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);    <span class="hljs-comment">// No need to pass RTV or DSV descriptor heap.</span><br><br>        <span class="hljs-comment">// Set null SRVs for the diffuse/normal textures.</span><br>        pShadowCommandList-&gt;<span class="hljs-built_in">SetGraphicsRootDescriptorTable</span>(<span class="hljs-number">0</span>, m_cbvSrvHeap-&gt;<span class="hljs-built_in">GetGPUDescriptorHandleForHeapStart</span>());<br><br>        <span class="hljs-comment">// Distribute objects over threads by drawing only 1/NumContexts </span><br>        <span class="hljs-comment">// objects per worker (i.e. every object such that objectnum % </span><br>        <span class="hljs-comment">// NumContexts == threadIndex).</span><br>        <span class="hljs-built_in">PIXBeginEvent</span>(pShadowCommandList, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;Worker drawing shadow pass...&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = threadIndex; j &lt; _countof(SampleAssets::Draws); j += NumContexts)<br>        &#123;<br>            SampleAssets::DrawParameters drawArgs = SampleAssets::Draws[j];<br><br>            pShadowCommandList-&gt;<span class="hljs-built_in">DrawIndexedInstanced</span>(drawArgs.IndexCount, <span class="hljs-number">1</span>, drawArgs.IndexStart, drawArgs.VertexBase, <span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">PIXEndEvent</span>(pShadowCommandList);<br><br>        <span class="hljs-built_in">ThrowIfFailed</span>(pShadowCommandList-&gt;<span class="hljs-built_in">Close</span>());<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !SINGLETHREADED</span><br>        <span class="hljs-comment">// Submit shadow pass.</span><br>        <span class="hljs-built_in">SetEvent</span>(m_workerFinishShadowPass[threadIndex]);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// Scene pass</span><br>        <span class="hljs-comment">// </span><br><br>        <span class="hljs-comment">// Populate the command list.  These can only be sent after the shadow </span><br>        <span class="hljs-comment">// passes for this frame have been submitted.</span><br>        <span class="hljs-built_in">SetCommonPipelineState</span>(pSceneCommandList);<br>        <span class="hljs-function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="hljs-title">rtvHandle</span><span class="hljs-params">(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize)</span></span>;<br>        <span class="hljs-function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="hljs-title">dsvHandle</span><span class="hljs-params">(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart())</span></span>;<br>        m_pCurrentFrameResource-&gt;<span class="hljs-built_in">Bind</span>(pSceneCommandList, TRUE, &amp;rtvHandle, &amp;dsvHandle);<br><br>        <span class="hljs-built_in">PIXBeginEvent</span>(pSceneCommandList, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;Worker drawing scene pass...&quot;</span>);<br><br>        D3D12_GPU_DESCRIPTOR_HANDLE cbvSrvHeapStart = m_cbvSrvHeap-&gt;<span class="hljs-built_in">GetGPUDescriptorHandleForHeapStart</span>();<br>        <span class="hljs-type">const</span> UINT cbvSrvDescriptorSize = m_device-&gt;<span class="hljs-built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);<br>        <span class="hljs-type">const</span> UINT nullSrvCount = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = threadIndex; j &lt; _countof(SampleAssets::Draws); j += NumContexts)<br>        &#123;<br>            SampleAssets::DrawParameters drawArgs = SampleAssets::Draws[j];<br><br>            <span class="hljs-comment">// Set the diffuse and normal textures for the current object.</span><br>            <span class="hljs-function">CD3DX12_GPU_DESCRIPTOR_HANDLE <span class="hljs-title">cbvSrvHandle</span><span class="hljs-params">(cbvSrvHeapStart, nullSrvCount + drawArgs.DiffuseTextureIndex, cbvSrvDescriptorSize)</span></span>;<br>            pSceneCommandList-&gt;<span class="hljs-built_in">SetGraphicsRootDescriptorTable</span>(<span class="hljs-number">0</span>, cbvSrvHandle);<br><br>            pSceneCommandList-&gt;<span class="hljs-built_in">DrawIndexedInstanced</span>(drawArgs.IndexCount, <span class="hljs-number">1</span>, drawArgs.IndexStart, drawArgs.VertexBase, <span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">PIXEndEvent</span>(pSceneCommandList);<br>        <span class="hljs-built_in">ThrowIfFailed</span>(pSceneCommandList-&gt;<span class="hljs-built_in">Close</span>());<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !SINGLETHREADED</span><br>        <span class="hljs-comment">// Tell main thread that we are done.</span><br>        <span class="hljs-built_in">SetEvent</span>(m_workerFinishedRenderFrame[threadIndex]); <br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>首先，调用该函数的线程会等待对应的<i><font color="Orange">m_workerBeginRenderFrame</font></i>事件被触发，后续我们将会看到该事件实际上会在渲染循环开始时开头的线程做好准备工作之后被触发。也就是说一旦准备工作做好了，就可以开始录制绘制命令了。</p><p>我们已经知道该示例的绘制过程分两趟，首先需要进行shadowpass。D3D12中要开启一个pass的绘制，首先需要设置好一系列的管线状态以及资源对象。两趟pass公共的资源和状态设置是通过<i><font color="Green">SetCommonPipelineState</font></i>来完成的。该函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::SetCommonPipelineState</span><span class="hljs-params">(ID3D12GraphicsCommandList* pCommandList)</span></span><br><span class="hljs-function"></span>&#123;<br>    pCommandList-&gt;<span class="hljs-built_in">SetGraphicsRootSignature</span>(m_rootSignature.<span class="hljs-built_in">Get</span>());<br><br>    ID3D12DescriptorHeap* ppHeaps[] = &#123; m_cbvSrvHeap.<span class="hljs-built_in">Get</span>(), m_samplerHeap.<span class="hljs-built_in">Get</span>() &#125;;<br>    pCommandList-&gt;<span class="hljs-built_in">SetDescriptorHeaps</span>(_countof(ppHeaps), ppHeaps);<br><br>    pCommandList-&gt;<span class="hljs-built_in">RSSetViewports</span>(<span class="hljs-number">1</span>, &amp;m_viewport);<br>    pCommandList-&gt;<span class="hljs-built_in">RSSetScissorRects</span>(<span class="hljs-number">1</span>, &amp;m_scissorRect);<br>    pCommandList-&gt;<span class="hljs-built_in">IASetPrimitiveTopology</span>(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);<br>    pCommandList-&gt;<span class="hljs-built_in">IASetVertexBuffers</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;m_vertexBufferView);<br>    pCommandList-&gt;<span class="hljs-built_in">IASetIndexBuffer</span>(&amp;m_indexBufferView);<br>    pCommandList-&gt;<span class="hljs-built_in">SetGraphicsRootDescriptorTable</span>(<span class="hljs-number">3</span>, m_samplerHeap-&gt;<span class="hljs-built_in">GetGPUDescriptorHandleForHeapStart</span>());<br>    pCommandList-&gt;<span class="hljs-built_in">OMSetStencilRef</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// Render targets and depth stencil are set elsewhere because the </span><br>    <span class="hljs-comment">// depth stencil depends on the frame resource being used.</span><br><br>    <span class="hljs-comment">// Constant buffers are set elsewhere because they depend on the </span><br>    <span class="hljs-comment">// frame resource being used.</span><br><br>    <span class="hljs-comment">// SRVs are set elsewhere because they change based on the object </span><br>    <span class="hljs-comment">// being drawn.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注释中也明确说明了，渲染目标、深度缓冲、常量缓冲以及着色器资源并不会在该函数中设置，因为它们具体绑定哪个资源取决于当前帧或者当前绘制的对象。</p><p>在设置好通用资源状态之后，接下来就来绑定shadowpass的帧资源。帧资源类的<i><font color="Green">Bind</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Sets up the descriptor tables for the worker command list to use </span><br><span class="hljs-comment">// resources provided by frame resource.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FrameResource::Bind</span><span class="hljs-params">(ID3D12GraphicsCommandList* pCommandList, BOOL scenePass, D3D12_CPU_DESCRIPTOR_HANDLE* pRtvHandle, D3D12_CPU_DESCRIPTOR_HANDLE* pDsvHandle)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (scenePass)<br>    &#123;<br>        <span class="hljs-comment">// Scene pass. We use constant buf #2 and depth stencil #2</span><br>        <span class="hljs-comment">// with rendering to the render target enabled.</span><br>        pCommandList-&gt;<span class="hljs-built_in">SetGraphicsRootDescriptorTable</span>(<span class="hljs-number">2</span>, m_shadowDepthHandle);        <span class="hljs-comment">// Set the shadow texture as an SRV.</span><br>        pCommandList-&gt;<span class="hljs-built_in">SetGraphicsRootDescriptorTable</span>(<span class="hljs-number">1</span>, m_sceneCbvHandle);<br>        <br>        <span class="hljs-built_in">assert</span>(pRtvHandle != <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-built_in">assert</span>(pDsvHandle != <span class="hljs-literal">nullptr</span>);<br><br>        pCommandList-&gt;<span class="hljs-built_in">OMSetRenderTargets</span>(<span class="hljs-number">1</span>, pRtvHandle, FALSE, pDsvHandle);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// Shadow pass. We use constant buf #1 and depth stencil #1</span><br>        <span class="hljs-comment">// with rendering to the render target disabled.</span><br>        pCommandList-&gt;<span class="hljs-built_in">SetGraphicsRootDescriptorTable</span>(<span class="hljs-number">2</span>, m_nullSrvHandle);            <span class="hljs-comment">// Set a null SRV for the shadow texture.</span><br>        pCommandList-&gt;<span class="hljs-built_in">SetGraphicsRootDescriptorTable</span>(<span class="hljs-number">1</span>, m_shadowCbvHandle);<br><br>        pCommandList-&gt;<span class="hljs-built_in">OMSetRenderTargets</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, FALSE, &amp;m_shadowDepthView);    <span class="hljs-comment">// No render target needed for the shadow pass.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数会区分当前渲染的是shadow还是scene。如果是场景渲染，那么应当设置好之前的shadowpass生成的shadow map以及scenepass的常量缓冲区，渲染目标应该设置为正常的后台缓冲区。但是如果是阴影渲染，那么只需要设置shadowpass的常量缓冲区即可，该pass的作用是生成shadow map，因此shader中shadowmap资源绑定一个空视图即可，而且由于渲染深度图并不需要有任何颜色渲染，因此不需要绑定渲染目标，简单地将渲染目标设置为nullptr即可。</p><p>回到<i><font color="Green">WorkerThread</font></i>函数，在绑定了帧资源之后，对于shadowpass，由于该pass同样不需要用到diffuse map和normalmap，因此着色器中该资源对应的视图也可以直接绑定为空视图。注意空视图在之前的创建过程中是创建在描述符堆的开始处，所以只需要绑定<code>GetGPUDescriptorHandleForHeapStart</code>返回的描述符句柄即可。</p><p>在完成了所有资源的绑定和渲染状态的设置之后，终于可以进行shadowpass的绘制了。每个线程会负责录制<strong>总绘制物体数/线程数</strong>个物体的绘制命令。</p><p>在完成了shadowpass绘制命令的录制之后，就可以激活<i><font color="Orange">m_workerFinishShadowPass</font></i>事件以通知主线程该线程shadowpass命令录制已经完成，接着主线程就会在所有线程的相应事件都被激活之后统一提交所有线程录制的shadowpass有关命令，在后文分析渲染函数<i><font color="Green">OnRender</font></i>代码的时候会详细分析这一块的执行顺序和逻辑。</p><p>在录制完shadow pass的命令后，线程可以紧接着开始录制scenepass的命令。即使此时shadow pass的命令还没有执行完毕，提前录制scenepass渲染命令并不会有什么问题，因为后文在分析<i><font color="Green">OnRender</font></i>代码的时候会看到绘制命令的执行会在shadowmap的布局转换之后，而shadowpass的绘制命令会在布局转换之前完成，因此即使提前录制好了命令，也不会立刻执行，不会产生资源冲突。</p><p>scene pass绘制命令的录制流程和shadowpass差不多，只不过绑定的资源不尽相同，这里不再赘述。</p><p>在录制完所有scenepass绘制命令之后，同样需要将<i><font color="Orange">m_workerFinishedRenderFrame</font></i>设置为激活状态，以通知主线程可以提交并执行scenepass的命令。</p><p>下面回到<i><font color="Green">LoadContexts</font></i>函数。从上文<i><font color="Green">WorkerThread</font></i>函数代码可以看到在渲染命令的执行过程中需要用到许多事件进行同步，因此在初始化阶段理应创建好这些事件。这部分代码只需要注意到<code>CreateEvent</code>函数的第二个参数始终设置为FALSE，这意味着系统在释放单一等待线程之后（也就是某线程中的<code>WaitForSingleObject</code>函数等待到了该激活的事件）会自动将该事件重置回未激活状态，如果该参数设置为TRUE则需要使用<code>ResetEvent</code>才能将被激活的事件重置为未激活的状态。另外<code>CreateEvent</code>的第三个参数代表事件创建时是否处于激活状态，这里也设置为FALSE。</p><p>在创建好这些同步量之后，就可以调用<code>_beginthreadex</code>来启动每个线程了。该函数限制传递给它的执行函数类型一定要为<code>unsigned (__stdcall *)(void *)</code>，也就是说它的参数一定要是一个void*指针，这就是为什么代码需要费劲地将传递给该函数的指向<code>ThreadParameter</code>对象的指针参数转换为void**，然后在<i><font color="Green">thunk</font></i>函数中又将其转换回来的原因。另外，即使在准备阶段就启动了线程，也不用担心资源竞争，因为前文看到了各线程录制命令需要等待<i><font color="Orange">m_workerBeginRenderFrame</font></i>事件被激活，而该事件只会在渲染开始时被激活。</p><p>准备阶段终于是告一段落了，接下来让我们短暂地回到最开始的<i><font color="Green">Win32Application::Run</font></i>函数，现在我们已经分析完了<i><font color="Green">OnInit</font></i>函数，可以看到接下来就是主渲染循环了。该循环中系统会反复触发<i><font color="Red">WM_PAINT</font></i>信号，回调函数处理该信号的方式是先后调用应用程序类的<i><font color="Green">OnUpdate</font></i>和<i><font color="Green">OnRender</font></i>函数，那接下来就来依次分析这两个函数的代码。</p><hr><h2 id="onupdate">OnUpdate</h2><p>该函数用于更新每一帧有关的资源，其代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Update frame-based values.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::OnUpdate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    m_timer.<span class="hljs-built_in">Tick</span>(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">PIXSetMarker</span>(m_commandQueue.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;Getting last completed fence.&quot;</span>);<br><br>    <span class="hljs-comment">// Get current GPU progress against submitted workload. Resources still scheduled </span><br>    <span class="hljs-comment">// for GPU execution cannot be modified or else undefined behavior will result.</span><br>    <span class="hljs-type">const</span> UINT64 lastCompletedFence = m_fence-&gt;<span class="hljs-built_in">GetCompletedValue</span>();<br><br>    <span class="hljs-comment">// Move to the next frame resource.</span><br>    m_currentFrameResourceIndex = (m_currentFrameResourceIndex + <span class="hljs-number">1</span>) % FrameCount;<br>    m_pCurrentFrameResource = m_frameResources[m_currentFrameResourceIndex];<br><br>    <span class="hljs-comment">// Make sure that this frame resource isn&#x27;t still in use by the GPU.</span><br>    <span class="hljs-comment">// If it is, wait for it to complete.</span><br>    <span class="hljs-keyword">if</span> (m_pCurrentFrameResource-&gt;m_fenceValue &gt; lastCompletedFence)<br>    &#123;<br>        HANDLE eventHandle = <span class="hljs-built_in">CreateEvent</span>(<span class="hljs-literal">nullptr</span>, FALSE, FALSE, <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">if</span> (eventHandle == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">HRESULT_FROM_WIN32</span>(<span class="hljs-built_in">GetLastError</span>()));<br>        &#125;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_fence-&gt;<span class="hljs-built_in">SetEventOnCompletion</span>(m_pCurrentFrameResource-&gt;m_fenceValue, eventHandle));<br>        <span class="hljs-built_in">WaitForSingleObject</span>(eventHandle, INFINITE);<br>        <span class="hljs-built_in">CloseHandle</span>(eventHandle);<br>    &#125;<br><br>    m_cpuTimer.<span class="hljs-built_in">Tick</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">float</span> frameTime = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(m_timer.<span class="hljs-built_in">GetElapsedSeconds</span>());<br>    <span class="hljs-type">float</span> frameChange = <span class="hljs-number">2.0f</span> * frameTime;<br><br>    <span class="hljs-keyword">if</span> (m_keyboardInput.leftArrowPressed)<br>        m_camera.<span class="hljs-built_in">RotateYaw</span>(-frameChange);<br>    <span class="hljs-keyword">if</span> (m_keyboardInput.rightArrowPressed)<br>        m_camera.<span class="hljs-built_in">RotateYaw</span>(frameChange);<br>    <span class="hljs-keyword">if</span> (m_keyboardInput.upArrowPressed)<br>        m_camera.<span class="hljs-built_in">RotatePitch</span>(frameChange);<br>    <span class="hljs-keyword">if</span> (m_keyboardInput.downArrowPressed)<br>        m_camera.<span class="hljs-built_in">RotatePitch</span>(-frameChange);<br><br>    <span class="hljs-keyword">if</span> (m_keyboardInput.animate)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NumLights; i++)<br>        &#123;<br>            <span class="hljs-type">float</span> direction = frameChange * <span class="hljs-built_in">pow</span>(<span class="hljs-number">-1.0f</span>, i);<br>            <span class="hljs-built_in">XMStoreFloat4</span>(&amp;m_lights[i].position, <span class="hljs-built_in">XMVector4Transform</span>(<span class="hljs-built_in">XMLoadFloat4</span>(&amp;m_lights[i].position), <span class="hljs-built_in">XMMatrixRotationY</span>(direction)));<br><br>            XMVECTOR eye = <span class="hljs-built_in">XMLoadFloat4</span>(&amp;m_lights[i].position);<br>            XMVECTOR at = <span class="hljs-built_in">XMVectorSet</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">8.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>);<br>            <span class="hljs-built_in">XMStoreFloat4</span>(&amp;m_lights[i].direction, <span class="hljs-built_in">XMVector3Normalize</span>(<span class="hljs-built_in">XMVectorSubtract</span>(at, eye)));<br>            XMVECTOR up = <span class="hljs-built_in">XMVectorSet</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>);<br>            m_lightCameras[i].<span class="hljs-built_in">Set</span>(eye, at, up);<br><br>            m_lightCameras[i].<span class="hljs-built_in">Get3DViewProjMatrices</span>(&amp;m_lights[i].view, &amp;m_lights[i].projection, <span class="hljs-number">90.0f</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(m_width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(m_height));<br>        &#125;<br>    &#125;<br><br>    m_pCurrentFrameResource-&gt;<span class="hljs-built_in">WriteConstantBuffers</span>(&amp;m_viewport, &amp;m_camera, m_lightCameras, m_lights);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的逻辑十分简单：首先等待当前帧的所有帧资源被GPU使用完毕，这是通过判断当前帧的栅栏值是否大于<code>m_fence-&gt;GetCompletedValue()</code>得到的栅栏值来实现的，如果大于意味着GPU端还没有执行到这个栅栏点，因此需要在CPU端等待GPU执行完毕才能继续更新当前帧资源。如果读者对栅栏的使用不是十分了解的话，建议阅读龙书的初始化章节。</p><p>在GPU端执行完毕之后，程序就可以更新帧资源了，本示例中需要更新的资源只有传递给shadowpass的常量缓冲区中的灯光信息（前提是打开了<code>animate</code>选项），虽说代码中有处理键盘输入的逻辑，但之前我们也看到了，示例为了简单起见将键盘输入处理函数体设置为空，所以实际上这部分并没有发生任何更新。</p><hr><h2 id="onrender">OnRender</h2><p>这就是真正提交渲染命令的函数了，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Render the scene.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::OnRender</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-built_in">BeginFrame</span>();<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> SINGLETHREADED</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NumContexts; i++)<br>        &#123;<br>            <span class="hljs-built_in">WorkerThread</span>(i);<br>        &#125;<br>        <span class="hljs-built_in">MidFrame</span>();<br>        <span class="hljs-built_in">EndFrame</span>();<br>        m_commandQueue-&gt;<span class="hljs-built_in">ExecuteCommandLists</span>(_countof(m_pCurrentFrameResource-&gt;m_batchSubmit), m_pCurrentFrameResource-&gt;m_batchSubmit);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NumContexts; i++)<br>        &#123;<br>            <span class="hljs-built_in">SetEvent</span>(m_workerBeginRenderFrame[i]); <span class="hljs-comment">// Tell each worker to start drawing.</span><br>        &#125;<br><br>        <span class="hljs-built_in">MidFrame</span>();<br>        <span class="hljs-built_in">EndFrame</span>();<br><br>        <span class="hljs-built_in">WaitForMultipleObjects</span>(NumContexts, m_workerFinishShadowPass, TRUE, INFINITE);<br><br>        <span class="hljs-comment">// You can execute command lists on any thread. Depending on the work </span><br>        <span class="hljs-comment">// load, apps can choose between using ExecuteCommandLists on one thread </span><br>        <span class="hljs-comment">// vs ExecuteCommandList from multiple threads.</span><br>        m_commandQueue-&gt;<span class="hljs-built_in">ExecuteCommandLists</span>(NumContexts + <span class="hljs-number">2</span>, m_pCurrentFrameResource-&gt;m_batchSubmit); <span class="hljs-comment">// Submit PRE, MID and shadows.</span><br><br>        <span class="hljs-built_in">WaitForMultipleObjects</span>(NumContexts, m_workerFinishedRenderFrame, TRUE, INFINITE);<br><br>        <span class="hljs-comment">// Submit remaining command lists.</span><br>        m_commandQueue-&gt;<span class="hljs-built_in">ExecuteCommandLists</span>(_countof(m_pCurrentFrameResource-&gt;m_batchSubmit) - NumContexts - <span class="hljs-number">2</span>, m_pCurrentFrameResource-&gt;m_batchSubmit + NumContexts + <span class="hljs-number">2</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        m_cpuTimer.<span class="hljs-built_in">Tick</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span> (m_titleCount == TitleThrottle)<br>        &#123;<br>            WCHAR cpu[<span class="hljs-number">64</span>];<br>            <span class="hljs-built_in">swprintf_s</span>(cpu, <span class="hljs-string">L&quot;%.4f CPU&quot;</span>, m_cpuTime / m_titleCount);<br>            <span class="hljs-built_in">SetCustomWindowText</span>(cpu);<br><br>            m_titleCount = <span class="hljs-number">0</span>;<br>            m_cpuTime = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            m_titleCount++;<br>            m_cpuTime += m_cpuTimer.<span class="hljs-built_in">GetElapsedSeconds</span>() * <span class="hljs-number">1000</span>;<br>            m_cpuTimer.<span class="hljs-built_in">ResetElapsedTime</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// Present and update the frame index for the next frame.</span><br>        <span class="hljs-built_in">PIXBeginEvent</span>(m_commandQueue.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;Presenting to screen&quot;</span>);<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_swapChain-&gt;<span class="hljs-built_in">Present</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-built_in">PIXEndEvent</span>(m_commandQueue.<span class="hljs-built_in">Get</span>());<br>        m_frameIndex = m_swapChain-&gt;<span class="hljs-built_in">GetCurrentBackBufferIndex</span>();<br><br>        <span class="hljs-comment">// Signal and increment the fence value.</span><br>        m_pCurrentFrameResource-&gt;m_fenceValue = m_fenceValue;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_commandQueue-&gt;<span class="hljs-built_in">Signal</span>(m_fence.<span class="hljs-built_in">Get</span>(), m_fenceValue));<br>        m_fenceValue++;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (HrException&amp; e)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">Error</span>() == DXGI_ERROR_DEVICE_REMOVED || e.<span class="hljs-built_in">Error</span>() == DXGI_ERROR_DEVICE_RESET)<br>        &#123;<br>            <span class="hljs-built_in">RestoreD3DResources</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">throw</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数的开头使用<i><font color="Green">BeginFrame</font></i>进行渲染前的一些准备工作，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Assemble the CommandListPre command list.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::BeginFrame</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    m_pCurrentFrameResource-&gt;<span class="hljs-built_in">Init</span>();<br><br>    <span class="hljs-comment">// Indicate that the back buffer will be used as a render target.</span><br>    m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;<span class="hljs-built_in">ResourceBarrier</span>(<span class="hljs-number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="hljs-built_in">Transition</span>(m_renderTargets[m_frameIndex].<span class="hljs-built_in">Get</span>(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));<br><br>    <span class="hljs-comment">// Clear the render target and depth stencil.</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> clearColor[] = &#123; <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span> &#125;;<br>    <span class="hljs-function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="hljs-title">rtvHandle</span><span class="hljs-params">(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize)</span></span>;<br>    m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;<span class="hljs-built_in">ClearRenderTargetView</span>(rtvHandle, clearColor, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>    m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;<span class="hljs-built_in">ClearDepthStencilView</span>(m_dsvHeap-&gt;<span class="hljs-built_in">GetCPUDescriptorHandleForHeapStart</span>(), D3D12_CLEAR_FLAG_DEPTH, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-built_in">ThrowIfFailed</span>(m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;<span class="hljs-built_in">Close</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，该函数会先初始化帧资源，帧资源初始化函数<i><font color="Green">Init</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FrameResource::Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Reset the command allocators and lists for the main thread.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CommandListCount; i++)<br>    &#123;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_commandAllocators[i]-&gt;<span class="hljs-built_in">Reset</span>());<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_commandLists[i]-&gt;<span class="hljs-built_in">Reset</span>(m_commandAllocators[i].<span class="hljs-built_in">Get</span>(), m_pipelineState.<span class="hljs-built_in">Get</span>()));<br>    &#125;<br><br>    <span class="hljs-comment">// Clear the depth stencil buffer in preparation for rendering the shadow map.</span><br>    m_commandLists[CommandListPre]-&gt;<span class="hljs-built_in">ClearDepthStencilView</span>(m_shadowDepthView, D3D12_CLEAR_FLAG_DEPTH, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-comment">// Reset the worker command allocators and lists.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NumContexts; i++)<br>    &#123;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_shadowCommandAllocators[i]-&gt;<span class="hljs-built_in">Reset</span>());<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_shadowCommandLists[i]-&gt;<span class="hljs-built_in">Reset</span>(m_shadowCommandAllocators[i].<span class="hljs-built_in">Get</span>(), m_pipelineStateShadowMap.<span class="hljs-built_in">Get</span>()));<br><br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_sceneCommandAllocators[i]-&gt;<span class="hljs-built_in">Reset</span>());<br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_sceneCommandLists[i]-&gt;<span class="hljs-built_in">Reset</span>(m_sceneCommandAllocators[i].<span class="hljs-built_in">Get</span>(), m_pipelineState.<span class="hljs-built_in">Get</span>()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数会负责重置该帧所有的命令列表和分配器。前面看到了在调用<i><font color="Green">OnUpdate</font></i>函数的时候会等待命令列表中的命令全部执行完毕，因此在GPU执行完命令分配器所引用的所有命令之后重置分配器是没有问题的。另外，该函数还会在<i><font color="Orange">CommandListPre</font></i>（也就是第一个命令列表）中录制好清除深度缓存的命令，因为首先开始的是shadowpass，此时的深度缓存应该是shadowmap，它是帧资源，当然应该由帧资源的初始化函数负责清除工作。</p><p>回到<i><font color="Green">BeginFrame</font></i>函数，在重置帧资源命令列表之后，由于上一帧（指当前帧资源对应的上一帧，实际应该是前三帧）的后备缓冲区还处于显示布局，因此还应该将其转换回渲染目标布局，然后需要清除该缓冲区的颜色值，并且清除scenepass的深度缓冲区。这些命令全部录制在最开始的命令列表<i><font color="Orange">CommandListPre</font></i>中。</p><p>在做好准备工作之后，就可以设置<i><font color="Orange">m_workerBeginRenderFrame</font></i>事件为激活状态以开启各个线程的命令录制工作。接下来<i><font color="Green">OnRender</font></i>分别调用<i><font color="Green">MidFrame</font></i>和<i><font color="Green">EndFrame</font></i>函数来录制shadowpass与scene pass之间的命令以及scenepass结束之后的命令。先看<i><font color="Green">MidFrame</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Assemble the CommandListMid command list.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::MidFrame</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Transition our shadow map from the shadow pass to readable in the scene pass.</span><br>    m_pCurrentFrameResource-&gt;<span class="hljs-built_in">SwapBarriers</span>();<br><br>    <span class="hljs-built_in">ThrowIfFailed</span>(m_pCurrentFrameResource-&gt;m_commandLists[CommandListMid]-&gt;<span class="hljs-built_in">Close</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>首先调用帧资源类的<i><font color="Green">SwapBarrier</font></i>函数，其代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FrameResource::SwapBarriers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Transition the shadow map from writeable to readable.</span><br>    m_commandLists[CommandListMid]-&gt;<span class="hljs-built_in">ResourceBarrier</span>(<span class="hljs-number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="hljs-built_in">Transition</span>(m_shadowTexture.<span class="hljs-built_in">Get</span>(), D3D12_RESOURCE_STATE_DEPTH_WRITE, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到该函数的作用就是将shadow pass中用作深度缓冲的shadowmap转换为可以作为scenepass的着色器可读资源的布局，这也是<i><font color="Orange">CommandListMid</font></i>中录制的唯一命令。接下来来看<i><font color="Green">EndFrame</font></i>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Assemble the CommandListPost command list.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::EndFrame</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    m_pCurrentFrameResource-&gt;<span class="hljs-built_in">Finish</span>();<br><br>    <span class="hljs-comment">// Indicate that the back buffer will now be used to present.</span><br>    m_pCurrentFrameResource-&gt;m_commandLists[CommandListPost]-&gt;<span class="hljs-built_in">ResourceBarrier</span>(<span class="hljs-number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="hljs-built_in">Transition</span>(m_renderTargets[m_frameIndex].<span class="hljs-built_in">Get</span>(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));<br><br>    <span class="hljs-built_in">ThrowIfFailed</span>(m_pCurrentFrameResource-&gt;m_commandLists[CommandListPost]-&gt;<span class="hljs-built_in">Close</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p><i><font color="Green">Finish</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FrameResource::Finish</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    m_commandLists[CommandListPost]-&gt;<span class="hljs-built_in">ResourceBarrier</span>(<span class="hljs-number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="hljs-built_in">Transition</span>(m_shadowTexture.<span class="hljs-built_in">Get</span>(), D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_DEPTH_WRITE));<br>&#125;<br></code></pre></td></tr></table></figure><p>它的作用是将shadowmap的布局转变回可以写入深度的布局以便下一帧的shadowpass写入深度。<i><font color="Green">EndFrame</font></i>还负责将后备缓冲区布局转换为显示布局以便显示到屏幕上。</p><p>这样事实上该示例的所有命令都已经录制完毕了。在此之后<i><font color="Green">OnRender</font></i>会等待所有线程均录制完shadowpass所需的命令并激活相应的<i><font color="Orange">m_workerFinishShadowPass</font></i>事件，一旦所有线程均录制完成，就可以一并提交<i><font color="Orange">CommandListPre</font></i>、所有线程中用于录制shadowpass命令的命令列表以及<i><font color="Orange">CommandListMid</font></i>到命令队列执行。那么这些不同列表之间的命令究竟是如何得到同步的呢？首先，<code>ExecuteCommandLists</code>可以提交一系列的命令列表，这些命令列表一定会按照提交的顺序开始执行，也就是说后提交的命令一定会等到先提交的命令开始执行了才开始执行，但是注意，这并不意味着后提交的命令一定会后于先提交的命令完成，这些命令的完成顺序仍然是未知的。这也就是说，<i><font color="Orange">CommandListMid</font></i>中录制的命令一定会晚于shadowpass命令列表中的命令开始，而在<i><font color="Orange">CommandListMid</font></i>中代码仅仅是录制了一条借助资源屏障的shadowmap布局转换命令，但是资源屏障本身就是具有同步的作用的。具体来说，资源屏障可以保证位于资源屏障之前录制的命令一定在执行到资源屏障命令之前完成，同样的，录制在资源屏障命令之后的命令一定会等待资源屏障命令执行完毕之后才会开始执行，因此，命令列表的提交顺序保证了shadowpass的命令是在资源屏障命令之前录制的，而资源屏障本身又保证了shadowpass中的命令一定会在后续命令开始之前完成，这样就完成了资源的同步，保证后续scenepass可以使用到正确布局且并未被GPU占用的资源。</p><p>接下来<i><font color="Green">OnRender</font></i>同样会等待所有线程的<i><font color="Orange">m_workerFinishedRenderFrame</font></i>事件被激活，这意味着scenepass的命令录制已经全部完成，那么就可以将scenepass的所有线程命令列表以及最后的<i><font color="Orange">CommandListEnd</font></i>一并提交到命令队列执行。同样，<i><font color="Orange">CommandListMid</font></i>中使用的资源屏障保证了scenepass的渲染命令一定会在shadowmap完成了布局转换之后执行，而<i><font color="Orange">CommandListEnd</font></i>中使用的资源布局保证了scenepass的渲染操作能够在显示渲染结果之前完成。</p><p>然后就是一些计时有关的操作，这里不做详细分析。最后，<i><font color="Green">OnRender</font></i>还需要更新保存的当前帧索引<i><font color="Orange">m_frameIndex</font></i>（由于已经调用了<code>Present</code>函数，因此当前后备缓冲区已经发生了更新，所以直接使用<code>GetCurrentBackBufferIndex</code>就可以获取当前帧索引）。最后，函数激活并且增加栅栏值以供下一帧<i><font color="Orange">OnUpdate</font></i>进行同步的时候使用。</p><p>这样就完成了渲染循环的分析。整个代码的分析也基本结束了。在程序的最后还有资源销毁函数<i><font color="Green">OnDestroy</font></i>，销毁资源时唯一需要注意的是要等待GPU完成所有工作了再销毁程序资源。这里对该函数不做分析，仅放上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::OnDestroy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Ensure that the GPU is no longer referencing resources that are about to be</span><br>    <span class="hljs-comment">// cleaned up by the destructor.</span><br>    &#123;<br>        <span class="hljs-type">const</span> UINT64 fence = m_fenceValue;<br>        <span class="hljs-type">const</span> UINT64 lastCompletedFence = m_fence-&gt;<span class="hljs-built_in">GetCompletedValue</span>();<br><br>        <span class="hljs-comment">// Signal and increment the fence value.</span><br>        <span class="hljs-built_in">ThrowIfFailed</span>(m_commandQueue-&gt;<span class="hljs-built_in">Signal</span>(m_fence.<span class="hljs-built_in">Get</span>(), m_fenceValue));<br>        m_fenceValue++;<br><br>        <span class="hljs-comment">// Wait until the previous frame is finished.</span><br>        <span class="hljs-keyword">if</span> (lastCompletedFence &lt; fence)<br>        &#123;<br>            <span class="hljs-built_in">ThrowIfFailed</span>(m_fence-&gt;<span class="hljs-built_in">SetEventOnCompletion</span>(fence, m_fenceEvent));<br>            <span class="hljs-built_in">WaitForSingleObject</span>(m_fenceEvent, INFINITE);<br>        &#125;<br>        <span class="hljs-built_in">CloseHandle</span>(m_fenceEvent);<br>    &#125;<br><br>    <span class="hljs-comment">// Close thread events and thread handles.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NumContexts; i++)<br>    &#123;<br>        <span class="hljs-built_in">CloseHandle</span>(m_workerBeginRenderFrame[i]);<br>        <span class="hljs-built_in">CloseHandle</span>(m_workerFinishShadowPass[i]);<br>        <span class="hljs-built_in">CloseHandle</span>(m_workerFinishedRenderFrame[i]);<br>        <span class="hljs-built_in">CloseHandle</span>(m_threadHandles[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; _countof(m_frameResources); i++)<br>    &#123;<br>        <span class="hljs-keyword">delete</span> m_frameResources[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样总算是理清了该示例的整体逻辑，也看到了多线程并发在实时渲染中的威力以及相应的复杂性，这也是现代图形API相对于古早API的一大优势，是现代图形API学习者所必须掌握的一环。</p><hr><h2 id="性能分析">性能分析</h2><p>最后我在官方代码的基础上添加了一个ImGui组件用于显示渲染帧率。关于在D3D12中ImGui的使用范例可以参考<a href="https://github.com/ocornut/imgui/blob/master/examples/example_win32_directx12/main.cpp#L479"><code>ImGui官方示例</code></a>。</p><p>首先是为项目添加ImGui支持。本来只需要添加相应的文件到项目中来就好了。然而官方示例将文件<strong>stdafx.h</strong>进行了预编译（在项目属性的预编译头栏中可以看到），导致所有添加到项目中的源文件都必须include这个头文件，然而ImGui源文件里面肯定是不能直接添加一个include该头文件的指令的（自己也试了下，报一堆错，懒得分析了。。。），然而又必须得将ImGui相应的源文件添加到项目中来，不然会报错无法解析的外部符号（链接器找不到ImGui头文件里面函数的定义）。。。于是思来想去，我决定将需要使用到的ImGui文件编译为一个静态库然后链接到程序中去，并且在<strong>stdafx.h</strong>中添加对ImGui头文件的include指令，此问题得以解决。</p><p>然后就是绘制Gui了。这里我主要是参考的官方示例，不过略微改动了一下示例的<i><font color="Green">EndFrame</font></i>函数，将其中对渲染目标布局的转换命令挪到了之后执行的Gui绘制命令列表中进行录制，这是因为我们当然不希望在绘制Gui的时候渲染目标的布局已经变为显示布局了。下面放上我添加的Gui绘制相应代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::OnRender</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <br>    m_cpuTimer.<span class="hljs-built_in">Tick</span>(<span class="hljs-literal">NULL</span>);<br><br><span class="hljs-keyword">if</span> (m_titleCount == TitleThrottle)<br>&#123;<br>    WCHAR cpu[<span class="hljs-number">64</span>];<br>    <span class="hljs-built_in">swprintf_s</span>(cpu, <span class="hljs-string">L&quot;%.4f CPU&quot;</span>, m_cpuTime / m_titleCount);<br>    <span class="hljs-built_in">SetCustomWindowText</span>(cpu);<br><br>    m_titleCount = <span class="hljs-number">0</span>;<br>    m_cpuTime = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    m_titleCount++;<br>    m_cpuTime += m_cpuTimer.<span class="hljs-built_in">GetElapsedSeconds</span>() * <span class="hljs-number">1000</span>;<br>    m_cpuTimer.<span class="hljs-built_in">ResetElapsedTime</span>();<br>&#125;<br><br>    <span class="hljs-comment">//进行Gui的绘制</span><br><span class="hljs-built_in">ThrowIfFailed</span>(gui_commands-&gt;<span class="hljs-built_in">Reset</span>(m_commandAllocator.<span class="hljs-built_in">Get</span>(), <span class="hljs-literal">nullptr</span>));<br><span class="hljs-built_in">recordGui</span>();<br>m_commandQueue-&gt;<span class="hljs-built_in">ExecuteCommandLists</span>(<span class="hljs-number">1</span>, submit_commands.<span class="hljs-built_in">GetAddressOf</span>());<br><br><span class="hljs-comment">// Present and update the frame index for the next frame.</span><br><span class="hljs-built_in">PIXBeginEvent</span>(m_commandQueue.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;Presenting to screen&quot;</span>);<br><span class="hljs-built_in">ThrowIfFailed</span>(m_swapChain-&gt;<span class="hljs-built_in">Present</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><span class="hljs-built_in">PIXEndEvent</span>(m_commandQueue.<span class="hljs-built_in">Get</span>());<br>m_frameIndex = m_swapChain-&gt;<span class="hljs-built_in">GetCurrentBackBufferIndex</span>();<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::drawGui</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">ImGui_ImplDX12_NewFrame</span>();<br>    <span class="hljs-built_in">ImGui_ImplWin32_NewFrame</span>();<br>    ImGui::<span class="hljs-built_in">NewFrame</span>();<br><br>    ImGui::<span class="hljs-built_in">Begin</span>(<span class="hljs-string">&quot;Profiler&quot;</span>);<br>    <span class="hljs-type">float</span> frameTime = m_cpuTime / m_titleCount;<br>    ImGui::<span class="hljs-built_in">Text</span>(<span class="hljs-string">&quot;Frame Time:   %.4f ms/frame&quot;</span>, frameTime);<br>    ImGui::<span class="hljs-built_in">Text</span>(<span class="hljs-string">&quot;Framerate:   %.4f fps&quot;</span>, <span class="hljs-number">1000.0f</span> / frameTime);<br>    ImGui::<span class="hljs-built_in">End</span>();<br><br>    ImGui::<span class="hljs-built_in">Render</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3D12Multithreading::recordGui</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">drawGui</span>();<br>    <span class="hljs-function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="hljs-title">rtvHandle</span><span class="hljs-params">(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize)</span></span>;<br>    gui_commands-&gt;<span class="hljs-built_in">OMSetRenderTargets</span>(<span class="hljs-number">1</span>, &amp;rtvHandle, FALSE, <span class="hljs-literal">nullptr</span>);<br>    gui_commands-&gt;<span class="hljs-built_in">SetDescriptorHeaps</span>(<span class="hljs-number">1</span>, gui_heap.<span class="hljs-built_in">GetAddressOf</span>());<br>    <span class="hljs-built_in">ImGui_ImplDX12_RenderDrawData</span>(ImGui::<span class="hljs-built_in">GetDrawData</span>(), gui_commands.<span class="hljs-built_in">Get</span>());<br>    gui_commands-&gt;<span class="hljs-built_in">ResourceBarrier</span>(<span class="hljs-number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::<span class="hljs-built_in">Transition</span>(m_renderTargets[m_frameIndex].<span class="hljs-built_in">Get</span>(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));<br>    gui_commands-&gt;<span class="hljs-built_in">Close</span>();<br><br>    submit_commands = gui_commands.<span class="hljs-built_in">Get</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>Gui的初始化部分和官方示例基本一致，这里就没有给出相应的代码部分了。</p><p>最后，来对比一下使用单线程和多线程渲染的帧率：</p><figure><img src="/2025/03/07/CG_api/d3d12/directX_samples/D3D12Multithreading/single.png" alt="单线程"><figcaption aria-hidden="true">单线程</figcaption></figure><figure><img src="/2025/03/07/CG_api/d3d12/directX_samples/D3D12Multithreading/multi.png" alt="多线程"><figcaption aria-hidden="true">多线程</figcaption></figure><p>可以看到在本示例中多线程渲染的帧率在我的电脑上几乎是单线程帧率的两倍，该示例还是比较简单的场景，更为复杂的场景或许使用多线程渲染会有更加显著的性能提升，多线程渲染在实时渲染中的作用可见一斑。</p><hr>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>d3d12</category>
      
      <category>DirectX_samples</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ray tracing basic</title>
    <link href="/2025/02/27/CG_api/vulkan/vulkan_samples/ray_tracing_basic/"/>
    <url>/2025/02/27/CG_api/vulkan/vulkan_samples/ray_tracing_basic/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言">前言</h2><p>从这篇起，我将开始Vulkan官方示例集中光线追踪部分的学习。官方示例集中提供了五个示例供Vulkan光追的学习，本文将重点分析第一个最为简单的示例。</p><p>如果有读者对光线追踪的原理不是很了解，可以参考<a href="https://www.bilibili.com/video/BV1X7411F744?spm_id_from=333.788.videopod.episodes&amp;vd_source=96b763f75b621baa119e5118b6164aee&amp;p=13"><code>games101</code></a>中关于光追的部分，可以说是解释得十分清晰详细了。另外，大名鼎鼎的<a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html"><code>ray tracing in one weekend</code></a>也是学习光追实现的好材料。本文非必要将不会涉及太多光追的原理，而是着重于Vulkan中光追的实现。关于Vulkan中的光追如何实现以及相关API使用的具体规范，可以参考<a href="https://docs.vulkan.org/guide/latest/extensions/ray_tracing.html"><code>官方文档</code></a>或者<a href="https://www.khronos.org/blog/ray-tracing-in-vulkan"><code>Khronos Group发表的文章</code></a>。</p><p>那下面就让我们推开Vulkan光追的大门一探究竟吧~</p><hr><h2 id="效果">效果</h2><p><strong>ray_tracing_basic</strong>示例仅绘制了一个再普通不过的三角形，和直接使用光栅化绘制出的三角形并无二致，这里放上程序运行的结果：</p><figure><img src="/2025/02/27/CG_api/vulkan/vulkan_samples/ray_tracing_basic/triangle.png" alt="光追三角形"><figcaption aria-hidden="true">光追三角形</figcaption></figure><hr><h2 id="特性拓展">特性拓展</h2><p>首先还是来看一下使用基本的光线追踪需要开启的拓展：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++">RaytracingBasic::<span class="hljs-built_in">RaytracingBasic</span>()<br>&#123;<br>title = <span class="hljs-string">&quot;Hardware accelerated ray tracing&quot;</span>;<br><br><span class="hljs-comment">// SPIRV 1.4 requires Vulkan 1.1</span><br><span class="hljs-built_in">set_api_version</span>(VK_API_VERSION_1_1);<br><br><span class="hljs-comment">// Ray tracing related extensions required by this sample</span><br><span class="hljs-built_in">add_device_extension</span>(VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME);<br><span class="hljs-built_in">add_device_extension</span>(VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME);<br><br><span class="hljs-comment">// Required by VK_KHR_acceleration_structure</span><br><span class="hljs-built_in">add_device_extension</span>(VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME);<br><span class="hljs-built_in">add_device_extension</span>(VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME);<br><span class="hljs-built_in">add_device_extension</span>(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME);<br><br><span class="hljs-comment">// Required for VK_KHR_ray_tracing_pipeline</span><br><span class="hljs-built_in">add_device_extension</span>(VK_KHR_SPIRV_1_4_EXTENSION_NAME);<br><br><span class="hljs-comment">// Required by VK_KHR_spirv_1_4</span><br><span class="hljs-built_in">add_device_extension</span>(VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME);<br>&#125;<br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::request_gpu_features</span><span class="hljs-params">(vkb::PhysicalDevice &amp;gpu)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// Enable extension features required by this sample</span><br><span class="hljs-comment">// These are passed to device creation via a pNext structure chain</span><br><span class="hljs-built_in">REQUEST_REQUIRED_FEATURE</span>(gpu,<br>                         VkPhysicalDeviceBufferDeviceAddressFeatures,<br>                         VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,<br>                         bufferDeviceAddress);<br><br><span class="hljs-built_in">REQUEST_REQUIRED_FEATURE</span>(gpu,<br>                         VkPhysicalDeviceRayTracingPipelineFeaturesKHR,<br>                         VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,<br>                         rayTracingPipeline);<br><br><span class="hljs-built_in">REQUEST_REQUIRED_FEATURE</span>(gpu,<br>                         VkPhysicalDeviceAccelerationStructureFeaturesKHR,<br>                         VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,<br>                         accelerationStructure);<br>&#125;<br></code></pre></td></tr></table></figure><p>本例中需要和光线追踪管线、加速结构构建以及缓冲区设备地址有关的拓展特性。（是必须的，所以没有像之前的mdi那个示例一样使用几个布尔成员记录特性是否支持，不支持就使用fallback。）</p><hr><h2 id="准备阶段">准备阶段</h2><p>准备函数<i><font color="Green">prepare</font></i>的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">RaytracingBasic::prepare</span><span class="hljs-params">(<span class="hljs-type">const</span> vkb::ApplicationOptions &amp;options)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!ApiVulkanSample::<span class="hljs-built_in">prepare</span>(options))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// This sample copies the ray traced output to the swap chain image, so we need to enable the required image usage flags</span><br><span class="hljs-type">const</span> std::set&lt;VkImageUsageFlagBits&gt; image_usage_flags = &#123;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_TRANSFER_DST_BIT&#125;;<br><span class="hljs-built_in">update_swapchain_image_usage_flags</span>(image_usage_flags);<br><br><span class="hljs-comment">// This sample renders the UI overlay on top of the ray tracing output, so we need to disable color attachment clears</span><br><span class="hljs-built_in">update_render_pass_flags</span>(RenderPassCreateFlags::ColorAttachmentLoad);<br><br><span class="hljs-comment">// Get the ray tracing pipeline properties, which we&#x27;ll need later on in the sample</span><br>ray_tracing_pipeline_properties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR;<br>VkPhysicalDeviceProperties2 device_properties&#123;&#125;;<br>device_properties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;<br>device_properties.pNext = &amp;ray_tracing_pipeline_properties;<br><span class="hljs-built_in">vkGetPhysicalDeviceProperties2</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_handle</span>(), &amp;device_properties);<br><br><span class="hljs-comment">// Get the acceleration structure features, which we&#x27;ll need later on in the sample</span><br>acceleration_structure_features.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR;<br>VkPhysicalDeviceFeatures2 device_features&#123;&#125;;<br>device_features.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;<br>device_features.pNext = &amp;acceleration_structure_features;<br><span class="hljs-built_in">vkGetPhysicalDeviceFeatures2</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_handle</span>(), &amp;device_features);<br><br>camera.type = vkb::CameraType::LookAt;<br>camera.<span class="hljs-built_in">set_perspective</span>(<span class="hljs-number">60.0f</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(width) / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(height), <span class="hljs-number">0.1f</span>, <span class="hljs-number">512.0f</span>);<br>camera.<span class="hljs-built_in">set_rotation</span>(glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>));<br>camera.<span class="hljs-built_in">set_translation</span>(glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-2.5f</span>));<br><br><span class="hljs-built_in">create_storage_image</span>();<br><span class="hljs-built_in">create_scene</span>();<br><span class="hljs-built_in">create_uniform_buffer</span>();<br><span class="hljs-built_in">create_ray_tracing_pipeline</span>();<br><span class="hljs-built_in">create_shader_binding_tables</span>();<br><span class="hljs-built_in">create_descriptor_sets</span>();<br><span class="hljs-built_in">build_command_buffers</span>();<br>prepared = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，交换链实际上是由应用程序类的基类构建好的，这就意味着事实上应用程序最初拥有的交换链是通用交换链，交换链图像仅可作为渲染目标使用（也就是枚举<i><font color="Red">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</font></i>对应的用途），但如果想要使用Vulkan光线追踪，一般是需要先将光线追踪生成的图像渲染到一张<strong>Storageimage</strong>上，然后再将<strong>Storageimage</strong>上的图像数据copy到交换链图像上去显示。因此，准备阶段开头首先需要更新交换链图像，将其同时设置为可以作为数据传输目标的图像（<i><font color="Red">VK_IMAGE_USAGE_TRANSFER_DST_BIT</font></i>），然后重建交换链以及相关资源。<i><font color="Green">update_swapchain_image_usage_flags</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ApiVulkanSample::update_swapchain_image_usage_flags</span><span class="hljs-params">(std::set&lt;VkImageUsageFlagBits&gt; image_usage_flags)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">update_swapchain</span>(image_usage_flags);<br><span class="hljs-built_in">create_swapchain_buffers</span>();<br><span class="hljs-built_in">setup_framebuffer</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个基类中的函数，这里不会具体分析它的代码逻辑，只需要知道它的功能就是负责根据新的渲染图像使用用途更新交换链，然后获取新的交换链图像句柄，并创建相应的图像视图保存在一个<code>SwapchainBuffer</code>结构体向量中，并且更新交换链图像相应的帧缓冲。</p><p>接下来，函数的注释行解释了为什么要更新渲染通道。这是因为基类创建的渲染通道默认是在执行通道之前会清除掉缓冲图像中的内容的，但是在本实例中我们需要在渲染通道开启之前将光追得到的图像复制到交换链图像上去，这就意味着渲染通道开始时我们不能清除已有的内容（不然光追就白做了。。。），而是要在光追得到的图像结果的基础上绘制UI界面。更新渲染通道代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ApiVulkanSample::update_render_pass_flags</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">vkDestroyRenderPass</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), render_pass, <span class="hljs-literal">nullptr</span>);<br><br>VkAttachmentLoadOp  color_attachment_load_op      = VK_ATTACHMENT_LOAD_OP_CLEAR;<br>VkAttachmentStoreOp color_attachment_store_op     = VK_ATTACHMENT_STORE_OP_STORE;<br>VkImageLayout       color_attachment_image_layout = VK_IMAGE_LAYOUT_UNDEFINED;<br><br><span class="hljs-comment">// Samples can keep the color attachment contents, e.g. if they have previously written to the swap chain images</span><br><span class="hljs-keyword">if</span> (flags &amp; RenderPassCreateFlags::ColorAttachmentLoad)<br>&#123;<br>color_attachment_load_op      = VK_ATTACHMENT_LOAD_OP_LOAD;<br>color_attachment_image_layout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;<br>&#125;<br><br>std::array&lt;VkAttachmentDescription, 2&gt; attachments = &#123;&#125;;<br><span class="hljs-comment">// Color attachment</span><br>attachments[<span class="hljs-number">0</span>].format         = <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_format</span>();<br>attachments[<span class="hljs-number">0</span>].samples        = VK_SAMPLE_COUNT_1_BIT;<br>attachments[<span class="hljs-number">0</span>].loadOp         = color_attachment_load_op;<br>attachments[<span class="hljs-number">0</span>].storeOp        = color_attachment_store_op;<br>attachments[<span class="hljs-number">0</span>].stencilLoadOp  = VK_ATTACHMENT_LOAD_OP_DONT_CARE;<br>attachments[<span class="hljs-number">0</span>].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>attachments[<span class="hljs-number">0</span>].initialLayout  = color_attachment_image_layout;<br>attachments[<span class="hljs-number">0</span>].finalLayout    = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;<br><span class="hljs-comment">// Depth attachment</span><br>attachments[<span class="hljs-number">1</span>].format         = depth_format;<br>attachments[<span class="hljs-number">1</span>].samples        = VK_SAMPLE_COUNT_1_BIT;<br>attachments[<span class="hljs-number">1</span>].loadOp         = VK_ATTACHMENT_LOAD_OP_CLEAR;<br>attachments[<span class="hljs-number">1</span>].storeOp        = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>attachments[<span class="hljs-number">1</span>].stencilLoadOp  = VK_ATTACHMENT_LOAD_OP_CLEAR;<br>attachments[<span class="hljs-number">1</span>].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>attachments[<span class="hljs-number">1</span>].initialLayout  = VK_IMAGE_LAYOUT_UNDEFINED;<br>attachments[<span class="hljs-number">1</span>].finalLayout    = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;<br><br>VkAttachmentReference color_reference = &#123;&#125;;<br>color_reference.attachment            = <span class="hljs-number">0</span>;<br>color_reference.layout                = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;<br><br>VkAttachmentReference depth_reference = &#123;&#125;;<br>depth_reference.attachment            = <span class="hljs-number">1</span>;<br>depth_reference.layout                = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;<br><br>VkSubpassDescription subpass_description    = &#123;&#125;;<br>subpass_description.pipelineBindPoint       = VK_PIPELINE_BIND_POINT_GRAPHICS;<br>subpass_description.colorAttachmentCount    = <span class="hljs-number">1</span>;<br>subpass_description.pColorAttachments       = &amp;color_reference;<br>subpass_description.pDepthStencilAttachment = &amp;depth_reference;<br>subpass_description.inputAttachmentCount    = <span class="hljs-number">0</span>;<br>subpass_description.pInputAttachments       = <span class="hljs-literal">nullptr</span>;<br>subpass_description.preserveAttachmentCount = <span class="hljs-number">0</span>;<br>subpass_description.pPreserveAttachments    = <span class="hljs-literal">nullptr</span>;<br>subpass_description.pResolveAttachments     = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-comment">// Subpass dependencies for layout transitions</span><br>std::array&lt;VkSubpassDependency, 2&gt; dependencies&#123;&#125;;<br><br>dependencies[<span class="hljs-number">0</span>].srcSubpass      = VK_SUBPASS_EXTERNAL;<br>dependencies[<span class="hljs-number">0</span>].dstSubpass      = <span class="hljs-number">0</span>;<br>dependencies[<span class="hljs-number">0</span>].srcStageMask    = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;<br>dependencies[<span class="hljs-number">0</span>].dstStageMask    = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT;<br>dependencies[<span class="hljs-number">0</span>].srcAccessMask   = VK_ACCESS_NONE_KHR;<br>dependencies[<span class="hljs-number">0</span>].dstAccessMask   = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;<br>dependencies[<span class="hljs-number">0</span>].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;<br><br>dependencies[<span class="hljs-number">1</span>].srcSubpass      = <span class="hljs-number">0</span>;<br>dependencies[<span class="hljs-number">1</span>].dstSubpass      = VK_SUBPASS_EXTERNAL;<br>dependencies[<span class="hljs-number">1</span>].srcStageMask    = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT;<br>dependencies[<span class="hljs-number">1</span>].dstStageMask    = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;<br>dependencies[<span class="hljs-number">1</span>].srcAccessMask   = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;<br>dependencies[<span class="hljs-number">1</span>].dstAccessMask   = VK_ACCESS_MEMORY_READ_BIT;<br>dependencies[<span class="hljs-number">1</span>].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;<br><br>VkRenderPassCreateInfo render_pass_create_info = &#123;&#125;;<br>render_pass_create_info.sType                  = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;<br>render_pass_create_info.attachmentCount        = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attachments.<span class="hljs-built_in">size</span>());<br>render_pass_create_info.pAttachments           = attachments.<span class="hljs-built_in">data</span>();<br>render_pass_create_info.subpassCount           = <span class="hljs-number">1</span>;<br>render_pass_create_info.pSubpasses             = &amp;subpass_description;<br>render_pass_create_info.dependencyCount        = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(dependencies.<span class="hljs-built_in">size</span>());<br>render_pass_create_info.pDependencies          = dependencies.<span class="hljs-built_in">data</span>();<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateRenderPass</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;render_pass_create_info, <span class="hljs-literal">nullptr</span>, &amp;render_pass));<br>&#125;<br></code></pre></td></tr></table></figure><p>这也是一个基类的函数，其中渲染通道的创建逻辑十分常规，在<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/"><code>我之前的文章</code></a>中已经详细地梳理过这部分内容，这里不再赘述。</p><p>接下来代码获取了光追管线和加速结构的硬件特性，这在之后创建管线和加速结构的时候会用到，到那部分内容的时候我们再讲。</p><p>在设置好摄像机类型和参数后，下面就来逐一分析一连串函数调用中各自的逻辑吧：</p><h3 id="create_storage_image">create_storage_image</h3><p>先上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Set up a storage image that the ray generation shader will be writing to</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::create_storage_image</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>storage_image.width  = width;<br>storage_image.height = height;<br><br>VkImageCreateInfo image = vkb::initializers::<span class="hljs-built_in">image_create_info</span>();<br>image.imageType         = VK_IMAGE_TYPE_2D;<br>image.format            = VK_FORMAT_B8G8R8A8_UNORM;<br>image.extent.width      = storage_image.width;<br>image.extent.height     = storage_image.height;<br>image.extent.depth      = <span class="hljs-number">1</span>;<br>image.mipLevels         = <span class="hljs-number">1</span>;<br>image.arrayLayers       = <span class="hljs-number">1</span>;<br>image.samples           = VK_SAMPLE_COUNT_1_BIT;<br>image.tiling            = VK_IMAGE_TILING_OPTIMAL;<br>image.usage             = VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_STORAGE_BIT;<br>image.initialLayout     = VK_IMAGE_LAYOUT_UNDEFINED;<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateImage</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;image, <span class="hljs-literal">nullptr</span>, &amp;storage_image.image));<br><br>VkMemoryRequirements memory_requirements;<br><span class="hljs-built_in">vkGetImageMemoryRequirements</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), storage_image.image, &amp;memory_requirements);<br>VkMemoryAllocateInfo memory_allocate_info = vkb::initializers::<span class="hljs-built_in">memory_allocate_info</span>();<br>memory_allocate_info.allocationSize       = memory_requirements.size;<br>memory_allocate_info.memoryTypeIndex      = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_memory_type</span>(memory_requirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateMemory</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;memory_allocate_info, <span class="hljs-literal">nullptr</span>, &amp;storage_image.memory));<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBindImageMemory</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), storage_image.image, storage_image.memory, <span class="hljs-number">0</span>));<br><br>VkImageViewCreateInfo color_image_view           = vkb::initializers::<span class="hljs-built_in">image_view_create_info</span>();<br>color_image_view.viewType                        = VK_IMAGE_VIEW_TYPE_2D;<br>color_image_view.format                          = VK_FORMAT_B8G8R8A8_UNORM;<br>color_image_view.subresourceRange                = &#123;&#125;;<br>color_image_view.subresourceRange.aspectMask     = VK_IMAGE_ASPECT_COLOR_BIT;<br>color_image_view.subresourceRange.baseMipLevel   = <span class="hljs-number">0</span>;<br>color_image_view.subresourceRange.levelCount     = <span class="hljs-number">1</span>;<br>color_image_view.subresourceRange.baseArrayLayer = <span class="hljs-number">0</span>;<br>color_image_view.subresourceRange.layerCount     = <span class="hljs-number">1</span>;<br>color_image_view.image                           = storage_image.image;<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateImageView</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;color_image_view, <span class="hljs-literal">nullptr</span>, &amp;storage_image.view));<br><br>VkCommandBuffer command_buffer = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">create_command_buffer</span>(VK_COMMAND_BUFFER_LEVEL_PRIMARY, <span class="hljs-literal">true</span>);<br>vkb::<span class="hljs-built_in">image_layout_transition</span>(command_buffer,<br>                             storage_image.image,<br>                             VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,<br>                             VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,<br>                             &#123;&#125;,<br>                             &#123;&#125;,<br>                             VK_IMAGE_LAYOUT_UNDEFINED,<br>                             VK_IMAGE_LAYOUT_GENERAL,<br>                             &#123;VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<br><span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">flush_command_buffer</span>(command_buffer, queue);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用就是创建一张用于存储光追渲染结果的Storagebuffer。其中应用程序类是自定义了一个<code>StorageImage</code>的结构体来存储相关的所有资源以及图像参数等信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StorageImage</span><br>&#123;<br>VkDeviceMemory memory;<br>VkImage        image = VK_NULL_HANDLE;<br>VkImageView    view;<br>VkFormat       format;<br><span class="hljs-type">uint32_t</span>       width;<br><span class="hljs-type">uint32_t</span>       height;<br>&#125; storage_image;<br></code></pre></td></tr></table></figure><p>具体的创建逻辑无需细说，在<a href="https://zpc-dsg.github.io/2024/12/12/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F/"><code>我之前的文章</code></a>中也有十分详细的介绍。这里需要注意的是在填写图像创建信息的时候图像的用途应该填写为<i><font color="Red">VK_IMAGE_USAGE_TRANSFER_SRC_BIT| VK_IMAGE_USAGE_STORAGE_BIT</font></i>，因为在作为Storageimage存储光追结果之余，它还需要作为数据传输源将图像数据复制到缓冲区图像中去。在函数的最后，为了能够使用该图像作为光追结果的写入目标，我们还需要提前转换图像布局。注意这里我们应该将其布局转换为<i><font color="Red">VK_IMAGE_LAYOUT_GENERAL</font></i>，因为光追着色器通常会对图像进行频繁的复杂读写操作，<i><font color="Red">VK_IMAGE_LAYOUT_GENERAL</font></i>是唯一适配这种复杂读写模式的布局。</p><h3 id="create_scene">create_scene</h3><p>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::create_scene</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">create_bottom_level_acceleration_structure</span>();<br><span class="hljs-built_in">create_top_level_acceleration_structure</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这个函数是调用了两个工具函数来完成的，这两个函数分别构建好了场景的底层加速结构和顶层加速结构。在构建光追加速结构的时候我们通常需要构建这两种结构，其中底层加速结构用于存储场景中实际的几何体信息，包括三角形或AABB信息；顶层结构体则存储对底层结构体的引用，并且管理底层加速结构的实例化。不过不管是构建哪种加速结构，基本的构建思路是一样的;</p><ul><li>首先根据加速结构的类型、几何体的类型数量等信息填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildGeometryInfoKHR.html"><code>VkAccelerationStructureBuildGeometryInfoKHR</code></a>信息结构体，此时填写这个结构体并不是为了创建加速结构，而是为了查询需要创建的加速结构的大小。</li><li>使用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureBuildSizesKHR.html"><code>vkGetAccelerationStructureBuildSizesKHR</code></a>得到需要构建的加速结构的大小以及构建过程中需要的<strong>scratchbuffer</strong>的大小（大小信息存储在<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildSizesInfoKHR.html"><code>VkAccelerationStructureBuildSizesInfoKHR</code></a>中）。</li><li>分配足够大小的缓冲区用于存储将要创建的加速结构以及构建过程会用到的<strong>scratchbuffer</strong>。</li><li>调用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateAccelerationStructureKHR.html"><code>vkCreateAccelerationStructureKHR</code></a>在缓冲区内的指定位置创建加速结构对象。</li><li>调用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildAccelerationStructuresKHR.html"><code>vkCmdBuildAccelerationStructuresKHR</code></a>来在GPU中真正构建加速结构。</li></ul><p>我们下面来分别详细分析这两个加速结构的构建过程：</p><h4 id="create_bottom_level_acceleration_structure">create_bottom_level_acceleration_structure</h4><p>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Create the bottom level acceleration structure that contains the scene&#x27;s geometry (triangles)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::create_bottom_level_acceleration_structure</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// Setup vertices and indices for a single triangle</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vertex</span><br>&#123;<br><span class="hljs-type">float</span> pos[<span class="hljs-number">3</span>];<br>&#125;;<br>std::vector&lt;Vertex&gt; vertices = &#123;<br>    &#123;&#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">-1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">-1.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;&#125;;<br>std::vector&lt;<span class="hljs-type">uint32_t</span>&gt; indices = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><br><span class="hljs-keyword">auto</span> vertex_buffer_size = vertices.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(Vertex);<br><span class="hljs-keyword">auto</span> index_buffer_size  = indices.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>);<br><br><span class="hljs-comment">// Create buffers for the bottom level geometry</span><br><span class="hljs-comment">// For the sake of simplicity we won&#x27;t stage the vertex data to the GPU memory</span><br><br><span class="hljs-comment">// Note that the buffer usage flags for buffers consumed by the bottom level acceleration structure require special flags</span><br><span class="hljs-type">const</span> VkBufferUsageFlags buffer_usage_flags = VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;<br><br>vertex_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), vertex_buffer_size, buffer_usage_flags, VMA_MEMORY_USAGE_CPU_TO_GPU);<br>vertex_buffer-&gt;<span class="hljs-built_in">update</span>(vertices.<span class="hljs-built_in">data</span>(), vertex_buffer_size);<br><br>index_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), index_buffer_size, buffer_usage_flags, VMA_MEMORY_USAGE_CPU_TO_GPU);<br>index_buffer-&gt;<span class="hljs-built_in">update</span>(indices.<span class="hljs-built_in">data</span>(), index_buffer_size);<br><br><span class="hljs-comment">// Setup a single transformation matrix that can be used to transform the whole geometry for a single bottom level acceleration structure</span><br>VkTransformMatrixKHR transform_matrix = &#123;<br>    <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>    <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>    <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;;<br>std::unique_ptr&lt;vkb::core::BufferC&gt; transform_matrix_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), <span class="hljs-built_in">sizeof</span>(transform_matrix), buffer_usage_flags, VMA_MEMORY_USAGE_CPU_TO_GPU);<br>transform_matrix_buffer-&gt;<span class="hljs-built_in">update</span>(&amp;transform_matrix, <span class="hljs-built_in">sizeof</span>(transform_matrix));<br><br>VkDeviceOrHostAddressConstKHR vertex_data_device_address&#123;&#125;;<br>VkDeviceOrHostAddressConstKHR index_data_device_address&#123;&#125;;<br>VkDeviceOrHostAddressConstKHR transform_matrix_device_address&#123;&#125;;<br><br>vertex_data_device_address.deviceAddress      = <span class="hljs-built_in">get_buffer_device_address</span>(vertex_buffer-&gt;<span class="hljs-built_in">get_handle</span>());<br>index_data_device_address.deviceAddress       = <span class="hljs-built_in">get_buffer_device_address</span>(index_buffer-&gt;<span class="hljs-built_in">get_handle</span>());<br>transform_matrix_device_address.deviceAddress = <span class="hljs-built_in">get_buffer_device_address</span>(transform_matrix_buffer-&gt;<span class="hljs-built_in">get_handle</span>());<br><br><span class="hljs-comment">// The bottom level acceleration structure contains one set of triangles as the input geometry</span><br>VkAccelerationStructureGeometryKHR acceleration_structure_geometry&#123;&#125;;<br>acceleration_structure_geometry.sType                            = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR;<br>acceleration_structure_geometry.geometryType                     = VK_GEOMETRY_TYPE_TRIANGLES_KHR;<br>acceleration_structure_geometry.flags                            = VK_GEOMETRY_OPAQUE_BIT_KHR;<br>acceleration_structure_geometry.geometry.triangles.sType         = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR;<br>acceleration_structure_geometry.geometry.triangles.vertexFormat  = VK_FORMAT_R32G32B32_SFLOAT;<br>acceleration_structure_geometry.geometry.triangles.vertexData    = vertex_data_device_address;<br>acceleration_structure_geometry.geometry.triangles.maxVertex     = <span class="hljs-number">3</span>;<br>acceleration_structure_geometry.geometry.triangles.vertexStride  = <span class="hljs-built_in">sizeof</span>(Vertex);<br>acceleration_structure_geometry.geometry.triangles.indexType     = VK_INDEX_TYPE_UINT32;<br>acceleration_structure_geometry.geometry.triangles.indexData     = index_data_device_address;<br>acceleration_structure_geometry.geometry.triangles.transformData = transform_matrix_device_address;<br><br><span class="hljs-comment">// Get the size requirements for buffers involved in the acceleration structure build process</span><br>VkAccelerationStructureBuildGeometryInfoKHR acceleration_structure_build_geometry_info&#123;&#125;;<br>acceleration_structure_build_geometry_info.sType         = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR;<br>acceleration_structure_build_geometry_info.type          = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;<br>acceleration_structure_build_geometry_info.flags         = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR;<br>acceleration_structure_build_geometry_info.geometryCount = <span class="hljs-number">1</span>;<br>acceleration_structure_build_geometry_info.pGeometries   = &amp;acceleration_structure_geometry;<br><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> primitive_count = <span class="hljs-number">1</span>;<br><br>VkAccelerationStructureBuildSizesInfoKHR acceleration_structure_build_sizes_info&#123;&#125;;<br>acceleration_structure_build_sizes_info.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR;<br><span class="hljs-built_in">vkGetAccelerationStructureBuildSizesKHR</span>(<br>    <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(),<br>    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,<br>    &amp;acceleration_structure_build_geometry_info,<br>    &amp;primitive_count,<br>    &amp;acceleration_structure_build_sizes_info);<br><br><span class="hljs-comment">// Create a buffer to hold the acceleration structure</span><br>bottom_level_acceleration_structure.buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<br>    <span class="hljs-built_in">get_device</span>(),<br>    acceleration_structure_build_sizes_info.accelerationStructureSize,<br>    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,<br>    VMA_MEMORY_USAGE_GPU_ONLY);<br><br><span class="hljs-comment">// Create the acceleration structure</span><br>VkAccelerationStructureCreateInfoKHR acceleration_structure_create_info&#123;&#125;;<br>acceleration_structure_create_info.sType  = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR;<br>acceleration_structure_create_info.buffer = bottom_level_acceleration_structure.buffer-&gt;<span class="hljs-built_in">get_handle</span>();<br>acceleration_structure_create_info.size   = acceleration_structure_build_sizes_info.accelerationStructureSize;<br>acceleration_structure_create_info.type   = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;<br><span class="hljs-built_in">vkCreateAccelerationStructureKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;acceleration_structure_create_info, <span class="hljs-literal">nullptr</span>, &amp;bottom_level_acceleration_structure.handle);<br><br><span class="hljs-comment">// The actual build process starts here</span><br><br><span class="hljs-comment">// Create a scratch buffer as a temporary storage for the acceleration structure build</span><br>ScratchBuffer scratch_buffer = <span class="hljs-built_in">create_scratch_buffer</span>(acceleration_structure_build_sizes_info.buildScratchSize);<br><br>VkAccelerationStructureBuildGeometryInfoKHR acceleration_build_geometry_info&#123;&#125;;<br>acceleration_build_geometry_info.sType                     = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR;<br>acceleration_build_geometry_info.type                      = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;<br>acceleration_build_geometry_info.flags                     = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR;<br>acceleration_build_geometry_info.mode                      = VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR;<br>acceleration_build_geometry_info.dstAccelerationStructure  = bottom_level_acceleration_structure.handle;<br>acceleration_build_geometry_info.geometryCount             = <span class="hljs-number">1</span>;<br>acceleration_build_geometry_info.pGeometries               = &amp;acceleration_structure_geometry;<br>acceleration_build_geometry_info.scratchData.deviceAddress = scratch_buffer.device_address;<br><br>VkAccelerationStructureBuildRangeInfoKHR acceleration_structure_build_range_info;<br>acceleration_structure_build_range_info.primitiveCount                                           = <span class="hljs-number">1</span>;<br>acceleration_structure_build_range_info.primitiveOffset                                          = <span class="hljs-number">0</span>;<br>acceleration_structure_build_range_info.firstVertex                                              = <span class="hljs-number">0</span>;<br>acceleration_structure_build_range_info.transformOffset                                          = <span class="hljs-number">0</span>;<br>std::vector&lt;VkAccelerationStructureBuildRangeInfoKHR *&gt; acceleration_build_structure_range_infos = &#123;&amp;acceleration_structure_build_range_info&#125;;<br><br><span class="hljs-comment">// Build the acceleration structure on the device via a one-time command buffer submission</span><br><span class="hljs-comment">// Some implementations may support acceleration structure building on the host (VkPhysicalDeviceAccelerationStructureFeaturesKHR-&gt;accelerationStructureHostCommands), but we prefer device builds</span><br>VkCommandBuffer command_buffer = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">create_command_buffer</span>(VK_COMMAND_BUFFER_LEVEL_PRIMARY, <span class="hljs-literal">true</span>);<br><span class="hljs-built_in">vkCmdBuildAccelerationStructuresKHR</span>(<br>    command_buffer,<br>    <span class="hljs-number">1</span>,<br>    &amp;acceleration_build_geometry_info,<br>    acceleration_build_structure_range_infos.<span class="hljs-built_in">data</span>());<br><span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">flush_command_buffer</span>(command_buffer, queue);<br><br><span class="hljs-built_in">delete_scratch_buffer</span>(scratch_buffer);<br><br><span class="hljs-comment">// Get the bottom acceleration structure&#x27;s handle, which will be used during the top level acceleration build</span><br>VkAccelerationStructureDeviceAddressInfoKHR acceleration_device_address_info&#123;&#125;;<br>acceleration_device_address_info.sType                 = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR;<br>acceleration_device_address_info.accelerationStructure = bottom_level_acceleration_structure.handle;<br>bottom_level_acceleration_structure.device_address =<br>    <span class="hljs-built_in">vkGetAccelerationStructureDeviceAddressKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;acceleration_device_address_info);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们选择的构建几何体是三角形。按照上文构建加速结构的大体流程，我们首先需要填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildGeometryInfoKHR.html"><code>VkAccelerationStructureBuildGeometryInfoKHR</code></a>信息结构体，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkAccelerationStructureBuildGeometryInfoKHR</span> &#123;</span><br>    VkStructureType                                     sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                         pNext;<br>    VkAccelerationStructureTypeKHR                      type;<br>    VkBuildAccelerationStructureFlagsKHR                flags;<br>    VkBuildAccelerationStructureModeKHR                 mode;<br>    VkAccelerationStructureKHR                          srcAccelerationStructure;<br>    VkAccelerationStructureKHR                          dstAccelerationStructure;<br>    <span class="hljs-type">uint32_t</span>                                            geometryCount;<br>    <span class="hljs-type">const</span> VkAccelerationStructureGeometryKHR*           pGeometries;<br>    <span class="hljs-type">const</span> VkAccelerationStructureGeometryKHR* <span class="hljs-type">const</span>*    ppGeometries;<br>    VkDeviceOrHostAddressKHR                            scratchData;<br>&#125; VkAccelerationStructureBuildGeometryInfoKHR;<br></code></pre></td></tr></table></figure><p>填写这个结构体当前的目的是为了得到加速结构和scratchbuffer的大小信息，因此我们无需填写所有成员。在代码中，首先指定创建的加速结构是底层加速结构（<i><font color="Red">VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR</font></i>），然后指定标志位为<i><font color="Red">VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR</font></i>用于指示硬件优化构建加速结构过程的性能。本示例中的加速结构仅包含一个三角形，所以几何数设置为1，几何体信息设置为前文填写好的<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureGeometryKHR.html"><code>VkAccelerationStructureGeometryKHR</code></a>，下面来看这个结构体的填写过程。首先还是放上它的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkAccelerationStructureGeometryKHR</span> &#123;</span><br>    VkStructureType                           sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                               pNext;<br>    VkGeometryTypeKHR                         geometryType;<br>    VkAccelerationStructureGeometryDataKHR    geometry;<br>    VkGeometryFlagsKHR                        flags;<br>&#125; VkAccelerationStructureGeometryKHR;<br></code></pre></td></tr></table></figure><p>首先设置好几何体类型，我们希望的类型是三角形（<i><font color="Red">VK_GEOMETRY_TYPE_TRIANGLES_KHR</font></i>），可能的几何体类型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkGeometryTypeKHR</span> &#123;</span><br>    VK_GEOMETRY_TYPE_TRIANGLES_KHR = <span class="hljs-number">0</span>,<br>    VK_GEOMETRY_TYPE_AABBS_KHR = <span class="hljs-number">1</span>,<br>    VK_GEOMETRY_TYPE_INSTANCES_KHR = <span class="hljs-number">2</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_ray_tracing_linear_swept_spheres</span><br>    VK_GEOMETRY_TYPE_SPHERES_NV = <span class="hljs-number">1000429004</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_ray_tracing_linear_swept_spheres</span><br>    VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV = <span class="hljs-number">1000429005</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_ray_tracing</span><br>    VK_GEOMETRY_TYPE_TRIANGLES_NV = VK_GEOMETRY_TYPE_TRIANGLES_KHR,<br>  <span class="hljs-comment">// Provided by VK_NV_ray_tracing</span><br>    VK_GEOMETRY_TYPE_AABBS_NV = VK_GEOMETRY_TYPE_AABBS_KHR,<br>&#125; VkGeometryTypeKHR;<br></code></pre></td></tr></table></figure><p>然后指定标志位为<i><font color="Red">VK_GEOMETRY_OPAQUE_BIT_KHR</font></i>，官方解释为这么设置就意味着该几何体即使与光线相交也不会触发任何<strong>any-hitshader</strong>的调用（<strong>any-hitshader</strong>常用于进行alpha测试有关的操作）。接下来就需要指定真正的几何体数据信息了，这是通过<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureGeometryDataKHR.html"><code>VkAccelerationStructureGeometryDataKHR</code></a>来指定的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">VkAccelerationStructureGeometryDataKHR</span> &#123;</span><br>    VkAccelerationStructureGeometryTrianglesDataKHR    triangles;<br>    VkAccelerationStructureGeometryAabbsDataKHR        aabbs;<br>    VkAccelerationStructureGeometryInstancesDataKHR    instances;<br>&#125; VkAccelerationStructureGeometryDataKHR;<br></code></pre></td></tr></table></figure><p>由于我们的几何体是三角形，所以这里只需填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureGeometryTrianglesDataKHR.html"><code>VkAccelerationStructureGeometryTrianglesDataKHR</code></a>结构体即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkAccelerationStructureGeometryTrianglesDataKHR</span> &#123;</span><br>    VkStructureType                  sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                      pNext;<br>    VkFormat                         vertexFormat;<br>    VkDeviceOrHostAddressConstKHR    vertexData;<br>    VkDeviceSize                     vertexStride;<br>    <span class="hljs-type">uint32_t</span>                         maxVertex;<br>    VkIndexType                      indexType;<br>    VkDeviceOrHostAddressConstKHR    indexData;<br>    VkDeviceOrHostAddressConstKHR    transformData;<br>&#125; VkAccelerationStructureGeometryTrianglesDataKHR;<br></code></pre></td></tr></table></figure><p>首先是指定顶点格式，顶点信息中只包含一个三维的位置向量，所以格式指定为<i><font color="Red">VK_FORMAT_R32G32B32_SFLOAT</font></i>。然后指定顶点数据缓冲所在的设备地址，这可以在创建好缓冲区之后通过<code>vkGetBufferDeviceAddressKHR</code>得到，在之前的mdi示例分析中已经有十分详细的介绍了，不过需要注意的是在创建这个顶点缓冲区时需要额外指定用途为<i><font color="Red">VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR</font></i>（包括索引和变换缓冲区也是）。<i><font color="Orange">maxVertex</font></i>官方文档中指定的是顶点缓冲中存储的顶点数减1，那按理来讲代码中应该填写为2才对，为什么这里填的是3呢？我试了下把这个地方改为2，结果仍然是正确的，那只能理解为这个值指定为比最大定点数减1要更大的数对结果都是没有影响的了（瞎猜的，还望大佬指点）。接下来的<i><font color="Orange">vertexStride</font></i>用于指定顶点之间的字节数，也就是一个顶点数据的大小。然后还需要指定相应的索引数据，包括索引类型以及索引缓冲的设备地址。最后还可以额外指定一个变换信息，用于对指定的几何体顶点位置进行一个调整，示例代码选择将这部分设置为单位矩阵，也就是无需调整（这里的变换矩阵同样需要上传到缓冲区中，然后通过设备地址访问）。</p><p>然后就可以查询加速结构以及scratch buffer所需大小了。<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureBuildSizesKHR.html"><code>vkGetAccelerationStructureBuildSizesKHR</code></a>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkGetAccelerationStructureBuildSizesKHR</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDevice                                    device,</span><br><span class="hljs-params">    VkAccelerationStructureBuildTypeKHR         buildType,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*                             pMaxPrimitiveCounts,</span><br><span class="hljs-params">    VkAccelerationStructureBuildSizesInfoKHR*   pSizeInfo)</span>;<br></code></pre></td></tr></table></figure><p>该函数调用会填写好<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildSizesInfoKHR.html"><code>VkAccelerationStructureBuildSizesInfoKHR</code></a>中的大小信息。接下来我们就可以根据这个大小信息创建加速结构缓冲区和scratchbuffer了。在创建加速结构缓冲区时唯一需要注意的是缓冲区的用途被设置为<i><font color="Red">VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR|VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</font></i>。然后就可以创建加速结构对象了，这只需要指定加速结构的类型、存储缓冲区以及其大小，然后调用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateAccelerationStructureKHR.html"><code>vkCreateAccelerationStructureKHR</code></a>即可。scratchbuffer则是通过应用程序类中的一个工具函数<i><font color="Green">create_scratch_buffer</font></i>来创建的，该函数定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Create buffer and allocate memory for a temporary scratch buffer</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">ScratchBuffer <span class="hljs-title">RaytracingBasic::create_scratch_buffer</span><span class="hljs-params">(VkDeviceSize size)</span></span><br><span class="hljs-function"></span>&#123;<br>ScratchBuffer scratch_buffer&#123;&#125;;<br><br>VkBufferCreateInfo buffer_create_info = &#123;&#125;;<br>buffer_create_info.sType              = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;<br>buffer_create_info.size               = size;<br>buffer_create_info.usage              = VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateBuffer</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;buffer_create_info, <span class="hljs-literal">nullptr</span>, &amp;scratch_buffer.handle));<br><br>VkMemoryRequirements memory_requirements = &#123;&#125;;<br><span class="hljs-built_in">vkGetBufferMemoryRequirements</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), scratch_buffer.handle, &amp;memory_requirements);<br><br>VkMemoryAllocateFlagsInfo memory_allocate_flags_info = &#123;&#125;;<br>memory_allocate_flags_info.sType                     = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;<br>memory_allocate_flags_info.flags                     = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR;<br><br>VkMemoryAllocateInfo memory_allocate_info = &#123;&#125;;<br>memory_allocate_info.sType                = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;<br>memory_allocate_info.pNext                = &amp;memory_allocate_flags_info;<br>memory_allocate_info.allocationSize       = memory_requirements.size;<br>memory_allocate_info.memoryTypeIndex      = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_memory_type</span>(memory_requirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateMemory</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;memory_allocate_info, <span class="hljs-literal">nullptr</span>, &amp;scratch_buffer.memory));<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBindBufferMemory</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), scratch_buffer.handle, scratch_buffer.memory, <span class="hljs-number">0</span>));<br><br>VkBufferDeviceAddressInfoKHR buffer_device_address_info&#123;&#125;;<br>buffer_device_address_info.sType  = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;<br>buffer_device_address_info.buffer = scratch_buffer.handle;<br>scratch_buffer.device_address     = <span class="hljs-built_in">vkGetBufferDeviceAddressKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;buffer_device_address_info);<br><br><span class="hljs-keyword">return</span> scratch_buffer;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数返回一个<code>ScratchBuffer</code>结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ScratchBuffer</span><br>&#123;<br><span class="hljs-type">uint64_t</span>       device_address;<br>VkBuffer       handle;<br>VkDeviceMemory memory;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该结构体简单地包含了缓冲区句柄、内存以及设备地址。</p><p><i><font color="Green">create_scratch_buffer</font></i>本身的缓冲区创建逻辑和一般的缓冲区创建逻辑并无二致，都是创建缓冲区对象，然后查询内存要求并且为该缓冲区对象分配合适的内存并绑定。这部分在<a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/"><code>我之前的文章</code></a>中已经有详细的描述了，这里不再赘述。</p><p>在创建好这两个对象之后，终于是可以真正地构建加速结构了。为此需要调用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildAccelerationStructuresKHR.html"><code>vkCmdBuildAccelerationStructuresKHR</code></a>，该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdBuildAccelerationStructuresKHR</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    infoCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkAccelerationStructureBuildGeometryInfoKHR* pInfos,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkAccelerationStructureBuildRangeInfoKHR* <span class="hljs-type">const</span>* ppBuildRangeInfos)</span>;<br></code></pre></td></tr></table></figure><p>首先指定需要构建多少个加速结构，这里我们当然只需要构建一个。然后需要填入<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildGeometryInfoKHR.html"><code>VkAccelerationStructureBuildGeometryInfoKHR</code></a>参数，还记得代码之前为了获取加速结构和scratchbuffer的大小已经填写过这个结构体了吗？当时填写的信息是不完整的，这里我们还需要再填写一遍完整的结构体信息。代码额外指定了要对这个加速结构执行的操作（<i><font color="Red">VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR</font></i>，也就是构建操作）、前文创建好的加速结构的句柄以及构建加速结构所需的scratchbuffer设备地址。最后一个参数是一个指向一个<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildRangeInfoKHR.html"><code>VkAccelerationStructureBuildRangeInfoKHR</code></a>结构体的指针的指针，<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildRangeInfoKHR.html"><code>VkAccelerationStructureBuildRangeInfoKHR</code></a>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkAccelerationStructureBuildRangeInfoKHR</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>    primitiveCount;<br>    <span class="hljs-type">uint32_t</span>    primitiveOffset;<br>    <span class="hljs-type">uint32_t</span>    firstVertex;<br>    <span class="hljs-type">uint32_t</span>    transformOffset;<br>&#125; VkAccelerationStructureBuildRangeInfoKHR;<br></code></pre></td></tr></table></figure><p>四个成员分别指定几何体数量、几何体数据在内存中的偏移（按字节）、第一个顶点对应的索引以及变换数据在内存中的偏移（按字节），这里我们绘制一个几何体，并且不需要任何偏移。</p><p>最后，只需启用一个command buffer提交构建命令即可。scratchbuffer在完成加速结构的构建后就没有用了，所以代码在构建完毕后将其销毁。函数在结尾处还将构建好的底层加速结构的设备地址保存起来了，在之后构建顶层加速结构的时候会用到底层加速结构的设备地址。</p><h4 id="create_top_level_acceleration_structure">create_top_level_acceleration_structure</h4><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Create the top level acceleration structure containing geometry instances of the bottom level acceleration structure(s)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::create_top_level_acceleration_structure</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>VkTransformMatrixKHR transform_matrix = &#123;<br>    <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>    <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>    <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;;<br><br>VkAccelerationStructureInstanceKHR acceleration_structure_instance&#123;&#125;;<br>acceleration_structure_instance.transform                              = transform_matrix;<br>acceleration_structure_instance.instanceCustomIndex                    = <span class="hljs-number">0</span>;<br>acceleration_structure_instance.mask                                   = <span class="hljs-number">0xFF</span>;<br>acceleration_structure_instance.instanceShaderBindingTableRecordOffset = <span class="hljs-number">0</span>;<br>acceleration_structure_instance.flags                                  = VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR;<br>acceleration_structure_instance.accelerationStructureReference         = bottom_level_acceleration_structure.device_address;<br><br>std::unique_ptr&lt;vkb::core::BufferC&gt; instances_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(),<br>                                                                                            <span class="hljs-built_in">sizeof</span>(VkAccelerationStructureInstanceKHR),<br>                                                                                            VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,<br>                                                                                            VMA_MEMORY_USAGE_CPU_TO_GPU);<br>instances_buffer-&gt;<span class="hljs-built_in">update</span>(&amp;acceleration_structure_instance, <span class="hljs-built_in">sizeof</span>(VkAccelerationStructureInstanceKHR));<br><br>VkDeviceOrHostAddressConstKHR instance_data_device_address&#123;&#125;;<br>instance_data_device_address.deviceAddress = <span class="hljs-built_in">get_buffer_device_address</span>(instances_buffer-&gt;<span class="hljs-built_in">get_handle</span>());<br><br><span class="hljs-comment">// The top level acceleration structure contains (bottom level) instance as the input geometry</span><br>VkAccelerationStructureGeometryKHR acceleration_structure_geometry&#123;&#125;;<br>acceleration_structure_geometry.sType                              = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR;<br>acceleration_structure_geometry.geometryType                       = VK_GEOMETRY_TYPE_INSTANCES_KHR;<br>acceleration_structure_geometry.flags                              = VK_GEOMETRY_OPAQUE_BIT_KHR;<br>acceleration_structure_geometry.geometry.instances.sType           = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR;<br>acceleration_structure_geometry.geometry.instances.arrayOfPointers = VK_FALSE;<br>acceleration_structure_geometry.geometry.instances.data            = instance_data_device_address;<br><br><span class="hljs-comment">// Get the size requirements for buffers involved in the acceleration structure build process</span><br>VkAccelerationStructureBuildGeometryInfoKHR acceleration_structure_build_geometry_info&#123;&#125;;<br>acceleration_structure_build_geometry_info.sType         = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR;<br>acceleration_structure_build_geometry_info.type          = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR;<br>acceleration_structure_build_geometry_info.flags         = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR;<br>acceleration_structure_build_geometry_info.geometryCount = <span class="hljs-number">1</span>;<br>acceleration_structure_build_geometry_info.pGeometries   = &amp;acceleration_structure_geometry;<br><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> primitive_count = <span class="hljs-number">1</span>;<br><br>VkAccelerationStructureBuildSizesInfoKHR acceleration_structure_build_sizes_info&#123;&#125;;<br>acceleration_structure_build_sizes_info.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR;<br><span class="hljs-built_in">vkGetAccelerationStructureBuildSizesKHR</span>(<br>    <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,<br>    &amp;acceleration_structure_build_geometry_info,<br>    &amp;primitive_count,<br>    &amp;acceleration_structure_build_sizes_info);<br><br><span class="hljs-comment">// Create a buffer to hold the acceleration structure</span><br>top_level_acceleration_structure.buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<br>    <span class="hljs-built_in">get_device</span>(),<br>    acceleration_structure_build_sizes_info.accelerationStructureSize,<br>    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,<br>    VMA_MEMORY_USAGE_GPU_ONLY);<br><br><span class="hljs-comment">// Create the acceleration structure</span><br>VkAccelerationStructureCreateInfoKHR acceleration_structure_create_info&#123;&#125;;<br>acceleration_structure_create_info.sType  = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR;<br>acceleration_structure_create_info.buffer = top_level_acceleration_structure.buffer-&gt;<span class="hljs-built_in">get_handle</span>();<br>acceleration_structure_create_info.size   = acceleration_structure_build_sizes_info.accelerationStructureSize;<br>acceleration_structure_create_info.type   = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR;<br><span class="hljs-built_in">vkCreateAccelerationStructureKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;acceleration_structure_create_info, <span class="hljs-literal">nullptr</span>, &amp;top_level_acceleration_structure.handle);<br><br><span class="hljs-comment">// The actual build process starts here</span><br><br><span class="hljs-comment">// Create a scratch buffer as a temporary storage for the acceleration structure build</span><br>ScratchBuffer scratch_buffer = <span class="hljs-built_in">create_scratch_buffer</span>(acceleration_structure_build_sizes_info.buildScratchSize);<br><br>VkAccelerationStructureBuildGeometryInfoKHR acceleration_build_geometry_info&#123;&#125;;<br>acceleration_build_geometry_info.sType                     = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR;<br>acceleration_build_geometry_info.type                      = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR;<br>acceleration_build_geometry_info.flags                     = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR;<br>acceleration_build_geometry_info.mode                      = VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR;<br>acceleration_build_geometry_info.dstAccelerationStructure  = top_level_acceleration_structure.handle;<br>acceleration_build_geometry_info.geometryCount             = <span class="hljs-number">1</span>;<br>acceleration_build_geometry_info.pGeometries               = &amp;acceleration_structure_geometry;<br>acceleration_build_geometry_info.scratchData.deviceAddress = scratch_buffer.device_address;<br><br>VkAccelerationStructureBuildRangeInfoKHR acceleration_structure_build_range_info;<br>acceleration_structure_build_range_info.primitiveCount                                           = <span class="hljs-number">1</span>;<br>acceleration_structure_build_range_info.primitiveOffset                                          = <span class="hljs-number">0</span>;<br>acceleration_structure_build_range_info.firstVertex                                              = <span class="hljs-number">0</span>;<br>acceleration_structure_build_range_info.transformOffset                                          = <span class="hljs-number">0</span>;<br>std::vector&lt;VkAccelerationStructureBuildRangeInfoKHR *&gt; acceleration_build_structure_range_infos = &#123;&amp;acceleration_structure_build_range_info&#125;;<br><br><span class="hljs-comment">// Build the acceleration structure on the device via a one-time command buffer submission</span><br><span class="hljs-comment">// Some implementations may support acceleration structure building on the host (VkPhysicalDeviceAccelerationStructureFeaturesKHR-&gt;accelerationStructureHostCommands), but we prefer device builds</span><br>VkCommandBuffer command_buffer = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">create_command_buffer</span>(VK_COMMAND_BUFFER_LEVEL_PRIMARY, <span class="hljs-literal">true</span>);<br><span class="hljs-built_in">vkCmdBuildAccelerationStructuresKHR</span>(<br>    command_buffer,<br>    <span class="hljs-number">1</span>,<br>    &amp;acceleration_build_geometry_info,<br>    acceleration_build_structure_range_infos.<span class="hljs-built_in">data</span>());<br><span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">flush_command_buffer</span>(command_buffer, queue);<br><br><span class="hljs-built_in">delete_scratch_buffer</span>(scratch_buffer);<br><br><span class="hljs-comment">// Get the top acceleration structure&#x27;s handle, which will be used to setup it&#x27;s descriptor</span><br>VkAccelerationStructureDeviceAddressInfoKHR acceleration_device_address_info&#123;&#125;;<br>acceleration_device_address_info.sType                 = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR;<br>acceleration_device_address_info.accelerationStructure = top_level_acceleration_structure.handle;<br>top_level_acceleration_structure.device_address =<br>    <span class="hljs-built_in">vkGetAccelerationStructureDeviceAddressKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;acceleration_device_address_info);<br>&#125;<br></code></pre></td></tr></table></figure><p>创建顶层加速结构的过程和底层加速结构大同小异，不过在创建细节上二者还是有一些出入。首先注意到顶层加速结构指定的几何体类型为<i><font color="Red">VK_GEOMETRY_TYPE_INSTANCES_KHR</font></i>，因此在填写顶层加速结构的<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureGeometryKHR.html"><code>VkAccelerationStructureGeometryKHR</code></a>的时候就需要填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureGeometryInstancesDataKHR.html"><code>VkAccelerationStructureGeometryInstancesDataKHR</code></a>信息结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkAccelerationStructureGeometryInstancesDataKHR</span> &#123;</span><br>    VkStructureType                  sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                      pNext;<br>    VkBool32                         arrayOfPointers;<br>    VkDeviceOrHostAddressConstKHR    data;<br>&#125; VkAccelerationStructureGeometryInstancesDataKHR;<br></code></pre></td></tr></table></figure><p>其中<i><font color="Orange">arrayOfPointers</font></i>代表最后一个<i><font color="Orange">data</font></i>成员是一个指向<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureInstanceKHR.html"><code>VkAccelerationStructureInstanceKHR</code></a>结构体的指针数组的地址还是一个单纯的<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureInstanceKHR.html"><code>VkAccelerationStructureInstanceKHR</code></a>结构体数组的地址。这里代码填写了<i><font color="Red">VK_FALSE</font></i>，也就是说为了填写<i><font color="Orange">data</font></i>，还需要填写一个<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureInstanceKHR.html"><code>VkAccelerationStructureInstanceKHR</code></a>结构体并且获取它的设备地址。<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureInstanceKHR.html"><code>VkAccelerationStructureInstanceKHR</code></a>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkAccelerationStructureInstanceKHR</span> &#123;</span><br>    VkTransformMatrixKHR          transform;<br>    <span class="hljs-type">uint32_t</span>                      instanceCustomIndex:<span class="hljs-number">24</span>;<br>    <span class="hljs-type">uint32_t</span>                      mask:<span class="hljs-number">8</span>;<br>    <span class="hljs-type">uint32_t</span>                      instanceShaderBindingTableRecordOffset:<span class="hljs-number">24</span>;<br>    VkGeometryInstanceFlagsKHR    flags:<span class="hljs-number">8</span>;<br>    <span class="hljs-type">uint64_t</span>                      accelerationStructureReference;<br>&#125; VkAccelerationStructureInstanceKHR;<br></code></pre></td></tr></table></figure><p>对于每个实例，还可以填写额外的变换，代码中仍然将其填写为单位矩阵表示不做变换。接下来的<i><font color="Orange">instanceCustomIndex</font></i>是一个用户指定的可以在光追着色器中通过<code>InstanceCustomIndexKHR</code>内置变量获取的索引值，本示例事实上并未用到该索引，设置为0。接下来的<i><font color="Orange">mask</font></i>会与着色器中的<code>Cull mask</code>一同决定该实例是否可以被光线击中（只要<strong>Cullmask &amp; instance.mask !=0就可以），这里直接保持默认值</strong>。<i><font color="Orange">instanceShaderBindingTableRecordOffset</font></i>指定该示例使用的<strong>hitshader</strong>（包括<strong>any hit shader</strong>和<strong>closesthitshader</strong>）在<strong>SBT</strong>中的偏移，示例仅绘制一个实例，指定为不偏移就可以了。接下来代码将标志位设置为<i><font color="Red">VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR</font></i>，表明在光追过程中禁用面剔除。最后指定好该实例指向的底层加速结构的地址，就完成了该结构体的填写。然后需要做的就是将该结构体数据上传到一个buffer中并且将该buffer的设备地址交给<i><font color="Orange">acceleration_structure_geometry</font></i>即可。</p><p>接下来的步骤和构建底层结构时如出一辙。同样获取该顶层加速结构以及构建所需的scratchbuffer大小，然后构建存储顶层加速结构的缓冲区以及顶层加速结构句柄，并且构建好scratchbuffer。之后再填写一遍完整的<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildGeometryInfoKHR.html"><code>VkAccelerationStructureBuildGeometryInfoKHR</code></a>信息，配合<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildRangeInfoKHR.html"><code>VkAccelerationStructureBuildRangeInfoKHR</code></a>信息传入<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildAccelerationStructuresKHR.html"><code>vkCmdBuildAccelerationStructuresKHR</code></a>构建好顶层加速结构。最后销毁scratchbuffer并且获取顶层加速结构的设备地址并保存即可。</p><h3 id="create_uniform_buffer">create_uniform_buffer</h3><p>代码很简单，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Create the uniform buffer used to pass matrices to the ray tracing ray generation shader</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::create_uniform_buffer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ubo = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(),<br>                                           <span class="hljs-built_in">sizeof</span>(uniform_data),<br>                                           VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,<br>                                           VMA_MEMORY_USAGE_CPU_TO_GPU);<br>ubo-&gt;<span class="hljs-built_in">convert_and_update</span>(uniform_data);<br><br><span class="hljs-built_in">update_uniform_buffers</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>就是更新uniform buffer，其中该示例用到的uniformbuffer所需数据结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UniformData</span><br>&#123;<br>glm::mat4 view_inverse;<br>glm::mat4 proj_inverse;<br>&#125; uniform_data;<br>std::unique_ptr&lt;vkb::core::BufferC&gt; ubo;<br></code></pre></td></tr></table></figure><h3 id="create_ray_tracing_pipeline">create_ray_tracing_pipeline</h3><p>放上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Create our ray tracing pipeline</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::create_ray_tracing_pipeline</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// Slot for binding top level acceleration structures to the ray generation shader</span><br>VkDescriptorSetLayoutBinding acceleration_structure_layout_binding&#123;&#125;;<br>acceleration_structure_layout_binding.binding         = <span class="hljs-number">0</span>;<br>acceleration_structure_layout_binding.descriptorType  = VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR;<br>acceleration_structure_layout_binding.descriptorCount = <span class="hljs-number">1</span>;<br>acceleration_structure_layout_binding.stageFlags      = VK_SHADER_STAGE_RAYGEN_BIT_KHR;<br><br>VkDescriptorSetLayoutBinding result_image_layout_binding&#123;&#125;;<br>result_image_layout_binding.binding         = <span class="hljs-number">1</span>;<br>result_image_layout_binding.descriptorType  = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;<br>result_image_layout_binding.descriptorCount = <span class="hljs-number">1</span>;<br>result_image_layout_binding.stageFlags      = VK_SHADER_STAGE_RAYGEN_BIT_KHR;<br><br>VkDescriptorSetLayoutBinding uniform_buffer_binding&#123;&#125;;<br>uniform_buffer_binding.binding         = <span class="hljs-number">2</span>;<br>uniform_buffer_binding.descriptorType  = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;<br>uniform_buffer_binding.descriptorCount = <span class="hljs-number">1</span>;<br>uniform_buffer_binding.stageFlags      = VK_SHADER_STAGE_RAYGEN_BIT_KHR;<br><br>std::vector&lt;VkDescriptorSetLayoutBinding&gt; bindings = &#123;<br>    acceleration_structure_layout_binding,<br>    result_image_layout_binding,<br>    uniform_buffer_binding&#125;;<br><br>VkDescriptorSetLayoutCreateInfo layout_info&#123;&#125;;<br>layout_info.sType        = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;<br>layout_info.bindingCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(bindings.<span class="hljs-built_in">size</span>());<br>layout_info.pBindings    = bindings.<span class="hljs-built_in">data</span>();<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorSetLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;layout_info, <span class="hljs-literal">nullptr</span>, &amp;descriptor_set_layout));<br><br>VkPipelineLayoutCreateInfo pipeline_layout_create_info&#123;&#125;;<br>pipeline_layout_create_info.sType          = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;<br>pipeline_layout_create_info.setLayoutCount = <span class="hljs-number">1</span>;<br>pipeline_layout_create_info.pSetLayouts    = &amp;descriptor_set_layout;<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreatePipelineLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;pipeline_layout_create_info, <span class="hljs-literal">nullptr</span>, &amp;pipeline_layout));<br><br><span class="hljs-comment">// Ray tracing shaders require SPIR-V 1.4, so we need to set the appropriate target environment for the glslang compiler</span><br>vkb::GLSLCompiler::<span class="hljs-built_in">set_target_environment</span>(glslang::EShTargetSpv, glslang::EShTargetSpv_1_4);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Setup ray tracing shader groups</span><br><span class="hljs-comment">    Each shader group points at the corresponding shader in the pipeline</span><br><span class="hljs-comment">*/</span><br>std::vector&lt;VkPipelineShaderStageCreateInfo&gt; shader_stages;<br><br><span class="hljs-comment">// Ray generation group</span><br>&#123;<br>shader_stages.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;ray_tracing_basic&quot;</span>, <span class="hljs-string">&quot;raygen.rgen&quot;</span>, VK_SHADER_STAGE_RAYGEN_BIT_KHR));<br>VkRayTracingShaderGroupCreateInfoKHR raygen_group_ci&#123;&#125;;<br>raygen_group_ci.sType              = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR;<br>raygen_group_ci.type               = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR;<br>raygen_group_ci.generalShader      = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(shader_stages.<span class="hljs-built_in">size</span>()) - <span class="hljs-number">1</span>;<br>raygen_group_ci.closestHitShader   = VK_SHADER_UNUSED_KHR;<br>raygen_group_ci.anyHitShader       = VK_SHADER_UNUSED_KHR;<br>raygen_group_ci.intersectionShader = VK_SHADER_UNUSED_KHR;<br>shader_groups.<span class="hljs-built_in">push_back</span>(raygen_group_ci);<br>&#125;<br><br><span class="hljs-comment">// Ray miss group</span><br>&#123;<br>shader_stages.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;ray_tracing_basic&quot;</span>, <span class="hljs-string">&quot;miss.rmiss&quot;</span>, VK_SHADER_STAGE_MISS_BIT_KHR));<br>VkRayTracingShaderGroupCreateInfoKHR miss_group_ci&#123;&#125;;<br>miss_group_ci.sType              = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR;<br>miss_group_ci.type               = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR;<br>miss_group_ci.generalShader      = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(shader_stages.<span class="hljs-built_in">size</span>()) - <span class="hljs-number">1</span>;<br>miss_group_ci.closestHitShader   = VK_SHADER_UNUSED_KHR;<br>miss_group_ci.anyHitShader       = VK_SHADER_UNUSED_KHR;<br>miss_group_ci.intersectionShader = VK_SHADER_UNUSED_KHR;<br>shader_groups.<span class="hljs-built_in">push_back</span>(miss_group_ci);<br>&#125;<br><br><span class="hljs-comment">// Ray closest hit group</span><br>&#123;<br>shader_stages.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;ray_tracing_basic&quot;</span>, <span class="hljs-string">&quot;closesthit.rchit&quot;</span>, VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR));<br>VkRayTracingShaderGroupCreateInfoKHR closes_hit_group_ci&#123;&#125;;<br>closes_hit_group_ci.sType              = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR;<br>closes_hit_group_ci.type               = VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR;<br>closes_hit_group_ci.generalShader      = VK_SHADER_UNUSED_KHR;<br>closes_hit_group_ci.closestHitShader   = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(shader_stages.<span class="hljs-built_in">size</span>()) - <span class="hljs-number">1</span>;<br>closes_hit_group_ci.anyHitShader       = VK_SHADER_UNUSED_KHR;<br>closes_hit_group_ci.intersectionShader = VK_SHADER_UNUSED_KHR;<br>shader_groups.<span class="hljs-built_in">push_back</span>(closes_hit_group_ci);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Create the ray tracing pipeline</span><br><span class="hljs-comment">*/</span><br>VkRayTracingPipelineCreateInfoKHR raytracing_pipeline_create_info&#123;&#125;;<br>raytracing_pipeline_create_info.sType                        = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR;<br>raytracing_pipeline_create_info.stageCount                   = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(shader_stages.<span class="hljs-built_in">size</span>());<br>raytracing_pipeline_create_info.pStages                      = shader_stages.<span class="hljs-built_in">data</span>();<br>raytracing_pipeline_create_info.groupCount                   = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(shader_groups.<span class="hljs-built_in">size</span>());<br>raytracing_pipeline_create_info.pGroups                      = shader_groups.<span class="hljs-built_in">data</span>();<br>raytracing_pipeline_create_info.maxPipelineRayRecursionDepth = <span class="hljs-number">1</span>;<br>raytracing_pipeline_create_info.layout                       = pipeline_layout;<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateRayTracingPipelinesKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), VK_NULL_HANDLE, VK_NULL_HANDLE, <span class="hljs-number">1</span>, &amp;raytracing_pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;pipeline));<br>&#125;<br></code></pre></td></tr></table></figure><p>构建一个光追管线除了要绑定所需的描述符之外，最重要的就是设置好<strong>SBT（Shaderbinding table）</strong>了。<a href="https://docs.vulkan.org/guide/latest/extensions/ray_tracing.html"><code>Vulkan官方文档中的一张图</code></a>对Vulkan光追使用到的着色器以及它们之间的流程关系做了一个形象的刻画：</p><figure><img src="/2025/02/27/CG_api/vulkan/vulkan_samples/ray_tracing_basic/shaders.png" alt="光追着色器"><figcaption aria-hidden="true">光追着色器</figcaption></figure><p>大致解释如下：</p><ul><li><strong>Ray generation shader</strong>代表着光追流程的起点，调用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdTraceRaysKHR.html"><code>vkCmdTraceRaysKHR</code></a>会启动一系列的该着色器调用，而该着色器负责在代码中使用<code>traceRayEXT</code>构造并发射追踪光线。</li><li><strong>Closest hitshader</strong>在最近的一个被光线击中的几何体上调用，主要用于进行一些光照计算以及继续迭代地追踪光线。</li><li><strong>Missshader</strong>在光线没击中几何体时调用，它的一个十分常见的用途是采样环境贴图。</li><li><strong>Intersectionshader</strong>用于指定用户自定义的光线相交逻辑。如果没有指定该着色器，光线与物体相交默认逻辑为判断光线和三角形是否相交。</li><li><strong>Any hitshader</strong>在光线的所有相交处都会被调用，一般用于过滤交点和用于alpha测试。</li></ul><p>对这些基本概念有了一个大致的了解后，下面回到示例代码，看看具体的代码是如何编写的。</p><p>首先指定光追管线所需的所有描述符，包括了加速结构（注意它的描述符类型要指定为<i><font color="Red">VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</font></i>)、存储光追结果的Storageimage以及uniformbuffer。指定这些描述符集布局以及创建相应的管线布局都是常规操作，读者可自行阅读。接下来重点来看<strong>SBT</strong>的构建。</p><p>构建SBT，需要填写管线用到的着色器阶段以及相应的shadergroup。而指定shader group又需要填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRayTracingShaderGroupCreateInfoKHR.html"><code>VkRayTracingShaderGroupCreateInfoKHR</code></a>信息结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_ray_tracing_pipeline</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkRayTracingShaderGroupCreateInfoKHR</span> &#123;</span><br>    VkStructureType                   sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                       pNext;<br>    VkRayTracingShaderGroupTypeKHR    type;<br>    <span class="hljs-type">uint32_t</span>                          generalShader;<br>    <span class="hljs-type">uint32_t</span>                          closestHitShader;<br>    <span class="hljs-type">uint32_t</span>                          anyHitShader;<br>    <span class="hljs-type">uint32_t</span>                          intersectionShader;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                       pShaderGroupCaptureReplayHandle;<br>&#125; VkRayTracingShaderGroupCreateInfoKHR;<br></code></pre></td></tr></table></figure><p>其中<i><font color="Orange">type</font></i>指定这个着色器组的类型，可能的取值有<i><font color="Red">VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR</font></i>（通用着色器组，通常用于RGS和MS）、<i><font color="Red">VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR</font></i>（三角形几何体命中着色器组，通常用于CHS和AHS）、<i><font color="Red">VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR</font></i>（过程几何体命中着色器组，通常用于IS、CHS和AHS），接下来的四个成员分别指定成员名对应的着色器在<code>VkPipelineShaderStageCreateInfo</code>数组中的索引（第一个指定的是RGS和MS），如果不使用某种着色器则把相应成员设置为<i><font color="Red">VK_SHADER_UNUSED_KHR</font></i>。最后一个成员指定捕获重放，这个我们暂且不关心。</p><p>解释清楚这个结构体之后代码的填写就十分简单易懂了。在填写完SBT信息之后，就可以填写最终用于创建光追管线的<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRayTracingPipelineCreateInfoKHR.html"><code>VkRayTracingPipelineCreateInfoKHR</code></a>信息结构体了，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_ray_tracing_pipeline</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkRayTracingPipelineCreateInfoKHR</span> &#123;</span><br>    VkStructureType                                      sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                          pNext;<br>    VkPipelineCreateFlags                                flags;<br>    <span class="hljs-type">uint32_t</span>                                             stageCount;<br>    <span class="hljs-type">const</span> VkPipelineShaderStageCreateInfo*               pStages;<br>    <span class="hljs-type">uint32_t</span>                                             groupCount;<br>    <span class="hljs-type">const</span> VkRayTracingShaderGroupCreateInfoKHR*          pGroups;<br>    <span class="hljs-type">uint32_t</span>                                             maxPipelineRayRecursionDepth;<br>    <span class="hljs-type">const</span> VkPipelineLibraryCreateInfoKHR*                pLibraryInfo;<br>    <span class="hljs-type">const</span> VkRayTracingPipelineInterfaceCreateInfoKHR*    pLibraryInterface;<br>    <span class="hljs-type">const</span> VkPipelineDynamicStateCreateInfo*              pDynamicState;<br>    VkPipelineLayout                                     layout;<br>    VkPipeline                                           basePipelineHandle;<br>    <span class="hljs-type">int32_t</span>                                              basePipelineIndex;<br>&#125; VkRayTracingPipelineCreateInfoKHR;<br></code></pre></td></tr></table></figure><p>本示例比较简单，只需要指定该结构体中的部分和着色器以及管线布局有关的成员就行了，这些成员的含义是显而易见的，其它未填写的成员在之后深入了解Vulkan光追的时候再做进一步的分析。另外，代码还指定了<i><font color="Orange">maxPipelineRayRecursionDepth</font></i>，这个成员指定光追中光线的最大弹射次数。由于示例仅仅渲染一个三角形，设置为1就足够了。</p><p>最后调用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRayTracingPipelinesKHR.html"><code>vkCreateRayTracingPipelinesKHR</code></a>即可创建光追管线对象。</p><p>在梳理完光追管线的创建流程之后，下面我们来分析一下本示例使用到的光追着色器代码。</p><p>首先是RGS：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 460</span><br><span class="hljs-meta">#extension GL_EXT_ray_tracing : enable</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>, set = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> accelerationStructureEXT topLevelAS;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>, set = <span class="hljs-number">0</span>, <span class="hljs-keyword">rgba8</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">image2D</span> image;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">2</span>, set = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> CameraProperties <br>&#123;<br><span class="hljs-type">mat4</span> viewInverse;<br><span class="hljs-type">mat4</span> projInverse;<br>&#125; cam;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) rayPayloadEXT <span class="hljs-type">vec3</span> hitValue;<br><br><span class="hljs-type">void</span> main() <br>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-type">vec2</span> pixelCenter = <span class="hljs-type">vec2</span>(gl_LaunchIDEXT.xy) + <span class="hljs-type">vec2</span>(<span class="hljs-number">0.5</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-type">vec2</span> inUV = pixelCenter/<span class="hljs-type">vec2</span>(gl_LaunchSizeEXT.xy);<br><span class="hljs-type">vec2</span> d = inUV * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>;<br><br><span class="hljs-type">vec4</span> origin = cam.viewInverse * <span class="hljs-type">vec4</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br><span class="hljs-type">vec4</span> target = cam.projInverse * <span class="hljs-type">vec4</span>(d.x, d.y, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) ;<br><span class="hljs-type">vec4</span> direction = cam.viewInverse*<span class="hljs-type">vec4</span>(<span class="hljs-built_in">normalize</span>(target.xyz), <span class="hljs-number">0</span>) ;<br><br><span class="hljs-type">float</span> tmin = <span class="hljs-number">0.001</span>;<br><span class="hljs-type">float</span> tmax = <span class="hljs-number">10000.0</span>;<br><br>    hitValue = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>);<br><br>    traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, <span class="hljs-number">0xff</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, origin.xyz, tmin, direction.xyz, tmax, <span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">imageStore</span>(image, <span class="hljs-type">ivec2</span>(gl_LaunchIDEXT.xy), <span class="hljs-type">vec4</span>(hitValue, <span class="hljs-number">0.0</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到为了使用光追相关的变量和API，首先需要开启<code>GL_EXT_ray_tracing</code>拓展。然后注意加速结构描述符在着色器内的指定方式（<strong>uniformaccelerationStructureEXT</strong>）。Storageimage的布局中指定的<strong>rgba8</strong>是<strong>图像格式限定符</strong>，指定该图像格式为RGBA四个通道，每个通道各8位，这个格式需要和Storageimage在程序中指定的格式相对应，合理指定图像格式可以优化硬件性能。还要注意<strong>rayPayloadEXT</strong>这个关键字，它用于指定<strong>光线载荷</strong>，所谓光线载荷，也就是可以在RGS、MS、CHS、AHS之间传递的数据，数据类型可以是任何有效类型，并且也可以指定多个光线载荷。代码中指定的荷载就是光线与物体相交点的颜色。</p><p>接下来来看main函数。发射一条光线当然需要确定光线的起点和方向。在本示例main函数中这是通过当前屏幕像素的方向来确定的。可以看到<i><font color="Orange">pixelCenter</font></i>就是当前像素的中心在屏幕空间的坐标（<strong>gl_launchIDEXT</strong>代表当前光线的编号，也就是第几条发射的光线），然后<i><font color="Orange">inUV</font></i>代表的就是像素的纹理坐标，将它变换到<strong>[-1,1]</strong>范围内就成了像素在NDC中的横纵坐标（也就是变量<i><font color="Orange">d</font></i>）。</p><p>然后为了得到从原点出发，指向当前像素的光线，我们需要首先将原点（摄像机所在位置）和像素中心点都变换到世界坐标中去，这就是通过对摄像机位置（代码中简单地设置为(0,0,0)）乘以视角矩阵的逆矩阵以及对NDC空间中的像素中心点顺次乘以投影矩阵和视角矩阵的逆矩阵实现的。这样光线的方向就确定了。</p><p>最后实际上还需要设置光线的最小和最大相交检测距离（在这两个距离之外即使与物体有交点也不会触发命中着色器调用）。在设置好所有这些参数之后，就可以调用<code>traceRayEXT</code>来开始光线追踪了。该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">traceRayEXT(<br>    accelerationStructure, <span class="hljs-comment">// 顶层加速结构</span><br>    rayFlags,             <span class="hljs-comment">// 光线标志</span><br>    cullMask,             <span class="hljs-comment">// 遮罩</span><br>    sbtRecordOffset,      <span class="hljs-comment">// SBT 记录偏移</span><br>    sbtRecordStride,      <span class="hljs-comment">// SBT 记录步长</span><br>    missIndex,            <span class="hljs-comment">// Miss Shader 索引</span><br>    rayOrigin,            <span class="hljs-comment">// 光线起点</span><br>    rayTmin,              <span class="hljs-comment">// 光线最小距离</span><br>    rayDirection,         <span class="hljs-comment">// 光线方向</span><br>    rayTmax,              <span class="hljs-comment">// 光线最大距离</span><br>    payloadLocation       <span class="hljs-comment">// 光线载荷索引</span><br>);<br></code></pre></td></tr></table></figure><p>示例代码中指定光线标志为<i><font color="Red">gl_RayFlagsOpaqueEXT</font></i>，代表忽略AHS，由于程序中并未指定AHS，所以这么设置标志并不影响。另外，代码将SBT步长设为0，意思是让硬件自行判断。如果SBT 中的记录大小相同，并且不需要自定义步长，可以将<code>sbtRecordStride</code> 设置为 0，让 Vulkan 自动处理步长。</p><p>最后，如果该发出的光线完成了追踪过程，hitValue中存储着最终的颜色值，只需要将这个颜色值写入Storageimage对应的像素即可。</p><p>好的，接下来让我们继续分析CHS的代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 460</span><br><span class="hljs-meta">#extension GL_EXT_ray_tracing : enable</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) rayPayloadInEXT <span class="hljs-type">vec3</span> hitValue;<br>hitAttributeEXT <span class="hljs-type">vec3</span> attribs;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-type">vec3</span> barycentricCoords = <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>f - attribs.x - attribs.y, attribs.x, attribs.y);<br>  hitValue = barycentricCoords;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个着色器就是用来决定光线追踪最终得到的颜色的。因为这个颜色值需要通过hitValue传递，所以这里也需要声明并使用hitValue。另外，关键字<code>hitAttributeEXT</code>是一个在IS、CHS、AHS中传递的量，当光线与几何体相交时，可以通过这个量来传递额外的几何信息。事实上，这个数据在IS中可以读写，但在CHS、AHS中只能读取。如果说用户没有定义自己的IS，那么这个数据实际上存储的是光线和三角形交点在三角形中的<strong>重心坐标（barycentriccoordinate）</strong>（更多有关GLSL_EXT_ray_tracing的拓展特性、关键字、API等，可以参考<a href="https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_ray_tracing.txt"><code>这个页面</code></a>）。在示例代码中就是这种情况：首先通过该数据获取交点在三角形中的重心坐标，然后将交点颜色值通过该重心坐标值进行设置。接下来是我个人对于颜色值的理解，未必准确：回忆之前在定义三角形顶点数据的时候，顺序是右侧顶点——左侧顶点——上方顶点，那么这三点的重心坐标应该分别为(1,0,0)，(0,1,0)，(0,0,1)，推测重心坐标所指定的两个值应该是后两个顶点的坐标值，如果是这样的话那么三个顶点的颜色值顺次为(1,0,0)，(0,1,0)，(0,0,1)，也就是分别为红色，绿色，蓝色，和前文程序运行结果完全一致！</p><p>最后来看MS的代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 460</span><br><span class="hljs-meta">#extension GL_EXT_ray_tracing : enable</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) rayPayloadInEXT <span class="hljs-type">vec3</span> hitValue;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    hitValue = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个逻辑就更简单了：如果没有交点，就将颜色值指定为(0,0,0.2)，这就是为什么运行结果三角形之外的背景呈深蓝色的原因。</p><p>另外，示例还提供了hlsl代码，我们也可以看看hlsl的API写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//RGS</span><br><br>RaytracingAccelerationStructure rs : <span class="hljs-keyword">register</span>(t0);<br>RWTexture2D&lt;float4&gt; image : <span class="hljs-keyword">register</span>(u1);<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CameraProperties</span></span><br><span class="hljs-class">&#123;</span><br>    float4x4 viewInverse;<br>    float4x4 projInverse;<br>&#125;;<br>cbuffer camera : <span class="hljs-keyword">register</span>(b2)<br>&#123;<br>    CameraProperties camera;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Payload</span></span><br><span class="hljs-class">&#123;</span><br>    [[vk::location(<span class="hljs-number">0</span>)]] float3 hitValue;<br>&#125;;<br><br>[shader(<span class="hljs-string">&quot;raygeneration&quot;</span>)]<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    uint3 LaunchID = DispatchRaysIndex();<br>    uint3 LaunchSize = DispatchRaysDimensions();<br><br>    <span class="hljs-type">const</span> float2 pixelCenter = float2(LaunchID.xy) + float2(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>);<br>    <span class="hljs-type">const</span> float2 inUV = pixelCenter / float2(LaunchSize.xy);<br>    float2 d = inUV * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>;<br>    float4 target = mul(camera.projInverse, float4(d.x, d.y, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br><br>    RayDesc rayDesc;<br>    rayDesc.Origin = mul(camera.viewInverse, float4(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)).xyz;<br>    rayDesc.Direction = mul(camera.viewInverse, float4(normalize(target.xyz), <span class="hljs-number">0</span>)).xyz;<br>    rayDesc.TMin = <span class="hljs-number">0.001</span>;<br>    rayDesc.TMax = <span class="hljs-number">10000.0</span>;<br><br>    Payload payload;<br>    TraceRay(rs, RAY_FLAG_FORCE_OPAQUE, <span class="hljs-number">0xff</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, rayDesc, payload);<br><br>    image[int2(LaunchID.xy)] = float4(payload.hitValue, <span class="hljs-number">0.0</span>);<br>&#125;<br><br><span class="hljs-comment">//CHS</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Attributes</span></span><br><span class="hljs-class">&#123;</span><br>    float2 bary;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Payload</span></span><br><span class="hljs-class">&#123;</span><br>    [[vk::location(<span class="hljs-number">0</span>)]] float3 hitValue;<br>&#125;;<br><br>[shader(<span class="hljs-string">&quot;closesthit&quot;</span>)]<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(inout Payload p, in Attributes attribs)</span><br>&#123;<br>    <span class="hljs-type">const</span> float3 barycentricCoords = float3(<span class="hljs-number">1.0f</span> - attribs.bary.x - attribs.bary.y, attribs.bary.x, attribs.bary.y);<br>    p.hitValue = barycentricCoords;<br>&#125;<br><br><span class="hljs-comment">//MS</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Payload</span></span><br><span class="hljs-class">&#123;</span><br>    [[vk::location(<span class="hljs-number">0</span>)]] float3 hitValue;<br>&#125;;<br><br>[shader(<span class="hljs-string">&quot;miss&quot;</span>)]<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(inout Payload p)</span><br>&#123;<br>    p.hitValue = float3(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>只是有一些语法层面上的不同，读者可以自行比较分析。</p><h3 id="create_shader_binding_tables">create_shader_binding_tables</h3><p>接下来需要创建真正的SBT对象了，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Create the Shader Binding Tables that connects the ray tracing pipelines&#x27; programs and the  top-level acceleration structure</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    SBT Layout used in this sample:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        /-----------\</span><br><span class="hljs-comment">        | raygen    |</span><br><span class="hljs-comment">        |-----------|</span><br><span class="hljs-comment">        | miss      |</span><br><span class="hljs-comment">        |-----------|</span><br><span class="hljs-comment">        | hit       |</span><br><span class="hljs-comment">        \-----------/</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::create_shader_binding_tables</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>           handle_size            = ray_tracing_pipeline_properties.shaderGroupHandleSize;<br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>           handle_size_aligned    = <span class="hljs-built_in">aligned_size</span>(ray_tracing_pipeline_properties.shaderGroupHandleSize, ray_tracing_pipeline_properties.shaderGroupHandleAlignment);<br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>           handle_alignment       = ray_tracing_pipeline_properties.shaderGroupHandleAlignment;<br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>           group_count            = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(shader_groups.<span class="hljs-built_in">size</span>());<br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>           sbt_size               = group_count * handle_size_aligned;<br><span class="hljs-type">const</span> VkBufferUsageFlags sbt_buffer_usage_flags = VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR | VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;<br><span class="hljs-type">const</span> VmaMemoryUsage     sbt_memory_usage       = VMA_MEMORY_USAGE_CPU_TO_GPU;<br><br><span class="hljs-comment">// Raygen</span><br><span class="hljs-comment">// Create binding table buffers for each shader type</span><br>raygen_shader_binding_table = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), handle_size, sbt_buffer_usage_flags, sbt_memory_usage, <span class="hljs-number">0</span>);<br>miss_shader_binding_table   = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), handle_size, sbt_buffer_usage_flags, sbt_memory_usage, <span class="hljs-number">0</span>);<br>hit_shader_binding_table    = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), handle_size, sbt_buffer_usage_flags, sbt_memory_usage, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// Copy the pipeline&#x27;s shader handles into a host buffer</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">uint8_t</span>&gt; <span class="hljs-title">shader_handle_storage</span><span class="hljs-params">(sbt_size)</span></span>;<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkGetRayTracingShaderGroupHandlesKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline, <span class="hljs-number">0</span>, group_count, sbt_size, shader_handle_storage.<span class="hljs-built_in">data</span>()));<br><br><span class="hljs-comment">// Copy the shader handles from the host buffer to the binding tables</span><br><span class="hljs-type">uint8_t</span> *data = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span> *&gt;(raygen_shader_binding_table-&gt;<span class="hljs-built_in">map</span>());<br><span class="hljs-built_in">memcpy</span>(data, shader_handle_storage.<span class="hljs-built_in">data</span>(), handle_size);<br>data = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span> *&gt;(miss_shader_binding_table-&gt;<span class="hljs-built_in">map</span>());<br><span class="hljs-built_in">memcpy</span>(data, shader_handle_storage.<span class="hljs-built_in">data</span>() + handle_size_aligned, handle_size);<br>data = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span> *&gt;(hit_shader_binding_table-&gt;<span class="hljs-built_in">map</span>());<br><span class="hljs-built_in">memcpy</span>(data, shader_handle_storage.<span class="hljs-built_in">data</span>() + handle_size_aligned * <span class="hljs-number">2</span>, handle_size);<br>raygen_shader_binding_table-&gt;<span class="hljs-built_in">unmap</span>();<br>miss_shader_binding_table-&gt;<span class="hljs-built_in">unmap</span>();<br>hit_shader_binding_table-&gt;<span class="hljs-built_in">unmap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>所谓的SBT，其实也是一块缓冲区内存，其中连续地保存了所有光追管线绑定的某种特定的shadergroup的handle。为了能将这些shadergroup的handle保存到缓冲区中，需要先从管线通过<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingShaderGroupHandlesNV.html"><code>vkGetRayTracingShaderGroupHandlesKHR</code></a>获取这些handle到CPU中，再上传到GPU中。该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_ray_tracing_pipeline</span><br>VkResult <span class="hljs-title function_">vkGetRayTracingShaderGroupHandlesKHR</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDevice                                    device,</span><br><span class="hljs-params">    VkPipeline                                  pipeline,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    firstGroup,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    groupCount,</span><br><span class="hljs-params">    <span class="hljs-type">size_t</span>                                      dataSize,</span><br><span class="hljs-params">    <span class="hljs-type">void</span>*                                       pData)</span>;<br></code></pre></td></tr></table></figure><p>可以看见，我们需要指定光追管线、首个想要获取句柄的绑定的shadergroup索引、获取的shadergroup总数、用于存储handle的内存大小以及相应的CPU内存区域。代码通过在之前获取并保存的<i><font color="Orange">ray_tracing_pipeline_properties</font></i>来获取shadergroup的句柄大小以及对齐要求，这样就可以计算出对齐之后的句柄大小，从而计算出所有句柄的大小之和（每个句柄是一样大，并且一样对齐的），计算对齐大小函数<i><font color="Green">aligned_size</font></i>也十分易于理解（其实就是将内存大小向上补齐为对齐大小的倍数）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">aligned_size</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> value, <span class="hljs-type">uint32_t</span> alignment)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (value + alignment - <span class="hljs-number">1</span>) &amp; ~(alignment - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们就可以通过<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingShaderGroupHandlesNV.html"><code>vkGetRayTracingShaderGroupHandlesKHR</code></a><a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingShaderGroupHandlesNV.html"><code>vkGetRayTracingShaderGroupHandlesKHR</code></a>将所有的句柄先保存在一个8字节无符号整数的向量中，然后再将向量中某shadergroup句柄对应偏移处的数据复制到用于存储该句柄的缓冲区中。按照创建光追管线时指定的shadergroup顺序，向量中句柄数据顺序应该为RGS——MS——CHS。</p><h3 id="create_descriptor_sets">create_descriptor_sets</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Create the descriptor sets used for the ray tracing dispatch</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::create_descriptor_sets</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::vector&lt;VkDescriptorPoolSize&gt; pool_sizes = &#123;<br>    &#123;VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR, <span class="hljs-number">1</span>&#125;,<br>    &#123;VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, <span class="hljs-number">1</span>&#125;,<br>    &#123;VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">1</span>&#125;&#125;;<br>VkDescriptorPoolCreateInfo descriptor_pool_create_info = vkb::initializers::<span class="hljs-built_in">descriptor_pool_create_info</span>(pool_sizes, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorPool</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_pool_create_info, <span class="hljs-literal">nullptr</span>, &amp;descriptor_pool));<br><br>VkDescriptorSetAllocateInfo descriptor_set_allocate_info = vkb::initializers::<span class="hljs-built_in">descriptor_set_allocate_info</span>(descriptor_pool, &amp;descriptor_set_layout, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_set_allocate_info, &amp;descriptor_set));<br><br><span class="hljs-comment">// Setup the descriptor for binding our top level acceleration structure to the ray tracing shaders</span><br>VkWriteDescriptorSetAccelerationStructureKHR descriptor_acceleration_structure_info&#123;&#125;;<br>descriptor_acceleration_structure_info.sType                      = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR;<br>descriptor_acceleration_structure_info.accelerationStructureCount = <span class="hljs-number">1</span>;<br>descriptor_acceleration_structure_info.pAccelerationStructures    = &amp;top_level_acceleration_structure.handle;<br><br>VkWriteDescriptorSet acceleration_structure_write&#123;&#125;;<br>acceleration_structure_write.sType           = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;<br>acceleration_structure_write.dstSet          = descriptor_set;<br>acceleration_structure_write.dstBinding      = <span class="hljs-number">0</span>;<br>acceleration_structure_write.descriptorCount = <span class="hljs-number">1</span>;<br>acceleration_structure_write.descriptorType  = VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR;<br><span class="hljs-comment">// The acceleration structure descriptor has to be chained via pNext</span><br>acceleration_structure_write.pNext = &amp;descriptor_acceleration_structure_info;<br><br>VkDescriptorImageInfo image_descriptor&#123;&#125;;<br>image_descriptor.imageView   = storage_image.view;<br>image_descriptor.imageLayout = VK_IMAGE_LAYOUT_GENERAL;<br><br>VkDescriptorBufferInfo buffer_descriptor = <span class="hljs-built_in">create_descriptor</span>(*ubo);<br><br>VkWriteDescriptorSet result_image_write   = vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_set, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, <span class="hljs-number">1</span>, &amp;image_descriptor);<br>VkWriteDescriptorSet uniform_buffer_write = vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_set, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">2</span>, &amp;buffer_descriptor);<br><br>std::vector&lt;VkWriteDescriptorSet&gt; write_descriptor_sets = &#123;<br>    acceleration_structure_write,<br>    result_image_write,<br>    uniform_buffer_write&#125;;<br><span class="hljs-built_in">vkUpdateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(write_descriptor_sets.<span class="hljs-built_in">size</span>()), write_descriptor_sets.<span class="hljs-built_in">data</span>(), <span class="hljs-number">0</span>, VK_NULL_HANDLE);<br>&#125;<br></code></pre></td></tr></table></figure><p>整个流程十分常规，无需多言。不过这里还是需要注意一下加速结构描述符的绑定：在指定加速结构的<code>VkWriteDescriptorSet</code>的时候，除了指定绑定点、绑定描述符集、描述符类型、绑定数目等常规信息之外，真正绑定的加速结构资源需要通过<i><font color="Orange">pNext</font></i>成员指向一个<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetAccelerationStructureKHR.html"><code>VkWriteDescriptorSetAccelerationStructureKHR</code></a>结构体来指定（就像缓冲区和图像资源分别会通过<code>VkDescriptorBufferInfo</code>和<code>VkDescriptorImageInfo</code>指定一样），其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkWriteDescriptorSetAccelerationStructureKHR</span> &#123;</span><br>    VkStructureType                      sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                          pNext;<br>    <span class="hljs-type">uint32_t</span>                             accelerationStructureCount;<br>    <span class="hljs-type">const</span> VkAccelerationStructureKHR*    pAccelerationStructures;<br>&#125; VkWriteDescriptorSetAccelerationStructureKHR;<br></code></pre></td></tr></table></figure><p>注意绑定到管线上的是顶层加速结构的句柄就可以了。</p><h3 id="build_command_buffers">build_command_buffers</h3><p>上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Command buffer generation</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::build_command_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (width != storage_image.width || height != storage_image.height)<br>&#123;<br><span class="hljs-comment">// If the view port size has changed, we need to recreate the storage image</span><br><span class="hljs-built_in">vkDestroyImageView</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), storage_image.view, <span class="hljs-literal">nullptr</span>);<br><span class="hljs-built_in">vkDestroyImage</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), storage_image.image, <span class="hljs-literal">nullptr</span>);<br><span class="hljs-built_in">vkFreeMemory</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), storage_image.memory, <span class="hljs-literal">nullptr</span>);<br><span class="hljs-built_in">create_storage_image</span>();<br><span class="hljs-comment">// The descriptor also needs to be updated to reference the new image</span><br>VkDescriptorImageInfo image_descriptor&#123;&#125;;<br>image_descriptor.imageView              = storage_image.view;<br>image_descriptor.imageLayout            = VK_IMAGE_LAYOUT_GENERAL;<br>VkWriteDescriptorSet result_image_write = vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_set, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, <span class="hljs-number">1</span>, &amp;image_descriptor);<br><span class="hljs-built_in">vkUpdateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-number">1</span>, &amp;result_image_write, <span class="hljs-number">0</span>, VK_NULL_HANDLE);<br>&#125;<br><br>VkCommandBufferBeginInfo command_buffer_begin_info = vkb::initializers::<span class="hljs-built_in">command_buffer_begin_info</span>();<br><br>VkImageSubresourceRange subresource_range = &#123;VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; draw_cmd_buffers.<span class="hljs-built_in">size</span>(); ++i)<br>&#123;<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBeginCommandBuffer</span>(draw_cmd_buffers[i], &amp;command_buffer_begin_info));<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Setup the strided device address regions pointing at the shader identifiers in the shader binding table</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> handle_size_aligned = <span class="hljs-built_in">aligned_size</span>(ray_tracing_pipeline_properties.shaderGroupHandleSize, ray_tracing_pipeline_properties.shaderGroupHandleAlignment);<br><br>VkStridedDeviceAddressRegionKHR raygen_shader_sbt_entry&#123;&#125;;<br>raygen_shader_sbt_entry.deviceAddress = <span class="hljs-built_in">get_buffer_device_address</span>(raygen_shader_binding_table-&gt;<span class="hljs-built_in">get_handle</span>());<br>raygen_shader_sbt_entry.stride        = handle_size_aligned;<br>raygen_shader_sbt_entry.size          = handle_size_aligned;<br><br>VkStridedDeviceAddressRegionKHR miss_shader_sbt_entry&#123;&#125;;<br>miss_shader_sbt_entry.deviceAddress = <span class="hljs-built_in">get_buffer_device_address</span>(miss_shader_binding_table-&gt;<span class="hljs-built_in">get_handle</span>());<br>miss_shader_sbt_entry.stride        = handle_size_aligned;<br>miss_shader_sbt_entry.size          = handle_size_aligned;<br><br>VkStridedDeviceAddressRegionKHR hit_shader_sbt_entry&#123;&#125;;<br>hit_shader_sbt_entry.deviceAddress = <span class="hljs-built_in">get_buffer_device_address</span>(hit_shader_binding_table-&gt;<span class="hljs-built_in">get_handle</span>());<br>hit_shader_sbt_entry.stride        = handle_size_aligned;<br>hit_shader_sbt_entry.size          = handle_size_aligned;<br><br>VkStridedDeviceAddressRegionKHR callable_shader_sbt_entry&#123;&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Dispatch the ray tracing commands</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">vkCmdBindPipeline</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, pipeline);<br><span class="hljs-built_in">vkCmdBindDescriptorSets</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, pipeline_layout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;descriptor_set, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">vkCmdTraceRaysKHR</span>(<br>    draw_cmd_buffers[i],<br>    &amp;raygen_shader_sbt_entry,<br>    &amp;miss_shader_sbt_entry,<br>    &amp;hit_shader_sbt_entry,<br>    &amp;callable_shader_sbt_entry,<br>    width,<br>    height,<br>    <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Copy ray tracing output to swap chain image</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// Prepare current swap chain image as transfer destination</span><br>vkb::<span class="hljs-built_in">image_layout_transition</span>(draw_cmd_buffers[i],<br>                             <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_swapchain</span>().<span class="hljs-built_in">get_images</span>()[i],<br>                             VK_IMAGE_LAYOUT_UNDEFINED,<br>                             VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);<br><br><span class="hljs-comment">// Prepare ray tracing output image as transfer source</span><br>vkb::<span class="hljs-built_in">image_layout_transition</span>(draw_cmd_buffers[i],<br>                             storage_image.image,<br>                             VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,<br>                             VK_PIPELINE_STAGE_TRANSFER_BIT,<br>                             &#123;&#125;,<br>                             VK_ACCESS_TRANSFER_READ_BIT,<br>                             VK_IMAGE_LAYOUT_GENERAL,<br>                             VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,<br>                             subresource_range);<br><br>VkImageCopy copy_region&#123;&#125;;<br>copy_region.srcSubresource = &#123;VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>copy_region.srcOffset      = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>copy_region.dstSubresource = &#123;VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>copy_region.dstOffset      = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>copy_region.extent         = &#123;width, height, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-built_in">vkCmdCopyImage</span>(draw_cmd_buffers[i], storage_image.image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,<br>               <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_swapchain</span>().<span class="hljs-built_in">get_images</span>()[i], VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, <span class="hljs-number">1</span>, &amp;copy_region);<br><br><span class="hljs-comment">// Transition swap chain image back for presentation</span><br>vkb::<span class="hljs-built_in">image_layout_transition</span>(draw_cmd_buffers[i],<br>                             <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_swapchain</span>().<span class="hljs-built_in">get_images</span>()[i],<br>                             VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,<br>                             VK_IMAGE_LAYOUT_PRESENT_SRC_KHR);<br><br><span class="hljs-comment">// Transition ray tracing output image back to general layout</span><br>vkb::<span class="hljs-built_in">image_layout_transition</span>(draw_cmd_buffers[i],<br>                             storage_image.image,<br>                             VK_PIPELINE_STAGE_TRANSFER_BIT,<br>                             VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,<br>                             VK_ACCESS_TRANSFER_READ_BIT,<br>                             &#123;&#125;,<br>                             VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,<br>                             VK_IMAGE_LAYOUT_GENERAL,<br>                             subresource_range);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Start a new render pass to draw the UI overlay on top of the ray traced image</span><br><span class="hljs-comment">*/</span><br>VkClearValue clear_values[<span class="hljs-number">2</span>];<br>clear_values[<span class="hljs-number">0</span>].color        = &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.033f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;;<br>clear_values[<span class="hljs-number">1</span>].depthStencil = &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0</span>&#125;;<br><br>VkRenderPassBeginInfo render_pass_begin_info    = vkb::initializers::<span class="hljs-built_in">render_pass_begin_info</span>();<br>render_pass_begin_info.renderPass               = render_pass;<br>render_pass_begin_info.framebuffer              = framebuffers[i];<br>render_pass_begin_info.renderArea.extent.width  = width;<br>render_pass_begin_info.renderArea.extent.height = height;<br>render_pass_begin_info.clearValueCount          = <span class="hljs-number">2</span>;<br>render_pass_begin_info.pClearValues             = clear_values;<br><br><span class="hljs-built_in">vkCmdBeginRenderPass</span>(draw_cmd_buffers[i], &amp;render_pass_begin_info, VK_SUBPASS_CONTENTS_INLINE);<br><span class="hljs-built_in">draw_ui</span>(draw_cmd_buffers[i]);<br><span class="hljs-built_in">vkCmdEndRenderPass</span>(draw_cmd_buffers[i]);<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkEndCommandBuffer</span>(draw_cmd_buffers[i]));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数用于构建提交给GPU执行的命令缓冲。事实上本示例需要录制的命令可以分为三部分：处理屏幕大小变化、开启光追、绘制UI界面。</p><p>首先判断当前屏幕大小有无变化，若发生了变化，则需要重建Storageimage（相应的描述符也需要更新），这部分没什么需要多分析的。</p><p>然后开始准备开启光追。Vulkan中光追命令的开启是通过<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdTraceRaysKHR.html"><code>vkCmdTraceRaysKHR</code></a>完成的。该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_ray_tracing_pipeline</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdTraceRaysKHR</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkStridedDeviceAddressRegionKHR*      pRaygenShaderBindingTable,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkStridedDeviceAddressRegionKHR*      pMissShaderBindingTable,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkStridedDeviceAddressRegionKHR*      pHitShaderBindingTable,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkStridedDeviceAddressRegionKHR*      pCallableShaderBindingTable,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    width,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    height,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    depth)</span>;<br></code></pre></td></tr></table></figure><p>大多参数都可以靠名字猜出它的含义：<i><font color="Orange">pRaygenShaderBindingTable</font></i>指定的是RGS的SBT绑定条目，<i><font color="Orange">pMissShaderBindingTable</font></i>指定的是MS的SBT绑定条目，<i><font color="Orange">pHitShaderBindingTable</font></i>指定的是IS、CHS、AHS的SBT绑定条目，而<i><font color="Orange">pRaygenShaderBindingTable</font></i><i><font color="Orange">pCallableShaderBindingTable</font></i>指定的则是一些可以被其它着色器调用的着色器绑定条目（一般用于封装一些计算逻辑以便代码复用等）。最后的三个成员分别代表发射光线在各个维度的数量。</p><p>为了指定这些SBT条目参数，需要填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkStridedDeviceAddressRegionKHR.html"><code>VkStridedDeviceAddressRegionKHR</code></a>结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_ray_tracing_pipeline</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkStridedDeviceAddressRegionKHR</span> &#123;</span><br>    VkDeviceAddress    deviceAddress;<br>    VkDeviceSize       stride;<br>    VkDeviceSize       size;<br>&#125; VkStridedDeviceAddressRegionKHR;<br></code></pre></td></tr></table></figure><p>由于示例程序中每种（前三种）SBT条目各一个，因此size和stride均为该条目对应的shadergroup handle在缓冲区种的对齐大小。</p><p>最后，只需要在开启光追前绑定管线和描述符即可。</p><p>然后，由于光追结果是渲染到Storageimage上的，我们需要将渲染数据复制到后台缓冲区中。在复制之前当然需要对后台缓冲区图像和Storageimage的布局进行合适的转换（分别转换为传输目标和传输源），不过这里要注意，前后两次的图像布局转换实际上使用的是不同的工具函数，前一个使用的是一般的<i><font color="Green">image_layout_transition</font></i>，它可以根据传入的前后布局来推断前后管线阶段和操作，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">image_layout_transition</span><span class="hljs-params">(VkCommandBuffer command_buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                             VkImage         image,</span></span><br><span class="hljs-params"><span class="hljs-function">                             VkImageLayout   old_layout,</span></span><br><span class="hljs-params"><span class="hljs-function">                             VkImageLayout   new_layout)</span></span><br><span class="hljs-function"></span>&#123;<br>VkImageSubresourceRange subresource_range = &#123;&#125;;<br>subresource_range.aspectMask              = VK_IMAGE_ASPECT_COLOR_BIT;<br>subresource_range.baseMipLevel            = <span class="hljs-number">0</span>;<br>subresource_range.levelCount              = <span class="hljs-number">1</span>;<br>subresource_range.baseArrayLayer          = <span class="hljs-number">0</span>;<br>subresource_range.layerCount              = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">image_layout_transition</span>(command_buffer, image, old_layout, new_layout, subresource_range);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">image_layout_transition</span><span class="hljs-params">(VkCommandBuffer                command_buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                             VkImage                        image,</span></span><br><span class="hljs-params"><span class="hljs-function">                             VkImageLayout                  old_layout,</span></span><br><span class="hljs-params"><span class="hljs-function">                             VkImageLayout                  new_layout,</span></span><br><span class="hljs-params"><span class="hljs-function">                             VkImageSubresourceRange <span class="hljs-type">const</span> &amp;subresource_range)</span></span><br><span class="hljs-function"></span>&#123;<br>VkPipelineStageFlags src_stage_mask  = <span class="hljs-built_in">getPipelineStageFlags</span>(old_layout);<br>VkPipelineStageFlags dst_stage_mask  = <span class="hljs-built_in">getPipelineStageFlags</span>(new_layout);<br>VkAccessFlags        src_access_mask = <span class="hljs-built_in">getAccessFlags</span>(old_layout);<br>VkAccessFlags        dst_access_mask = <span class="hljs-built_in">getAccessFlags</span>(new_layout);<br><br><span class="hljs-built_in">image_layout_transition</span>(command_buffer, image, src_stage_mask, dst_stage_mask, src_access_mask, dst_access_mask, old_layout, new_layout, subresource_range);<br>&#125;<br><br><br><span class="hljs-function">VkPipelineStageFlags <span class="hljs-title">getPipelineStageFlags</span><span class="hljs-params">(VkImageLayout layout)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">switch</span> (layout)<br>&#123;<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_UNDEFINED:<br><span class="hljs-keyword">return</span> VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_PREINITIALIZED:<br><span class="hljs-keyword">return</span> VK_PIPELINE_STAGE_HOST_BIT;<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL:<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL:<br><span class="hljs-keyword">return</span> VK_PIPELINE_STAGE_TRANSFER_BIT;<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL:<br><span class="hljs-keyword">return</span> VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL:<br><span class="hljs-keyword">return</span> VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT;<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR:<br><span class="hljs-keyword">return</span> VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL:<br><span class="hljs-keyword">return</span> VK_PIPELINE_STAGE_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_PRESENT_SRC_KHR:<br><span class="hljs-keyword">return</span> VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_GENERAL:<br><span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-string">&quot;Don&#x27;t know how to get a meaningful VkPipelineStageFlags for VK_IMAGE_LAYOUT_GENERAL! Don&#x27;t use it!&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><br><span class="hljs-function">VkAccessFlags <span class="hljs-title">getAccessFlags</span><span class="hljs-params">(VkImageLayout layout)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">switch</span> (layout)<br>&#123;<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_UNDEFINED:<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_PRESENT_SRC_KHR:<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_PREINITIALIZED:<br><span class="hljs-keyword">return</span> VK_ACCESS_HOST_WRITE_BIT;<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL:<br><span class="hljs-keyword">return</span> VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL:<br><span class="hljs-keyword">return</span> VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR:<br><span class="hljs-keyword">return</span> VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR;<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL:<br><span class="hljs-keyword">return</span> VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_INPUT_ATTACHMENT_READ_BIT;<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL:<br><span class="hljs-keyword">return</span> VK_ACCESS_TRANSFER_READ_BIT;<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL:<br><span class="hljs-keyword">return</span> VK_ACCESS_TRANSFER_WRITE_BIT;<br><span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_GENERAL:<br><span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-string">&quot;Don&#x27;t know how to get a meaningful VkAccessFlags for VK_IMAGE_LAYOUT_GENERAL! Don&#x27;t use it!&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是可以发现这个函数无法处理图像布局为<i><font color="Red">VK_IMAGE_LAYOUT_GENERAL</font></i>的情况，因为这种情况下图像可能用于各种用途，因此需要用户来指定相应的管线阶段和操作，这就是为什么在第二个布局转换的时候代码额外指定了管线阶段和操作（注意这里源阶段直接简单粗暴地指定为<i><font color="Red">VK_PIPELINE_STAGE_ALL_COMMANDS_BIT</font></i>）。</p><p>在完成了Storageimage和后台缓冲区图像的布局转换后，就可以复制图像数据了。复制完成后，别忘了将后台缓冲区图像布局转换为显示最优，并且将Storageimage布局转换回<i><font color="Red">VK_IMAGE_LAYOUT_GENERAL</font></i>供下一帧使用。</p><p>最后完成UI界面绘制命令的录制工作，就完成了整个命令录制。</p><p>准备阶段到此结束。</p><h2 id="绘制阶段">绘制阶段</h2><p>绘制阶段的代码十分简单，就是提交录制好的命令，然后更新UBO数据即可。直接放上代码，不再分析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::render</span><span class="hljs-params">(<span class="hljs-type">float</span> delta_time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!prepared)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">draw</span>();<br><span class="hljs-keyword">if</span> (camera.updated)<br>&#123;<br><span class="hljs-built_in">update_uniform_buffers</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ApiVulkanSample::<span class="hljs-built_in">prepare_frame</span>();<br>submit_info.commandBufferCount = <span class="hljs-number">1</span>;<br>submit_info.pCommandBuffers    = &amp;draw_cmd_buffers[current_buffer];<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkQueueSubmit</span>(queue, <span class="hljs-number">1</span>, &amp;submit_info, VK_NULL_HANDLE));<br>ApiVulkanSample::<span class="hljs-built_in">submit_frame</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::update_uniform_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>uniform_data.proj_inverse = glm::<span class="hljs-built_in">inverse</span>(camera.matrices.perspective);<br>uniform_data.view_inverse = glm::<span class="hljs-built_in">inverse</span>(camera.matrices.view);<br>ubo-&gt;<span class="hljs-built_in">convert_and_update</span>(uniform_data);<br>&#125;<br></code></pre></td></tr></table></figure><p>终于是完成了对于光追基础示例的分析！！（瘫了 **(=_=)**</p><hr>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_samples</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Multi draw indirect</title>
    <link href="/2025/02/23/CG_api/vulkan/vulkan_samples/multi_draw_indirect/"/>
    <url>/2025/02/23/CG_api/vulkan/vulkan_samples/multi_draw_indirect/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言">前言</h2><p>所谓<strong>Multi drawindirect</strong>（多重间接绘制，下文简称mdi），指的是改变从CPU上传绘制命令的绘制参数到GPU进行绘制的方式，改为将绘制参数储存在GPU缓冲区中，绘制命令调用的时候直接从该缓冲区提取绘制参数信息。使用mdi有如下几点好处：</p><ul><li>所有绘制物体的顶点和索引可以放在同一个顶点和索引缓冲区中，只需要绑定顶点缓冲区和索引缓冲区一次就可以进行所有绘制，无需像普通的绘制调用一样，不同物体的绘制需要反复绑定具有新的顶点缓冲和输入布局的管线对象。</li><li>显著减少了资源的绑定次数，比如所有模型用到的纹理可以存储在一个纹理序列中供像素着色器通过实例索引来选择正确的纹理进行绘制，而无需像普通的绘制一样，每个物体需要各自绑定自己所需要的纹理等资源。</li><li>mdi在绘制参数中允许指定顶点和索引偏移，这就允许索引缓冲区在索引数目远多于<i><font color="Orange">uint_16</font></i>所能表示的最大数目的时候仍有可能使用<i><font color="Orange">uint_16</font></i>的索引格式（因为每个模型的索引值都可以从0开始指定，然后通过偏移索引到正确的顶点，只要每单个绘制模型的索引数小于<i><font color="Orange">uint_16</font></i>能表示的最大数目就行）。</li><li>一组drawcall可以一次性被GPU执行，这显著减少了命令缓冲区的开销。</li></ul><p>Vulkan官方示例集的<a href="https://docs.vulkan.org/samples/latest/samples/performance/multi_draw_indirect/README.html">文档</a>中给出了关于mdi的基本介绍，可以参考。</p><p>另外，mdi是<strong>GPU-driven-pipeline</strong>的一个重要环节，所谓<strong>GPU-driven-pipeline</strong>，简单来说就是将很多CPU做的工作放到GPU上执行。<a href="https://zhuanlan.zhihu.com/p/409244895?utm_psn=1877657433960222722">知乎大佬</a>的文章对这一块做了一个概要性的介绍，可以对<strong>GPU-driven-pipeline</strong>的基础流程有一个了解。</p><p>下面废话不多说，让我们进入到示例集源码的世界中探寻基本mdi功能的实现细节~。</p><hr><h2 id="特性拓展要求">特性拓展要求</h2><p>首先想要启用mdi，需要检查一些拓展和特性硬件是否支持。可以看到在<strong>multi_draw_indirect.h</strong>头文件中应用程序类<i><font color="Orange">MultiDrawIndirect</font></i>中有三个布尔成员：<i><font color="Orange">m_supports_mdi</font></i>、<i><font color="Orange">m_supports_first_instance</font></i>和<i><font color="Orange">m_supports_buffer_device</font></i>。</p><p>第一个成员显然用于标识硬件是否支持多重间接绘制，如果不支持的话，那么在调用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexedIndirect.html"><code>vkCmdDrawIndexedIndirect</code></a>的时候它的<code>drawCount</code>参数只能为0或1，这也就意味着我们只能对每个要绘制的实例单独调用一次<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexedIndirect.html"><code>vkCmdDrawIndexedIndirect</code></a>，而如果支持的话，那么就可以通过将<code>drawCount</code>指定为需要的绘制次数从而一次绘制调用绘制所有物体。</p><p>第二个成员用于决定mdi是否支持实例偏移，也就是在调用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexedIndirect.html"><code>vkCmdDrawIndexedIndirect</code></a>的时候指定<code>firstInstance</code>偏移值，如果不支持的话那么该参数只能取值为0，也就是不允许偏移。在官方示例中后续的绘制命令调用实际上直接默认该特性是支持的了，也不知道为什么。。。</p><p>最后一个成员决定硬件是否支持缓冲区地址，这会决定使用CS进行视锥剔除的时候结果会怎么写入存储绘制参数的缓冲区，这在后文分析GPUcull的时候会讲到。</p><p>最后来看一下代码是怎么填写这些布尔成员的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++">MultiDrawIndirect::<span class="hljs-built_in">MultiDrawIndirect</span>()<br>&#123;<br><span class="hljs-built_in">set_api_version</span>(VK_API_VERSION_1_2);<br><span class="hljs-built_in">add_device_extension</span>(VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME, <span class="hljs-literal">true</span> <span class="hljs-comment">/* optional */</span>);<br>&#125;<br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::request_gpu_features</span><span class="hljs-params">(vkb::PhysicalDevice &amp;gpu)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (gpu.<span class="hljs-built_in">get_features</span>().multiDrawIndirect)<br>&#123;<br>gpu.<span class="hljs-built_in">get_mutable_requested_features</span>().multiDrawIndirect = VK_TRUE;<br>m_supports_mdi                                         = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (gpu.<span class="hljs-built_in">get_features</span>().drawIndirectFirstInstance)<br>&#123;<br>gpu.<span class="hljs-built_in">get_mutable_requested_features</span>().drawIndirectFirstInstance = VK_TRUE;<br>m_supports_first_instance                                      = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// Query whether the device supports buffer device addresses</span><br>m_supports_buffer_device =<br>    <span class="hljs-built_in">REQUEST_OPTIONAL_FEATURE</span>(gpu, VkPhysicalDeviceVulkan12Features, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES, bufferDeviceAddress);<br><br><span class="hljs-comment">// This sample references 128 objects. We need to check whether this is supported by the device</span><br>VkPhysicalDeviceProperties physical_device_properties;<br><span class="hljs-built_in">vkGetPhysicalDeviceProperties</span>(gpu.<span class="hljs-built_in">get_handle</span>(), &amp;physical_device_properties);<br><br><span class="hljs-keyword">if</span> (physical_device_properties.limits.maxPerStageDescriptorSamplers &lt; <span class="hljs-number">128</span>)<br>&#123;<br><span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(fmt::format(<span class="hljs-built_in">FMT_STRING</span>(<span class="hljs-string">&quot;This sample requires at least 128 descriptor samplers, but device only supports &#123;:d&#125;&quot;</span>), physical_device_properties.limits.maxPerStageDescriptorSamplers));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于mdi和firstInstance，可以看到查询比较简单，只需要查询<a href="https://docs.vulkan.org/spec/latest/chapters/features.html"><code>VkPhysicalDeviceFeatures</code></a>结构体就可以了，<code>multiDrawIndirect</code>和<code>drawIndirectFirstInstance</code>就是对应的我们希望查询的成员。只需要查询硬件是否支持，支持就启用然后把相应的布尔成员设置为true就可以了。而如果要查询硬件对bufferaddress的支持状态，我们还需要启用拓展<i><font color="Red">VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME</font></i>，然后才可以进行相应的查询。查询的时候，我们需要将<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVulkan12Features.html"><code>VkPhysicalDeviceVulkan12Features</code></a>传递给<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFeatures2.html"><code>VkPhysicalDeviceFeatures2</code></a>的pNext指针，然后交给<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures2.html"><code>vkGetPhysicalDeviceFeatures2</code></a>进行查询和结构体的填充工作即可。</p><p>最后要注意的是，由于我们准备将所有的纹理一起绑定成一个数组供像素着色器使用，所以最后还需要查询硬件是否支持在单阶段内绑定采样器数量大于128，如果不行的话那程序也无法运行。</p><p>在我的电脑上所有的这些布尔成员都会被设置为true。</p><hr><h2 id="准备阶段">准备阶段</h2><p>然后我们就来着重分析<i><font color="Orange">prepare</font></i>函数的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MultiDrawIndirect::prepare</span><span class="hljs-params">(<span class="hljs-type">const</span> vkb::ApplicationOptions &amp;options)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!ApiVulkanSample::<span class="hljs-built_in">prepare</span>(options))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>camera.type = vkb::CameraType::FirstPerson;<br>camera.<span class="hljs-built_in">set_perspective</span>(<span class="hljs-number">60.0f</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(width) / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(height), <span class="hljs-number">0.001f</span>, <span class="hljs-number">512.0f</span>);<br>camera.<span class="hljs-built_in">set_rotation</span>(glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">-23.5</span>, <span class="hljs-number">-45</span>, <span class="hljs-number">0</span>));<br>camera.<span class="hljs-built_in">set_translation</span>(glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">-0.2</span>));<br><br><span class="hljs-keyword">if</span> (!compute_queue)<br>&#123;<br>compute_queue = &amp;<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_by_flags</span>(VK_QUEUE_COMPUTE_BIT, <span class="hljs-number">0</span>);<br>&#125;<br><br>queue_families.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;queue_bit : &#123;VK_QUEUE_GRAPHICS_BIT, VK_QUEUE_COMPUTE_BIT&#125;)<br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> index = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_by_flags</span>(queue_bit, <span class="hljs-number">0</span>).<span class="hljs-built_in">get_family_index</span>();<br><span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">find</span>(queue_families.<span class="hljs-built_in">cbegin</span>(), queue_families.<span class="hljs-built_in">cend</span>(), index) == queue_families.<span class="hljs-built_in">cend</span>())<br>&#123;<br>queue_families.<span class="hljs-built_in">emplace_back</span>(index);<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">create_samplers</span>();<br><span class="hljs-built_in">load_scene</span>();<br><span class="hljs-built_in">initialize_resources</span>();<br><span class="hljs-built_in">update_scene_uniform</span>();<br><span class="hljs-built_in">create_pipeline</span>();<br><span class="hljs-built_in">create_compute_pipeline</span>();<br><span class="hljs-built_in">initialize_descriptors</span>();<br><span class="hljs-built_in">build_command_buffers</span>();<br><span class="hljs-built_in">cpu_cull</span>();        <span class="hljs-comment">// initialize buffer</span><br><span class="hljs-built_in">run_cull</span>();<br><br>prepared = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先还是调用基类的准备函数，包括创建一些基础的同步量、交换链、命令缓冲等，这里不详细展开了。然后是设置好摄像机的模式和参数，并且申请到图形和计算队列的使用权，后续会提交命令到这两个队列中去。</p><p>接下来开始逐个分析下方一连串的函数调用：</p><h3 id="create_samplers">create_samplers</h3><p>先上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::create_samplers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>VkSamplerCreateInfo sampler_info = vkb::initializers::<span class="hljs-built_in">sampler_create_info</span>();<br>sampler_info.magFilter           = VK_FILTER_LINEAR;<br>sampler_info.minFilter           = VK_FILTER_LINEAR;<br>sampler_info.mipmapMode          = VK_SAMPLER_MIPMAP_MODE_LINEAR;<br>sampler_info.addressModeU        = VK_SAMPLER_ADDRESS_MODE_REPEAT;<br>sampler_info.addressModeV        = VK_SAMPLER_ADDRESS_MODE_REPEAT;<br>sampler_info.addressModeW        = VK_SAMPLER_ADDRESS_MODE_REPEAT;<br>sampler_info.mipLodBias          = <span class="hljs-number">0.0f</span>;<br>sampler_info.maxAnisotropy       = <span class="hljs-number">1.0f</span>;<br>sampler_info.minLod              = <span class="hljs-number">0.0f</span>;<br>sampler_info.maxLod              = <span class="hljs-number">1.0f</span>;<br>sampler_info.borderColor         = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE;<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateSampler</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;sampler_info, <span class="hljs-literal">nullptr</span>, &amp;sampler_linear));<br><br><span class="hljs-comment">// Some formats don&#x27;t support linear filtering, so create a nearest filtered sampler as a fallback</span><br>sampler_info.magFilter  = VK_FILTER_NEAREST;<br>sampler_info.minFilter  = VK_FILTER_NEAREST;<br>sampler_info.mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST;<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateSampler</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;sampler_info, <span class="hljs-literal">nullptr</span>, &amp;sampler_nearest));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这只是一个很简单的采样器创建操作，分别创建了两种采样器，一种使用线性过滤的方式进行采样，另一种使用最近过滤的方式进行采样，如果一些图像格式不支持线性过滤，那么就会使用最近过滤的采样器作为fallback。没什么需要多分析的了，继续继续~</p><h3 id="load_scene">load_scene</h3><p>同样先上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::load_scene</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> std::string scene_path = <span class="hljs-string">&quot;scenes/vokselia/&quot;</span>;<br>ApiVulkanSample::<span class="hljs-built_in">load_scene</span>(scene_path + <span class="hljs-string">&quot;vokselia.gltf&quot;</span>);<br><br><span class="hljs-built_in">assert</span>(<span class="hljs-built_in">has_scene</span>());<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;mesh : <span class="hljs-built_in">get_scene</span>().<span class="hljs-built_in">get_components</span>&lt;vkb::sg::Mesh&gt;())<br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> texture_index = textures.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>  &amp;short_name    = mesh-&gt;<span class="hljs-built_in">get_name</span>();<br><span class="hljs-keyword">auto</span>         image_name    = scene_path + short_name + <span class="hljs-string">&quot;.ktx&quot;</span>;<br><span class="hljs-keyword">auto</span>         image         = vkb::sg::Image::<span class="hljs-built_in">load</span>(image_name, image_name, vkb::sg::Image::Color);<br><br>image-&gt;<span class="hljs-built_in">create_vk_image</span>(<span class="hljs-built_in">get_device</span>());<br>Texture texture;<br>texture.n_mip_maps = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(image-&gt;<span class="hljs-built_in">get_mipmaps</span>().<span class="hljs-built_in">size</span>());<br><span class="hljs-built_in">assert</span>(texture.n_mip_maps == <span class="hljs-number">1</span>);<br>texture.image = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::Image&gt;(<span class="hljs-built_in">get_device</span>(),<br>                                                   image-&gt;<span class="hljs-built_in">get_extent</span>(),<br>                                                   image-&gt;<span class="hljs-built_in">get_format</span>(),<br>                                                   VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT,<br>                                                   VMA_MEMORY_USAGE_GPU_ONLY,<br>                                                   VK_SAMPLE_COUNT_1_BIT,<br>                                                   <span class="hljs-number">1</span>,<br>                                                   <span class="hljs-number">1</span>,<br>                                                   VK_IMAGE_TILING_OPTIMAL,<br>                                                   <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">auto</span> data_buffer = vkb::core::BufferC::<span class="hljs-built_in">create_staging_buffer</span>(<span class="hljs-built_in">get_device</span>(), image-&gt;<span class="hljs-built_in">get_data</span>());<br><br><span class="hljs-keyword">auto</span> &amp;texture_cmd = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_command_pool</span>().<span class="hljs-built_in">request_command_buffer</span>();<br>texture_cmd.<span class="hljs-built_in">begin</span>(VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, VK_NULL_HANDLE);<br><br>VkImageSubresourceRange subresource_range = &#123;VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>subresource_range.baseMipLevel            = <span class="hljs-number">0</span>;<br>subresource_range.levelCount              = texture.n_mip_maps;<br><br>vkb::<span class="hljs-built_in">image_layout_transition</span>(<br>    texture_cmd.<span class="hljs-built_in">get_handle</span>(), texture.image-&gt;<span class="hljs-built_in">get_handle</span>(), VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, subresource_range);<br><br><span class="hljs-keyword">auto</span>              offsets              = image-&gt;<span class="hljs-built_in">get_offsets</span>();<br>VkBufferImageCopy region               = &#123;&#125;;<br>region.imageSubresource.aspectMask     = VK_IMAGE_ASPECT_COLOR_BIT;<br>region.imageSubresource.mipLevel       = <span class="hljs-number">0</span>;<br>region.imageSubresource.baseArrayLayer = <span class="hljs-number">0</span>;<br>region.imageSubresource.layerCount     = <span class="hljs-number">1</span>;<br>region.imageExtent                     = image-&gt;<span class="hljs-built_in">get_extent</span>();<br>region.bufferOffset                    = offsets[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><br>texture_cmd.<span class="hljs-built_in">copy_buffer_to_image</span>(data_buffer, *texture.image, &#123;region&#125;);<br>texture_cmd.<span class="hljs-built_in">end</span>();<br><br><span class="hljs-keyword">auto</span> &amp;queue = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_by_flags</span>(VK_QUEUE_GRAPHICS_BIT, <span class="hljs-number">0</span>);<br>queue.<span class="hljs-built_in">submit</span>(texture_cmd, <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">request_fence</span>());<br><span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_fence_pool</span>().<span class="hljs-built_in">wait</span>();<br><span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_fence_pool</span>().<span class="hljs-built_in">reset</span>();<br><br>texture.image_view = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::ImageView&gt;(*texture.image, VK_IMAGE_VIEW_TYPE_2D);<br><br><span class="hljs-comment">// Get the properties for the image format. We&#x27;ll need to check whether a linear sampler is valid.</span><br><span class="hljs-type">const</span> VkFormatProperties fmtProps = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_format_properties</span>(image-&gt;<span class="hljs-built_in">get_format</span>());<br><br>VkDescriptorImageInfo image_descriptor;<br>image_descriptor.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;<br>image_descriptor.imageView   = texture.image_view-&gt;<span class="hljs-built_in">get_handle</span>();<br>image_descriptor.sampler     = (fmtProps.optimalTilingFeatures &amp; VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT) ?<br>                                   sampler_linear :<br>                                   sampler_nearest;<br>image_descriptors.<span class="hljs-built_in">push_back</span>(image_descriptor);<br>textures.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">move</span>(texture));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;sub_mesh : mesh-&gt;<span class="hljs-built_in">get_submeshes</span>())<br>&#123;<br>SceneModel model;<br>model.texture_index = texture_index;<br><br><span class="hljs-keyword">auto</span> pts = CopyBuffer&lt;glm::vec3&gt;&#123;&#125;(sub_mesh-&gt;vertex_buffers, <span class="hljs-string">&quot;position&quot;</span>);<br><span class="hljs-keyword">auto</span> uvs = CopyBuffer&lt;glm::vec2&gt;&#123;&#125;(sub_mesh-&gt;vertex_buffers, <span class="hljs-string">&quot;texcoord_0&quot;</span>);<br><span class="hljs-built_in">assert</span>(uvs.<span class="hljs-built_in">size</span>() == pts.<span class="hljs-built_in">size</span>());<br><br>model.vertices.<span class="hljs-built_in">resize</span>(pts.<span class="hljs-built_in">size</span>());<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; pts.<span class="hljs-built_in">size</span>(); ++i)<br>&#123;<br>model.vertices[i].pt = &#123;pts[i].x, -pts[i].y, pts[i].z&#125;;<br>model.vertices[i].uv = uvs[i];<br>&#125;<br><br><span class="hljs-built_in">assert</span>(sub_mesh-&gt;index_type == VK_INDEX_TYPE_UINT16);<br><span class="hljs-keyword">auto</span> buffer = sub_mesh-&gt;index_buffer.<span class="hljs-built_in">get</span>();<br><span class="hljs-keyword">if</span> (buffer)<br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> sz         = buffer-&gt;<span class="hljs-built_in">get_size</span>();<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> nTriangles = sz / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint16_t</span>) / <span class="hljs-number">3</span>;<br>model.triangles.<span class="hljs-built_in">resize</span>(nTriangles);<br><span class="hljs-keyword">auto</span> ptr = buffer-&gt;<span class="hljs-built_in">get_data</span>();<br><span class="hljs-built_in">assert</span>(!!ptr);<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">uint16_t</span>&gt; <span class="hljs-title">temp_buffer</span><span class="hljs-params">(nTriangles * <span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-built_in">memcpy</span>(temp_buffer.<span class="hljs-built_in">data</span>(), ptr, nTriangles * <span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(temp_buffer[<span class="hljs-number">0</span>]));<br>model.triangles.<span class="hljs-built_in">resize</span>(nTriangles);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; nTriangles; ++i)<br>&#123;<br>model.triangles[i] = &#123;<br>    <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint16_t</span>&gt;(temp_buffer[<span class="hljs-number">3</span> * i]),<br>    <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint16_t</span>&gt;(temp_buffer[<span class="hljs-number">3</span> * i + <span class="hljs-number">1</span>]),<br>    <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint16_t</span>&gt;(temp_buffer[<span class="hljs-number">3</span> * i + <span class="hljs-number">2</span>])&#125;;<br>&#125;<br>&#125;<br>model.bounding_sphere = <span class="hljs-built_in">BoundingSphere</span>(pts);<br>models.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">move</span>(model));<br>&#125;<br>&#125;<br><br>std::vector&lt;std::pair&lt;VkImage, VkImageSubresourceRange&gt;&gt; imagesAndRanges;<br>imagesAndRanges.<span class="hljs-built_in">reserve</span>(textures.<span class="hljs-built_in">size</span>());<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> &amp;texture : textures)<br>&#123;<br>imagesAndRanges.<span class="hljs-built_in">emplace_back</span>(<br>    std::<span class="hljs-built_in">make_pair</span>(texture.image-&gt;<span class="hljs-built_in">get_handle</span>(), VkImageSubresourceRange&#123;VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">0</span>, texture.n_mip_maps, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;));<br>&#125;<br><br><span class="hljs-keyword">auto</span> &amp;cmd = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_command_pool</span>().<span class="hljs-built_in">request_command_buffer</span>();<br>cmd.<span class="hljs-built_in">begin</span>(VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, VK_NULL_HANDLE);<br>vkb::<span class="hljs-built_in">image_layout_transition</span>(cmd.<span class="hljs-built_in">get_handle</span>(), imagesAndRanges, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);<br>cmd.<span class="hljs-built_in">end</span>();<br><span class="hljs-keyword">auto</span> &amp;queue = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_by_flags</span>(VK_QUEUE_GRAPHICS_BIT, <span class="hljs-number">0</span>);<br>queue.<span class="hljs-built_in">submit</span>(cmd, <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">request_fence</span>());<br><span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_fence_pool</span>().<span class="hljs-built_in">wait</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这就比较冗长了，让我们耐下心来逐行分析吧。</p><p>首先需要将场景模型给加载到程序中来，使用工具函数<i><font color="Green">load_scene</font></i>即可完成加载。这里我们并不会具体分析这个加载函数的代码，对于这些框架类代码的分析会留待日后进行，这里我们只需要知道加载进来的模型包含了很多信息，包括我们需要使用的<code>mesh</code>信息，其中每个<code>mesh</code>又是由很多许多<code>submesh</code>所组成的。<code>mesh</code>中包含了名称、纹理名称等众多信息，顶点、索引等信息则存储在每一个<code>submesh</code>中。</p><p><i><font color="Green">load_scene</font></i>用一个循环来处理模型所有的mesh，首先通过mesh存储的纹理名确定它的存储路径，并使用<i><font color="Green">create_vk_image</font></i>工具函数将纹理数据创建为一个Vulkan图像对象。<i><font color="Green">create_vk_image</font></i>就是一个简单的<code>VkImage</code>和相应的<code>VkImageView</code>创建函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Image::create_vk_image</span><span class="hljs-params">(Device &amp;device, VkImageViewType image_view_type, VkImageCreateFlags flags)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">assert</span>(!vk_image &amp;&amp; !vk_image_view &amp;&amp; <span class="hljs-string">&quot;Vulkan image already constructed&quot;</span>);<br><br>vk_image = std::<span class="hljs-built_in">make_unique</span>&lt;core::Image&gt;(device,<br>                                         <span class="hljs-built_in">get_extent</span>(),<br>                                         format,<br>                                         VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT,<br>                                         VMA_MEMORY_USAGE_GPU_ONLY,<br>                                         VK_SAMPLE_COUNT_1_BIT,<br>                                         <span class="hljs-built_in">to_u32</span>(mipmaps.<span class="hljs-built_in">size</span>()),<br>                                         layers,<br>                                         VK_IMAGE_TILING_OPTIMAL,<br>                                         flags);<br>vk_image-&gt;<span class="hljs-built_in">set_debug_name</span>(<span class="hljs-built_in">get_name</span>());<br><br>vk_image_view = std::<span class="hljs-built_in">make_unique</span>&lt;core::ImageView&gt;(*vk_image, image_view_type);<br>vk_image_view-&gt;<span class="hljs-built_in">set_debug_name</span>(<span class="hljs-string">&quot;View on &quot;</span> + <span class="hljs-built_in">get_name</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>然后代码将为该Image对象创建一个<code>Texture</code>结构体中，并一并保存到<i><font color="Orange">textures</font></i>向量中以构建完整的纹理数组。<code>Texture</code>结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Texture</span><br>&#123;<br>std::unique_ptr&lt;vkb::core::Image&gt;     image;<br>std::unique_ptr&lt;vkb::core::ImageView&gt; image_view;<br><span class="hljs-type">uint32_t</span>                              n_mip_maps;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可见我们需要填充构成该纹理的图像、视图和mipmap等级。程序中会验证所有的纹理mipmap等级都为1，然后使用一个stagingbuffer，将<i><font color="Orange">image</font></i>中的图像数据传递到<code>Texture</code>结构体的<i><font color="Orange">image</font></i>成员中（<code>vkb::sg::Image</code>类将构建该图像的数据信息保存在私有成员<i><font color="Orange">std::vector<uint_8>data</uint_8></font></i>中，通过<i><font color="Green">get_data</font></i>成员函数获取）。当然，在将stagingbuffer中的数据copy到纹理对象<i><font color="Orange">texture.image</font></i>之前，我们还需要对<i><font color="Orange">texture.image</font></i>进行图像布局的转换，因为图像刚创建的时候其布局是未定义的。关于布局转换有关的基础内容可以参考我之前的博客中对VulkanTutorial对应内容的<a href="https://zpc-dsg.github.io/2024/12/12/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F/"><code>翻译和理解</code></a>。为了进行布局的转换和数据的复制，我们需要启动一个commandbuffer来录制有关命令并提交给队列执行。这部分代码中的<i><font color="Green">image_layout_transition</font></i>和<i><font color="Green">copy_buffer_to_image</font></i>函数就是封装了对应的布局转换和复制数据过程，其中布局转换就是通过一个<code>VkImageMemoryBarrier</code>来实现，而数据复制则通过调用<code>VkCmdCopyBufferToImage</code>来完成。再录制好相关命令之后，只需提交到图形队列执行，然后在CPU端等待所有操作执行完毕即可。在创建好了图像之后图像视图也就直接在此基础上创建即可。</p><p>纹理对象创建完毕了，但为了使用纹理资源我们需要创建相应的描述符才行。于是代码在创建好<i><font color="Orange">texture</font></i>后马上填写该纹理对应的描述符信息，并且通过查询该纹理图像的格式来决定该纹理能否使用线性过滤的采样器。填写好的<code>VkDescriptorImageInfo</code>同样放进应用程序类的一个向量成员<i><font color="Orange">image_descriptors</font></i>中供后续真正创建和绑定描述符的时候使用。</p><p>在完成了对<code>mesh</code>的纹理的储存之后，还需要提取出每个<code>submesh</code>的顶点和索引信息，每个<code>submesh</code>的顶点和索引信息都会保存在<code>SceneModel</code>结构体中，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SceneModel</span><br>&#123;<br>std::vector&lt;Vertex&gt;                  vertices;<br>std::vector&lt;std::array&lt;<span class="hljs-type">uint16_t</span>, 3&gt;&gt; triangles;<br><span class="hljs-type">size_t</span>                               vertex_buffer_offset = <span class="hljs-number">0</span>;<br><span class="hljs-type">size_t</span>                               index_buffer_offset  = <span class="hljs-number">0</span>;<br><span class="hljs-type">size_t</span>                               texture_index        = <span class="hljs-number">0</span>;<br>BoundingSphere                       bounding_sphere;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看见，我们需要填写的信息包括顶点信息，顶点所构成的三角形的索引信息，顶点在最终构建的所有模型的顶点缓冲中的偏移以及索引的偏移，该<code>submesh</code>使用的纹理索引（后续像素着色器也就是通过这个值来索引纹理数组中的纹理）以及该<code>submesh</code>的包围球（用于视锥剔除），其中<code>Vertex</code>结构体和<code>BoundingSphere</code>结构体分别定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vertex</span><br>&#123;<br>glm::vec3 pt;<span class="hljs-comment">//位置向量</span><br>glm::vec2 uv;<span class="hljs-comment">//纹理坐标</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BoundingSphere</span><br>&#123;<br><span class="hljs-built_in">BoundingSphere</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">BoundingSphere</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;glm::vec3&gt; &amp;pts)</span></span>;<br>glm::vec3 center = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">float</span>     radius = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>来看代码对每个<code>submesh</code>对应的<code>SceneModel</code>的填写逻辑：首先是填写纹理索引，这就是当前<code>mesh</code>对应的索引。然后从<code>submesh</code>中提取出位置和纹理坐标信息，构成顶点后填入到<code>SceneModel</code>内。这个信息的提取过程是通过应用程序类附带的一个工具函数对象类<code>CopyBuffer</code>实现的，其代码也非常直观（其实就是一个简单的内存复制<code>memcpy</code>操作），放在下方：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CopyBuffer</span><br>&#123;<br><span class="hljs-function">std::vector&lt;T&gt; <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(std::unordered_map&lt;std::string, vkb::core::BufferC&gt; &amp;buffers, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *bufferName)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> iter = buffers.<span class="hljs-built_in">find</span>(bufferName);<br><span class="hljs-keyword">if</span> (iter == buffers.<span class="hljs-built_in">cend</span>())<br>&#123;<br><span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br><span class="hljs-keyword">auto</span>          &amp;buffer = iter-&gt;second;<br>std::vector&lt;T&gt; out;<br><br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> sz = buffer.<span class="hljs-built_in">get_size</span>();<br>out.<span class="hljs-built_in">resize</span>(sz / <span class="hljs-built_in">sizeof</span>(T));<br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> alreadyMapped = buffer.<span class="hljs-built_in">get_data</span>() != <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">if</span> (!alreadyMapped)<br>&#123;<br>buffer.<span class="hljs-built_in">map</span>();<br>&#125;<br><span class="hljs-built_in">memcpy</span>(&amp;out[<span class="hljs-number">0</span>], buffer.<span class="hljs-built_in">get_data</span>(), sz);<br><span class="hljs-keyword">if</span> (!alreadyMapped)<br>&#123;<br>buffer.<span class="hljs-built_in">unmap</span>();<br>&#125;<br><span class="hljs-keyword">return</span> out;<br>&#125;<br>&#125;;<br><br>&#125;        <span class="hljs-comment">// namespace</span><br></code></pre></td></tr></table></figure><p>然后再来处理三角形索引信息，这个逻辑也非常直观，这里不再赘述。最后根据该<code>submesh</code>的所有顶点位置创建相应的包围球，相应的创建逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">BoundingSphere</span>(<span class="hljs-type">const</span> std::vector&lt;glm::vec3&gt; &amp;pts)<br>&#123;<br><span class="hljs-keyword">if</span> (pts.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// This is a simple method of calculating a bounding sphere.</span><br><span class="hljs-comment">// For finding an optimal bounding sphere, see Welzl&#x27;s algorithm</span><br><span class="hljs-keyword">this</span>-&gt;center = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;pt : pts)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;center += pt;<br>&#125;<br><span class="hljs-keyword">this</span>-&gt;center /= <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(pts.<span class="hljs-built_in">size</span>());<br><span class="hljs-keyword">this</span>-&gt;radius = glm::<span class="hljs-built_in">distance2</span>(pts[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>-&gt;center);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">1</span>; i &lt; pts.<span class="hljs-built_in">size</span>(); ++i)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;radius = std::<span class="hljs-built_in">max</span>(<span class="hljs-keyword">this</span>-&gt;radius, glm::<span class="hljs-built_in">distance2</span>(pts[i], <span class="hljs-keyword">this</span>-&gt;center));<br>&#125;<br><span class="hljs-keyword">this</span>-&gt;radius = std::<span class="hljs-built_in">nextafter</span>(<span class="hljs-built_in">sqrtf</span>(<span class="hljs-keyword">this</span>-&gt;radius), std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">max</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>可见创建的过程其实就是取所有顶点的平均点（也可以说是它们的重心）为包围球的中心，半径就是该中心点到所有点的最远距离。这是一种简单的创建包围球的思路。这里解释一下<a href="https://en.cppreference.com/w/cpp/numeric/math/nextafter"><code>std::nextafter</code></a>，它的作用其实就是在浮点数之间找到下一个可表示的值。它通常用于数值计算中，以便在浮点数的精度范围内进行微小的增量调整。</p><p>在完成所有<code>mesh</code>信息的存储工作之后，最终我们还需要将所有之前创建的纹理对象的布局从之前的<i><font color="Red">VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</font></i>转换为<i><font color="Red">VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</font></i>以方便后续像素着色器对它们的读取。这样就完成了整个<i><font color="Green">load_scene</font></i>的工作。</p><h3 id="initialize_resources">initialize_resources</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::initialize_resources</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">size_t</span>       vertex_buffer_size = <span class="hljs-number">0</span>, index_buffer_size = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> model_buffer_size = models.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(SceneModel);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;model : models)<br>&#123;<br>model.vertex_buffer_offset = vertex_buffer_size;<br>model.index_buffer_offset  = index_buffer_size;<br><br>vertex_buffer_size += model.vertices.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(Vertex);<br>index_buffer_size += model.triangles.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(model.triangles[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-built_in">assert</span>(vertex_buffer_size &amp;&amp; index_buffer_size &amp;&amp; model_buffer_size);<br><span class="hljs-keyword">auto</span> staging_vertex_buffer = vkb::core::BufferC::<span class="hljs-built_in">create_staging_buffer</span>(<span class="hljs-built_in">get_device</span>(), vertex_buffer_size, <span class="hljs-literal">nullptr</span>);<br><span class="hljs-keyword">auto</span> staging_index_buffer  = vkb::core::BufferC::<span class="hljs-built_in">create_staging_buffer</span>(<span class="hljs-built_in">get_device</span>(), index_buffer_size, <span class="hljs-literal">nullptr</span>);<br><span class="hljs-keyword">auto</span> staging_model_buffer  = vkb::core::BufferC::<span class="hljs-built_in">create_staging_buffer</span>(<span class="hljs-built_in">get_device</span>(), model_buffer_size, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-comment">// We will store the GPU commands in the indirect call buffer</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> default_indirect_flags = VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;<br><span class="hljs-keyword">auto</span>           indirect_flags         = default_indirect_flags;<br><span class="hljs-keyword">if</span> (m_supports_buffer_device)<br>&#123;<br>indirect_flags |= VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;<br>&#125;<br>indirect_call_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), models.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(VkDrawIndexedIndirectCommand), indirect_flags, VMA_MEMORY_USAGE_GPU_ONLY, VMA_ALLOCATION_CREATE_MAPPED_BIT, queue_families);<br><br><span class="hljs-comment">// Create a buffer containing the addresses of the indirect calls.</span><br><span class="hljs-comment">// In this sample, the order of the addresses will match that of the other buffers, but in general they could be in any order</span><br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> address_buffer_size    = <span class="hljs-built_in">sizeof</span>(VkDeviceAddress);<br><span class="hljs-keyword">auto</span>         staging_address_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), address_buffer_size, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VMA_MEMORY_USAGE_CPU_TO_GPU);<br><span class="hljs-keyword">if</span> (m_supports_buffer_device)<br>&#123;<br><span class="hljs-keyword">auto</span> *destPtr = (<span class="hljs-type">uint64_t</span> *) staging_address_buffer-&gt;<span class="hljs-built_in">get_data</span>();<br><br>VkBufferDeviceAddressInfoKHR address_info&#123;VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR&#125;;<br>address_info.buffer    = indirect_call_buffer-&gt;<span class="hljs-built_in">get_handle</span>();<br>VkDeviceAddress srcPtr = <span class="hljs-built_in">vkGetBufferDeviceAddressKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;address_info);<br><br>*destPtr = srcPtr;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; models.<span class="hljs-built_in">size</span>(); ++i)<br>&#123;<br><span class="hljs-keyword">auto</span> &amp;model = models[i];<br>staging_vertex_buffer.<span class="hljs-built_in">update</span>(model.vertices.<span class="hljs-built_in">data</span>(), model.vertices.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(Vertex), model.vertex_buffer_offset);<br>staging_index_buffer.<span class="hljs-built_in">update</span>(model.triangles.<span class="hljs-built_in">data</span>(), model.triangles.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(model.triangles[<span class="hljs-number">0</span>]), model.index_buffer_offset);<br><br>GpuModelInformation model_information;<br>model_information.bounding_sphere_center = model.bounding_sphere.center;<br>model_information.bounding_sphere_radius = model.bounding_sphere.radius;<br>model_information.texture_index          = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(model.texture_index);<br>model_information.firstIndex             = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(model.index_buffer_offset / (<span class="hljs-built_in">sizeof</span>(model.triangles[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])));<br>model_information.indexCount             = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(model.triangles.<span class="hljs-built_in">size</span>());<br>staging_model_buffer.<span class="hljs-built_in">update</span>(&amp;model_information, <span class="hljs-built_in">sizeof</span>(GpuModelInformation), i * <span class="hljs-built_in">sizeof</span>(GpuModelInformation));<br>&#125;<br><br>staging_vertex_buffer.<span class="hljs-built_in">flush</span>();<br>staging_index_buffer.<span class="hljs-built_in">flush</span>();<br>staging_model_buffer.<span class="hljs-built_in">flush</span>();<br><br><span class="hljs-keyword">auto</span> &amp;cmd = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">request_command_buffer</span>();<br>cmd.<span class="hljs-built_in">begin</span>(VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, VK_NULL_HANDLE);<br><span class="hljs-keyword">auto</span> copy = [<span class="hljs-keyword">this</span>, &amp;cmd](vkb::core::BufferC &amp;staging_buffer, VkBufferUsageFlags buffer_usage_flags) &#123;<br><span class="hljs-keyword">auto</span> output_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), staging_buffer.<span class="hljs-built_in">get_size</span>(), buffer_usage_flags | VK_BUFFER_USAGE_TRANSFER_DST_BIT, VMA_MEMORY_USAGE_GPU_ONLY, VMA_ALLOCATION_CREATE_MAPPED_BIT, queue_families);<br>cmd.<span class="hljs-built_in">copy_buffer</span>(staging_buffer, *output_buffer, staging_buffer.<span class="hljs-built_in">get_size</span>());<br><br>vkb::BufferMemoryBarrier barrier;<br>barrier.src_stage_mask  = VK_PIPELINE_STAGE_TRANSFER_BIT;<br>barrier.dst_stage_mask  = VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT;<br>barrier.src_access_mask = VK_ACCESS_TRANSFER_WRITE_BIT;<br>barrier.dst_access_mask = VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_SHADER_WRITE_BIT;<br>cmd.<span class="hljs-built_in">buffer_memory_barrier</span>(*output_buffer, <span class="hljs-number">0</span>, VK_WHOLE_SIZE, barrier);<br><span class="hljs-keyword">return</span> output_buffer;<br>&#125;;<br>vertex_buffer            = <span class="hljs-built_in">copy</span>(staging_vertex_buffer, VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_STORAGE_BUFFER_BIT);<br>index_buffer             = <span class="hljs-built_in">copy</span>(staging_index_buffer, VK_BUFFER_USAGE_INDEX_BUFFER_BIT);<br>model_information_buffer = <span class="hljs-built_in">copy</span>(staging_model_buffer, VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT);<br><span class="hljs-keyword">if</span> (m_supports_buffer_device)<br>&#123;<br><span class="hljs-comment">// In this sample, we use a staging buffer for the device address buffer (i.e. for device exclusive memory).</span><br><span class="hljs-comment">// However, since the size of each element (sizeof(uint64_t)) is smaller than the objects it&#x27;s pointing to, it could instead use host-visible memory</span><br><span class="hljs-comment">// for fast referencing of the underlying data</span><br>device_address_buffer = <span class="hljs-built_in">copy</span>(*staging_address_buffer, VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT);<br>&#125;<br><br>cmd.<span class="hljs-built_in">end</span>();<br><span class="hljs-keyword">auto</span> &amp;queue = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_by_flags</span>(VK_QUEUE_GRAPHICS_BIT, <span class="hljs-number">0</span>);<br>queue.<span class="hljs-built_in">submit</span>(cmd, <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">request_fence</span>());<br><span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_fence_pool</span>().<span class="hljs-built_in">wait</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数的所完成的工作就是创建好所有之后的计算或者渲染阶段需要使用到的缓冲区。</p><p>要创建缓冲区，首先当然需要知道想要创建的缓冲区大小。我们希望创建一个包含了所有模型的顶点缓冲区和对应的索引缓冲区，包含所有绘制命令的间接绘制缓冲区以及会用作实例缓冲区和CS使用的SSBO的模型数据缓冲区。因此函数开头首先使用一个循环遍历之前保存的所有<code>SceneModel</code>，将每个<code>SceneModel</code>之前没有填写的顶点和索引偏移信息填写进去（偏移就是排在该<code>SceneModel</code>之前的所有顶点数和索引数之和），同时通过累加获取需要创建的大顶点缓冲区和索引缓冲区的大小。因为顶点、索引和模型数据在初始化之后就不再改变了，我们当然希望这些缓冲区都是devicelocal的，因此需要首先创建相应的staging buffer，将数据先传递到stagingbuffer中，再复制到真正的缓冲区中。</p><p>绘制调用的参数虽说会改变，但是程序仍然将绘制参数缓冲区存放在devicelocal的内存区域中，该缓冲区的初始化逻辑在<i><font color="Green">cpu_cull</font></i>函数中执行，后续我们会讲到，在<i><font color="Green">initialize_resources</font></i>函数中只是将这个缓冲区创建好，并没有填写所需的数据。需要注意的是这个缓冲区的用途设置，它被设置为<i><font color="Red">VK_BUFFER_USAGE_TRANSFER_SRC_BIT| VK_BUFFER_USAGE_STORAGE_BUFFER_BIT |VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT |VK_BUFFER_USAGE_TRANSFER_DST_BIT</font></i>的一个位组合，如果硬件还支持deviceaddress的话那么该缓冲区还应该具有<i><font color="Red">VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</font></i>的作用，后续在分析着色器的时候会看到如果该缓冲区设置了这个标志位，那么计算着色器可以直接读取这个缓冲区的地址来对缓冲区内的数据进行访问而无需绑定该缓冲区。不过为了访问绘制参数缓冲区的地址，仍需创建一个用于存储该地址的addressbuffer，通过<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferDeviceAddress.html"><code>vkGetBufferDeviceAddress</code></a>获取绘制参数缓冲区的地址然后传递给stagingbuffer，再将staging buffer中的数据复制到addressbuffer中供计算着色器使用即可。这个copy操作会在后续通过一个lambda表达式和顶点、索引、模型缓冲区一并进行。</p><p>接下来函数首先将顶点、索引以及所有模型信息的数据上传到它们对应的stagingbuffer中去，然后将stagingbuffer中的数据copy到真正使用的缓冲区中。这部分没什么好说的，就是录制复制相关的命令然后提交给图形队列执行，在CPU端等待执行结束即可。同样，模型信息缓冲区也需要上传相应的数据，其中存储的会是<code>GpuModelInformation</code>数组，该结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GpuModelInformation</span><br>&#123;<br>glm::vec3 bounding_sphere_center;<br><span class="hljs-type">float</span>     bounding_sphere_radius;<br><span class="hljs-type">uint32_t</span>  texture_index = <span class="hljs-number">0</span>;<br><span class="hljs-type">uint32_t</span>  firstIndex    = <span class="hljs-number">0</span>;<br><span class="hljs-type">uint32_t</span>  indexCount    = <span class="hljs-number">0</span>;<br><span class="hljs-type">uint32_t</span>  _pad          = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个结构体最后多出一个占位用的<i><font color="Orange">_pad</font></i>，这是为了满足Vulkan的内存对齐需求。因为在glsl中一个<strong>vec3</strong>向量实际要求的内存对齐必须和<strong>vec4</strong>一致，也就是16字节，如果最后没有这个<i><font color="Orange">_pad</font></i>的话，缓冲区中的<code>GpuModelInformation</code>数组中相邻两个结构体之间就会有一个字节空隙，但是代码中在将数据上传到stagingbuffer的时候是直接通过c++结构体大小来计算更新位置的偏移的，这就很可能会导致上传数据的大小超出了缓冲区的实际大小或者数据错位。关于数据对齐部分的内容同样可以参考我之前对VulkanTutorial相关部分的<a href="https://zpc-dsg.github.io/2024/12/06/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B1%A0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86/"><code>翻译</code></a>，更详细的说明可以直接参考<a href="https://docs.vulkan.org/spec/latest/chapters/interfaces.html#interfaces-resources-layout"><code>官方说明文档</code></a>。</p><p>回到模型信息缓冲区的数据上传，整体逻辑上大体没啥问题，但是让我有些不理解的地方在于代码将模型信息的<i><font color="Orange">indexCount</font></i>成员设置为模型的三角形数量，为什么不需要乘以一个3呢？不过似乎这个地方并不影响后续的程序运行，因为这个成员好像压根就没用上。。。</p><h3 id="update_scene_uniform">update_scene_uniform</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!scene_uniform_buffer)<br>&#123;<br>scene_uniform_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<br>    <span class="hljs-built_in">get_device</span>(), <span class="hljs-built_in">sizeof</span>(SceneUniform), VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, VMA_MEMORY_USAGE_CPU_TO_GPU, VMA_ALLOCATION_CREATE_MAPPED_BIT, queue_families);<br>&#125;<br>scene_uniform.proj        = camera.matrices.perspective;<br>scene_uniform.view        = camera.matrices.view;<br>scene_uniform.proj_view   = scene_uniform.proj * scene_uniform.view;<br>scene_uniform.model_count = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(models.<span class="hljs-built_in">size</span>());<br><br>scene_uniform_buffer-&gt;<span class="hljs-built_in">update</span>(&amp;scene_uniform, <span class="hljs-built_in">sizeof</span>(scene_uniform), <span class="hljs-number">0</span>);<br><br>scene_uniform_buffer-&gt;<span class="hljs-built_in">flush</span>();<br></code></pre></td></tr></table></figure><p>这个逻辑就相当简单了，无非是负责创建并更新场景缓冲区，包括投影矩阵、视图矩阵、模型数信息。</p><h3 id="create_pipeline">create_pipeline</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::create_pipeline</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::vector&lt;VkDescriptorPoolSize&gt; pool_sizes = &#123;<br>    &#123;VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, <span class="hljs-number">6</span>&#125;,<br>    &#123;VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="hljs-number">1</span> * <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(textures.<span class="hljs-built_in">size</span>())&#125;,<br>    &#123;VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">6</span>&#125;&#125;;<br>VkDescriptorPoolCreateInfo descriptor_pool_create_info = vkb::initializers::<span class="hljs-built_in">descriptor_pool_create_info</span>(pool_sizes, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorPool</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_pool_create_info, <span class="hljs-literal">nullptr</span>, &amp;descriptor_pool));<br><br><span class="hljs-comment">// The model information will be used to index textures in the fragment shader,</span><br><span class="hljs-comment">// as well as perform frustum culling in the compute shader</span><br>VkDescriptorSetLayoutBinding model_information_binding&#123;&#125;;<br>model_information_binding.binding         = <span class="hljs-number">0</span>;<br>model_information_binding.descriptorType  = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;<br>model_information_binding.descriptorCount = <span class="hljs-number">1</span>;<br>model_information_binding.stageFlags      = VK_SHADER_STAGE_COMPUTE_BIT;<br><br><span class="hljs-comment">// This array of textures will be accessed via the instance ID</span><br>VkDescriptorSetLayoutBinding image_array_binding&#123;&#125;;<br>image_array_binding.binding         = <span class="hljs-number">1</span>;<br>image_array_binding.descriptorType  = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;<br>image_array_binding.descriptorCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(textures.<span class="hljs-built_in">size</span>());<br>image_array_binding.stageFlags      = VK_SHADER_STAGE_FRAGMENT_BIT;<br><br>VkDescriptorSetLayoutBinding scene_uniform_binding&#123;&#125;;<br>scene_uniform_binding.binding         = <span class="hljs-number">2</span>;<br>scene_uniform_binding.descriptorType  = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;<br>scene_uniform_binding.descriptorCount = <span class="hljs-number">1</span>;<br>scene_uniform_binding.stageFlags      = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT | VK_SHADER_STAGE_COMPUTE_BIT;<br><br>VkDescriptorSetLayoutBinding command_buffer_binding&#123;&#125;;<br>command_buffer_binding.binding         = <span class="hljs-number">3</span>;<br>command_buffer_binding.descriptorType  = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;<br>command_buffer_binding.descriptorCount = <span class="hljs-number">1</span>;<br>command_buffer_binding.stageFlags      = VK_SHADER_STAGE_COMPUTE_BIT;<br><br><span class="hljs-comment">// Create descriptors</span><br><span class="hljs-keyword">auto</span> create_descriptors = [<span class="hljs-keyword">this</span>](<span class="hljs-type">const</span> std::vector&lt;VkDescriptorSetLayoutBinding&gt; &amp;set_layout_bindings, VkDescriptorSetLayout &amp;_descriptor_set_layout, VkPipelineLayout &amp;_pipeline_layout) &#123;<br>VkDescriptorSetLayoutCreateInfo descriptor_layout = vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_create_info</span>(set_layout_bindings.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(set_layout_bindings.<span class="hljs-built_in">size</span>()));<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorSetLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_layout, <span class="hljs-literal">nullptr</span>, &amp;_descriptor_set_layout));<br><br>VkPipelineLayoutCreateInfo pipeline_layout_create_info =<br>    vkb::initializers::<span class="hljs-built_in">pipeline_layout_create_info</span>(<br>        &amp;_descriptor_set_layout,<br>        <span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreatePipelineLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;pipeline_layout_create_info, <span class="hljs-literal">nullptr</span>, &amp;_pipeline_layout));<br>&#125;;<br><br><span class="hljs-comment">// Render pipeline</span><br>std::vector&lt;VkDescriptorSetLayoutBinding&gt; set_layout_bindings = &#123;model_information_binding, image_array_binding, scene_uniform_binding, command_buffer_binding&#125;;<br><span class="hljs-built_in">create_descriptors</span>(set_layout_bindings, descriptor_set_layout, pipeline_layout);<br><br><span class="hljs-comment">// Compute pipeline</span><br><span class="hljs-comment">// Note we don&#x27;t include the texture array</span><br>std::vector&lt;VkDescriptorSetLayoutBinding&gt; gpu_compute_set_layout_bindings = &#123;model_information_binding, scene_uniform_binding, command_buffer_binding&#125;;<br><span class="hljs-built_in">create_descriptors</span>(gpu_compute_set_layout_bindings, gpu_cull_descriptor_set_layout, gpu_cull_pipeline_layout);<br><br><span class="hljs-comment">// Device address pipeline</span><br><span class="hljs-comment">// Note that we don&#x27;t bind the command buffer directly; instead, we use the references from the device addresses</span><br><span class="hljs-comment">// This will be used in the device address shader (cull_address.comp)</span><br><span class="hljs-keyword">if</span> (m_supports_buffer_device)<br>&#123;<br>VkDescriptorSetLayoutBinding device_address_binding&#123;&#125;;<br>device_address_binding.binding                                           = <span class="hljs-number">4</span>;<br>device_address_binding.descriptorType                                    = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;<br>device_address_binding.descriptorCount                                   = <span class="hljs-number">1</span>;<br>device_address_binding.stageFlags                                        = VK_SHADER_STAGE_COMPUTE_BIT;<br>std::vector&lt;VkDescriptorSetLayoutBinding&gt; device_address_layout_bindings = &#123;model_information_binding, scene_uniform_binding, device_address_binding&#125;;<br><span class="hljs-built_in">create_descriptors</span>(device_address_layout_bindings, device_address_descriptor_set_layout, device_address_pipeline_layout);<br>&#125;<br><br>VkPipelineInputAssemblyStateCreateInfo input_assembly_state = vkb::initializers::<span class="hljs-built_in">pipeline_input_assembly_state_create_info</span>(VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, <span class="hljs-number">0</span>, VK_FALSE);<br><br>VkPipelineRasterizationStateCreateInfo rasterization_state = vkb::initializers::<span class="hljs-built_in">pipeline_rasterization_state_create_info</span>(VK_POLYGON_MODE_FILL, VK_CULL_MODE_BACK_BIT, VK_FRONT_FACE_COUNTER_CLOCKWISE, <span class="hljs-number">0</span>);<br><br>VkPipelineColorBlendAttachmentState blend_attachment_state = vkb::initializers::<span class="hljs-built_in">pipeline_color_blend_attachment_state</span>(<span class="hljs-number">0xf</span>, VK_FALSE);<br><br>VkPipelineColorBlendStateCreateInfo color_blend_state = vkb::initializers::<span class="hljs-built_in">pipeline_color_blend_state_create_info</span>(<span class="hljs-number">1</span>, &amp;blend_attachment_state);<br><br>VkPipelineDepthStencilStateCreateInfo depth_stencil_state = vkb::initializers::<span class="hljs-built_in">pipeline_depth_stencil_state_create_info</span>(VK_TRUE, VK_TRUE, VK_COMPARE_OP_LESS);<br>depth_stencil_state.depthBoundsTestEnable                 = VK_FALSE;<br>depth_stencil_state.minDepthBounds                        = <span class="hljs-number">0.f</span>;<br>depth_stencil_state.maxDepthBounds                        = <span class="hljs-number">1.f</span>;<br><br>VkPipelineViewportStateCreateInfo viewport_state = vkb::initializers::<span class="hljs-built_in">pipeline_viewport_state_create_info</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><br>std::vector&lt;VkDynamicState&gt; dynamic_state_enables = &#123;<br>    VK_DYNAMIC_STATE_VIEWPORT,<br>    VK_DYNAMIC_STATE_SCISSOR&#125;;<br>VkPipelineDynamicStateCreateInfo dynamic_state =<br>    vkb::initializers::<span class="hljs-built_in">pipeline_dynamic_state_create_info</span>(<br>        dynamic_state_enables.<span class="hljs-built_in">data</span>(),<br>        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(dynamic_state_enables.<span class="hljs-built_in">size</span>()),<br>        <span class="hljs-number">0</span>);<br><br>VkPipelineMultisampleStateCreateInfo multisample_state = vkb::initializers::<span class="hljs-built_in">pipeline_multisample_state_create_info</span>(VK_SAMPLE_COUNT_1_BIT, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// Vertex bindings and attributes</span><br><span class="hljs-type">const</span> std::vector&lt;VkVertexInputBindingDescription&gt; vertex_input_bindings = &#123;<br>    vkb::initializers::<span class="hljs-built_in">vertex_input_binding_description</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Vertex), VK_VERTEX_INPUT_RATE_VERTEX),<br>    vkb::initializers::<span class="hljs-built_in">vertex_input_binding_description</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">sizeof</span>(GpuModelInformation), VK_VERTEX_INPUT_RATE_INSTANCE),<br>&#125;;<br><span class="hljs-type">const</span> std::vector&lt;VkVertexInputAttributeDescription&gt; vertex_input_attributes = &#123;<br>    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, VK_FORMAT_R32G32B32_SFLOAT, <span class="hljs-built_in">offsetof</span>(Vertex, pt)),<br>    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, VK_FORMAT_R32G32_SFLOAT, <span class="hljs-built_in">offsetof</span>(Vertex, uv)),<br>    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, VK_FORMAT_R32G32B32_SFLOAT, <span class="hljs-built_in">offsetof</span>(GpuModelInformation, bounding_sphere_center)),<br>    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, VK_FORMAT_R32_SFLOAT, <span class="hljs-built_in">offsetof</span>(GpuModelInformation, bounding_sphere_radius)),<br>    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, VK_FORMAT_R32_UINT, <span class="hljs-built_in">offsetof</span>(GpuModelInformation, texture_index)),<br>&#125;;<br>VkPipelineVertexInputStateCreateInfo vertex_input_state = vkb::initializers::<span class="hljs-built_in">pipeline_vertex_input_state_create_info</span>();<br>vertex_input_state.vertexBindingDescriptionCount        = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertex_input_bindings.<span class="hljs-built_in">size</span>());<br>vertex_input_state.pVertexBindingDescriptions           = vertex_input_bindings.<span class="hljs-built_in">data</span>();<br>vertex_input_state.vertexAttributeDescriptionCount      = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertex_input_attributes.<span class="hljs-built_in">size</span>());<br>vertex_input_state.pVertexAttributeDescriptions         = vertex_input_attributes.<span class="hljs-built_in">data</span>();<br><br>VkGraphicsPipelineCreateInfo pipeline_create_info = vkb::initializers::<span class="hljs-built_in">pipeline_create_info</span>(pipeline_layout, render_pass, <span class="hljs-number">0</span>);<br>pipeline_create_info.pVertexInputState            = &amp;vertex_input_state;<br>pipeline_create_info.pInputAssemblyState          = &amp;input_assembly_state;<br>pipeline_create_info.pRasterizationState          = &amp;rasterization_state;<br>pipeline_create_info.pColorBlendState             = &amp;color_blend_state;<br>pipeline_create_info.pMultisampleState            = &amp;multisample_state;<br>pipeline_create_info.pViewportState               = &amp;viewport_state;<br>pipeline_create_info.pDepthStencilState           = &amp;depth_stencil_state;<br>pipeline_create_info.pDynamicState                = &amp;dynamic_state;<br><br><span class="hljs-type">const</span> std::array&lt;VkPipelineShaderStageCreateInfo, 2&gt; shader_stages = &#123;<br>    <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;multi_draw_indirect/multi_draw_indirect.vert&quot;</span>, VK_SHADER_STAGE_VERTEX_BIT),<br>    <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;multi_draw_indirect/multi_draw_indirect.frag&quot;</span>, VK_SHADER_STAGE_FRAGMENT_BIT)&#125;;<br><br>pipeline_create_info.stageCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(shader_stages.<span class="hljs-built_in">size</span>());<br>pipeline_create_info.pStages    = shader_stages.<span class="hljs-built_in">data</span>();<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateGraphicsPipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;pipeline));<br>&#125;<br></code></pre></td></tr></table></figure><p>看着是真挺吓人的，不过大多都是已经司空见惯的操作罢了（没办法，Vulkan创建管线就是这么麻烦，不写这么多也不行。。。），我们快速地浏览一下对应的逻辑：</p><p>函数首先创建了用于分配缓冲区、SSBO、组合图像采样器描述符集的描述符池，然后开始填写创建<code>pipeline layout</code>所需的<code>descriptor set layout</code>信息，而填写<code>descriptor set layout</code>有需要填写该描述符集绑定的所有描述符的类型、绑定点、数量、绑定阶段等信息。这一部分本身涉及到Vulkan的资源绑定原理，确实是比较绕的，这部分推荐一下在知乎上看到的<a href="https://zhuanlan.zhihu.com/p/616099137?utm_psn=1877761418515861505"><code>大佬的文章</code></a>，个人感觉看完后也是对于这一部分的理解清晰和系统化了不少，可谓受益良多。</p><p>事实上应用程序类中保存了三个PSO，分别为<i><font color="Orange">pipeline</font></i>，<i><font color="Orange">gpu_cull_pipeline</font></i>和<i><font color="Orange">device_address_pipeline</font></i>，它们各自当然具有不同的描述符绑定状态。<i><font color="Orange">pipeline</font></i>就是图形管线对象，它需要绑定的描述符有场景缓冲区、模型信息缓冲区、组合采样器以及绘制参数缓冲区，另外注意组合采样器的绑定，它是在一个绑定点指定绑定了所有的纹理，所以最后在片段着色器中会用到一个纹理的数组；<i><font color="Orange">gpu_cull_pipeline</font></i>是GPU视锥剔除管线对象，它所需要使用的描述符有场景缓冲区、模型信息缓冲区以及绘制参数缓冲区；最后是<i><font color="Orange">device_address_pipeline</font></i>对象，如果硬件支持deviceaddress，并且用户设置应用程序的剔除模式为<i><font color="Red">GPU_DEVICE_ADDRESS</font></i>，那么程序就会使用该管线来进行GPU上的视锥剔除。它使用到的描述符则是将<i><font color="Orange">gpu_cull_pipeline</font></i>使用的绘制参数缓冲区换成了设备地址缓冲区，也就是用于保存绘制参数缓冲区地址的缓冲区。事实上，该示例提供了三种视锥剔除模式供用户选择：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">RenderMode</span><br>&#123;<br>CPU,<br>GPU,<br>GPU_DEVICE_ADDRESS<br>&#125; render_mode = GPU;<br></code></pre></td></tr></table></figure><p>默认的模式是普通的GPU剔除。</p><p>接下来的一系列渲染管线的固定管线阶段设置都是常规操作，这里不再赘述，不熟悉的读者可以参考我的博客上之前的<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/"><code>系列文章</code></a>。</p><p>接下来就是指定顶点输入布局了。顶点输入槽0将会绑定模型顶点信息，包括了位置和纹理坐标属性；输入槽1则会绑定实例缓冲，也就是存储模型信息的缓冲，注意此时要将<code>VkVertexInputRate</code>设置为<i><font color="Red">VK_VERTEX_INPUT_RATE_INSTANCE</font></i>以表明这是一个逐实例属性，另外可以发现我们在顶点属性中只用到了<code>GpuModelInformation</code>的包围球球心、包围球半径以及纹理索引三个成员。</p><p>在创建管线对象的最后，程序指定了图形管线使用到的顶点和像素着色器。两个着色器的代码都十分简单易懂：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//vertex shader</span><br><br><span class="hljs-meta">#version 460</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> position;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> uv;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> sphere_center;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">float</span> sphere_radius;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">4</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">uint</span> texture_index;<br><br><span class="hljs-keyword">layout</span>(set = <span class="hljs-number">0</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">uniform</span> GlobalUniform<br>&#123;<br><span class="hljs-type">mat4</span> view;<br><span class="hljs-type">mat4</span> proj;<br><span class="hljs-type">mat4</span> proj_view;<br><span class="hljs-type">uint</span> model_count;<br>&#125;<br>global_uniform;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> o_uv;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">uint</span> o_texture_index;<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>)<br>&#123;<br>o_uv            = uv;<br><span class="hljs-built_in">gl_Position</span>     = global_uniform.proj * global_uniform.view * <span class="hljs-type">vec4</span>(position, <span class="hljs-number">1.0</span>);<br>o_texture_index = texture_index;<br>&#125;<br><br><span class="hljs-comment">//fragment shader</span><br><br><span class="hljs-meta">#version 460</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> in_uv;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">flat</span> <span class="hljs-keyword">in</span> <span class="hljs-type">uint</span> in_texture_index;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> o_color;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>, set = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> textures[<span class="hljs-number">225</span>];<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>)<br>&#123;<br>o_color = <span class="hljs-type">vec4</span>(<span class="hljs-built_in">texture</span>(textures[<span class="hljs-type">uint</span>(<span class="hljs-built_in">round</span>(in_texture_index))], in_uv));<br>o_color.rgb *= <span class="hljs-number">1.5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到事实上代码中也没有用到包围球的半径和中心，那为啥还要上传这两个顶点属性？为了之后代码的拓展性吗？不是很懂。。。</p><h3 id="create_compute_pipeline">create_compute_pipeline</h3><p>同样上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::create_compute_pipeline</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> create = [<span class="hljs-keyword">this</span>](VkPipelineLayout &amp;layout, VkPipeline &amp;_pipeline, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename) &#123;<br>VkComputePipelineCreateInfo compute_create_info = vkb::initializers::<span class="hljs-built_in">compute_pipeline_create_info</span>(layout, <span class="hljs-number">0</span>);<br>compute_create_info.stage                       = <span class="hljs-built_in">load_shader</span>(filename, VK_SHADER_STAGE_COMPUTE_BIT);<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateComputePipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;compute_create_info, <span class="hljs-literal">nullptr</span>, &amp;_pipeline));<br>&#125;;<br><br><span class="hljs-built_in">create</span>(gpu_cull_pipeline_layout, gpu_cull_pipeline, <span class="hljs-string">&quot;multi_draw_indirect/cull.comp&quot;</span>);<br><br><span class="hljs-keyword">if</span> (m_supports_buffer_device)<br>&#123;<br><span class="hljs-built_in">create</span>(device_address_pipeline_layout, device_address_pipeline, <span class="hljs-string">&quot;multi_draw_indirect/cull_address.comp&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>没什么好说的，就是创建两个用于视锥剔除的计算管线。主要看一下这两个管线用到的CS：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//cull.comp</span><br><br><span class="hljs-meta">#version 460</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">local_size_x</span> = <span class="hljs-number">64</span>) <span class="hljs-keyword">in</span>;<br><br>struct ModelInformation<br>&#123;<br><span class="hljs-type">float</span> x;<br><span class="hljs-type">float</span> y;<br><span class="hljs-type">float</span> z;<br><span class="hljs-type">float</span> r;<br><span class="hljs-type">uint</span>  texture_index;<br><span class="hljs-type">uint</span>  firstIndex;<br><span class="hljs-type">uint</span>  indexCount;<br><span class="hljs-type">uint</span>  _pad;<br>&#125;;<br><br>struct VkDrawIndexedIndirectCommand<br>&#123;<br><span class="hljs-type">uint</span> indexCount;<br><span class="hljs-type">uint</span> instanceCount;<br><span class="hljs-type">uint</span> firstIndex;<br><span class="hljs-type">int</span>  vertexOffset;<br><span class="hljs-type">uint</span> firstInstance;<br>&#125;;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">std430</span>, set = <span class="hljs-number">0</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">buffer</span> <span class="hljs-keyword">readonly</span> ModelInformationBuffer<br>&#123;<br>ModelInformation arr[];<br>&#125;<br>model_buffer;<br><br><span class="hljs-keyword">layout</span>(set = <span class="hljs-number">0</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">uniform</span> GlobalUniform<br>&#123;<br><span class="hljs-type">mat4</span> view;<br><span class="hljs-type">mat4</span> proj;<br><span class="hljs-type">mat4</span> proj_view;<br><span class="hljs-type">uint</span> model_count;<br>&#125;<br>global_uniform;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">std430</span>, set = <span class="hljs-number">0</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">buffer</span> <span class="hljs-keyword">writeonly</span> CommandBuffer<br>&#123;<br>VkDrawIndexedIndirectCommand commands[];<br>&#125;<br>command_buffer;<br><br><span class="hljs-comment">// See &quot;VisibilityTester&quot; in the C++ code for explanation</span><br><span class="hljs-type">bool</span> check_is_visible(<span class="hljs-type">mat4</span> mat, <span class="hljs-type">vec3</span> origin, <span class="hljs-type">float</span> radius)<br>&#123;<br><span class="hljs-type">uint</span> plane_index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; ++j, ++plane_index)<br>&#123;<br><span class="hljs-keyword">if</span> (plane_index == <span class="hljs-number">2</span> || plane_index == <span class="hljs-number">3</span>)<br>&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-type">float</span> <span class="hljs-built_in">sign</span>  = (j &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1.</span>f : <span class="hljs-number">-1.</span>f;<br><span class="hljs-type">vec4</span>        plane = <span class="hljs-type">vec4</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; ++k)<br>&#123;<br>plane[k] = mat[k][<span class="hljs-number">3</span>] + <span class="hljs-built_in">sign</span> * mat[k][i];<br>&#125;<br>plane.xyzw /= <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">dot</span>(plane.xyz, plane.xyz));<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">dot</span>(origin, plane.xyz) + plane.w + radius &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br><span class="hljs-type">uint</span> id = <span class="hljs-built_in">gl_GlobalInvocationID</span>.x;<br><span class="hljs-keyword">if</span> (id &gt;= global_uniform.model_count)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>ModelInformation model                    = model_buffer.arr[id];<br><span class="hljs-type">bool</span>             is_visible               = check_is_visible(global_uniform.proj_view, <span class="hljs-type">vec3</span>(model.x, model.y, model.z), model.r);<br>command_buffer.commands[id].instanceCount = is_visible ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//cull_address.comp</span><br><br><span class="hljs-meta">#version 460</span><br><br><span class="hljs-meta">#extension GL_EXT_buffer_reference : require</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">local_size_x</span> = <span class="hljs-number">64</span>) <span class="hljs-keyword">in</span>;<br><br>struct ModelInformation<br>&#123;<br><span class="hljs-type">float</span> x;<br><span class="hljs-type">float</span> y;<br><span class="hljs-type">float</span> z;<br><span class="hljs-type">float</span> r;<br><span class="hljs-type">uint</span>  texture_index;<br><span class="hljs-type">uint</span>  firstIndex;<br><span class="hljs-type">uint</span>  indexCount;<br><span class="hljs-type">uint</span>  _pad;<br>&#125;;<br><br>struct VkDrawIndexedIndirectCommand<br>&#123;<br><span class="hljs-type">uint</span> indexCount;<br><span class="hljs-type">uint</span> instanceCount;<br><span class="hljs-type">uint</span> firstIndex;<br><span class="hljs-type">int</span>  vertexOffset;<br><span class="hljs-type">uint</span> firstInstance;<br>&#125;;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">std430</span>, set = <span class="hljs-number">0</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">buffer</span> <span class="hljs-keyword">readonly</span> ModelInformationBuffer<br>&#123;<br>ModelInformation arr[];<br>&#125;<br>model_buffer;<br><br><span class="hljs-keyword">layout</span>(set = <span class="hljs-number">0</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">uniform</span> GlobalUniform<br>&#123;<br><span class="hljs-type">mat4</span> view;<br><span class="hljs-type">mat4</span> proj;<br><span class="hljs-type">mat4</span> proj_view;<br><span class="hljs-type">uint</span> model_count;<br>&#125;<br>global_uniform;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">std430</span>, buffer_reference) <span class="hljs-keyword">buffer</span> CommandBuffer<br>&#123;<br>VkDrawIndexedIndirectCommand commands[];<br>&#125;<br>command_buffer;<br><br><span class="hljs-keyword">layout</span>(set = <span class="hljs-number">0</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">4</span>) <span class="hljs-keyword">buffer</span> Addresses<br>&#123;<br>CommandBuffer command_buffer;<br>&#125;<br>addresses;<br><br><span class="hljs-comment">// See &quot;VisibilityTester&quot; in the C++ code for explanation</span><br><span class="hljs-type">bool</span> check_is_visible(<span class="hljs-type">mat4</span> mat, <span class="hljs-type">vec3</span> origin, <span class="hljs-type">float</span> radius)<br>&#123;<br><span class="hljs-type">uint</span> plane_index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; ++j, ++plane_index)<br>&#123;<br><span class="hljs-keyword">if</span> (plane_index == <span class="hljs-number">2</span> || plane_index == <span class="hljs-number">3</span>)<br>&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-type">float</span> <span class="hljs-built_in">sign</span>  = (j &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1.</span>f : <span class="hljs-number">-1.</span>f;<br><span class="hljs-type">vec4</span>        plane = <span class="hljs-type">vec4</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; ++k)<br>&#123;<br>plane[k] = mat[k][<span class="hljs-number">3</span>] + <span class="hljs-built_in">sign</span> * mat[k][i];<br>&#125;<br>plane.xyzw /= <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">dot</span>(plane.xyz, plane.xyz));<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">dot</span>(origin, plane.xyz) + plane.w + radius &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br><span class="hljs-type">uint</span>             id         = <span class="hljs-built_in">gl_GlobalInvocationID</span>.x;<br><span class="hljs-keyword">if</span> (id &gt;= global_uniform.model_count)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>ModelInformation model      = model_buffer.arr[id];<br><span class="hljs-type">bool</span>             is_visible = check_is_visible(global_uniform.proj_view, <span class="hljs-type">vec3</span>(model.x, model.y, model.z), model.r);<br><br>addresses.command_buffer.commands[id].instanceCount = is_visible ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个计算着色器的逻辑是相同的，就是结合模型信息缓冲区给出的包围球半径和中心信息，使用<i><font color="Green">check_is_visible</font></i>函数判断该<code>submesh</code>在不在视锥体内，在就将绘制参数缓冲区中存储的每个<code>VkDrawIndexedIndirectCommand</code>的<i><font color="Orange">instanceCount</font></i>成员设置为1，这样绘制命令在调用这些绘制参数的时候就会知道需要绘制1个实例；反之如果不在视锥体内那这个<code>submesh</code>就无需绘制，那么只需要将<i><font color="Orange">instanceCount</font></i>成员设置为0，绘制命令调用该参数的时候自然就知道该实例无需绘制了。</p><p>两个着色器代码唯一的区别在于对绘制参数缓冲区的访问方式。如果设备不支持deviceaddress，那么就只有通过将该缓冲区绑定到着色器上访问，但若是支持这个特性，就可以通过缓冲区地址来访问该缓冲区而无需绑定。在glsl中为了这样使用缓冲区，只需要首先启用拓展<strong>GL_EXT_buffer_reference</strong>，然后将想要通过引用访问的缓冲区的布局指定为<strong>buffer_reference</strong>，这样这个缓冲区中的数据就可以作为着色器代码中的一个变量或者另外一个缓冲区或结构体的成员被访问了，访问方式仍然是通过.运算符。更详细的关于<strong>GL_EXT_buffer_reference</strong>拓展的说明可以参考<a href="https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_buffer_reference.txt"><code>这个页面</code></a>。</p><p>最后关于判断可见性的函数<i><font color="Green">check_is_visible</font></i>，它的逻辑和CPU视锥剔除使用的逻辑是完全一样的，我会在下文分析到CPU剔除的时候加以说明。</p><h3 id="initialize_descriptors">initialize_descriptors</h3><p>先上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::initialize_descriptors</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Target</span><br>&#123;<br>RenderPipeline,<br>ComputePipeline,<br>AddressPipeline<br>&#125;;<br><br><span class="hljs-keyword">auto</span> bind = [<span class="hljs-keyword">this</span>](VkDescriptorSet &amp;_descriptor_set, VkDescriptorSetLayout &amp;_descriptor_set_layout, Target target) &#123;<br>VkDescriptorSetAllocateInfo descriptor_set_allocate_info = vkb::initializers::<span class="hljs-built_in">descriptor_set_allocate_info</span>(descriptor_pool, &amp;_descriptor_set_layout, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_set_allocate_info, &amp;_descriptor_set));<br><br>VkDescriptorBufferInfo model_buffer_descriptor = <span class="hljs-built_in">create_descriptor</span>(*model_information_buffer);<br>VkWriteDescriptorSet   model_write             = vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(_descriptor_set, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, <span class="hljs-number">0</span>, &amp;model_buffer_descriptor, <span class="hljs-number">1</span>);<br><br>VkWriteDescriptorSet texture_array_write = vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(_descriptor_set, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="hljs-number">1</span>, image_descriptors.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(image_descriptors.<span class="hljs-built_in">size</span>()));<br><br>VkDescriptorBufferInfo scene_descriptor = <span class="hljs-built_in">create_descriptor</span>(*scene_uniform_buffer);<br>VkWriteDescriptorSet   scene_write      = vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(_descriptor_set, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">2</span>, &amp;scene_descriptor, <span class="hljs-number">1</span>);<br><br>VkDescriptorBufferInfo draw_command_descriptor = <span class="hljs-built_in">create_descriptor</span>(*indirect_call_buffer);<br>VkWriteDescriptorSet   draw_command_write      = vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(_descriptor_set, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, <span class="hljs-number">3</span>, &amp;draw_command_descriptor, <span class="hljs-number">1</span>);<br><br>VkDescriptorBufferInfo device_address_descriptor;<br>VkWriteDescriptorSet   device_address_write;<br><span class="hljs-keyword">if</span> (m_supports_buffer_device &amp;&amp; device_address_buffer)<br>&#123;<br>device_address_descriptor = <span class="hljs-built_in">create_descriptor</span>(*device_address_buffer);<br>device_address_write      = vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(_descriptor_set, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, <span class="hljs-number">4</span>, &amp;device_address_descriptor, <span class="hljs-number">1</span>);<br>&#125;<br><br>std::vector&lt;VkWriteDescriptorSet&gt; write_descriptor_sets;<br><span class="hljs-keyword">switch</span> (target)<br>&#123;<br><span class="hljs-keyword">case</span> Target::RenderPipeline:<br>write_descriptor_sets = &#123;model_write, texture_array_write, scene_write, draw_command_write&#125;;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> Target::ComputePipeline:<br>write_descriptor_sets = &#123;model_write, scene_write, draw_command_write&#125;;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> Target::AddressPipeline:<br>write_descriptor_sets = &#123;model_write, scene_write, device_address_write&#125;;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-built_in">vkUpdateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(write_descriptor_sets.<span class="hljs-built_in">size</span>()), write_descriptor_sets.<span class="hljs-built_in">data</span>(), <span class="hljs-number">0</span>, VK_NULL_HANDLE);<br>&#125;;<br><br><span class="hljs-comment">// render pipeline</span><br><span class="hljs-built_in">bind</span>(descriptor_set, descriptor_set_layout, Target::RenderPipeline);<br><br><span class="hljs-comment">//  compute pipeline</span><br><span class="hljs-built_in">bind</span>(gpu_cull_descriptor_set, gpu_cull_descriptor_set_layout, Target::ComputePipeline);<br><br><span class="hljs-comment">// Device address pipeline</span><br><span class="hljs-keyword">if</span> (m_supports_buffer_device)<br>&#123;<br><span class="hljs-built_in">bind</span>(device_address_descriptor_set, device_address_descriptor_set_layout, Target::AddressPipeline);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数用于真正指定描述符绑定的资源对象。这部分内容也没什么好说的，函数开头的枚举类就是为了后续指定不同管线所需要绑定的不同描述符，然后后续为每个管线都指定好对应的描述符资源绑定就行了。</p><h3 id="build_command_buffers">build_command_buffers</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::build_command_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>VkCommandBufferBeginInfo command_buffer_begin_info = vkb::initializers::<span class="hljs-built_in">command_buffer_begin_info</span>();<br><br>VkClearValue clear_values[<span class="hljs-number">2</span>];<br>clear_values[<span class="hljs-number">0</span>].color        = default_clear_color;<br>clear_values[<span class="hljs-number">1</span>].depthStencil = &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0</span>&#125;;<br><br>VkRenderPassBeginInfo render_pass_begin_info    = vkb::initializers::<span class="hljs-built_in">render_pass_begin_info</span>();<br>render_pass_begin_info.renderPass               = render_pass;<br>render_pass_begin_info.renderArea.offset.x      = <span class="hljs-number">0</span>;<br>render_pass_begin_info.renderArea.offset.y      = <span class="hljs-number">0</span>;<br>render_pass_begin_info.renderArea.extent.width  = width;<br>render_pass_begin_info.renderArea.extent.height = height;<br>render_pass_begin_info.clearValueCount          = <span class="hljs-number">2</span>;<br>render_pass_begin_info.pClearValues             = clear_values;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; draw_cmd_buffers.<span class="hljs-built_in">size</span>(); ++i)<br>&#123;<br>render_pass_begin_info.framebuffer = framebuffers[i];<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBeginCommandBuffer</span>(draw_cmd_buffers[i], &amp;command_buffer_begin_info));<br><br><span class="hljs-built_in">vkCmdBeginRenderPass</span>(draw_cmd_buffers[i], &amp;render_pass_begin_info, VK_SUBPASS_CONTENTS_INLINE);<br><br>VkViewport viewport = vkb::initializers::<span class="hljs-built_in">viewport</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(height), <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br><span class="hljs-built_in">vkCmdSetViewport</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;viewport);<br><br>VkRect2D scissor = vkb::initializers::<span class="hljs-built_in">rect2D</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int32_t</span>&gt;(width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int32_t</span>&gt;(height), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">vkCmdSetScissor</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;scissor);<br><br><span class="hljs-built_in">vkCmdBindPipeline</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline);<br><span class="hljs-built_in">vkCmdBindDescriptorSets</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline_layout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;descriptor_set, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>VkDeviceSize offsets[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-built_in">vkCmdBindIndexBuffer</span>(draw_cmd_buffers[i], index_buffer-&gt;<span class="hljs-built_in">get_handle</span>(), <span class="hljs-number">0</span>, VK_INDEX_TYPE_UINT16);<br><span class="hljs-built_in">vkCmdBindVertexBuffers</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, vertex_buffer-&gt;<span class="hljs-built_in">get</span>(), offsets);<br><span class="hljs-built_in">vkCmdBindVertexBuffers</span>(draw_cmd_buffers[i], <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, model_information_buffer-&gt;<span class="hljs-built_in">get</span>(), offsets);<br><br><span class="hljs-keyword">if</span> (m_enable_mdi &amp;&amp; m_supports_mdi)<br>&#123;<br><span class="hljs-built_in">vkCmdDrawIndexedIndirect</span>(draw_cmd_buffers[i], indirect_call_buffer-&gt;<span class="hljs-built_in">get_handle</span>(), <span class="hljs-number">0</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(cpu_commands.<span class="hljs-built_in">size</span>()), <span class="hljs-built_in">sizeof</span>(cpu_commands[<span class="hljs-number">0</span>]));<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; cpu_commands.<span class="hljs-built_in">size</span>(); ++j)<br>&#123;<br><span class="hljs-built_in">vkCmdDrawIndexedIndirect</span>(draw_cmd_buffers[i], indirect_call_buffer-&gt;<span class="hljs-built_in">get_handle</span>(), j * <span class="hljs-built_in">sizeof</span>(cpu_commands[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>, <span class="hljs-built_in">sizeof</span>(cpu_commands[<span class="hljs-number">0</span>]));<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">draw_ui</span>(draw_cmd_buffers[i]);<br><br><span class="hljs-built_in">vkCmdEndRenderPass</span>(draw_cmd_buffers[i]);<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkEndCommandBuffer</span>(draw_cmd_buffers[i]));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数用于录制绘制命令，其中的逻辑也是司空见惯，无非是开启渲染通道，设置动态阶段（这里是视口和剪裁区域），绑定PSO，绑定描述符集，绑定索引和顶点缓冲，最后调用间接绘制函数。不过这里还是有一些细节需要注意一下：首先是代码绑定了两个顶点缓冲区，分别绑定于绑定点0，1上，其中后一个绑定的缓冲区存储的就是实例信息。另外，根据硬件是否支持mdi以及是否启用mdi，调用间接绘制的方式也是不同的，如果支持且启用了mdi，那么就可以一个绘制调用绘制所有物体，反之则只能每个实例都调用一次绘制函数了，并且还需要为每个绘制指定绘制参数在绘制参数缓冲区中的偏移。</p><h3 id="cpu_cull">cpu_cull</h3><p>在准备阶段的最后，还需要进行一次CPU端的视锥剔除，这是因为在后面的主渲染循环中我们会看到，在一帧渲染之后程序会进行下一帧的视锥剔除，这也就意味着第一帧的剔除需要在循环之外先行进行。另外，用于传递数据到绘制参数缓冲区的stagingbuffer也是在第一次调用该函数的时候创建，因此需要在准备阶段先调用一次这个函数，创建好stagingbuffer并且将第一帧的剔除结果写入到绘制参数缓冲区中，后续如果使用GPU视锥剔除的话才能顺利更新绘制参数缓冲区的内容。下面放上该函数的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::cpu_cull</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cpu_commands.<span class="hljs-built_in">resize</span>(models.<span class="hljs-built_in">size</span>());<br><br><span class="hljs-function">VisibilityTester <span class="hljs-title">tester</span><span class="hljs-params">(scene_uniform.proj * scene_uniform.view)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; models.<span class="hljs-built_in">size</span>(); ++i)<br>&#123;<br><span class="hljs-comment">// we control visibility by changing the instance count</span><br><span class="hljs-keyword">auto</span>                        &amp;model = models[i];<br>VkDrawIndexedIndirectCommand cmd&#123;&#125;;<br>cmd.firstIndex    = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(model.index_buffer_offset / (<span class="hljs-built_in">sizeof</span>(model.triangles[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])));<br>cmd.indexCount    = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(model.triangles.<span class="hljs-built_in">size</span>()) * <span class="hljs-number">3</span>;<br>cmd.vertexOffset  = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int32_t</span>&gt;(model.vertex_buffer_offset / <span class="hljs-built_in">sizeof</span>(Vertex));<br>cmd.firstInstance = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(i);<br>cmd.instanceCount = tester.<span class="hljs-built_in">is_visible</span>(model.bounding_sphere.center, model.bounding_sphere.radius);<br>cpu_commands[i]   = cmd;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> call_buffer_size = cpu_commands.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(cpu_commands[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">assert</span>(!!indirect_call_buffer &amp;&amp; indirect_call_buffer-&gt;<span class="hljs-built_in">get_size</span>() == call_buffer_size);<br><br><span class="hljs-keyword">if</span> (!cpu_staging_buffer || cpu_staging_buffer-&gt;<span class="hljs-built_in">get_size</span>() != call_buffer_size)<br>&#123;<br>cpu_staging_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), models.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(VkDrawIndexedIndirectCommand), VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VMA_MEMORY_USAGE_CPU_TO_GPU);<br>&#125;<br><br>cpu_staging_buffer-&gt;<span class="hljs-built_in">update</span>(cpu_commands.<span class="hljs-built_in">data</span>(), call_buffer_size, <span class="hljs-number">0</span>);<br>cpu_staging_buffer-&gt;<span class="hljs-built_in">flush</span>();<br><br><span class="hljs-keyword">auto</span> &amp;transfer_cmd = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_command_pool</span>().<span class="hljs-built_in">request_command_buffer</span>();<br>transfer_cmd.<span class="hljs-built_in">begin</span>(VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, VK_NULL_HANDLE);<br>transfer_cmd.<span class="hljs-built_in">copy_buffer</span>(*cpu_staging_buffer, *indirect_call_buffer, call_buffer_size);<br>transfer_cmd.<span class="hljs-built_in">end</span>();<br><br><span class="hljs-keyword">auto</span> &amp;queue = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_by_flags</span>(VK_QUEUE_GRAPHICS_BIT, <span class="hljs-number">0</span>);<br>queue.<span class="hljs-built_in">submit</span>(transfer_cmd, <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">request_fence</span>());<br><span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_fence_pool</span>().<span class="hljs-built_in">wait</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是在CPU端通过视锥裁剪更新绘制参数向量的内容。为了指定绘制参数，对每个<code>submesh</code>，我们都需要填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDrawIndexedIndirectCommand.html"><code>VkDrawIndexedIndirectCommand</code></a>结构体，为了指定该<code>submesh</code>的绘制参数，我们需要指定它的顶点在顶点缓冲区中的范围，这是通过指定索引的起始偏移和数量，结合顶点的偏移来计算的，其偏移量可以很容易地根据之前在<code>SceneModel</code>结构体中保存的偏移量得到（实际上这个偏移量也就是顺次保存这些<code>submesh</code>的顶点和索引数据时排在该<code>submesh</code>之前的所有顶点和索引的数目）。然后还需要指定的绘制参数是本次绘制的实例偏移以及数目，偏移就是本次绘制的模型在<code>SceneModel</code>向量中的偏移（这样后续顶点着色器在获取实例缓冲区信息的时候就会根据这个偏移索引到正确的实例模型信息），而绘制的实例数目取决于视锥剔除的结果，通过视锥剔除了就绘制一个实例，否则不绘制。可以看到视锥剔除是通过一个自定义的判断可见性结构体<code>VisibilityTester</code>来完成的，它的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Test for visibility using bounding sphere.</span><br><span class="hljs-comment"> * See https://www.gamedevs.org/uploads/fast-extraction-viewing-frustum-planes-from-world-view-projection-matrix.pdf</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">VisibilityTester</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">VisibilityTester</span><span class="hljs-params">(glm::mat4x4 view_matrix)</span> :</span><br><span class="hljs-function">    planes(get_view_planes(view_matrix))</span><br><span class="hljs-function">&#123;</span>&#125;<br>std::array&lt;glm::vec4, 6&gt; planes;<br><br><span class="hljs-function"><span class="hljs-type">static</span> std::array&lt;glm::vec4, 6&gt; <span class="hljs-title">get_view_planes</span><span class="hljs-params">(<span class="hljs-type">const</span> glm::mat4x4 &amp;mat)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> glm;<br>std::array&lt;vec4, 6&gt; out&#123;&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; ++j)<br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> sign = j ? <span class="hljs-number">1.f</span> : <span class="hljs-number">-1.f</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; ++k)<br>&#123;<br>out[<span class="hljs-number">2</span> * i + j][k] = mat[k][<span class="hljs-number">3</span>] + sign * mat[k][i];<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// normalize plane; see Appendix A.2</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;plane : out)<br>&#123;<br>plane /= <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-built_in">length</span>(<span class="hljs-built_in">vec3</span>(plane.xyz)));<br>&#125;<br><span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_visible</span><span class="hljs-params">(glm::vec3 origin, <span class="hljs-type">float</span> radius)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> glm;<br>std::array&lt;<span class="hljs-type">int</span>, 4&gt; V&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">return</span> std::<span class="hljs-built_in">all_of</span>(V.<span class="hljs-built_in">begin</span>(), V.<span class="hljs-built_in">end</span>(), [<span class="hljs-keyword">this</span>, origin, radius](<span class="hljs-type">size_t</span> i) &#123;<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;plane = planes[i];<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">dot</span>(origin, <span class="hljs-built_in">vec3</span>(plane.xyz)) + plane.w + radius &gt;= <span class="hljs-number">0</span>;<br>&#125;);<br>&#125;<br>&#125;;<br><br>&#125;        <span class="hljs-comment">// namespace</span><br></code></pre></td></tr></table></figure><p>判断一个物体是不是处于视锥体内，只需要判断这个物体是不是位于视锥体的每一个面内（即面的法线向量同侧），如果是则说明该物体可见（不过这里的实现实际上只是判断了物体在不在左右和前后平面内，不知道为啥。。。），反之则需要剔除。在<a href="https://www.gamedevs.org/uploads/fast-extraction-viewing-frustum-planes-from-world-view-projection-matrix.pdf"><code>注释中给出的文章</code></a>中详细地给出了从投影矩阵或者VP矩阵或者MVP矩阵重建视锥体六个面的方法，简单来讲其实就是一个线性变换，将齐次裁剪空间中的平面方程变为观察空间（或者世界空间，或者模型空间）中的平面方程，而这个线性变换其实就由投影矩阵（或者VP,MVP矩阵）给出。具体的实现读者可以自行详细分析。</p><p>接下来当然就是将CPU端的数据首先上传到staging buffer，然后再用stagingbuffer中的数据更新绘制参数缓冲区，这里不再赘述。</p><h3 id="run_cull">run_cull</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::run_cull</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">switch</span> (render_mode)<br>&#123;<br><span class="hljs-keyword">case</span> RenderMode::CPU:<br><span class="hljs-built_in">cpu_cull</span>();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> RenderMode::GPU:<br><span class="hljs-keyword">case</span> RenderMode::GPU_DEVICE_ADDRESS:<br><span class="hljs-built_in">run_gpu_cull</span>();<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在准备阶段的最后，执行玩CPU剔除后，程序还执行了一次剔除。由于程序的默认剔除模式是GPU，所以事实上在第一帧之前程序还会进行一次GPU的剔除，那么我们就顺势分析一下GPU剔除函数<i><font color="Green">run_gpu_cull</font></i>都做了什么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::run_gpu_cull</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">assert</span>(!!gpu_cull_pipeline);<br><span class="hljs-keyword">auto</span>                     cmd   = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">create_command_buffer</span>(VK_COMMAND_BUFFER_LEVEL_PRIMARY);<br>VkCommandBufferBeginInfo begin = vkb::initializers::<span class="hljs-built_in">command_buffer_begin_info</span>();<br><br><span class="hljs-built_in">vkBeginCommandBuffer</span>(cmd, &amp;begin);<br><span class="hljs-keyword">auto</span> bind = [&amp;cmd](VkPipeline &amp;_pipeline, VkPipelineLayout &amp;_pipeline_layout, VkDescriptorSet &amp;_descriptor_set) &#123;<br><span class="hljs-built_in">vkCmdBindPipeline</span>(cmd, VK_PIPELINE_BIND_POINT_COMPUTE, _pipeline);<br><span class="hljs-built_in">vkCmdBindDescriptorSets</span>(cmd, VK_PIPELINE_BIND_POINT_COMPUTE, _pipeline_layout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;_descriptor_set, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>&#125;;<br><br><span class="hljs-keyword">if</span> (render_mode == RenderMode::GPU)<br>&#123;<br><span class="hljs-built_in">bind</span>(gpu_cull_pipeline, gpu_cull_pipeline_layout, gpu_cull_descriptor_set);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">bind</span>(device_address_pipeline, device_address_pipeline_layout, device_address_descriptor_set);<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> dispatch_x = !models.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">1</span> + <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;((models.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) / <span class="hljs-number">64</span>) : <span class="hljs-number">1</span>;<br><span class="hljs-built_in">vkCmdDispatch</span>(cmd, dispatch_x, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">vkEndCommandBuffer</span>(cmd);<br><br>VkSubmitInfo submit       = vkb::initializers::<span class="hljs-built_in">submit_info</span>();<br>submit.commandBufferCount = <span class="hljs-number">1</span>;<br>submit.pCommandBuffers    = &amp;cmd;<br><br><span class="hljs-built_in">vkQueueSubmit</span>(compute_queue-&gt;<span class="hljs-built_in">get_handle</span>(), <span class="hljs-number">1</span>, &amp;submit, <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">request_fence</span>());<br><span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_fence_pool</span>().<span class="hljs-built_in">wait</span>();<br><span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_fence_pool</span>().<span class="hljs-built_in">reset</span>();<br><span class="hljs-comment">// we&#x27;re done so dealloc it from the pool.</span><br><span class="hljs-built_in">vkFreeCommandBuffers</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_command_pool</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-number">1</span>, &amp;cmd);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，<i><font color="Green">run_gpu_cull</font></i>函数就是录制了执行GPU剔除的命令并且提交计算队列执行。启动GPU剔除的过程十分简单，就是绑定管线对象以及所需的描述符集，然后执行dispatch即可。可以看到程序是将一个工作组的大小设置为了64。最后代码是设定为让CPU端等待命令执行完毕。实际上为了追求更高的效率，是可以让上一帧的CS在运行的时候就进行下一帧的前置逻辑的，不过就需要在下一帧绘制开始之前同步CS，使得在渲染开始前CS已经执行完毕。</p><hr><h2 id="渲染阶段">渲染阶段</h2><p>漫长的准备阶段终于是结束了，接下来就开始进入渲染循环的分析了。渲染循环主要调用的是<i><font color="Green">render</font></i>函数，其代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::render</span><span class="hljs-params">(<span class="hljs-type">float</span> delta_time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!prepared)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (render_mode == GPU_DEVICE_ADDRESS &amp;&amp; !m_supports_buffer_device)<br>&#123;<br>render_mode = GPU;<br>&#125;<br><br><span class="hljs-keyword">if</span> (m_requires_rebuild)<br>&#123;<br><span class="hljs-built_in">rebuild_command_buffers</span>();<br>m_requires_rebuild = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-built_in">draw</span>();<br><br><span class="hljs-built_in">update_scene_uniform</span>();<br><br><span class="hljs-keyword">if</span> (!m_freeze_cull)<br>&#123;<br><span class="hljs-built_in">run_cull</span>();<br>&#125;<br><span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_fence_pool</span>().<span class="hljs-built_in">wait</span>();<br><span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_fence_pool</span>().<span class="hljs-built_in">reset</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到一帧的渲染主逻辑就是绘制——更新场景属性——进行下一帧的剔除。更新场景信息和进行剔除的函数已经在前文分析过了，下面只需要来看<i><font color="Green">draw</font></i>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiDrawIndirect::draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ApiVulkanSample::<span class="hljs-built_in">prepare_frame</span>();<br><br><span class="hljs-comment">// Command buffer to be submitted to the queue</span><br>submit_info.commandBufferCount = <span class="hljs-number">1</span>;<br>submit_info.pCommandBuffers    = &amp;draw_cmd_buffers[current_buffer];<br><br><span class="hljs-comment">// Submit to queue</span><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkQueueSubmit</span>(queue, <span class="hljs-number">1</span>, &amp;submit_info, VK_NULL_HANDLE));<br><br>ApiVulkanSample::<span class="hljs-built_in">submit_frame</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到<i><font color="Green">draw</font></i>的代码逻辑也十分简单，就是准备好渲染所需的资源（交换链图像等），然后提交准备阶段录制好的渲染命令（每一帧渲染命令都是一致的，无需每帧录制），最后显示渲染结果即可。</p><p>代码部分就此分析完毕，可喜可贺！！</p><h2 id="效果对比">效果对比</h2><p>下面来看一下在我的电脑上使用不同的视锥剔除方式运行该示例的性能分别怎么样：</p><figure><img src="/2025/02/23/CG_api/vulkan/vulkan_samples/multi_draw_indirect/cpu.png" alt="CPU Cull"><figcaption aria-hidden="true">CPU Cull</figcaption></figure><figure><img src="/2025/02/23/CG_api/vulkan/vulkan_samples/multi_draw_indirect/gpu.png" alt="GPU Cull"><figcaption aria-hidden="true">GPU Cull</figcaption></figure><figure><img src="/2025/02/23/CG_api/vulkan/vulkan_samples/multi_draw_indirect/gpu_da.png" alt="GPU Address Cull"><figcaption aria-hidden="true">GPU Address Cull</figcaption></figure><p>可以看到反而是CPU剔除的效率最高，难道是因为场景不够大，还无法完全发挥出GPU大人的实力吗（</p><hr><h2 id="尝试welzl算法">尝试Welzl算法</h2><p>最后，官方示例在计算包围球的代码（也就是包围球构造函数）中提到了Welzl算法是计算最佳包围球的算法。于是我就想着要么去实现一下这个算法，算法逻辑和代码框架可以参考<a href="https://www.geeksforgeeks.org/minimum-enclosing-circle-using-welzls-algorithm/"><code>这篇文章</code></a>，简单点说其实就是一个递归算法：包含n个点的最小包围球，可以由包含n-1个点的最小包围球得到，如果这n-1个点的最小包围球包含第n个点，那么这n-1个点的最小包围球就是这n个点的最小包围球，如果不然，则第n个点一定在最小包围球的边界上（证明也比较容易，读者可以自行想象）。我当时一看逻辑和代码框架，感觉这不是很好理解吗？于是马上兴致勃勃地动手实践了一下：首先在应用程序类中新添一个枚举类<i><font color="Orange">CalcMethod</font></i>用于代表包围球的计算方式是按照原来程序的方式计算还是按照Welzl算法计算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">CalcMethod</span><br>&#123;<br>SIMPLE,<br>WELZL<br>&#125; calc_method = SIMPLE;<br></code></pre></td></tr></table></figure><p>然后在程序窗口中新添一个选项框用于选择包围球的计算模式。</p><p>在准备场景的<i><font color="Green">load_scene</font></i>函数中，我准备直接计算好每个模型的简单包围球和Welzl包围球，并一并保存在<code>SceneModel</code>结构体中。然后就是包围球计算的实现，这里放上我写的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs c++">MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">BoundingSphere</span>(<span class="hljs-type">const</span> std::vector&lt;glm::vec3&gt; &amp;pts, CalcMethod method)<br>&#123;<br><span class="hljs-keyword">if</span> (method == CalcMethod::SIMPLE)<br>&#123;<br><span class="hljs-keyword">if</span> (pts.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// This is a simple method of calculating a bounding sphere.</span><br><span class="hljs-comment">// For finding an optimal bounding sphere, see Welzl&#x27;s algorithm</span><br><span class="hljs-keyword">this</span>-&gt;center = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;pt : pts)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;center += pt;<br>&#125;<br><span class="hljs-keyword">this</span>-&gt;center /= <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(pts.<span class="hljs-built_in">size</span>());<br><span class="hljs-keyword">this</span>-&gt;radius = glm::<span class="hljs-built_in">distance2</span>(pts[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>-&gt;center);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">1</span>; i &lt; pts.<span class="hljs-built_in">size</span>(); ++i)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;radius = std::<span class="hljs-built_in">max</span>(<span class="hljs-keyword">this</span>-&gt;radius, glm::<span class="hljs-built_in">distance2</span>(pts[i], <span class="hljs-keyword">this</span>-&gt;center));<br>&#125;<br><span class="hljs-keyword">this</span>-&gt;radius = std::<span class="hljs-built_in">nextafter</span>(<span class="hljs-built_in">sqrtf</span>(<span class="hljs-keyword">this</span>-&gt;radius), std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">max</span>());<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>std::vector&lt;glm::vec3&gt; points = pts;<br>std::random_device rd;<br><span class="hljs-function">std::mt19937 <span class="hljs-title">g</span><span class="hljs-params">(rd())</span></span>; <br>std::<span class="hljs-built_in">shuffle</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), g);<br><span class="hljs-built_in">welzlHelper</span>(points, &#123;&#125;, pts.<span class="hljs-built_in">size</span>());<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">welzlHelper</span>(std::vector&lt;glm::vec3&gt; points, std::vector&lt;glm::vec3&gt; bounds, <span class="hljs-type">int</span> n)<br>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || bounds.<span class="hljs-built_in">size</span>() == <span class="hljs-number">3</span>)<br>&#123;<br><span class="hljs-built_in">minCircleTrivial</span>(bounds);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> id = <span class="hljs-built_in">rand</span>() % n;<br>glm::vec3 point = points[id];<br><br>std::<span class="hljs-built_in">swap</span>(points[id], points[n - <span class="hljs-number">1</span>]);<br><br><span class="hljs-built_in">welzlHelper</span>(points, bounds, n<span class="hljs-number">-1</span>);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isInside</span>(center, radius, point))<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>bounds.<span class="hljs-built_in">push_back</span>(point);<br><span class="hljs-built_in">welzlHelper</span>(points, bounds, n - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">void</span> MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">minCircleTrivial</span>(std::vector&lt;glm::vec3&gt; points) &#123;<br><span class="hljs-built_in">assert</span>(points.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">if</span> (points.<span class="hljs-built_in">empty</span>())<br>&#123;<br>center = &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;;<br>radius = <span class="hljs-number">0.0f</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (points.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>&#123;<br>center = points[<span class="hljs-number">0</span>];<br>radius = <span class="hljs-number">0.0f</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (points.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-built_in">circleFrom</span>(points[<span class="hljs-number">0</span>], points[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">3</span>; j++)<br>&#123;<br><span class="hljs-built_in">circleFrom</span>(points[i], points[j]);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValidCircle</span>(center, radius, points))<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">circleFrom</span>(points[<span class="hljs-number">0</span>], points[<span class="hljs-number">1</span>], points[<span class="hljs-number">2</span>]);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">isInside</span>(glm::vec3 center, <span class="hljs-type">float</span> radius, glm::vec3 point)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>(center, point) &lt;= radius - epsilon;<br>&#125;<br><br><span class="hljs-type">bool</span> MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">isValidCircle</span>(glm::vec3 center, <span class="hljs-type">float</span> radius, std::vector&lt;glm::vec3&gt; points)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;p : points)<br>&#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isInside</span>(center, radius, p))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">float</span> MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">dist</span>(glm::vec3 point_1, glm::vec3 point_2)<br>&#123;<br><span class="hljs-keyword">return</span> std::<span class="hljs-built_in">nextafter</span>(<span class="hljs-built_in">sqrtf</span>(glm::<span class="hljs-built_in">dot</span>(point_2 - point_1, point_2 - point_1)), std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">max</span>());<br>&#125;<br><br><span class="hljs-type">void</span> MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">circleFrom</span>(glm::vec3 point_1, glm::vec3 point_2)<br>&#123;<br>center = (point_1 + point_2) / <span class="hljs-number">2.0f</span>;<br>radius = <span class="hljs-built_in">dist</span>(point_1, point_2) / <span class="hljs-number">2.0f</span>;<br>&#125;<br><br><span class="hljs-type">void</span> MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">circleFrom</span>(glm::vec3 point_1, glm::vec3 point_2, glm::vec3 point_3)<br>&#123;<br>center = point_1 + <span class="hljs-built_in">getCircleCenter</span>(point_2 - point_1, point_3 - point_1);<br>radius = <span class="hljs-built_in">dist</span>(center, point_1);<br>&#125;<br><br>glm::vec3 MultiDrawIndirect::BoundingSphere::<span class="hljs-built_in">getCircleCenter</span>(glm::vec3 vec_1, glm::vec3 vec_2)<br>&#123;<br><span class="hljs-type">float</span> length_1 = glm::<span class="hljs-built_in">dot</span>(vec_1, vec_1);<br><span class="hljs-type">float</span> length_2 = glm::<span class="hljs-built_in">dot</span>(vec_2, vec_2);<br><span class="hljs-type">float</span> dot=glm::<span class="hljs-built_in">dot</span>(vec_1,vec_2);<br><br><span class="hljs-type">float</span> x = (length_1 * length_2 - length_2 * dot) / (<span class="hljs-number">2</span> * (length_1 * length_2 - dot * dot));<br><span class="hljs-type">float</span> y = (length_1 * length_2 - length_1 * dot) / (<span class="hljs-number">2</span> * (length_1 * length_2 - dot * dot));<br><br><span class="hljs-keyword">return</span> x * vec_1 + y * vec_2;<br>&#125;<br></code></pre></td></tr></table></figure><p>大功告成！本来以为程序就能这么愉快地运行下去了，然而事与愿违：由于这是一个递归算法，由于模型的顶点过多，直接让调用栈内存爆了。。。我这是真没辙啊，也没有看到相应的迭代实现，自己也想不出来。本想着是不是可以保留部分离模型中心点较远的点，然后仅仅计算这部分点的包围球作为整个模型的包围球，但想来想去都无法严谨地证明这么做得到的包围球一定可以包含所有模型顶点，几种选点的方法都被自己证伪了。。。然后只能在google上漫无目的地搜查优化方案，结果还真给找到了，不过是<a href="https://informatica.vu.lt/journal/INFORMATICA/article/1251/text"><code>一篇论文</code></a>，大致思路其实也是选择部分点计算包围球，但是整体看上去还是比较复杂的，虽说看懂没问题，但复现还是需要花费大量的时间，目前时间紧张，只能挖个坑日后来填了~</p><hr>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_samples</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>post</title>
    <link href="/2025/02/17/CG_api/d3d11/d3d11_with_windowsSDK/%E5%88%9D%E7%BA%A7%E7%AF%87%E7%BB%86%E8%8A%82%E8%A1%A5%E5%85%85/"/>
    <url>/2025/02/17/CG_api/d3d11/d3d11_with_windowsSDK/%E5%88%9D%E7%BA%A7%E7%AF%87%E7%BB%86%E8%8A%82%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Compute_nBody的OpenGL复现</title>
    <link href="/2025/02/07/CG_api/openGL/VKSample_OGL/compute_nbody/"/>
    <url>/2025/02/07/CG_api/openGL/VKSample_OGL/compute_nbody/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言">前言</h2><p>在看Vulkan官方示例集的时候，我就有想法要将这个示例集用到的特性和实现的效果全部使用别的图形API实现一遍。个人而言比较熟悉的API是OpenGL，所以就先构建OpenGL版本的示例集了。当然在这之后我还打算构建相应的D3D11和D3D12版本，并且如果允许的话构建一个抽象层将不同API的实现整合起来。不过当然这些都是长远的打算了，现在还是一步一个脚印地记录一下OpenGL版本的程序构建过程吧。</p><p>经过几天的不懈努力，终于是完成了对于Vulkan官方示例集中的第一个示例<strong>compute_nbody</strong>的构建。由于我没有具体研究过示例集的架构和对图形API的封装，所以项目的架构上多少还是比较简陋的，不过这个架构将在我不断实现新特性的过程中不断完善，我的目标是仿照官方示例集的架构完成一个比较成熟的用于展现所有示例特性的OpenGL框架，中间肯定会随着我对于示例集框架理解的加深不断重构自己的框架，苯人萌新一枚，还望大佬轻喷。</p><p>即使是一个简陋的框架，这几天来我也没少被折磨，中间也是遇到了各种令人质壁分离的bug（毕竟还是经验不足，不过好在没有放弃，终于还是基本复现出了官方特性集中的效果（虽说相对而言要丑不少，不过性能和视觉效果上的优化会在之后慢慢进行），当渲染窗口终于脱离黑屏，展示出五彩斑斓的粒子效果时，我也总算是能长舒一口气了。这篇文章不会非常具体地介绍框架中的各种实现细节（毕竟也没啥好介绍的。。。），也不会具体介绍<strong>compute_nbody</strong>示例的实现原理（这在我博客的<a href="https://zpc-dsg.github.io/2025/01/24/CG_api/vulkan/vulkan_samples/compute_nbody/"><code>另一篇文章</code></a>中已经有非常详细的分析了），而是会着重于记录在开发过程中自己遇到的各种问题以及最后找出的解决方案，也给之后的自己提个醒吧~</p><p>本项目的代码框架已经开源在<a href="https://github.com/ZPC-dsg/VkSamples_OGL"><code>我的github仓库中</code></a>。</p><hr><h2 id="问题1无法解析的外部符号xxx">问题1：无法解析的外部符号XXX</h2><p>在初步架构好项目之后，编译运行，然后程序报了一堆无法解析的外部符号bug。。。初步判断这是没有在项目中包含相应的库文件导致的（我原来将子项目Component设置为了生成exe文件，然后将这些库文件路径添加到了它的属性页，但之后发现应该要将这个项目构建为静态库，但是静态库项目的属性页是没有链接器选项的，所以原来我以为添加了的那些库就没了），于是将所有用到的第三方库的.lib文件位置加入项目属性设置——链接器选项中的附加库目录，并将这些.lib文件添加至附加依赖项。然后重新生成项目，发现<strong>stb_image</strong>文件中的函数仍然报错无法解析的外部符号，想起来在使用<strong>stb_image</strong>的时候应该要自己创建一个源文件并且在源文件中定义宏<i><font color="Red">STB_IMAGE_IMPLEMENTATION</font></i>，于是添加上这个源文件之后彻底解决了无法解析的外部符号问题。</p><hr><h2 id="问题2已跳过nvoglv64.dll加载">问题2：已跳过nvoglv64.dll加载</h2><p>这个bug着实是折磨了我挺久，它的恶心之处在于程序直接就崩溃了，甚至连调试的机会都不给，调用堆栈也一点信息没有，只能看到VS在程序崩溃后弹出一个界面告诉你已跳过nvoglv64.dll加载blabla的（根本不知所云xs），属实是给我整不会了。。。。google了一圈发现还真有人遇到过类似的问题，而且我发现有一些帖子提到是在使用<strong>stb_image</strong>加载图像的时候遇到了这种问题。于是我决定写一个小的测试程序来检验一下我的问题根源是不是也是这个，遂写了一个简单的渲染全屏纹理的测试程序，然后先是随便使用了一张正常的jpg图像，发现加载正常测试程序正常运行，然后我再尝试使用该测试程序加载<strong>compute_nbody</strong>项目本应该用到的纹理图像时，发现相同的问题出现了，合着还真是这个图像加载库的问题。。。</p><p>回想起之前不知道在哪里看到过<strong>stb_image</strong>加载png文件很容易产生问题，而我的<strong>compute_nbody</strong>项目使用的那两张纹理是我截屏得到的。说起来获取这两张纹理的过程也十分曲折。。。因为Vulkan官方示例集所提供的相应纹理是<strong>ktx</strong>格式的，还不是一般的<strong>ktx</strong>格式（我也是服了），亲测一般的ktx转jpg工具对这些图像无效。。。（DirectX官方提供的都不行），在<a href="https://zpc-dsg.github.io/2025/01/24/CG_api/vulkan/vulkan_samples/compute_nbody/"><code>我的分析compute_nbody逻辑细节</code></a>的文章中我提到自己最终是发现Vulkan官方示例集中有一个<strong>texture_loading</strong>的示例，然后我将该示例中读取文件的路径改成了<strong>compute_nbody</strong>中的那两张纹理才得以显示这两张图像的庐山真面目。不过事实上这还不够，因为我希望得到的是这两张纹理的jpg格式图像，但是<strong>texture_loading</strong>示例的展示效果并不是全屏纹理，而是一个空间中带有光照的四边形。。。好吧，没办法，我只能写一个渲染全屏四边形的着色器然后替换掉程序原来使用的那个着色器，最后终于得到了想要的全屏纹理！后续我就直接使用Windows自带的截屏工具截屏这个程序窗口中的纹理图像输出结果了，当然更好的办法肯定是将这个渲染结果直接写到一张jpg图像中去，后续可以去尝试完成这个操作，不过当下就暂且将就一下吧（因为实在是不想再搞了www。。。）</p><p>截屏获取了这两张纹理后，由于截屏得到的图像是png格式的，我最开始的时候随便找了个在线的png转jpg工具将这两张图像直接转为jpg格式然后放到我的程序中使用，结果就是报了已跳过nvoglv64.dll加载的错。于是乎我改变一种策略，直接采取最简单粗暴的办法：直接将截屏图像的后缀名改为.jpg。结果发现这样得到的图像文件竟然可以正常加载！困扰我一个上午的问题就这么不明不白地解决了（有那么亿点点摸不着头脑）。考虑到这是图像加载库本身的问题，我估计也想不明白具体缘由，所以一切正常那就万事大吉，resultis everything!（</p><hr><h2 id="问题3文件路径读取错误">问题3：文件路径读取错误</h2><p>没时间庆祝上文那个大bug的修复了，接下来赶到战场的是文件路径读取问题。。。我发现自己的程序始终无法正常打开着色器文件和纹理文件。问题的原因倒是很明显，就是文件的相对路径指定错了，但是说实话最后调整到正确的相对路径还是费了我一番功夫（主要好像网上也没搜到具体讲这个的，可能是我太菜了。。。）。在我的项目组织里，生成最终可执行文件的<strong>main.cpp</strong>位于解决方案目录（也就是程序根目录）的<strong>Main</strong>文件夹中，而生成的最终可执行文件<strong>main.exe</strong>则是被我设置为了生成在解决方案目录下的<strong>bin</strong>文件夹下的<strong>Debug-x64</strong>子文件夹中。另外，所有的纹理文件都被存储在解决方案目录下的<strong>assets</strong>文件夹的<strong>textures</strong>子文件夹中，所有着色器文件都在解决方案目录下的<strong>Shaders</strong>文件夹中。一开始我以为项目文件中指定的相对路径应该是相对于<strong>main.exe</strong>所在位置的相对路径（事实上GPT也是这么告诉我的。。。），于是乎相对路径就应该指定为<code>../../assets/textures/xxx.jpg</code>，但实际情况就是这样设置相对路径是无法正确加载文件的。。。然后我尝试了一下<code>../assets/textures/xxx.jpg</code>这种路径设置，结果就正常加载了！（着色器文件也是这样）。我认为可能是因为项目文件中的相对路径相对的不是<strong>main.exe</strong>所在位置，而是<strong>main.cpp</strong>所在位置，当然这并没有经过验证，也望有经验的大佬路过指点一二。总之，这个问题算是解决了。</p><p>其实在这中间还有个小插曲，在中间反复试验相对路径失败后，我就想着要么直接用绝对路径吧，不过当然不可能直接在程序中硬编码我的电脑上的项目绝对路径（不然别人下载源码也用不了），于是我想着在项目属性页面将<strong>$(SolutionDir)</strong>设置为一个宏，然后在程序中使用这个宏。结果这么做之后，我发现这个宏在文件中展开之后路径名中的分隔符用的不是/而是，而众所周知c++字符串中，只能使用两个反斜杠转义，但问题就在于我设置的宏展开之后不是把，而是直接就把（只剩下字符串最后那个），这种情况下想要人工修正字符串都无从下手（我也不知道为什么会出现这种情况），也是让人很崩溃。后google了一下在程序中获取绝对路径的方法，发现好像都各有各的问题，还是需要人工转换修正一下字符串，觉得太麻烦了，遂放弃绝对路径，还是回去捣鼓相对路径了。。。</p><hr><h2 id="问题4opengl对象无法复制">问题4：OpenGL对象无法复制</h2><p>终于是扫清了程序主逻辑之外的一切障碍，本以为后续将是一马平川，但是马上OpenGL的不讲理直接崩溃式报错又是给了我一个大比兜。。。好吧图形程序的调试本来就是挺恶心的，这点我也见识过，也早有心理准备，不过又碰上了之后该无从下手还是无从下手。</p><p>然后我突然意识到，Vulkan有官方提供的调试层，OpenGL难道就没有类似物吗？结果一看还真有，OpenGL同样也可以设置debug用回调函数来输出API使用错误等程序有关信息，为啥我之前一直都没想着用呢？（还是太年轻。。。被多拷打几次就老实了）于是老老实实配置好debug回调函数，控制一下输出信息等级和范围（忽略一些不太重要的信息），并且写一个宏<i><font color="Red">GL_CALL</font></i>用于为回调函数添加错误发生所在文件和行数信息，这样一个初步的调试层就设置好了！接下来终于可以摆脱直接崩溃的噩梦，“愉快”地查看问题所在了！（后续我会不断完善调试层和异常类的开发，以便在程序崩溃的时候提供更加简明扼要且易于阅读的错误信息，个人认为<a href="https://www.bilibili.com/video/BV1KC4y1Y7tc/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click"><code>chilli的d3d11教程</code></a>（B站上有人翻译）中提供了一个非常具有参考价值的异常类工程架构，之后可以试着仿照一下什么的，不得不感叹大佬nb！）</p><p>设置好调试层，然后一键运行程序，效果也是相当炸裂：由于图形程序会在一个渲染循环中不停运行，然后每一帧都会报错，导致运行个1秒左右命令行报错就能整出个几百行，那叫一个眼花缭乱。。。关键是，错误信息也是让人一头雾水：我的着色器和缓冲区等对象都已经成功创建并且对它们进行了绑定，怎么错误信息里一堆提示我绑定的不是一个OpenGL有效对象呢？明明经过我严格的测试，这些对象的创建过程本身没有任何问题，也是成功创建了，而且我也对它们执行了正常的绑定？（绑定就一行代码，我想着这也能出幺蛾子？？？）</p><p>于是我决定再着手写一个小的测试程序验证下。简单起见我直接在程序入口函数<strong>main</strong>中使用我自己封装的缓冲区类<i><font color="Orange">Buffer</font></i>创建了一个测试Storagebuffer对象b，然后正常绑定b并且在计算着色器中使用b（写了一个简单的使用计算着色器改变粒子位置然后渲染粒子效果的测试程序），结果发现一切正常？？？这属实是让我极度迷惑：为啥同样是使用自己封装的缓冲类，使用方式还几乎一致，为什么我构建的项目就会疯狂报错？想了一个晚上没明白为什么，中间也对其它部分进行了各种各样琐碎的调试，但均无法解决这个问题，说实话也是整的我身心俱疲，一度想要切割了。。。</p><p>幸运的是，当天晚上临睡前我突然灵光一闪：我发现我在主程序中对封装对象的使用还是和在<strong>main</strong>函数中直接写的测试程序有区别的，区别就在于<strong>main</strong>函数中我是直接构造<i><font color="Orange">Buffer</font></i>对象，也就是说是直接调用了一次构造函数；而在主程序中需要用到的<i><font color="Orange">Buffer</font></i>对象是需要在程序对象的构造函数完成后，在后续的<i><font color="Green">prepare</font></i>函数中构建的，也就意味着在程序对象构造函数中调用了一次<i><font color="Orange">Buffer</font></i>的默认构造函数，然后在<i><font color="Green">prepare</font></i>函数中调用了它的默认拷贝赋值运算符才完成了真正意义上作为程序类成员的<i><font color="Orange">Buffer</font></i>对象的构建。（<i><font color="Orange">Buffer</font></i>的默认构造函数本身是没有什么意义的，当时给它添加一个这样的构造函数只是因为没有默认构造函数的话就没法完成程序类的构造函数，因为在程序类的构造函数中我不希望真正构建好<i><font color="Orange">Buffer</font></i>成员，但如果直接不构造<i><font color="Orange">Buffer</font></i>成员如果没有默认构造函数的话就会报错，因为该成员无法生成导致程序类不完整），当时我有一种预感，就是当<i><font color="Orange">Buffer</font></i>对象拷贝后，拷贝到的对象虽然拥有和原对象同样值的bufferID（也就是<i><font color="Green">glGenBuffers</font></i>函数的第二个参数），但是它们的内存位置是不同的，这可能会导致绑定拷贝后对象时绑定的内存地址不是真正创建的缓冲区内存位置！于是我决定第二天早上来尝试一下自己的想法。</p><p>事实证明主要问题还真就出在这里！第二天，我略微改动了一下测试程序，刻意先默认构造再拷贝赋值缓冲区对象b，结果出现了主程序中一模一样的问题！可把我给激动坏了，总算是发现了问题的症结所在。于是我的改动方案是让所有封装的OpenGL对象类继承自一个共同的基类<i><font color="Orange">NoCopyable</font></i>，看名字也知道这个类的作用其实就是组织一切由它派生的子类的复制行为。实现起来也很简单，就是把该基类的所有赋值运算符全部设为delete的就行了。然后，我删除了所有这些OpenGL对象类的默认构造函数，并且把程序类中相应的类成员改用<strong>unique_ptr</strong>包装，这样就不用担心程序类构造函数调用时这些对象的初始化问题了，也防止了后续不经意的拷贝操作。</p><p>这样就解决了这个困扰了我将近半天的问题，确实是我之前从来没有注意过的刁钻问题（毕竟之前写OpenGL程序都是一个顺序大函数，不会出现这种拷贝赋值的情况。。。），也是给我好好上了一课。</p><hr><h2 id="问题5缓冲区数据复制性能问题">问题5：缓冲区数据复制性能问题</h2><p>不过命令行的报错信息远远没有到此结束。在解决了无法绑定到正确的OpenGL对象问题之后，情况是确实回调函数已经不再输出错误信息了，但是却出现了很多性能问题的警告，大体意思是说什么将数据从GPUlocal内存复制到hostvisible内存，对性能有影响blabla的，那这个指向性还是比较明确的，就是我原来在写<strong>compute_nbody</strong>项目的时候使用的存储计算结果的storagebuffer和用于顶点数据的vertex buffer是分开的，最初的想法是storagebuffer在存储好计算的结果之后将结果复制到vertexbuffer中，供后续渲染使用。但是其实后面我发现OpenGL中缓冲区是可以随时改变绑定目标的（毕竟缓冲区本身只是一块只记录了所存储数据的内存区域），那么何不将计算完成后的Storagebuffer重新绑定到<i><font color="Red">GL_ARRAY_BUFFER</font></i>后直接用于顶点缓冲呢？于是我就这么尝试了一下，发现确实可行，并且命令行也不再有任何警告信息了！如此黝黑寂静的命令行还真是让我感觉有点陌生了属于（笑。</p><hr><h2 id="问题6没有报错但黑屏">问题6：没有报错但黑屏</h2><p>在解决了命令行的调试信息之后，令人崩溃的是程序最终的显示结果仍然是黑屏。这种情况下一般就是渲染资源没有设置正确或者着色器效果不对什么的了，也是非常棘手的一类bug，因为它好像没有什么好的调试方法，只能挨个去判断设置的各个Uniform变量啥啥的值有没有问题之类的。事实上我最开始也就是按着这个思路做的，但并没能够找到任何蛛丝马迹，又是瞎忙活了快半天无功而反，也是给我整的十分emo。结果下午的时候我突然意识到，Vulkan的官方示例集中好像在设置渲染管线的时候是关闭了深度测试的，但是我并没有在我的程序中这么做。于是我赶快去试了试关闭深度缓冲，结果程序正常显示了！！！真是皇天不负有心人！当然我也并不能清楚地解释为什么关闭深度测试之后粒子就能够正常显示在屏幕上了（就算粒子之间会有遮挡关系我想至少也不应该是黑屏吧。。。），但是好在最后得到了正确的结果。当然，刚成功时的程序运行效果比现在的这个版本还要丑很多，效果不一致可能是因为在计算着色器中会使用程序一帧的运行时长<i><font color="Orange">delta_time</font></i>来计算当前帧粒子应该具有的速度和所在的位置，这个值在我的项目中当然和示例集可能会有很大的差距，最后得到的效果也就不尽相同。另外我的项目使用的窗口系统是<strong>glfw</strong>，而官方示例集是使用<strong>WindowsAPI</strong>编写的窗口系统，所以显示上可能也会有差距。并且我所使用的粒子纹理是截屏得到和，和真正示例集中使用的纹理相比肯定也会有一些不同。总之为了效果尽可能好看些，我稍微调整了一下着色器参数，虽然还是达不到示例集中的效果，但至少相比最初好看多了！</p><p>另外，其实在这之前还有个小插曲，就是开始时我发现自己无法调整渲染的粒子的大小，反复调整着色器中的<i><font color="Orange">gl_PointSize</font></i>好像并没有作用。后面我发现自己是没有在设置OpenGL渲染选项的时候启用<i><font color="Red">GL_PROGRAM_POINT_SIZE</font></i>，也是没谁了。。。</p><hr><h2 id="结语">结语</h2><p>终于是在经过几天的不懈努力之后得到了想要的结果，经历了项目从0到1的架构之后感觉自己也确实学到了不少。后续我还会为这个项目添加上<strong>imgui</strong>支持以支持窗口化显示一些渲染信息之类的，总之这都是后话了。新的一年，再接再厉吧！</p><p>最后放上我的程序运行结果：</p><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"loop":"yes","screenshot":"yes","video":{"url":"/2025/02/07/CG_api/openGL/VKSample_OGL/compute_nbody/compute_nbody.mp4"},"danmaku":{"api":"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><hr>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>OpenGL</category>
      
      <category>VKSample_OGL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文章汇总</title>
    <link href="/2025/01/24/articles/algo_techniques/%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB1/"/>
    <url>/2025/01/24/articles/algo_techniques/%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.从MVP矩阵构建视锥体：<a href="https://www.gamedevs.org/uploads/fast-extraction-viewing-frustum-planes-from-world-view-projection-matrix.pdf"><code>https://www.gamedevs.org/uploads/fast-extraction-viewing-frustum-planes-from-world-view-projection-matrix.pdf</code></a></p>]]></content>
    
    
    <categories>
      
      <category>articles</category>
      
      <category>algo_techniques</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Compute_nbody</title>
    <link href="/2025/01/24/CG_api/vulkan/vulkan_samples/compute_nbody/"/>
    <url>/2025/01/24/CG_api/vulkan/vulkan_samples/compute_nbody/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言">前言</h2><p>这几天终于完成了对Vulkan官方示例集中的Compute_nbody示例源码的阅读。该示例旨在利用计算着色器模拟一个简易的粒子效果。在阅读的过程中自己也厘清了不少之前比较模糊的概念，大佬们的文章无疑对我助益良多，文末会放上相应文章的链接。本文就将根据我自己的理解，浅浅分析一下这个示例的操作流程，后续我还会尝试实现该效果的OGL以及d3d11,d3d12版本。</p><hr><h2 id="效果">效果</h2><p>首先上视频，看看这个粒子效果~</p><div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"loop":"yes","screenshot":"yes","video":{"url":"/2025/01/24/CG_api/vulkan/vulkan_samples/compute_nbody/compute_nBody.mp4"},"danmaku":{"api":"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><hr><h2 id="流程概述">流程概述</h2><p>实现该粒子效果的流程主要分为四步：</p><ul><li>渲染前准备计算和渲染所需的资源</li><li>使用两个compute pass计算在新的一帧中粒子的位置与速度</li><li>使用一个graphics pass在屏幕上显示粒子效果</li><li>更新效果相关着色器常量</li></ul><p>接下来我们将一步步跟随源码来探究这四步流程之中的细节，尤其是其中较为复杂繁琐的同步设置。本示例对应源码文件为<strong>compute_nbody.cpp</strong>。</p><hr><h2 id="准备阶段">准备阶段</h2><p>准备工作流程由<i><font color="green">bool ComputeNBody::prepare(constvkb::ApplicationOptions&amp;options)</font></i>函数给出，该函数将在渲染循环开始之前运行，准备好渲染循环需要的图形和计算资源。函数源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ComputeNBody::prepare</span><span class="hljs-params">(<span class="hljs-type">const</span> vkb::ApplicationOptions &amp;options)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!ApiVulkanSample::<span class="hljs-built_in">prepare</span>(options))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>graphics.queue_family_index = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_family_index</span>(VK_QUEUE_GRAPHICS_BIT);<br>compute.queue_family_index  = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_family_index</span>(VK_QUEUE_COMPUTE_BIT);<br><br><span class="hljs-comment">// Not all implementations support a work group size of 256, so we need to check with the device limits</span><br>work_group_size = std::<span class="hljs-built_in">min</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(<span class="hljs-number">256</span>), <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_properties</span>().limits.maxComputeWorkGroupSize[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">// Same for shared data size for passing data between shader invocations</span><br>shared_data_size = std::<span class="hljs-built_in">min</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(<span class="hljs-number">1024</span>), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_properties</span>().limits.maxComputeSharedMemorySize / <span class="hljs-built_in">sizeof</span>(glm::vec4)));<br><br><span class="hljs-built_in">load_assets</span>();<br><span class="hljs-built_in">setup_descriptor_pool</span>();<br><span class="hljs-built_in">prepare_graphics</span>();<br><span class="hljs-built_in">prepare_compute</span>();<br><span class="hljs-built_in">build_command_buffers</span>();<br>prepared = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数开头首先调用<i><font color="green">ApiVulkanSample::prepare</font></i>。<strong>ComputeNBody</strong>类是继承自<strong>ApiVulkanSample</strong>类的，这里先调用基类的<i><font color="green">prepare</font></i>函数来准备好继承自该类的示例公用的图形管线所需的大部分资源，比如说帧缓冲、颜色深度附件、用于同步显示等渲染流程的信号量等。该函数不涉及到主要逻辑，我们只将其源码放在下面，后续用到相关资源时再提及：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ApiVulkanSample::prepare</span><span class="hljs-params">(<span class="hljs-type">const</span> vkb::ApplicationOptions &amp;options)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!VulkanSample::<span class="hljs-built_in">prepare</span>(options))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>depth_format = vkb::<span class="hljs-built_in">get_suitable_depth_format</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_handle</span>());<br><br><span class="hljs-comment">// Create synchronization objects</span><br>VkSemaphoreCreateInfo semaphore_create_info = vkb::initializers::<span class="hljs-built_in">semaphore_create_info</span>();<br><span class="hljs-comment">// Create a semaphore used to synchronize image presentation</span><br><span class="hljs-comment">// Ensures that the current swapchain render target has completed presentation and has been released by the presentation engine, ready for rendering</span><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateSemaphore</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;semaphore_create_info, <span class="hljs-literal">nullptr</span>, &amp;semaphores.acquired_image_ready));<br><span class="hljs-comment">// Create a semaphore used to synchronize command submission</span><br><span class="hljs-comment">// Ensures that the image is not presented until all commands have been sumbitted and executed</span><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateSemaphore</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;semaphore_create_info, <span class="hljs-literal">nullptr</span>, &amp;semaphores.render_complete));<br><br><span class="hljs-comment">// Set up submit info structure</span><br><span class="hljs-comment">// Semaphores will stay the same during application lifetime</span><br><span class="hljs-comment">// Command buffer submission info is set by each example</span><br>submit_info                   = vkb::initializers::<span class="hljs-built_in">submit_info</span>();<br>submit_info.pWaitDstStageMask = &amp;submit_pipeline_stages;<br><br><span class="hljs-keyword">if</span> (window-&gt;<span class="hljs-built_in">get_window_mode</span>() != vkb::Window::Mode::Headless)<br>&#123;<br>submit_info.waitSemaphoreCount   = <span class="hljs-number">1</span>;<br>submit_info.pWaitSemaphores      = &amp;semaphores.acquired_image_ready;<br>submit_info.signalSemaphoreCount = <span class="hljs-number">1</span>;<br>submit_info.pSignalSemaphores    = &amp;semaphores.render_complete;<br>&#125;<br><br>queue = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_suitable_graphics_queue</span>().<span class="hljs-built_in">get_handle</span>();<br><br><span class="hljs-built_in">create_swapchain_buffers</span>();<br><span class="hljs-built_in">create_command_pool</span>();<br><span class="hljs-built_in">create_command_buffers</span>();<br><span class="hljs-built_in">create_synchronization_primitives</span>();<br><span class="hljs-built_in">setup_depth_stencil</span>();<br><span class="hljs-built_in">setup_render_pass</span>();<br><span class="hljs-built_in">create_pipeline_cache</span>();<br><span class="hljs-built_in">setup_framebuffer</span>();<br><br>width  = <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_surface_extent</span>().width;<br>height = <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_surface_extent</span>().height;<br><br><span class="hljs-built_in">prepare_gui</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来的两行用于查询并设置图形和计算命令各自提交队列的索引。这里用到的两个结构体<i><font color="Orange">graphics</font></i>和<i><font color="Orange">compute</font></i>分别存储了图形和计算阶段需要的各种资源，下面是它们的定义，后续关于图形和计算的操作都是基于这两个结构体内容进行的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span><br>&#123;<br>std::unique_ptr&lt;vkb::core::BufferC&gt; uniform_buffer;               <span class="hljs-comment">// Contains scene matrices</span><br>VkDescriptorSetLayout               descriptor_set_layout;        <span class="hljs-comment">// Particle system rendering shader binding layout</span><br>VkDescriptorSet                     descriptor_set;               <span class="hljs-comment">// Particle system rendering shader bindings</span><br>VkPipelineLayout                    pipeline_layout;              <span class="hljs-comment">// Layout of the graphics pipeline</span><br>VkPipeline                          pipeline;                     <span class="hljs-comment">// Particle rendering pipeline</span><br>VkSemaphore                         semaphore;                    <span class="hljs-comment">// Execution dependency between compute &amp; graphic submission</span><br><span class="hljs-type">uint32_t</span>                            queue_family_index;<br><span class="hljs-keyword">struct</span><br>&#123;<br>glm::mat4 projection;<br>glm::mat4 view;<br>glm::vec2 screenDim;<br>&#125; ubo;<br>&#125; graphics;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">struct</span><br>&#123;<br>std::unique_ptr&lt;vkb::core::BufferC&gt; storage_buffer;               <span class="hljs-comment">// (Shader) storage buffer object containing the particles</span><br>std::unique_ptr&lt;vkb::core::BufferC&gt; uniform_buffer;               <span class="hljs-comment">// Uniform buffer object containing particle system parameters</span><br>VkQueue                             queue;                        <span class="hljs-comment">// Separate queue for compute commands (queue family may differ from the one used for graphics)</span><br>VkCommandPool                       command_pool;                 <span class="hljs-comment">// Use a separate command pool (queue family may differ from the one used for graphics)</span><br>VkCommandBuffer                     command_buffer;               <span class="hljs-comment">// Command buffer storing the dispatch commands and barriers</span><br>VkSemaphore                         semaphore;                    <span class="hljs-comment">// Execution dependency between compute &amp; graphic submission</span><br>VkDescriptorSetLayout               descriptor_set_layout;        <span class="hljs-comment">// Compute shader binding layout</span><br>VkDescriptorSet                     descriptor_set;               <span class="hljs-comment">// Compute shader bindings</span><br>VkPipelineLayout                    pipeline_layout;              <span class="hljs-comment">// Layout of the compute pipeline</span><br>VkPipeline                          pipeline_calculate;           <span class="hljs-comment">// Compute pipeline for N-Body velocity calculation (1st pass)</span><br>VkPipeline                          pipeline_integrate;           <span class="hljs-comment">// Compute pipeline for euler integration (2nd pass)</span><br>VkPipeline                          blur;<br>VkPipelineLayout                    pipeline_layout_blur;<br>VkDescriptorSetLayout               descriptor_set_layout_blur;<br>VkDescriptorSet                     descriptor_set_blur;<br><span class="hljs-type">uint32_t</span>                            queue_family_index;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ComputeUBO</span><br>&#123;                              <span class="hljs-comment">// Compute shader uniform block object</span><br><span class="hljs-type">float</span>   delta_time;        <span class="hljs-comment">//Frame delta time</span><br><span class="hljs-type">int32_t</span> particle_count;<br>&#125; ubo;<br>&#125; compute;<br></code></pre></td></tr></table></figure><p>接下来同样需要查询的是硬件所允许的计算工作组大小<i><font color="Orange">work_group_size</font></i>以及一个工作组内共享数据区域的大小<i><font color="Orange">shared_data_size</font></i>（以<strong>glm::vec4</strong>大小为单位）。注意，由于本程序只需要划分一维工作组，所以只需要查询一维工作组大小即可。通过添加打印语句可以发现在我的设备上这两个查询值分别为<strong>1024</strong>和<strong>3072</strong>《所以最后这两个变量值分别为<strong>256</strong>和<strong>1024</strong>。</p><p>下面函数通过调用一组工具函数完成整个准备阶段，我们分别来看每一个函数都做了什么：</p><h3 id="加载纹理资源">加载纹理资源</h3><p>接下来函数将加载粒子的颜色纹理和渐变纹理，这通过<i><font color="Green">voidload_assets()</font></i>函数完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::load_assets</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>textures.particle = <span class="hljs-built_in">load_texture</span>(<span class="hljs-string">&quot;textures/particle_rgba.ktx&quot;</span>, vkb::sg::Image::Color);<br>textures.gradient = <span class="hljs-built_in">load_texture</span>(<span class="hljs-string">&quot;textures/particle_gradient_rgba.ktx&quot;</span>, vkb::sg::Image::Color);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数调用了基类中的<i><font color="Green">load_texture</font></i>函数来进行图片的加载，这里不会介绍该工具函数的具体逻辑，后续在分析官方示例集架构的技术细节的时候可能会单独分析以下这些实现细节，现在暂且按下不表~</p><p><code>.ktx</code> 文件是一种用于存储纹理数据的文件格式，全称为<strong>Khronos Texture</strong>。它由 Khronos Group 定义，主要用于OpenGL 和 Vulkan 等图形 API 中，以便高效地加载和使用纹理。</p><p>本来想着使用Khronos Group提供的KTXTools来加载一下这两张图片看看，结果一用发现KTXTools竟然只支持加载ktx2文件（有被无语到。。。然后又试了试其它线上的KTX文件加载工具，竟然都不能把这个示例中用到的文件转换成png或其它可直接浏览的图像格式（什么鬼。。。然后我就想着要么手动写一个OpenGL程序用来解析并显示KTX文件，但在我稍微浏览了一下<i><font color="Orange">load_texture</font></i>函数对KTX文件的加载实现之后果断放弃了（别问，问就是太长不愿看。正当束手无策之际，我不经意间发现Vulkan官方示例集的代码仓库中竟然就有一个<strong>texture_loading</strong>示例！简直救了老命，稍微梳理了一下这个示例的实现后，我将示例中用到的纹理分别修改为<strong>particle_rgba.ktx</strong>和<strong>particle_gradient_rgba.ktx</strong>，然后终于显示出了这两张图片的庐山真面目。。。如下图：</p><figure><img src="/2025/01/24/CG_api/vulkan/vulkan_samples/compute_nbody/color.png" alt="particle_rgba"><figcaption aria-hidden="true">particle_rgba</figcaption></figure><figure><img src="/2025/01/24/CG_api/vulkan/vulkan_samples/compute_nbody/gradient.png" alt="particle_gradient_rgba"><figcaption aria-hidden="true">particle_gradient_rgba</figcaption></figure><p>好了，闲话少说，让我们继续探索源码~</p><hr><h3 id="构建描述符池">构建描述符池</h3><p>在纹理加载完毕后，紧接着<i><font color="Green">prepare</font></i>函数开始构建描述符池。描述符池对象本身位于基类中，是所有示例所公用的。<i><font color="Green">voidsetup_descriptor_pool()</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::setup_descriptor_pool</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//要注意，pool_sizes描述的是描述符的数量，而不是描述符集的数量</span><br>std::vector&lt;VkDescriptorPoolSize&gt; pool_sizes =<br>    &#123;<br>        vkb::initializers::<span class="hljs-built_in">descriptor_pool_size</span>(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">2</span>),<br>        vkb::initializers::<span class="hljs-built_in">descriptor_pool_size</span>(VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, <span class="hljs-number">1</span>),<br>        vkb::initializers::<span class="hljs-built_in">descriptor_pool_size</span>(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="hljs-number">2</span>)&#125;;<br><br>VkDescriptorPoolCreateInfo descriptor_pool_create_info =<br>    vkb::initializers::<span class="hljs-built_in">descriptor_pool_create_info</span>(<br>        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(pool_sizes.<span class="hljs-built_in">size</span>()),<br>        pool_sizes.<span class="hljs-built_in">data</span>(),<br>        <span class="hljs-number">2</span>);<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorPool</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_pool_create_info, <span class="hljs-literal">nullptr</span>, &amp;descriptor_pool));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，该示例需要分配两个Uniform buffer，一个Storagebuffer和两个组合图像采样器，其中两个Uniformbuffer分别对应于<i><font color="Orange">graphics</font></i>和<i><font color="Orange">compute</font></i>结构体中的两个ubo对象，Storagebuffer用于储存计算着色器的输出结果并用于图形管线顶点着色器的输入，两个组合图像采样器分别用于片段着色器采样上文加载的两张图片。</p><hr><h3 id="准备图形资源">准备图形资源</h3><p>接下来开始准备图形管线需要的资源，<i><font color="Orange">voidprepare_graphics()</font></i>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::prepare_graphics</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">prepare_storage_buffers</span>();<br><span class="hljs-built_in">prepare_uniform_buffers</span>();<br><span class="hljs-built_in">setup_descriptor_set_layout</span>();<br><span class="hljs-built_in">prepare_pipelines</span>();<br><span class="hljs-built_in">setup_descriptor_set</span>();<br><br><span class="hljs-comment">// Semaphore for compute &amp; graphics sync</span><br>VkSemaphoreCreateInfo semaphore_create_info = vkb::initializers::<span class="hljs-built_in">semaphore_create_info</span>();<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateSemaphore</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;semaphore_create_info, <span class="hljs-literal">nullptr</span>, &amp;graphics.semaphore));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，该函数流程分为如下几步：</p><ul><li>准备Storage buffer</li><li>准备图形的Uniform buffer</li><li>设置好图形管线的描述符布局</li><li>构建图形渲染管线</li><li>设置好图形所用描述符资源</li><li>构建用于图形—计算同步的信号量</li></ul><p>我们分别来看这些操作：</p><h4 id="准备storage-buffer">准备Storage buffer</h4><p>先上<i><font color="Orange">prepare_storage_buffer</font></i>函数代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::prepare_storage_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>std::vector&lt;glm::vec3&gt; attractors = &#123;<br>glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">2.5f</span>, <span class="hljs-number">1.5f</span>, <span class="hljs-number">0.0f</span>),<br>glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">-2.5f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">0.0f</span>),<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>std::vector&lt;glm::vec3&gt; attractors = &#123;<br>    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">5.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>),<br>    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">-5.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>),<br>    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">5.0f</span>),<br>    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-5.0f</span>),<br>    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">4.0f</span>, <span class="hljs-number">0.0f</span>),<br>    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">-8.0f</span>, <span class="hljs-number">0.0f</span>),<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>num_particles = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attractors.<span class="hljs-built_in">size</span>()) * PARTICLES_PER_ATTRACTOR;<br><br><span class="hljs-comment">// Initial particle positions</span><br><span class="hljs-function">std::vector&lt;Particle&gt; <span class="hljs-title">particle_buffer</span><span class="hljs-params">(num_particles)</span></span>;<br><br><span class="hljs-function">std::default_random_engine      <span class="hljs-title">rnd_engine</span><span class="hljs-params">(lock_simulation_speed ? <span class="hljs-number">0</span> : <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-type">unsigned</span>&gt;(time(<span class="hljs-literal">nullptr</span>)))</span></span>;<br><span class="hljs-function">std::normal_distribution&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">rnd_distribution</span><span class="hljs-params">(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>)</span></span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attractors.<span class="hljs-built_in">size</span>()); i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> j = <span class="hljs-number">0</span>; j &lt; PARTICLES_PER_ATTRACTOR; j++)<br>&#123;<br>Particle &amp;particle = particle_buffer[i * PARTICLES_PER_ATTRACTOR + j];<br><br><span class="hljs-comment">// First particle in group as heavy center of gravity</span><br><span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)<br>&#123;<br>particle.pos = glm::<span class="hljs-built_in">vec4</span>(attractors[i] * <span class="hljs-number">1.5f</span>, <span class="hljs-number">90000.0f</span>);<br>particle.vel = glm::<span class="hljs-built_in">vec4</span>(glm::<span class="hljs-built_in">vec4</span>(<span class="hljs-number">0.0f</span>));<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">// Position</span><br>glm::vec3 <span class="hljs-built_in">position</span>(attractors[i] + glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-built_in">rnd_distribution</span>(rnd_engine), <span class="hljs-built_in">rnd_distribution</span>(rnd_engine), <span class="hljs-built_in">rnd_distribution</span>(rnd_engine)) * <span class="hljs-number">0.75f</span>);<br><span class="hljs-type">float</span>     len = glm::<span class="hljs-built_in">length</span>(glm::<span class="hljs-built_in">normalize</span>(position - attractors[i]));<br>position.y *= <span class="hljs-number">2.0f</span> - (len * len);<br><br><span class="hljs-comment">// Velocity</span><br>glm::vec3 angular  = glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.5f</span>, <span class="hljs-number">1.5f</span>, <span class="hljs-number">0.5f</span>) * (((i % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>) ? <span class="hljs-number">1.0f</span> : <span class="hljs-number">-1.0f</span>);<br>glm::vec3 velocity = glm::<span class="hljs-built_in">cross</span>((position - attractors[i]), angular) + glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-built_in">rnd_distribution</span>(rnd_engine), <span class="hljs-built_in">rnd_distribution</span>(rnd_engine), <span class="hljs-built_in">rnd_distribution</span>(rnd_engine) * <span class="hljs-number">0.025f</span>);<br><br><span class="hljs-type">float</span> mass   = (<span class="hljs-built_in">rnd_distribution</span>(rnd_engine) * <span class="hljs-number">0.5f</span> + <span class="hljs-number">0.5f</span>) * <span class="hljs-number">75.0f</span>;<br>particle.pos = glm::<span class="hljs-built_in">vec4</span>(position, mass);<br>particle.vel = glm::<span class="hljs-built_in">vec4</span>(velocity, <span class="hljs-number">0.0f</span>);<br>&#125;<br><br><span class="hljs-comment">// Color gradient offset</span><br>particle.vel.w = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(i) * <span class="hljs-number">1.0f</span> / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attractors.<span class="hljs-built_in">size</span>());<br>&#125;<br>&#125;<br><br>compute.ubo.particle_count = num_particles;<br><br>VkDeviceSize storage_buffer_size = particle_buffer.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(Particle);<br><br><span class="hljs-comment">// Staging</span><br><span class="hljs-comment">// SSBO won&#x27;t be changed on the host after upload so copy to device local memory</span><br>vkb::core::BufferC staging_buffer = vkb::core::BufferC::<span class="hljs-built_in">create_staging_buffer</span>(<span class="hljs-built_in">get_device</span>(), particle_buffer);<br><br>compute.storage_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(),<br>                                                              storage_buffer_size,<br>                                                              VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT,<br>                                                              VMA_MEMORY_USAGE_GPU_ONLY);<br><br><span class="hljs-comment">// Copy from staging buffer to storage buffer</span><br>VkCommandBuffer copy_command = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">create_command_buffer</span>(VK_COMMAND_BUFFER_LEVEL_PRIMARY, <span class="hljs-literal">true</span>);<br>VkBufferCopy    copy_region  = &#123;&#125;;<br>copy_region.size             = storage_buffer_size;<br><span class="hljs-built_in">vkCmdCopyBuffer</span>(copy_command, staging_buffer.<span class="hljs-built_in">get_handle</span>(), compute.storage_buffer-&gt;<span class="hljs-built_in">get_handle</span>(), <span class="hljs-number">1</span>, &amp;copy_region);<br><span class="hljs-comment">// Execute a transfer to the compute queue, if necessary</span><br><span class="hljs-keyword">if</span> (graphics.queue_family_index != compute.queue_family_index)<br>&#123;<br>VkBufferMemoryBarrier buffer_barrier =<br>    &#123;<br>        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,<br>        <span class="hljs-literal">nullptr</span>,<br>        VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,<br>        <span class="hljs-number">0</span>,<br>        graphics.queue_family_index,<br>        compute.queue_family_index,<br>        compute.storage_buffer-&gt;<span class="hljs-built_in">get_handle</span>(),<br>        <span class="hljs-number">0</span>,<br>        compute.storage_buffer-&gt;<span class="hljs-built_in">get_size</span>()&#125;;<br><br><span class="hljs-built_in">vkCmdPipelineBarrier</span>(<br>    copy_command,<br>    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,<br>    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>    <span class="hljs-number">1</span>, &amp;buffer_barrier,<br>    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>&#125;<br><br><span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">flush_command_buffer</span>(copy_command, queue, <span class="hljs-literal">true</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最开始的一大段逻辑用于在CPU端初始化Storagebuffer一开始会存储的数据，也就是粒子的初始位置和速度，暂时存储在<i><font color="Orange">particle_buffer</font></i>对象中。位置和速度具体值的计算我并没有细看，也不会详细解释，因为这部分只会影响到最后粒子系统的视觉效果，和本示例的逻辑框架本身没什么联系，有兴趣的读者当然也可以自行定义这些量来达到不一样的效果。这里唯一需要注意的点是为了更好的存储效率和空间利用率，粒子的位置向量实际上存储为一个4维的向量，它的w坐标用于存储粒子的质量，这个质量会影响粒子的运动表现（可以参阅后文的着色器代码）。另外，速度向量同样为一个四维向量，w坐标此时用于存储这个粒子的颜色在颜色梯度图中的偏移，这会影响粒子颜色的采样结果，最终获得上文视频中那样五彩斑斓的效果（同样参阅后文着色器代码）。</p><p>然后，该函数顺带手就将<i><font color="Orange">compute</font></i>结构体中的粒子数量给设定好了。虽然这理应由之后准备计算阶段资源的函数设定，不过既然Storagebuffer由<i><font color="Orange">prepare_storage_buffer</font></i>函数准备，那么在这里就设定好这个数量显然更方便。</p><p>接下来就是常规的构建Storagebuffer流程了，也就是先构建一个临时缓冲区，将CPU端数据先上传至临时缓冲区中，然后创建一个仅供GPU使用的Storagebuffer，将临时缓冲区中的数据复制到Storagebuffer中去。当然，在Vulkan中缓冲区的复制操作需要启动一个命令缓冲来录制相应复制命令并提交执行。这部分不需要过多解释了，有不清楚这一部分细节的读者可以参考<a href="https://vulkan-tutorial.com/"><code>Vulkan Tutorial</code></a>中的对应教程或者<a href="https://zpc-dsg.github.io/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/"><code>我的博客</code></a>中对该教程这部分内容的翻译和分析。</p><p>最后，该函数判断图形队列和计算队列的队列家族是否是同一个，如果是同一个，就不需要对Storagebuffer进行繁琐的归属权转移工作了（因为Storagebuffer在创建时的共享模式是设定为<i><font color="Red">VK_SHARING_MODE_EXCLUSIVE</font></i>的，这意味着当不同的队列使用它的时候它的队列归属权需要转移给将要使用它的队列），不过显然大多数情况下这两个队列是处在不同的队列家族的（至少在我的电脑上是这样），那么归属权就要发生转移。关于队列归属权的转移，<a href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-queue-transfers"><code>Vulkan官方文档7.7.4节</code></a>给出了十分清晰且全面的解释（不过这里想吐槽一下的是我的电脑每次打开官方文档页面都会卡死然后崩掉，不知道是电脑的原因还是官方页面的问题。。。如果有和我有同样问题的小伙伴建议直接下载pdf文档离线阅读~），概括地说该操作需要注意的点大致就是一个归属权的转移操作包括两部分：原队列的释放操作和目标队列的获取操作，而且这两个操作必须要配对进行。队列归属权的转移会发生在源阶段的所有指定写操作变得available和内存对等待阶段指定的操作变得visible这两个时间节点之间。关于available和visible以及更多关于Vulkan中同步有关的内容，<a href="https://themaister.net/blog/2019/08/14/yet-another-blog-explaining-vulkan-synchronization/"><code>这篇文章</code></a>提供了一个非常清晰易懂且详实的说明，十分具有参考价值！（虽然我不清楚文章中说<strong>VkBufferMemoryBarrier</strong>是个废物应该作何理解，至少在这个官方示例中内存屏障一直使用的这个。。。另外之后我可能也会考虑翻译一下这一篇文章吧，对初学者而言还是十分友好的）另外需要注意的是，在上文代码的释放归属权操作中目标阶段的<strong>accessmask</strong>被设置为了0，即不需要指定任何在目标阶段可能需要访问资源的操作，这是合理的，因为毕竟我们并不需要在原队列上继续对该资源有什么操作，归属权已经转移了（事实上根据官方文档所述，目标阶段的<strong>accessmask</strong>也可以取非零值，只不过实际上没有任何作用。另外，同理可知在目标队列获取归属权的时候也无需设置源阶段的<strong>accessmask</strong>，因为源阶段并没有对资源执行任何写操作，资源是从别的地方转移来的）。</p><p>终于，Storaage buffer准备就绪！</p><hr><h4 id="准备uniform-buffer">准备Uniform buffer</h4><p>接下来程序开始准备图形和计算所需的Uniform buffer。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::prepare_uniform_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// Compute shader uniform buffer block</span><br>compute.uniform_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(),<br>                                                              <span class="hljs-built_in">sizeof</span>(compute.ubo),<br>                                                              VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,<br>                                                              VMA_MEMORY_USAGE_CPU_TO_GPU);<br><br><span class="hljs-comment">// Vertex shader uniform buffer block</span><br>graphics.uniform_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(),<br>                                                               <span class="hljs-built_in">sizeof</span>(graphics.ubo),<br>                                                               VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,<br>                                                               VMA_MEMORY_USAGE_CPU_TO_GPU);<br><span class="hljs-comment">//上面的buffer创建均使用VMA(Vulkan Memory allocator)来分配内存</span><br><br><span class="hljs-built_in">update_compute_uniform_buffers</span>(<span class="hljs-number">1.0f</span>);<br><span class="hljs-built_in">update_graphics_uniform_buffers</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码就十分简单易懂了，无非就是创建好图形和计算各自的Uniformbuffer，然后赋予这两个缓冲区初始时的数据。完整起见<i><font color="Green">update_compute_uniform_buffer</font></i>和<i><font color="Green">update_graphics_uniform_buffer</font></i>的代码也放在下面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::update_compute_uniform_buffers</span><span class="hljs-params">(<span class="hljs-type">float</span> delta_time)</span></span><br><span class="hljs-function"></span>&#123;<br>compute.ubo.delta_time = paused ? <span class="hljs-number">0.0f</span> : delta_time;<br>compute.uniform_buffer-&gt;<span class="hljs-built_in">convert_and_update</span>(compute.ubo);<span class="hljs-comment">//简单地将新的ubo数据逐字节复制到uniform buffer中</span><br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::update_graphics_uniform_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>graphics.ubo.projection = camera.matrices.perspective;<br>graphics.ubo.view       = camera.matrices.view;<br>graphics.ubo.screenDim  = glm::<span class="hljs-built_in">vec2</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(height));<br>graphics.uniform_buffer-&gt;<span class="hljs-built_in">convert_and_update</span>(graphics.ubo);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里<i><font color="Orange">convert_and_update</font></i>是类外的一个函数，负责将更新后的数据复制到缓冲区中，我们在这里不会过多探讨这些工具函数的细节，只需要大致知道它是做什么的就行了，后续如果有时间的话我会令开一个系列的文章来研究官方示例集的程序架构有关细节。</p><hr><h4 id="设置描述符集布局">设置描述符集布局</h4><p>接下来函数开始设置图形管线所需的描述符集布局。我们已经知道图形管线需要两个图形采样器和一个Uniformbuffer，所以描述符集布局的设置也是十分易于理解的。相应的<i><font color="Green">setup_descriptor_set_layout</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::setup_descriptor_set_layout</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::vector&lt;VkDescriptorSetLayoutBinding&gt; set_layout_bindings;<br>set_layout_bindings = &#123;<br>    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT, <span class="hljs-number">0</span>),<br>    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT, <span class="hljs-number">1</span>),<br>    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_SHADER_STAGE_VERTEX_BIT, <span class="hljs-number">2</span>),<br>&#125;;<br><br>VkDescriptorSetLayoutCreateInfo descriptor_layout =<br>    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_create_info</span>(<br>        set_layout_bindings.<span class="hljs-built_in">data</span>(),<br>        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(set_layout_bindings.<span class="hljs-built_in">size</span>()));<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorSetLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_layout, <span class="hljs-literal">nullptr</span>, &amp;graphics.descriptor_set_layout));<br><br>VkPipelineLayoutCreateInfo pipeline_layout_create_info =<br>    vkb::initializers::<span class="hljs-built_in">pipeline_layout_create_info</span>(<br>        &amp;graphics.descriptor_set_layout,<br>        <span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreatePipelineLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;pipeline_layout_create_info, <span class="hljs-literal">nullptr</span>, &amp;graphics.pipeline_layout));<br>&#125;<br></code></pre></td></tr></table></figure><p>在创建好描述符集布局之后顺带手也将管线布局给设置好了。这个示例的图形管线布局只需要指定描述符集布局而不需要指定Pushconstant，所以只需要将先前创建好的描述符集布局喂给管线布局就好了。</p><hr><h4 id="创建图形管线">创建图形管线</h4><p>然后就是图形管线的创建部分代码了。这段代码确实很长，但是所有管线阶段的设置都十分常规，在这里我不会做过多的解释，只会着重分析一下图形管线着色器阶段所用的顶点和片段着色器的代码。如果对这部分不了解的同学也不用慌，可以参考我<a href="https://zpc-dsg.github.io/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/"><code>之前关于渲染管线的部分文章</code></a>，对管线构建过程有十分详细的说明。</p><p>代码同样放在下面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::prepare_pipelines</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>VkPipelineInputAssemblyStateCreateInfo input_assembly_state =<br>    vkb::initializers::<span class="hljs-built_in">pipeline_input_assembly_state_create_info</span>(<br>        VK_PRIMITIVE_TOPOLOGY_POINT_LIST,<br>        <span class="hljs-number">0</span>,<br>        VK_FALSE);<br><br>VkPipelineRasterizationStateCreateInfo rasterization_state =<br>    vkb::initializers::<span class="hljs-built_in">pipeline_rasterization_state_create_info</span>(<br>        VK_POLYGON_MODE_FILL,<br>        VK_CULL_MODE_NONE,<br>        VK_FRONT_FACE_COUNTER_CLOCKWISE,<br>        <span class="hljs-number">0</span>);<br><br>VkPipelineColorBlendAttachmentState blend_attachment_state =<br>    vkb::initializers::<span class="hljs-built_in">pipeline_color_blend_attachment_state</span>(<br>        <span class="hljs-number">0xf</span>,<br>        VK_FALSE);<br><br>VkPipelineColorBlendStateCreateInfo color_blend_state =<br>    vkb::initializers::<span class="hljs-built_in">pipeline_color_blend_state_create_info</span>(<br>        <span class="hljs-number">1</span>,<br>        &amp;blend_attachment_state);<br><br>VkPipelineDepthStencilStateCreateInfo depth_stencil_state =<br>    vkb::initializers::<span class="hljs-built_in">pipeline_depth_stencil_state_create_info</span>(<br>        VK_FALSE,<br>        VK_FALSE,<br>        VK_COMPARE_OP_ALWAYS);<br><br>VkPipelineViewportStateCreateInfo viewport_state =<br>    vkb::initializers::<span class="hljs-built_in">pipeline_viewport_state_create_info</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><br>VkPipelineMultisampleStateCreateInfo multisample_state =<br>    vkb::initializers::<span class="hljs-built_in">pipeline_multisample_state_create_info</span>(<br>        VK_SAMPLE_COUNT_1_BIT,<br>        <span class="hljs-number">0</span>);<br><br>std::vector&lt;VkDynamicState&gt; dynamic_state_enables = &#123;<br>    VK_DYNAMIC_STATE_VIEWPORT,<br>    VK_DYNAMIC_STATE_SCISSOR&#125;;<br>VkPipelineDynamicStateCreateInfo dynamicState =<br>    vkb::initializers::<span class="hljs-built_in">pipeline_dynamic_state_create_info</span>(<br>        dynamic_state_enables.<span class="hljs-built_in">data</span>(),<br>        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(dynamic_state_enables.<span class="hljs-built_in">size</span>()),<br>        <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// Rendering pipeline</span><br><span class="hljs-comment">// Load shaders</span><br>std::array&lt;VkPipelineShaderStageCreateInfo, 2&gt; shader_stages;<br><br>shader_stages[<span class="hljs-number">0</span>] = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;compute_nbody&quot;</span>, <span class="hljs-string">&quot;particle.vert&quot;</span>, VK_SHADER_STAGE_VERTEX_BIT);<br>shader_stages[<span class="hljs-number">1</span>] = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;compute_nbody&quot;</span>, <span class="hljs-string">&quot;particle.frag&quot;</span>, VK_SHADER_STAGE_FRAGMENT_BIT);<br><br><span class="hljs-comment">// Vertex bindings and attributes</span><br><span class="hljs-type">const</span> std::vector&lt;VkVertexInputBindingDescription&gt; vertex_input_bindings = &#123;<br>    vkb::initializers::<span class="hljs-built_in">vertex_input_binding_description</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Particle), VK_VERTEX_INPUT_RATE_VERTEX),<br>&#125;;<br><span class="hljs-type">const</span> std::vector&lt;VkVertexInputAttributeDescription&gt; vertex_input_attributes = &#123;<br>    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, VK_FORMAT_R32G32B32A32_SFLOAT, <span class="hljs-built_in">offsetof</span>(Particle, pos)),<br>    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, VK_FORMAT_R32G32B32A32_SFLOAT, <span class="hljs-built_in">offsetof</span>(Particle, vel))&#125;;<br>VkPipelineVertexInputStateCreateInfo vertex_input_state = vkb::initializers::<span class="hljs-built_in">pipeline_vertex_input_state_create_info</span>();<br>vertex_input_state.vertexBindingDescriptionCount        = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertex_input_bindings.<span class="hljs-built_in">size</span>());<br>vertex_input_state.pVertexBindingDescriptions           = vertex_input_bindings.<span class="hljs-built_in">data</span>();<br>vertex_input_state.vertexAttributeDescriptionCount      = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertex_input_attributes.<span class="hljs-built_in">size</span>());<br>vertex_input_state.pVertexAttributeDescriptions         = vertex_input_attributes.<span class="hljs-built_in">data</span>();<br><br>VkGraphicsPipelineCreateInfo pipeline_create_info =<br>    vkb::initializers::<span class="hljs-built_in">pipeline_create_info</span>(<br>        graphics.pipeline_layout,<br>        render_pass,<br>        <span class="hljs-number">0</span>);<br><br>pipeline_create_info.pVertexInputState   = &amp;vertex_input_state;<br>pipeline_create_info.pInputAssemblyState = &amp;input_assembly_state;<br>pipeline_create_info.pRasterizationState = &amp;rasterization_state;<br>pipeline_create_info.pColorBlendState    = &amp;color_blend_state;<br>pipeline_create_info.pMultisampleState   = &amp;multisample_state;<br>pipeline_create_info.pViewportState      = &amp;viewport_state;<br>pipeline_create_info.pDepthStencilState  = &amp;depth_stencil_state;<br>pipeline_create_info.pDynamicState       = &amp;dynamicState;<br>pipeline_create_info.stageCount          = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(shader_stages.<span class="hljs-built_in">size</span>());<br>pipeline_create_info.pStages             = shader_stages.<span class="hljs-built_in">data</span>();<br>pipeline_create_info.renderPass          = render_pass;<br><br><span class="hljs-comment">// Additive blending</span><br>blend_attachment_state.colorWriteMask      = <span class="hljs-number">0xF</span>;<br>blend_attachment_state.blendEnable         = VK_TRUE;<br>blend_attachment_state.colorBlendOp        = VK_BLEND_OP_ADD;<br>blend_attachment_state.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;<br>blend_attachment_state.dstColorBlendFactor = VK_BLEND_FACTOR_ONE;<br>blend_attachment_state.alphaBlendOp        = VK_BLEND_OP_ADD;<br>blend_attachment_state.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;<br>blend_attachment_state.dstAlphaBlendFactor = VK_BLEND_FACTOR_DST_ALPHA;<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateGraphicsPipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;graphics.pipeline));<br><span class="hljs-comment">//pipeline cache参考另一个sample,文档为 https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/performance/pipeline_cache</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么下面我们来看一下顶点着色器和片段着色器的代码。事实上官方示例给的着色器文件glsl和hlsl版本的都有，不过出于glsl还是和Vulkan更适配的原因，这里仅给出glsl着色器代码，有兴趣的读者完全可以自行翻阅示例源文件~</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> inPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> inVel;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">float</span> outGradientPos;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">uniform</span> UBO <br>&#123;<br><span class="hljs-type">mat4</span> projection;<br><span class="hljs-type">mat4</span> modelview;<br><span class="hljs-type">vec2</span> screendim;<br>&#125; ubo;<br><br><span class="hljs-keyword">out</span> gl_PerVertex<br>&#123;<br><span class="hljs-type">vec4</span> <span class="hljs-built_in">gl_Position</span>;<br><span class="hljs-type">float</span> <span class="hljs-built_in">gl_PointSize</span>;<br>&#125;;<br><br><span class="hljs-type">void</span> main () <br>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-type">float</span> spriteSize = <span class="hljs-number">0.005</span> * inPos.w; <span class="hljs-comment">// Point size influenced by mass (stored in inPos.w);</span><br><br><span class="hljs-type">vec4</span> eyePos = ubo.modelview * <span class="hljs-type">vec4</span>(inPos.x, inPos.y, inPos.z, <span class="hljs-number">1.0</span>); <br><span class="hljs-type">vec4</span> projectedCorner = ubo.projection * <span class="hljs-type">vec4</span>(<span class="hljs-number">0.5</span> * spriteSize, <span class="hljs-number">0.5</span> * spriteSize, eyePos.z, eyePos.w);<br><span class="hljs-built_in">gl_PointSize</span> = <span class="hljs-built_in">clamp</span>(ubo.screendim.x * projectedCorner.x / projectedCorner.w, <span class="hljs-number">1.0</span>, <span class="hljs-number">128.0</span>);<br><br><span class="hljs-built_in">gl_Position</span> = ubo.projection * eyePos;<br><br>outGradientPos = inVel.w;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> samplerColorMap;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> samplerGradientRamp;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">float</span> inGradientPos;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outFragColor;<br><br><span class="hljs-type">void</span> main () <br>&#123;<br><span class="hljs-type">vec3</span> color = <span class="hljs-built_in">texture</span>(samplerGradientRamp, <span class="hljs-type">vec2</span>(inGradientPos, <span class="hljs-number">0.0</span>)).rgb;<br>outFragColor.rgb = <span class="hljs-built_in">texture</span>(samplerColorMap, <span class="hljs-built_in">gl_PointCoord</span>).rgb * color;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先对于顶点着色器，它会根据每个粒子的质量决定粒子在屏幕上绘制点的大小。由于我们之前是将粒子的质量存储在位置向量的第四个分量中，所以只需取位置向量的w分量即可获得质量大小。</p><p>之后代码通过一些逻辑来真正计算点的大小。需要注意的是，在对点的观察空间大小进行了投射变换之后，然后再进行透视除法，其实就相当于求出了在NDC空间中点的相对大小，也就是点大小与屏幕宽度的比值。而<i><font color="Orange">gl_PointSize</font></i>描述的是屏幕空间中点所占像素数量，因此我们还需要对点的相对大小乘以一个屏幕宽度（从上文对图形Uniformbuffer的设置代码可知这个宽度通过<i><font color="Orange">screendim.x</font></i>给出。）。最后，顶点着色器将粒子在梯度图中的颜色坐标（这存储在速度向量的第四个分量中）传递给片段着色器供其使用。</p><p>片段着色器的代码是十分简单易懂的，就是两次采样纹理获得粒子的最终颜色。首先通过顶点着色器传递而来的梯度图坐标采样得到粒子的颜色（从上文的图像可以看出梯度图虽说是二维的，但是y方向的颜色值始终是相同的，所以采样的时候可以忽略y坐标），然后再乘以由另一个纹理给出的粒子亮度（观察上文图片知第二次采样的纹理其实是一个灰度图，只用于控制粒子不同位置的亮度，这样可以细化粒子的视觉表现）。这里一开始我对于内置变量<i><font color="Orange">gl_PointCoord</font></i>并不熟，后来查阅了相关文档（以及在GPT的鼎力支持下~）大概弄懂了它所表示的含义，简述如下：</p><p><code>gl_PointCoord代表点精灵的纹理坐标，这只有在渲染点精灵的上下文中才可以使用。点精灵（Point Sprite） 是一种在计算机图形学中用于渲染点的技术，通常用于表示粒子效果、星星、光点等。点精灵通过使用纹理来增强视觉效果， 使得单个点不仅仅是一个简单的像素，而是一个具有纹理和其他视觉属性的对象。点精灵通常被视为一个正方形或矩形， 渲染时会在屏幕上显示为一个四边形。这个四边形的大小由 gl_PointSize 控制。在渲染点精灵时，OpenGL 会将点精灵的 每个片段（fragment）映射到纹理的坐标系中。假设点精灵的大小为 size，在屏幕上的中心位置为 (centerX, centerY)， gl_PointCoord 的计算可以理解为：     x 坐标：gl_PointCoord.x = (fragmentX - (centerX - size/2)) / size     y 坐标：gl_PointCoord.y = (fragmentY - (centerY - size/2)) / size</code></p><p>这样就厘清了渲染阶段使用的着色器代码！</p><hr><h4 id="绑定描述符资源">绑定描述符资源</h4><p>创建好渲染管线后，现在我们可以将实际使用的描述符资源绑定起来供后续渲染流程使用了。<i><font color="Orange">setup_descriptor_set</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::setup_descriptor_set</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>VkDescriptorSetAllocateInfo alloc_info =<br>    vkb::initializers::<span class="hljs-built_in">descriptor_set_allocate_info</span>(<br>        descriptor_pool,<br>        &amp;graphics.descriptor_set_layout,<br>        <span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;alloc_info, &amp;graphics.descriptor_set));<br><br>VkDescriptorBufferInfo            buffer_descriptor         = <span class="hljs-built_in">create_descriptor</span>(*graphics.uniform_buffer);<br>VkDescriptorImageInfo             particle_image_descriptor = <span class="hljs-built_in">create_descriptor</span>(textures.particle);<br>VkDescriptorImageInfo             gradient_image_descriptor = <span class="hljs-built_in">create_descriptor</span>(textures.gradient);<br>std::vector&lt;VkWriteDescriptorSet&gt; write_descriptor_sets;<br>write_descriptor_sets = &#123;<br>    vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(graphics.descriptor_set, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="hljs-number">0</span>, &amp;particle_image_descriptor),<br>    vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(graphics.descriptor_set, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="hljs-number">1</span>, &amp;gradient_image_descriptor),<br>    vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(graphics.descriptor_set, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">2</span>, &amp;buffer_descriptor),<br>&#125;;<br><span class="hljs-built_in">vkUpdateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(write_descriptor_sets.<span class="hljs-built_in">size</span>()), write_descriptor_sets.<span class="hljs-built_in">data</span>(), <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码将三个描述符资源绑定在一个描述符集上（不过这三个资源具有各自不同的着色器绑定点），然后设置好它们各自的更新方式。这部分内容在<a href="https://zpc-dsg.github.io/2024/12/06/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B1%A0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86/"><code>我之前的文章</code></a>中也有详细的说明，这里不再赘述，有需要的读者请移步~</p><hr><h4 id="创建同步信号量">创建同步信号量</h4><p>图形准备阶段的最后，程序将用于图形—计算同步的信号量创建好。这个信号量将用于保证计算着色器开始对Storagebuffer进行操作的时候图形管线已经完成了对其中内容的读取，不然图形管线有可能会读取到正在被计算着色器写入的内容，引发未定义的行为。</p><p>好了，现在图形阶段的准备工作总算是告一段落了，然而坏消息是这仍然不是终点。。。接下来让我们稍事休息，调匀呼吸，然后继续开始计算阶段所需的资源准备的探索吧（强颜欢笑</p><hr><h3 id="准备计算资源">准备计算资源</h3><p>人狠话不多，先上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::prepare_compute</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// Get compute queue</span><br><span class="hljs-built_in">vkGetDeviceQueue</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), compute.queue_family_index, <span class="hljs-number">0</span>, &amp;compute.queue);<br><br><span class="hljs-comment">// Create compute pipeline</span><br><span class="hljs-comment">// Compute pipelines are created separate from graphics pipelines even if they use the same queue (family index)</span><br><br>std::vector&lt;VkDescriptorSetLayoutBinding&gt; set_layout_bindings = &#123;<br>    <span class="hljs-comment">// Binding 0 : Particle position storage buffer</span><br>    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(<br>        VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,<br>        VK_SHADER_STAGE_COMPUTE_BIT,<br>        <span class="hljs-number">0</span>),<br>    <span class="hljs-comment">// Binding 1 : Uniform buffer</span><br>    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(<br>        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,<br>        VK_SHADER_STAGE_COMPUTE_BIT,<br>        <span class="hljs-number">1</span>),<br>&#125;;<br><br>VkDescriptorSetLayoutCreateInfo descriptor_layout =<br>    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_create_info</span>(<br>        set_layout_bindings.<span class="hljs-built_in">data</span>(),<br>        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(set_layout_bindings.<span class="hljs-built_in">size</span>()));<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorSetLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_layout, <span class="hljs-literal">nullptr</span>, &amp;compute.descriptor_set_layout));<br><br>VkPipelineLayoutCreateInfo pipeline_layout_create_info =<br>    vkb::initializers::<span class="hljs-built_in">pipeline_layout_create_info</span>(<br>        &amp;compute.descriptor_set_layout,<br>        <span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreatePipelineLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;pipeline_layout_create_info, <span class="hljs-literal">nullptr</span>, &amp;compute.pipeline_layout));<br><br>VkDescriptorSetAllocateInfo alloc_info =<br>    vkb::initializers::<span class="hljs-built_in">descriptor_set_allocate_info</span>(<br>        descriptor_pool,<br>        &amp;compute.descriptor_set_layout,<br>        <span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;alloc_info, &amp;compute.descriptor_set));<br><br>VkDescriptorBufferInfo            storage_buffer_descriptor = <span class="hljs-built_in">create_descriptor</span>(*compute.storage_buffer);<br>VkDescriptorBufferInfo            uniform_buffer_descriptor = <span class="hljs-built_in">create_descriptor</span>(*compute.uniform_buffer);<br>std::vector&lt;VkWriteDescriptorSet&gt; compute_write_descriptor_sets =<br>    &#123;<br>        <span class="hljs-comment">// Binding 0 : Particle position storage buffer</span><br>        vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(<br>            compute.descriptor_set,<br>            VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,<br>            <span class="hljs-number">0</span>,<br>            &amp;storage_buffer_descriptor),<br>        <span class="hljs-comment">// Binding 1 : Uniform buffer</span><br>        vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(<br>            compute.descriptor_set,<br>            VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,<br>            <span class="hljs-number">1</span>,<br>            &amp;uniform_buffer_descriptor)&#125;;<br><br><span class="hljs-built_in">vkUpdateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(compute_write_descriptor_sets.<span class="hljs-built_in">size</span>()), compute_write_descriptor_sets.<span class="hljs-built_in">data</span>(), <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">// Create pipelines</span><br>VkComputePipelineCreateInfo compute_pipeline_create_info = vkb::initializers::<span class="hljs-built_in">compute_pipeline_create_info</span>(compute.pipeline_layout, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 1st pass - Particle movement calculations，更新速度</span><br>compute_pipeline_create_info.stage = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;compute_nbody&quot;</span>, <span class="hljs-string">&quot;particle_calculate.comp&quot;</span>, VK_SHADER_STAGE_COMPUTE_BIT);<br><br><span class="hljs-comment">// Set some shader parameters via specialization constants</span><br><span class="hljs-comment">//专用常量的sample文档可以参考 https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/performance/specialization_constants</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SpecializationData</span><br>&#123;<br><span class="hljs-type">uint32_t</span> workgroup_size;<br><span class="hljs-type">uint32_t</span> shared_data_size;<br><span class="hljs-type">float</span>    gravity;<br><span class="hljs-type">float</span>    power;<br><span class="hljs-type">float</span>    soften;<br>&#125; specialization_data;<br><br>std::vector&lt;VkSpecializationMapEntry&gt; specialization_map_entries;<br>specialization_map_entries.<span class="hljs-built_in">push_back</span>(vkb::initializers::<span class="hljs-built_in">specialization_map_entry</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">offsetof</span>(SpecializationData, workgroup_size), <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>)));<br>specialization_map_entries.<span class="hljs-built_in">push_back</span>(vkb::initializers::<span class="hljs-built_in">specialization_map_entry</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">offsetof</span>(SpecializationData, shared_data_size), <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>)));<br>specialization_map_entries.<span class="hljs-built_in">push_back</span>(vkb::initializers::<span class="hljs-built_in">specialization_map_entry</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">offsetof</span>(SpecializationData, gravity), <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br>specialization_map_entries.<span class="hljs-built_in">push_back</span>(vkb::initializers::<span class="hljs-built_in">specialization_map_entry</span>(<span class="hljs-number">3</span>, <span class="hljs-built_in">offsetof</span>(SpecializationData, power), <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br>specialization_map_entries.<span class="hljs-built_in">push_back</span>(vkb::initializers::<span class="hljs-built_in">specialization_map_entry</span>(<span class="hljs-number">4</span>, <span class="hljs-built_in">offsetof</span>(SpecializationData, soften), <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br><br>specialization_data.workgroup_size   = work_group_size;<br>specialization_data.shared_data_size = shared_data_size;<br>specialization_data.gravity          = <span class="hljs-number">0.002f</span>;<br>specialization_data.power            = <span class="hljs-number">0.75f</span>;<br>specialization_data.soften           = <span class="hljs-number">0.05f</span>;<br><br>VkSpecializationInfo specialization_info =<br>    vkb::initializers::<span class="hljs-built_in">specialization_info</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(specialization_map_entries.<span class="hljs-built_in">size</span>()), specialization_map_entries.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">sizeof</span>(specialization_data), &amp;specialization_data);<br>compute_pipeline_create_info.stage.pSpecializationInfo = &amp;specialization_info;<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateComputePipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;compute_pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;compute.pipeline_calculate));<br><br><span class="hljs-comment">// 2nd pass - Particle integration，更新位置</span><br>compute_pipeline_create_info.stage = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;compute_nbody&quot;</span>, <span class="hljs-string">&quot;particle_integrate.comp&quot;</span>, VK_SHADER_STAGE_COMPUTE_BIT);<br><br>specialization_map_entries.<span class="hljs-built_in">clear</span>();<br>specialization_map_entries.<span class="hljs-built_in">push_back</span>(vkb::initializers::<span class="hljs-built_in">specialization_map_entry</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>)));<br>specialization_info =<br>    vkb::initializers::<span class="hljs-built_in">specialization_info</span>(<span class="hljs-number">1</span>, specialization_map_entries.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">sizeof</span>(work_group_size), &amp;work_group_size);<br><br>compute_pipeline_create_info.stage.pSpecializationInfo = &amp;specialization_info;<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateComputePipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;compute_pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;compute.pipeline_integrate));<br><br><span class="hljs-comment">// Separate command pool as queue family for compute may be different than graphics</span><br>VkCommandPoolCreateInfo command_pool_create_info = &#123;&#125;;<br>command_pool_create_info.sType                   = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;<br>command_pool_create_info.queueFamilyIndex        = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_family_index</span>(VK_QUEUE_COMPUTE_BIT);<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateCommandPool</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;command_pool_create_info, <span class="hljs-literal">nullptr</span>, &amp;compute.command_pool));<br><br><span class="hljs-comment">// Create a command buffer for compute operations</span><br>VkCommandBufferAllocateInfo command_buffer_allocate_info =<br>    vkb::initializers::<span class="hljs-built_in">command_buffer_allocate_info</span>(<br>        compute.command_pool,<br>        VK_COMMAND_BUFFER_LEVEL_PRIMARY,<br>        <span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateCommandBuffers</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;command_buffer_allocate_info, &amp;compute.command_buffer));<br><br><span class="hljs-comment">// Semaphore for compute &amp; graphics sync</span><br>VkSemaphoreCreateInfo semaphore_create_info = vkb::initializers::<span class="hljs-built_in">semaphore_create_info</span>();<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateSemaphore</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;semaphore_create_info, <span class="hljs-literal">nullptr</span>, &amp;compute.semaphore));<br><br><span class="hljs-comment">// Signal the semaphore</span><br>VkSubmitInfo submit_info         = &#123;VK_STRUCTURE_TYPE_SUBMIT_INFO&#125;;<br>submit_info.signalSemaphoreCount = <span class="hljs-number">1</span>;<br>submit_info.pSignalSemaphores    = &amp;compute.semaphore;<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkQueueSubmit</span>(queue, <span class="hljs-number">1</span>, &amp;submit_info, VK_NULL_HANDLE));<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkQueueWaitIdle</span>(queue));<br><br><span class="hljs-comment">// Build a single command buffer containing the compute dispatch commands</span><br><span class="hljs-built_in">build_compute_command_buffer</span>();<br><br><span class="hljs-comment">// If necessary, acquire and immediately release the storage buffer, so that the initial acquire</span><br><span class="hljs-comment">// from the graphics command buffers are matched up properly.</span><br><br><span class="hljs-keyword">if</span> (graphics.queue_family_index != compute.queue_family_index)<br>&#123;<br>VkCommandBuffer transfer_command;<br><br><span class="hljs-comment">// Create a transient command buffer for setting up the initial buffer transfer state</span><br>VkCommandBufferAllocateInfo command_buffer_allocate_info =<br>    vkb::initializers::<span class="hljs-built_in">command_buffer_allocate_info</span>(<br>        compute.command_pool,<br>        VK_COMMAND_BUFFER_LEVEL_PRIMARY,<br>        <span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateCommandBuffers</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;command_buffer_allocate_info, &amp;transfer_command));<br><br>VkCommandBufferBeginInfo command_buffer_info&#123;&#125;;<br>command_buffer_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBeginCommandBuffer</span>(transfer_command, &amp;command_buffer_info));<br><br>VkBufferMemoryBarrier acquire_buffer_barrier =<br>    &#123;<br>        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,<br>        <span class="hljs-literal">nullptr</span>,<br>        <span class="hljs-number">0</span>,<br>        VK_ACCESS_SHADER_WRITE_BIT,<br>        graphics.queue_family_index,<br>        compute.queue_family_index,<br>        compute.storage_buffer-&gt;<span class="hljs-built_in">get_handle</span>(),<br>        <span class="hljs-number">0</span>,<br>        compute.storage_buffer-&gt;<span class="hljs-built_in">get_size</span>()&#125;;<br><span class="hljs-built_in">vkCmdPipelineBarrier</span>(<br>    transfer_command,<br>    VK_PIPELINE_STAGE_TRANSFER_BIT,<br>    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>    <span class="hljs-number">1</span>, &amp;acquire_buffer_barrier,<br>    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br><br>VkBufferMemoryBarrier release_buffer_barrier =<br>    &#123;<br>        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,<br>        <span class="hljs-literal">nullptr</span>,<br>        VK_ACCESS_SHADER_WRITE_BIT,<br>        <span class="hljs-number">0</span>,<br>        compute.queue_family_index,<br>        graphics.queue_family_index,<br>        compute.storage_buffer-&gt;<span class="hljs-built_in">get_handle</span>(),<br>        <span class="hljs-number">0</span>,<br>        compute.storage_buffer-&gt;<span class="hljs-built_in">get_size</span>()&#125;;<br><span class="hljs-built_in">vkCmdPipelineBarrier</span>(<br>    transfer_command,<br>    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,<br>    VK_PIPELINE_STAGE_TRANSFER_BIT,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>    <span class="hljs-number">1</span>, &amp;release_buffer_barrier,<br>    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-comment">// Copied from Device::flush_command_buffer, which we can&#x27;t use because it would be</span><br><span class="hljs-comment">// working with the wrong command pool</span><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkEndCommandBuffer</span>(transfer_command));<br><br><span class="hljs-comment">// Submit compute commands</span><br>VkSubmitInfo submit_info&#123;&#125;;<br>submit_info.sType              = VK_STRUCTURE_TYPE_SUBMIT_INFO;<br>submit_info.commandBufferCount = <span class="hljs-number">1</span>;<br>submit_info.pCommandBuffers    = &amp;transfer_command;<br><br><span class="hljs-comment">// Create fence to ensure that the command buffer has finished executing</span><br>VkFenceCreateInfo fence_info&#123;&#125;;<br>fence_info.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;<br>fence_info.flags = VK_FLAGS_NONE;<br><br>VkFence fence;<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateFence</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;fence_info, <span class="hljs-literal">nullptr</span>, &amp;fence));<br><span class="hljs-comment">// Submit to the *compute* queue</span><br>VkResult result = <span class="hljs-built_in">vkQueueSubmit</span>(compute.queue, <span class="hljs-number">1</span>, &amp;submit_info, fence);<br><span class="hljs-comment">// Wait for the fence to signal that command buffer has finished executing</span><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkWaitForFences</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-number">1</span>, &amp;fence, VK_TRUE, DEFAULT_FENCE_TIMEOUT));<br><span class="hljs-built_in">vkDestroyFence</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), fence, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-built_in">vkFreeCommandBuffers</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), compute.command_pool, <span class="hljs-number">1</span>, &amp;transfer_command);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看着是不是很唬人？没错它实际上也很唬人。。。不过慢慢拆解后，它的逻辑还是十分清晰的，且听我徐徐道来~</p><p>在对这段代码进行了细致的梳理后，我认为该函数所做的工作可以分为几个步骤：</p><ul><li>创建描述符集布局和计算管线布局</li><li>创建描述符集并绑定</li><li>创建计算管线</li><li>创建计算阶段命令提交所需的命令池并分配相应的命令缓冲</li><li>创建用于计算—图形同步的信号量</li><li>录制计算阶段命令</li><li>处理第一帧的Storage buffer归属权转移</li></ul><p>是不是也挺复杂的？接下来我们就一步步来探究吧。</p><h4 id="创建布局">创建布局</h4><p>首先要明确的是，计算着色器需要绑定两个资源，一个Storagebuffer，一个Uniformbuffer。在明确了这一点之后，创建相应的布局就是常规操作了。</p><hr><h4 id="创建描述符集并绑定">创建描述符集并绑定</h4><p>同样，程序从描述符池分配一个描述符集给计算阶段，该描述符集会引用相应的Storagebuffer和Uniform buffer资源。这部分同样是常规的代码，不再赘述。</p><hr><h4 id="创建计算管线">创建计算管线</h4><p>由于本程序使用了两个computepass来完成对粒子位置和速度的计算，所以需要相应地创建两个计算管线对象。计算管线的创建过程比图形管线要简单不少。在本程序中只需指定管线需要的着色器和布局就可以了。第一阶段的ji算管线对象使用的计算着色器代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br>struct Particle<br>&#123;<br><span class="hljs-type">vec4</span> pos;<br><span class="hljs-type">vec4</span> vel;<br>&#125;;<br><br><span class="hljs-comment">// Binding 0 : Position storage buffer</span><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">std140</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">buffer</span> Pos <br>&#123;<br>   Particle particles[ ];<br>&#125;;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">uniform</span> UBO <br>&#123;<br><span class="hljs-type">float</span> deltaT;<br><span class="hljs-type">int</span> particleCount;<br>&#125; ubo;<br><br><span class="hljs-keyword">layout</span> (constant_id = <span class="hljs-number">1</span>) <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> SHARED_DATA_SIZE = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">layout</span> (constant_id = <span class="hljs-number">2</span>) <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> GRAVITY = <span class="hljs-number">0.002</span>;<br><span class="hljs-keyword">layout</span> (constant_id = <span class="hljs-number">3</span>) <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> POWER = <span class="hljs-number">0.75</span>;<br><span class="hljs-keyword">layout</span> (constant_id = <span class="hljs-number">4</span>) <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> SOFTEN = <span class="hljs-number">0.05</span>;<br><br><span class="hljs-keyword">layout</span> (local_size_x_id = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span>;<br><br><span class="hljs-comment">// Share data between computer shader invocations to speed up caluclations</span><br><span class="hljs-keyword">shared</span> <span class="hljs-type">vec4</span> sharedData[SHARED_DATA_SIZE];<br><br><span class="hljs-meta">#define TIME_FACTOR 0.05</span><br><br><span class="hljs-type">void</span> main() <br>&#123;<br><span class="hljs-comment">// Current SSBO index</span><br><span class="hljs-type">uint</span> <span class="hljs-keyword">index</span> = <span class="hljs-built_in">gl_GlobalInvocationID</span>.x;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &gt;= ubo.particleCount) <br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-type">vec4</span> position = particles[<span class="hljs-keyword">index</span>].pos;<br><span class="hljs-type">vec4</span> velocity = particles[<span class="hljs-keyword">index</span>].vel;<br><span class="hljs-type">vec4</span> acceleration = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ubo.particleCount; i += SHARED_DATA_SIZE)<br>&#123;<br><span class="hljs-keyword">if</span> (i + <span class="hljs-built_in">gl_LocalInvocationID</span>.x &lt; ubo.particleCount)<br>&#123;<br>sharedData[<span class="hljs-built_in">gl_LocalInvocationID</span>.x] = particles[i + <span class="hljs-built_in">gl_LocalInvocationID</span>.x].pos;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>sharedData[<span class="hljs-built_in">gl_LocalInvocationID</span>.x] = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>);<br>&#125;<br><br><span class="hljs-built_in">barrier</span>();<span class="hljs-comment">//对工作组中的线程进行同步</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">gl_WorkGroupSize</span>.x; j++)<br>&#123;<br><span class="hljs-type">vec4</span> other = sharedData[j];<br><span class="hljs-type">vec3</span> len = other.xyz - position.xyz;<br>acceleration.xyz += GRAVITY * len * other.w / <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">dot</span>(len, len) + SOFTEN, POWER);<br>&#125;<br><br><span class="hljs-built_in">barrier</span>();<br>&#125;<br><br>particles[<span class="hljs-keyword">index</span>].vel.xyz += ubo.deltaT * TIME_FACTOR * acceleration.xyz;<br><br><span class="hljs-comment">// Gradient texture position</span><br>particles[<span class="hljs-keyword">index</span>].vel.w += <span class="hljs-number">0.1</span> * TIME_FACTOR * ubo.deltaT;<br><span class="hljs-keyword">if</span> (particles[<span class="hljs-keyword">index</span>].vel.w &gt; <span class="hljs-number">1.0</span>)<br>particles[<span class="hljs-keyword">index</span>].vel.w -= <span class="hljs-number">1.0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>先来分析主函数的逻辑。首先根据<code>index &gt;= ubo.particleCount</code>这行代码可以得知该计算着色器应该是每个调用处理一个粒子的计算。然后在每一个调用单元中，首先提取出Storagebuffer中存储的粒子位置和速度。为了更新粒子的速度，首先需要计算粒子当前的加速度。这里着色器使用了一个for循环来枚举出所有对粒子状态产生影响的其它粒子，并且将其存储在工作组的共享空间中，每个调用负责填写对应<i><font color="Orange">gl_LocalInvocationID</font></i>索引处的共享数据。然后，各调用需要等待所有调用均完成了一个循环内的数据填写，此时<i><font color="Orange">sharedData</font></i>内的数据已经填写完整，接下来每个调用使用所有填写好的共享数据信息开始计算各自处理的粒子的加速度，这样就模拟了多个粒子之间复杂的相互作用关系。同样，在每次调用你计算完各自的加速度增量之后也需要等待所有的调用计算完毕才能执行下一轮循环，不然共享数据可能还没有被某个调用读取完毕就已经被另一个调用写入了。</p><p>在执行完循环后，每个调用处理的粒子的加速度已经计算完毕，接下来只需使用加速度乘以时间计算该粒子速度的变化量即可（当然这里还乘了一个时间因子以添加对粒子运动速度的控制）。不过前文提到过，速度的第四个分量会存储粒子在梯度图中的坐标，这里同样需要更新。程序采用的更新方式为让粒子颜色按时间沿着梯度图均匀变化，从而让粒子的颜色随时间变化而周期性改变。</p><p>这样粒子速度更新的逻辑就已经厘清了。不过在此之外还需要看一看着色器所使用的变量。这里对我而言比较陌生的部分首先是constant_id那部分对应的变量声明。经查阅资料知这其实是在指定Vulkan中的一种特殊的着色器变量——<strong>专有常量（Specializationconstant)</strong>。关于专有常量，我也还没有十分细致的了解，只是大体知道这种常量一般用于指定在着色器中不太需要变化的量，相比于Uniform变量而言着色器在编译的时候可以对专有常量进行一定的优化，相比于着色器文件内定义的常量而言专有常量可以传递给许多不同的着色器文件。不过幸运的是官方示例集中实际上也有专门的用于展示专有常量作用的示例<strong>specialization_constants</strong>，我会在之后去阅读相关的源码以加深理解~</p><p>另外还有一个不太了解的点就是输入处的代码<code>layout (local_size_x_id = 0) in;</code>，经简单的搜索了解到local_size_x_id=0实际上代表local_size_x取specializationconstants中指定的第一个常量（事实上专有常量的id编号是从0开始的，但是代码中并没有列举第0号常量，这个常量实际上就用于指定工作组调用的第一个维度大小了，从后文在CPU端对专有常量的设定也可以看出来事实上是设置了5个专有常量的，并且第一个指定的是工作组调用维度的大小），更多解释可见https://zhuanlan.zhihu.com/p/468404001。</p><p>最后还有一个需要提及的点，就是在glsl中是允许将constantvariable指定为数组大小的，但是在hlsl中这种用法是不允许的（这在本示例对应的hlsl文件中有提及）。</p><p>好的，现在让我们把注意力拉回到示例源码上~在设定好管线的计算着色器后，紧接着程序就开始设定着色器用到的专有常量了。同样，这部分代码其实大概来看也是能理解意思的，不过我打算将更清晰的理解推迟到之后阅读示例<strong>specialization_constants</strong>源码的时候，所以这里只看个大概就行（摸了。。。</p><p>另外，从<code>compute_pipeline_create_info.stage.pSpecializationInfo = &amp;specialization_info;</code>一行代码也可以看出专有常量其实也是Pipelinestage指定的一部分。经查阅可知确实如此：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineShaderStageCreateInfo</span> &#123;</span><br>    VkStructureType                     sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                         pNext;<br>    VkPipelineShaderStageCreateFlags    flags;<br>    VkShaderStageFlagBits               stage;<br>    VkShaderModule                      module;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                         pName;<br>    <span class="hljs-type">const</span> VkSpecializationInfo*         pSpecializationInfo;<br>&#125; VkPipelineShaderStageCreateInfo;<br></code></pre></td></tr></table></figure><p>这样第一阶段的管线就构建完毕了，接下来赶到战场的是第二阶段的管线构建。同样先来查看一下管线使用的着色器源码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br>struct Particle<br>&#123;<br><span class="hljs-type">vec4</span> pos;<br><span class="hljs-type">vec4</span> vel;<br>&#125;;<br><br><span class="hljs-comment">// Binding 0 : Position storage buffer</span><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">std140</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">buffer</span> Pos <br>&#123;<br>   Particle particles[ ];<br>&#125;;<br><br><span class="hljs-keyword">layout</span> (local_size_x_id = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span>;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">uniform</span> UBO <br>&#123;<br><span class="hljs-type">float</span> deltaT;<br><span class="hljs-type">int</span> particleCount;<br>&#125; ubo;<br><br><span class="hljs-meta">#define TIME_FACTOR 0.05</span><br><br><span class="hljs-type">void</span> main() <br>&#123;<br><span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-type">int</span>(<span class="hljs-built_in">gl_GlobalInvocationID</span>);<br><span class="hljs-type">vec4</span> position = particles[<span class="hljs-keyword">index</span>].pos;<br><span class="hljs-type">vec4</span> velocity = particles[<span class="hljs-keyword">index</span>].vel;<br>position += ubo.deltaT * TIME_FACTOR * velocity;<br>particles[<span class="hljs-keyword">index</span>].pos = position;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个着色器负责更新粒子的位置。更新逻辑同样是一个调用处理一个粒子的更新，然后位置计算的逻辑也就是简单的速度乘时间得到位置变化量，然后更新即可。</p><p>这个着色器同样需要一个专有常量来指定工作组调用第一个维度的大小，所以在示例程序中同样需要设定Pipelinestage需要的专有常量信息，只不过这时候就只需要这一个专有常量了。</p><p>这样两个compute pass的管线均已构建完毕！</p><hr><h4 id="创建命令缓冲">创建命令缓冲</h4><p>图形命令提交使用的命令缓冲是由基类提供的命令池分配的，但基类的命令池只适用于分配提交图形命令的命令缓冲，想要提交计算命令还需要在示例类中自行创建计算命令池并分配计算命令缓冲，这就是<i><font color="Orange">compute</font></i>结构体中<i><font color="Orange">command_pool</font></i>和<i><font color="Orange">commmand_buffer</font></i>成员的作用。在明确了这一点之后，命令池的创建和命令缓冲的分配就是常规操作了，不熟悉的读者可以参考我之前翻译的VulkanTutorial中对命令缓冲部分的<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2"><code>教程</code></a>。</p><hr><h4 id="创建同步信号量-1">创建同步信号量</h4><p>接下来需要创建用于计算—图形同步的信号量，因为图形的顶点输入阶段需要等待计算着色器工作完毕才能读入Storagebuffer中的数据。但是这里的巧妙之处在于，程序在创建信号量之后创建了一个没有录制任何命令但附带有该信号量的提交信息，然后立刻提交该空命令列表。刚开始我也是看的一脸懵，不过后续我发现信号量只有在提交的命令全部完成后才能被点亮，似乎没有其它（至少更便捷的）点亮手段，所以这段代码的唯一作用肯定就是在创建好该信号量之后立刻点亮它。那么现在问题就是为什么要这么做呢？根据我的分析，这应该是因为渲染第一帧画面的时候，渲染管线的顶点输入使用的是Storagebuffer中已经在渲染前设定好的初始值，而不会像之后的所有帧那样依赖于计算着色器对Storagebuffer的更新结果。因此第一帧渲染时，图形管线应该直接输入Storagebuffer中的数据而无需使用该信号量在顶点输入阶段等待计算着色器运行完毕，所以这里将信号量的初始状态设置为点亮以取消计算着色器运行对顶点输入阶段的阻塞效果。</p><hr><h4 id="录制计算命令">录制计算命令</h4><p>接下来程序使用<i><font color="Green">build_compute_command_buffer</font></i>函数来录制计算命令。该函数源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::build_compute_command_buffer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>VkCommandBufferBeginInfo command_buffer_begin_info = vkb::initializers::<span class="hljs-built_in">command_buffer_begin_info</span>();<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBeginCommandBuffer</span>(compute.command_buffer, &amp;command_buffer_begin_info));<br><br><span class="hljs-comment">// Acquire</span><br><span class="hljs-keyword">if</span> (graphics.queue_family_index != compute.queue_family_index)<br>&#123;<br>VkBufferMemoryBarrier buffer_barrier =<br>    &#123;<br>        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,<br>        <span class="hljs-literal">nullptr</span>,<br>        <span class="hljs-number">0</span>,<br>        VK_ACCESS_SHADER_WRITE_BIT,<br>        graphics.queue_family_index,<br>        compute.queue_family_index,<br>        compute.storage_buffer-&gt;<span class="hljs-built_in">get_handle</span>(),<br>        <span class="hljs-number">0</span>,<br>        compute.storage_buffer-&gt;<span class="hljs-built_in">get_size</span>()&#125;;<br><br><span class="hljs-built_in">vkCmdPipelineBarrier</span>(<br>    compute.command_buffer,<br>    VK_PIPELINE_STAGE_TRANSFER_BIT,<br>    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>    <span class="hljs-number">1</span>, &amp;buffer_barrier,<br>    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>&#125;<br><br><span class="hljs-comment">// First pass: Calculate particle movement</span><br><span class="hljs-comment">// -------------------------------------------------------------------------------------------------------</span><br><span class="hljs-built_in">vkCmdBindPipeline</span>(compute.command_buffer, VK_PIPELINE_BIND_POINT_COMPUTE, compute.pipeline_calculate);<br><span class="hljs-built_in">vkCmdBindDescriptorSets</span>(compute.command_buffer, VK_PIPELINE_BIND_POINT_COMPUTE, compute.pipeline_layout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;compute.descriptor_set, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">vkCmdDispatch</span>(compute.command_buffer, num_particles / work_group_size, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// Add memory barrier to ensure that the computer shader has finished writing to the buffer</span><br>VkBufferMemoryBarrier memory_barrier = vkb::initializers::<span class="hljs-built_in">buffer_memory_barrier</span>();<br>memory_barrier.buffer                = compute.storage_buffer-&gt;<span class="hljs-built_in">get_handle</span>();<br>memory_barrier.size                  = compute.storage_buffer-&gt;<span class="hljs-built_in">get_size</span>();<br>memory_barrier.srcAccessMask         = VK_ACCESS_SHADER_WRITE_BIT;<br>memory_barrier.dstAccessMask         = VK_ACCESS_SHADER_READ_BIT;<br>memory_barrier.srcQueueFamilyIndex   = VK_QUEUE_FAMILY_IGNORED;<br>memory_barrier.dstQueueFamilyIndex   = VK_QUEUE_FAMILY_IGNORED;<br><br><span class="hljs-built_in">vkCmdPipelineBarrier</span>(<br>    compute.command_buffer,<br>    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,<br>    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,<br>    VK_FLAGS_NONE,<br>    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>    <span class="hljs-number">1</span>, &amp;memory_barrier,<br>    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-comment">// Second pass: Integrate particles</span><br><span class="hljs-comment">// -------------------------------------------------------------------------------------------------------</span><br><span class="hljs-built_in">vkCmdBindPipeline</span>(compute.command_buffer, VK_PIPELINE_BIND_POINT_COMPUTE, compute.pipeline_integrate);<br><span class="hljs-built_in">vkCmdDispatch</span>(compute.command_buffer, num_particles / work_group_size, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// Release</span><br><span class="hljs-keyword">if</span> (graphics.queue_family_index != compute.queue_family_index)<br>&#123;<br>VkBufferMemoryBarrier buffer_barrier =<br>    &#123;<br>        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,<br>        <span class="hljs-literal">nullptr</span>,<br>        VK_ACCESS_SHADER_WRITE_BIT,<br>        <span class="hljs-number">0</span>,<br>        compute.queue_family_index,<br>        graphics.queue_family_index,<br>        compute.storage_buffer-&gt;<span class="hljs-built_in">get_handle</span>(),<br>        <span class="hljs-number">0</span>,<br>        compute.storage_buffer-&gt;<span class="hljs-built_in">get_size</span>()&#125;;<br><br><span class="hljs-built_in">vkCmdPipelineBarrier</span>(<br>    compute.command_buffer,<br>    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,<br>    VK_PIPELINE_STAGE_TRANSFER_BIT,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>    <span class="hljs-number">1</span>, &amp;buffer_barrier,<br>    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>&#125;<br><br><span class="hljs-built_in">vkEndCommandBuffer</span>(compute.command_buffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>也不短（没完没了了。。。还是让我们耐下性子继续分析吧~</p><p>首先，要录制命令当然需要先启动之前分配好的计算命令缓冲。然后，计算队列需要获取Storagebuffer的归属权，因为在准备图形资源的时候图形队列是释放了Storagebuffer的归属权，但计算队列还没有执行相应的获取操作。在得到Storagebuffer归属权之后，紧接着就可以录制执行第一个computepass的命令了，这只需要绑定相应的计算管线，绑定管线需要的描述符集，最后将计算工作打包成多个工作组即可。</p><p>在完成了第一个计算任务之后，我们需要显示地同步两个pass以保证它们运行的先后顺序，这同样是通过BufferMemoryBarrier来实现的（只不过此时该内存屏障用来保证执行顺序的先后关系而不是用来转移内存归属权）。在此之后就可以安心地录制执行第二个pass的命令了。</p><p>在录制完所有的管线执行命令之后，最后计算队列还需要释放对Storagebuffer的所有权，因为在计算完毕后Storage buffer将供图形管线使用。</p><hr><h4 id="处理第一帧storage-buffer归属权转移">处理第一帧Storagebuffer归属权转移</h4><p>终于来到了准备计算资源的最后一部分，也是当初困扰我最久的一部分，就是<i><font color="Green">build_compute_command_buffer</font></i>函数下面的那一大段。经过仔细的分析之后我认为这段代码的目的同样在于处理第一帧渲染的特殊情形。在后文录制图形命令部分我们实际上可以看到图形部分录制的第一个命令会是图形队列对Storagebuffer归属权的获取，这是因为在除了第一帧之外的所有帧中，图形的顶点输入阶段会等待计算阶段执行完毕，而计算阶段在更新完Storagebuffer后会释放对它的所有权，此时图形队列一定需要一个匹配的获取所有权的操作。但是问题在于第一帧，在第一帧渲染的时候，图形管线有关命令的执行不会等待计算阶段的运行，但图形队列从计算队列获取所有权一定需要和计算队列向图形队列释放所有权相匹配，但第一帧跳过了计算队列的所有操作，那也就是说计算命令缓冲中开头的计算队列获取所有权和结尾的计算队列释放所有权都被跳过了，这并不是我们希望看到的。因此在准备计算资源代码的最后程序从计算命令池（因为是计算队列的获取和释放操作，当然需要从计算命令池中分配）中分配一个临时的计算缓冲用来处理上述匹配操作，并且设置一个栅栏(Fence)来保证在图形队列获取到Storagebuffer前匹配操作已经完成。</p><p>计算阶段的准备工作终于大功告成！接下来开始准备图形命令的录制吧！</p><hr><h3 id="录制图形命令">录制图形命令</h3><p>准备阶段的最后一步是把绘制有关的命令录制好。<i><font color="Green">build_command_buffers</font></i>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::build_command_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>VkCommandBufferBeginInfo command_buffer_begin_info = vkb::initializers::<span class="hljs-built_in">command_buffer_begin_info</span>();<br><br>VkClearValue clear_values[<span class="hljs-number">2</span>];<br>clear_values[<span class="hljs-number">0</span>].color        = &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;;<br>clear_values[<span class="hljs-number">1</span>].depthStencil = &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0</span>&#125;;<br><br>VkRenderPassBeginInfo render_pass_begin_info    = vkb::initializers::<span class="hljs-built_in">render_pass_begin_info</span>();<br>render_pass_begin_info.renderPass               = render_pass;<br>render_pass_begin_info.renderArea.offset.x      = <span class="hljs-number">0</span>;<br>render_pass_begin_info.renderArea.offset.y      = <span class="hljs-number">0</span>;<br>render_pass_begin_info.renderArea.extent.width  = width;<br>render_pass_begin_info.renderArea.extent.height = height;<br>render_pass_begin_info.clearValueCount          = <span class="hljs-number">2</span>;<br>render_pass_begin_info.pClearValues             = clear_values;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; draw_cmd_buffers.<span class="hljs-built_in">size</span>(); ++i)<br>&#123;<br><span class="hljs-comment">// Set target frame buffer</span><br>render_pass_begin_info.framebuffer = framebuffers[i];<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBeginCommandBuffer</span>(draw_cmd_buffers[i], &amp;command_buffer_begin_info));<br><br><span class="hljs-comment">// Acquire</span><br><span class="hljs-keyword">if</span> (graphics.queue_family_index != compute.queue_family_index)<br>&#123;<br>VkBufferMemoryBarrier buffer_barrier =<br>    &#123;<br>        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,<br>        <span class="hljs-literal">nullptr</span>,<br>        <span class="hljs-number">0</span>,<br>        VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,<br>        compute.queue_family_index,<br>        graphics.queue_family_index,<br>        compute.storage_buffer-&gt;<span class="hljs-built_in">get_handle</span>(),<br>        <span class="hljs-number">0</span>,<br>        compute.storage_buffer-&gt;<span class="hljs-built_in">get_size</span>()&#125;;<br><br><span class="hljs-built_in">vkCmdPipelineBarrier</span>(<br>    draw_cmd_buffers[i],<br>    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,<br>    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>    <span class="hljs-number">1</span>, &amp;buffer_barrier,<br>    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>&#125;<br><br><span class="hljs-comment">// Draw the particle system using the update vertex buffer</span><br><span class="hljs-built_in">vkCmdBeginRenderPass</span>(draw_cmd_buffers[i], &amp;render_pass_begin_info, VK_SUBPASS_CONTENTS_INLINE);<span class="hljs-comment">//VK_SUBPASS_CONTENTS_INLINE代表子通道命令录制在初级命令缓冲中</span><br>VkViewport viewport = vkb::initializers::<span class="hljs-built_in">viewport</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(height), <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br><span class="hljs-built_in">vkCmdSetViewport</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;viewport);<br>VkRect2D scissor = vkb::initializers::<span class="hljs-built_in">rect2D</span>(width, height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">vkCmdSetScissor</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;scissor);<br><span class="hljs-built_in">vkCmdBindPipeline</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphics.pipeline);<br><span class="hljs-built_in">vkCmdBindDescriptorSets</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphics.pipeline_layout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;graphics.descriptor_set, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>VkDeviceSize offsets[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">vkCmdBindVertexBuffers</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, compute.storage_buffer-&gt;<span class="hljs-built_in">get</span>(), offsets);<br><span class="hljs-built_in">vkCmdDraw</span>(draw_cmd_buffers[i], num_particles, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">draw_ui</span>(draw_cmd_buffers[i]);<br><span class="hljs-built_in">vkCmdEndRenderPass</span>(draw_cmd_buffers[i]);<br><br><span class="hljs-comment">// Release barrier</span><br><span class="hljs-keyword">if</span> (graphics.queue_family_index != compute.queue_family_index)<br>&#123;<br>VkBufferMemoryBarrier buffer_barrier =<br>    &#123;<br>        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,<br>        <span class="hljs-literal">nullptr</span>,<br>        VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,<br>        <span class="hljs-number">0</span>,<br>        graphics.queue_family_index,<br>        compute.queue_family_index,<br>        compute.storage_buffer-&gt;<span class="hljs-built_in">get_handle</span>(),<br>        <span class="hljs-number">0</span>,<br>        compute.storage_buffer-&gt;<span class="hljs-built_in">get_size</span>()&#125;;<br><br><span class="hljs-built_in">vkCmdPipelineBarrier</span>(<br>    draw_cmd_buffers[i],<br>    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,<br>    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>    <span class="hljs-number">1</span>, &amp;buffer_barrier,<br>    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>&#125;<br><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkEndCommandBuffer</span>(draw_cmd_buffers[i]));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>录制的流程也和<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2"><code>我之前的文章</code></a>中对VulkanTutorial相应教程的翻译并没有多少区别，大致的流程就是先开始命令缓冲的录制，然后开启渲染通道，之后将视口和裁剪区域设置好，绑定渲染管线，绑定管线用到的描述符资源，绑定顶点缓冲，然后开启绘制，绘制结束后结束渲染通道并结束命令录制。不过这里也有几个需要关注一下的点：首先是注意到渲染命令的录制针对每一个帧缓冲都要进行一次，并且每个帧缓冲需要录制的命令是相同的，所以在函数中我们可以看到程序使用了一个循环来录制这些命令。另外注意到所有的命令是录制到<i><font color="Orange">draw_cmd_buffers</font></i>上，这组命令缓冲本身不是示例类内的成员，它们是基类已经准备好的成员，供子类的图形命令绘制调用，它们的数量和帧缓冲的数量是一致的，同样这里用到的帧缓冲<i><font color="Orange">framebuffers</font></i>也是基类创建好的资源。然后就是上文提到过图形录制的第一步需要让图形队列获取Storagebuffer的所有权，所以在开启渲染通道之前需要首先使用一个内存屏障来完成图形队列归属权的获取操作。最后在真正的绘制部分我们会发现其实程序录制了两个绘制命令，其中第一个是对粒子系统的绘制，第二个实际上是对程序UI界面的绘制（没错，就是那个<i><font color="Green">draw_ui</font></i>函数），Vulkan官方示例集采用<a href="https://github.com/ocornut/imgui"><code>imgui</code></a>作为窗口系统，后续在探索该示例集框架的时候我们再来详细分析这个函数以及相关绘制调用的逻辑，这里只要知道它的大致作用就行了。最后，在命令录制的最后，图形队列已经不再需要使用Storagebuffer了，此时应该将Storagebuffer交给计算对列处理，因此最后图形队列需要释放对Storagebuffer的所有权，这也和计算命令最开始的计算队列获取所有权是对应的。</p><hr><h3 id="准备阶段的收尾">准备阶段的收尾</h3><p>终于将<i><font color="Green">prepare</font></i>函数中的主逻辑给分析完了，在该函数的最后，程序将私有变量<i><font color="Orange">prepared</font></i>设置为true，代表准备工作已经结束了，可以开始主渲染循环了。Ok，事不宜迟，那现在就让我们开始主渲染循环逻辑的分析吧！</p><hr><h2 id="主渲染循环">主渲染循环</h2><p>程序的主渲染循环的主要逻辑是通过循环调用示例类的<i><font color="Green">render</font></i>函数实现的。我们就着重关注这个函数的逻辑。下面先上函数代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::render</span><span class="hljs-params">(<span class="hljs-type">float</span> delta_time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!prepared)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">draw</span>();<br><span class="hljs-built_in">update_compute_uniform_buffers</span>(delta_time);<br><span class="hljs-keyword">if</span> (camera.updated)<br>&#123;<br><span class="hljs-built_in">update_graphics_uniform_buffers</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的逻辑的相对比较简单，主要可以分为两个部分：</p><ul><li>绘制粒子效果</li><li>更新使用的Uniform buffer资源</li></ul><p>下面同样我们来一步步分析这些步骤：</p><h3 id="绘制粒子效果">绘制粒子效果</h3><p>粒子效果的绘制过程已经被封装到了<i><font color="Green">draw</font></i>函数中了。下面是<i><font color="Green">draw</font></i>函数的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ApiVulkanSample::<span class="hljs-built_in">prepare_frame</span>();<br><br>VkPipelineStageFlags graphics_wait_stage_masks[]  = &#123;VK_PIPELINE_STAGE_VERTEX_INPUT_BIT, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&#125;;<br>VkSemaphore          graphics_wait_semaphores[]   = &#123;compute.semaphore, semaphores.acquired_image_ready&#125;;<br>VkSemaphore          graphics_signal_semaphores[] = &#123;graphics.semaphore, semaphores.render_complete&#125;;<br><br><span class="hljs-comment">// Submit graphics commands</span><br>submit_info.commandBufferCount   = <span class="hljs-number">1</span>;<br>submit_info.pCommandBuffers      = &amp;draw_cmd_buffers[current_buffer];<br>submit_info.waitSemaphoreCount   = <span class="hljs-number">2</span>;<br>submit_info.pWaitSemaphores      = graphics_wait_semaphores;<br>submit_info.pWaitDstStageMask    = graphics_wait_stage_masks;<br>submit_info.signalSemaphoreCount = <span class="hljs-number">2</span>;<br>submit_info.pSignalSemaphores    = graphics_signal_semaphores;<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkQueueSubmit</span>(queue, <span class="hljs-number">1</span>, &amp;submit_info, VK_NULL_HANDLE));<br><br>ApiVulkanSample::<span class="hljs-built_in">submit_frame</span>();<br><br><span class="hljs-comment">// Wait for rendering finished</span><br>VkPipelineStageFlags wait_stage_mask = VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT;<br><br><span class="hljs-comment">// Submit compute commands</span><br>VkSubmitInfo compute_submit_info         = vkb::initializers::<span class="hljs-built_in">submit_info</span>();<br>compute_submit_info.commandBufferCount   = <span class="hljs-number">1</span>;<br>compute_submit_info.pCommandBuffers      = &amp;compute.command_buffer;<br>compute_submit_info.waitSemaphoreCount   = <span class="hljs-number">1</span>;<br>compute_submit_info.pWaitSemaphores      = &amp;graphics.semaphore;<br>compute_submit_info.pWaitDstStageMask    = &amp;wait_stage_mask;<br>compute_submit_info.signalSemaphoreCount = <span class="hljs-number">1</span>;<br>compute_submit_info.pSignalSemaphores    = &amp;compute.semaphore;<br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkQueueSubmit</span>(compute.queue, <span class="hljs-number">1</span>, &amp;compute_submit_info, VK_NULL_HANDLE));<br>&#125;<br></code></pre></td></tr></table></figure><p>首先程序会调用基类的<i><font color="Green">prepare_frame</font></i>函数来进行真正的绘制前的准备工作，包括处理窗口大小的变化，获取需要绘制到的下一张图像等，这里我们放上这个函数的代码，但是同样不会进行过多的分析，因为这部分函数并不属于这个示例的主逻辑，只需要知道它的大致功能就行了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ApiVulkanSample::prepare_frame</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">has_swapchain</span>())<br>&#123;<br><span class="hljs-built_in">handle_surface_changes</span>();<br><span class="hljs-comment">// Acquire the next image from the swap chain</span><br>VkResult result = <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_swapchain</span>().<span class="hljs-built_in">acquire_next_image</span>(current_buffer, semaphores.acquired_image_ready, VK_NULL_HANDLE);<br><span class="hljs-comment">// Recreate the swapchain if it&#x27;s no longer compatible with the surface (OUT_OF_DATE)</span><br><span class="hljs-keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR)<br>&#123;<br><span class="hljs-built_in">resize</span>(width, height);<br>&#125;<br><span class="hljs-comment">// VK_SUBOPTIMAL_KHR means that acquire was successful and semaphore is signaled but image is suboptimal</span><br><span class="hljs-comment">// allow rendering frame to suboptimal swapchain as otherwise we would have to manually unsignal semaphore and acquire image again</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != VK_SUBOPTIMAL_KHR)<br>&#123;<br><span class="hljs-built_in">VK_CHECK</span>(result);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在准备好渲染所需的帧资源之后，现在就可以进行渲染命令提交信息的填写了。这里需要厘清的是提交信息中信号量的设置。这里可以看到程序设置了两个等待的信号量，分别是<i><font color="Orange">compute.semaphore</font></i>和<i><font color="Orange">semaphores.acquired_image_ready</font></i>，这两个信号会分别在<i><font color="Red">VK_PIPELINE_STAGE_VERTEX_INPUT_BIT</font></i>和<i><font color="Red">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>阶段上等待，第一个信号量是示例准备阶段创建的用于进行计算—图形阶段同步的信号量，它会在顶点数据输入阶段等待计算命令的完成以将它点亮，点亮之后才能从Storagebuffer读取顶点数据；第二个信号量是基类创建的成员，在上文的<i><font color="Green">prepare_frame</font></i>函数中我们也看到了它的作用是通知后续阶段用于本次绘制的图像已经准备好了，片段着色器可以向这张图像输出颜色了。如果有读者对这个过程不是很清楚的话可以参考<a href="https://zpc-dsg.github.io/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/"><code>我的这篇文章</code></a>。总之，该信号量大体的工作方式就是会在获取到图像之后被点亮，然后片段着色器输出阶段会等待这个信号量被点亮，然后才能执行下一步的输出。</p><p>同时也可以发现提交信息中还设置了两个在渲染命令执行完毕后会点亮的信号量：<i><font color="Orange">graphics.semaphore</font></i>用于进行图形—计算同步，计算着色器想要进行Storagebuffer的更新，必须等待图形命令完成对Storagebuffer的使用；另一个信号量<i><font color="Orange">semaphores.render_complete</font></i>同样是基类的成员，它用于进行渲染和屏幕显示之间的同步，这部分同步代码在下方的<i><font color="Green">submit_frame</font></i>中给出，我们还是给出这个函数的代码但不会做具体的分析，因为这部分的逻辑在<a href="https://zpc-dsg.github.io/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/"><code>我之前的文章</code></a>中也有系统的梳理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ApiVulkanSample::submit_frame</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">has_swapchain</span>())<br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;queue = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_by_present</span>(<span class="hljs-number">0</span>);<br><br>VkSwapchainKHR sc = <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_swapchain</span>().<span class="hljs-built_in">get_handle</span>();<br><br>VkPresentInfoKHR present_info = &#123;&#125;;<br>present_info.sType            = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;<br>present_info.pNext            = <span class="hljs-literal">NULL</span>;<br>present_info.swapchainCount   = <span class="hljs-number">1</span>;<br>present_info.pSwapchains      = &amp;sc;<br>present_info.pImageIndices    = &amp;current_buffer;<br><br>VkDisplayPresentInfoKHR disp_present_info&#123;&#125;;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">is_extension_supported</span>(VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME) &amp;&amp;<br>    window-&gt;<span class="hljs-built_in">get_display_present_info</span>(&amp;disp_present_info, width, height))<br>&#123;<br><span class="hljs-comment">// Add display present info if supported and wanted</span><br>present_info.pNext = &amp;disp_present_info;<br>&#125;<br><br><span class="hljs-comment">// Check if a wait semaphore has been specified to wait for before presenting the image</span><br><span class="hljs-keyword">if</span> (semaphores.render_complete != VK_NULL_HANDLE)<br>&#123;<br>present_info.pWaitSemaphores    = &amp;semaphores.render_complete;<br>present_info.waitSemaphoreCount = <span class="hljs-number">1</span>;<br>&#125;<br><br>VkResult present_result = queue.<span class="hljs-built_in">present</span>(present_info);<br><br><span class="hljs-keyword">if</span> (!((present_result == VK_SUCCESS) || (present_result == VK_SUBOPTIMAL_KHR)))<br>&#123;<br><span class="hljs-keyword">if</span> (present_result == VK_ERROR_OUT_OF_DATE_KHR)<br>&#123;<br><span class="hljs-comment">// Swap chain is no longer compatible with the surface and needs to be recreated</span><br><span class="hljs-built_in">resize</span>(width, height);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">VK_CHECK</span>(present_result);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// DO NOT USE</span><br><span class="hljs-comment">// vkDeviceWaitIdle and vkQueueWaitIdle are extremely expensive functions, and are used here purely for demonstrating the vulkan API</span><br><span class="hljs-comment">// without having to concern ourselves with proper syncronization. These functions should NEVER be used inside the render loop like this (every frame).</span><br><span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_by_present</span>(<span class="hljs-number">0</span>).<span class="hljs-built_in">wait_idle</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就完成了图形命令提交信息的指定，接下来只需一键提交即可（bushi。提交之后，我们就需要来继续处理计算命令的提交了。从代码中可以看到计算阶段会等待之前在图形阶段完成时点亮的信号量<i><font color="Orange">graphics.semaphore</font></i>，然后在完成了自己的工作之后会负责点亮<i><font color="Orange">compute.semaphore</font></i>以通知下一帧的顶点输入阶段已经可以输入更新好的数据了。最后提交命令，大功告成！</p><hr><h3 id="更新uniform-buffer">更新Uniform buffer</h3><p>当然，每一帧中着色器会用到的Uniform变量也是会变的，所以当然应该要在每一个循环的最后更新下一帧会用到的变量。每一帧所耗费的时间都有可能会变化，所以计算阶段使用的Uniformbuffer中的<i><font color="Orange">delta_time</font></i>一定需要更新。另外注意到<i><font color="Orange">graphics</font></i>中的<i><font color="Orange">ubo</font></i>结构体中包含的三个成员中<i><font color="Orange">screenDim</font></i>成员只要窗口大小不发生变化就不会发生改变，而另外两个成员均依赖于当前摄像机的状态，所以如果摄像机没有发生改变，则这两个变量也无需更新。</p><p>本示例的分析终于结束了！撒花！！！</p><hr>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_samples</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>后记</title>
    <link href="/2024/12/27/CG_api/vulkan/vulkan_tutorial/%E5%90%8E%E8%AE%B0/"/>
    <url>/2024/12/27/CG_api/vulkan/vulkan_tutorial/%E5%90%8E%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="写在最后的话">写在最后的话</h2><p>本教程的更新终于是告一段落了。期间苯人诸事缠身，以至没能达成一口气更完全系列的目标，不过好歹还是在几个月的坚持努力下将这个系列教程彻底地梳理了一遍。虽仍不乏疑惑，不过自我感觉对于Vulkan各个模块之间的关联的认知清晰度又提升了一个层次，可喜可贺！</p><p>当然，这只不过是个开始，接下来苯人希望能够更加深入地了解Vulkan，特别是用Vulkan实现各种各样的渲染效果。因此预计接下来苯人会开始学习VulkanSamples中的各个功能实例以深入学习Vulkan的使用，挖个坑先（笑</p><p>多说无益，完结撒花！！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/12/26/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7/">上一篇：多重采样</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多重采样</title>
    <link href="/2024/12/26/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7/"/>
    <url>/2024/12/26/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在<a href="https://zpc-dsg.github.io/2024/12/23/CG_api/vulkan/vulkan_tutorial/%E7%94%9F%E6%88%90%E5%A4%9A%E7%BA%A7%E6%B8%90%E8%BF%9C%E7%BA%B9%E7%90%86/">上一章</a>中，我们使用多级渐远纹理一定程度上解决了远处渲染物体的走样现象（如摩尔纹等），但是当我们渲染近处的物体时，走样仍然会发生，如下图：</p><figure><img src="/2024/12/26/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7/alias.png" alt="近处走样现象"><figcaption aria-hidden="true">近处走样现象</figcaption></figure><p>可以看到，当我们在近处渲染一个简单的正方形时，正方形的边缘呈现出明显的锯齿状。这是因为屏幕上的像素数量有限，因此光栅化器只能将屏幕打散为有限个像素，当渲染一个三角形面片到这些像素上去的时候，一般来讲完全位于三角形内部的像素会被渲染，而一部分位于三角形内部或者完全不在它内部的像素不会被渲染，因此最后渲染出来的几何形体就是一个锯齿状的三角形，如下图所示：<img src="/2024/12/26/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7/jagged.png" alt="锯齿状三角形"></p><p>为了一定程度上解决这类问题，本节我们将使用<strong>多重采样抗锯齿（Multisampleanti-aliasing,MSAA）</strong>的方式来平滑渲染物体的边缘。<strong>MSAA</strong>简单来说就是在几何体的边缘处进行多重采样，即在一个边缘像素中选取多个样本点采样，最后根据处于几何体内部的样本点比例来确定最后该像素的颜色混合比例。使用多重采样的效果大致如下：</p><figure><img src="/2024/12/26/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7/multi.png" alt="多重采样三角形"><figcaption aria-hidden="true">多重采样三角形</figcaption></figure><p>可见这么做可以一定程度上平滑化原来锯齿状的边缘，提升视觉体验。需要注意的是，多重采样并不会对非边缘像素（完全处于或不处于几何体内部的像素）进行多重采样，这样相比于<strong>SSAA(Supersampleanti-aliasing)</strong>有着显著的性能提升。更详细的关于<strong>MSAA</strong>以及更多采样方式的介绍可以参考<a href="https://www.bilibili.com/video/BV1X7411F744?vd_source=96b763f75b621baa119e5118b6164aee&amp;p=6&amp;spm_id_from=333.788.videopod.episodes">games101</a>中有关课程或者<a href="https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing">这篇文章</a></p><p>本节我们将使用多重采样来改善程序效果。这主要分为以下几步：</p><ul><li>得到最大采样数有关信息</li><li>创建多重采样附件有关资源</li><li>为帧缓冲添加新的多重采样附件</li></ul><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Multisampling">Multisampling</a>章节。</p><hr><h2 id="查询最大采样数">查询最大采样数</h2><p>一般来讲现代硬件都支持每个像素最少8个采样点，不过也不能完全保证这一点。因此保险起见我们还是应该显式地查询硬件支持的每像素最大采样点数。这可以通过查询[<code>VkPhysicalDeviceProperties</code>][id5]来得到。我们新建一个<i><font color="Green">VkSampleCountFlagBitsgetMaxUsableSampleCount()</font></i>函数来进行有关的查询：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkSampleCountFlagBits <span class="hljs-title">getMaxUsableSampleCount</span><span class="hljs-params">()</span> </span>&#123;<br>    VkPhysicalDeviceProperties physicalDeviceProperties;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceProperties</span>(physicalDevice, &amp;physicalDeviceProperties);<br><br>    VkSampleCountFlags counts = physicalDeviceProperties.limits.framebufferColorSampleCounts &amp; physicalDeviceProperties.limits.framebufferDepthSampleCounts;<br>    <span class="hljs-keyword">if</span> (counts &amp; VK_SAMPLE_COUNT_64_BIT) &#123; <span class="hljs-keyword">return</span> VK_SAMPLE_COUNT_64_BIT; &#125;<br>    <span class="hljs-keyword">if</span> (counts &amp; VK_SAMPLE_COUNT_32_BIT) &#123; <span class="hljs-keyword">return</span> VK_SAMPLE_COUNT_32_BIT; &#125;<br>    <span class="hljs-keyword">if</span> (counts &amp; VK_SAMPLE_COUNT_16_BIT) &#123; <span class="hljs-keyword">return</span> VK_SAMPLE_COUNT_16_BIT; &#125;<br>    <span class="hljs-keyword">if</span> (counts &amp; VK_SAMPLE_COUNT_8_BIT) &#123; <span class="hljs-keyword">return</span> VK_SAMPLE_COUNT_8_BIT; &#125;<br>    <span class="hljs-keyword">if</span> (counts &amp; VK_SAMPLE_COUNT_4_BIT) &#123; <span class="hljs-keyword">return</span> VK_SAMPLE_COUNT_4_BIT; &#125;<br>    <span class="hljs-keyword">if</span> (counts &amp; VK_SAMPLE_COUNT_2_BIT) &#123; <span class="hljs-keyword">return</span> VK_SAMPLE_COUNT_2_BIT; &#125;<br><br>    <span class="hljs-keyword">return</span> VK_SAMPLE_COUNT_1_BIT;<br>&#125;<br></code></pre></td></tr></table></figure><p>在查询的时候我们需要兼顾颜色附件和模板附件分别支持的最大采样数，然后取较小的那个，因为我们需要同时使用这两者。这里的查询逻辑是直接返回硬件支持的最大采样数，不过一般而言这未必是效果最好的，可能相比于更低的采样数视觉效果的改善不明显，但是性能上的开销却大了很多。因此在实际应用中还是应该结合视觉效果和性能选取最合适的中间值。</p><p>接下来我们在类内新添一个成员<i><font color="Orange">msaaSamples</font></i>来存储查询得到的多重采样数，并且在<i><font color="Green">pickPhysicalDevice</font></i>中进行查询：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pickPhysicalDevice</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; device : devices) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isDeviceSuitable</span>(device)) &#123;<br>            physicalDevice = device;<br>            msaaSamples = <span class="hljs-built_in">getMaxUsableSampleCount</span>();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="创建多重采样附件资源">创建多重采样附件资源</h2><p>想要使用多重采样，我们必须要创建一个特殊的颜色附件，这个附件能够在一个像素中存储多个样本点。这个多重采样附件不能被用于显示，它只负责写入渲染结果，之后将渲染结果解析到一个正常的颜色附件上，然后再显示这个正常的附件颜色。因此，我们需要创建一个多重采样附件作为渲染结果输出目的地。注意，我们只需要创建一个这样的附件就好了，因为不会有两个渲染操作同时发生，我们只需要反复使用一个多重采样附件即可。</p><p>在类内新添多重采样附件有关的资源成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br>VkImage colorImage;<br>VkDeviceMemory colorImageMemory;<br>VkImageView colorImageView;<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>现在我们在创建图像时就需要考虑图像的每像素采样数了。因此，为<i><font color="Green">createImage</font></i>函数新添一个参数<i><font color="Orange">VkSampleCountFlagBitsnumSamples</font></i>用于传递创建该图像需要的采样数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createImage</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> width, <span class="hljs-type">uint32_t</span> height, <span class="hljs-type">uint32_t</span> mipLevels, VkSampleCountFlagBits numSamples, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage&amp; image, VkDeviceMemory&amp; imageMemory)</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    imageInfo.samples = numSamples;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因此，所有用到该函数的代码都需要改变相应的写法。我们暂时向所有用到该函数的代码的采样数形参传递<i><font color="Red">VK_SAMPLE_COUNT_1_BIT</font></i>，之后我们再来正确设置其中某些代码该形参的具体值。</p><p>现在我们来创建所有多重采样附件资源。在类内新添一个<i><font color="Green">voidcreateColorResources()</font></i>函数来负责创建相应资源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createColorResources</span><span class="hljs-params">()</span> </span>&#123;<br>    VkFormat colorFormat = swapChainImageFormat;<br><br>    <span class="hljs-built_in">createImage</span>(swapChainExtent.width, swapChainExtent.height, <span class="hljs-number">1</span>, msaaSamples, colorFormat, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, colorImage, colorImageMemory);<br>    colorImageView = <span class="hljs-built_in">createImageView</span>(colorImage, colorFormat, VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是，我们在创建多重采样图像时多级渐远层级设置为1个层级，这是因为在Vulkan中，图像使用多重采样就意味着多级渐远层级数只能设置为1，事实上需要多重采样的图像一般是帧缓冲的附件而非纹理，也不需要使用多级渐远纹理。</p><p>然后在<i><font color="Green">initVulkan</font></i>中使用该函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-built_in">createColorResources</span>();<br>    <span class="hljs-built_in">createDepthResources</span>();<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们需要改变之前创建深度附件资源有关代码以使深度附件使用多重采样。深度附件不会被用来展示，所以我们也无需像颜色附件那样为多重采样深度附件再添加一个相应的用于获取解析结果的正常深度附件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createDepthResources</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-built_in">createImage</span>(swapChainExtent.width, swapChainExtent.height, <span class="hljs-number">1</span>, msaaSamples, depthFormat, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, depthImage, depthImageMemory);<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们还需要在重建交换链代码中负责重建多重采样附件有关的资源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recreateSwapChain</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-built_in">createImageViews</span>();<br>    <span class="hljs-built_in">createColorResources</span>();<br>    <span class="hljs-built_in">createDepthResources</span>();<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="添加多重采样附件">添加多重采样附件</h2><p>接下来我们需要更新一下<i><font color="Green">createRenderPass</font></i>函数以添加多重采样功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createRenderPass</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    colorAttachment.samples = msaaSamples;<br>    colorAttachment.finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;<br>    <span class="hljs-comment">//...</span><br>    depthAttachment.samples = msaaSamples;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里颜色附件的最终布局从原来的<i><font color="Red">VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</font></i>更改为了<i><font color="Red">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</font></i>，这是因为当前颜色附件使用了多重采样，它不能直接显示到屏幕上，而是需要先解析到一个正常采样的附件上去。</p><p>现在我们还需要一个用于解析当前多重采样的颜色附件的附件，因此再创建一个相应的解析附件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkAttachmentDescription colorAttachmentResolve&#123;&#125;;<br>colorAttachmentResolve.format = swapChainImageFormat;<br>colorAttachmentResolve.samples = VK_SAMPLE_COUNT_1_BIT;<br>colorAttachmentResolve.loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;<br>colorAttachmentResolve.storeOp = VK_ATTACHMENT_STORE_OP_STORE;<br>colorAttachmentResolve.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;<br>colorAttachmentResolve.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>colorAttachmentResolve.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;<br>colorAttachmentResolve.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;<br></code></pre></td></tr></table></figure><p>当然，我们还需要为这个新附件添加一个相应的附件引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkAttachmentReference colorAttachmentResolveRef&#123;&#125;;<br>colorAttachmentResolveRef.attachment = <span class="hljs-number">2</span>;<br>colorAttachmentResolveRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;<br></code></pre></td></tr></table></figure><p>渲染期间这个解析附件仍然作为颜色附件使用，因此我们将其布局设置为<i><font color="Red">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</font></i>。</p><p>接下来就是向子通道所使用的附件中加入该解析附件以及在创建整个渲染通道时使用该附件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br>subpass.pResolveAttachments = &amp;colorAttachmentResolveRef;<br><span class="hljs-comment">//...</span><br>std::array&lt;VkAttachmentDescription, 3&gt; attachments = &#123;colorAttachment, depthAttachment, colorAttachmentResolve&#125;;<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>渲染通道修改完毕。现在我们还需要修改帧缓冲的构造以添加相应的多重采样图像视图：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createFramebuffers</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//...</span><br>        std::array&lt;VkImageView, 3&gt; attachments = &#123;<br>            colorImageView,<br>            depthImageView,<br>            swapChainImageViews[i]<br>        &#125;;<br>        <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后，别忘了在构建整个渲染管线的时候将多重采样阶段补充上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createGraphicsPipeline</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    multisampling.rasterizationSamples = msaaSamples;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>大功告成！</p><hr><h2 id="进一步的质量改善">进一步的质量改善</h2><p><strong>MSAA</strong>并非毫无瑕疵的。事实上，它只能使得几何体的边缘平滑化，但对几何体的内部却不做任何特殊处理。因此如果我们使用一个图案十分精细、颜色反差较大的贴图，在几何体内部的贴图表面我们还是可以看到明显的走样和锯齿。因此，为了进一步提升视觉体验，我们还可以使用<strong>SampleShading</strong>来平滑化内部像素颜色。</p><p>所谓<strong>SampleShading</strong>，指的是一种在多重采样环境下，允许每个样本独立地进行着色计算的技术。这意味着每个像素的多个样本可以使用不同的颜色计算结果，而不是仅仅使用一个颜色值。</p><p>为了使用<strong>SampleShading</strong>，我们需要首先在Vulkan中开启相应的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createLogicalDevice</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    deviceFeatures.sampleRateShading = VK_TRUE; <br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createGraphicsPipeline</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    multisampling.sampleShadingEnable = VK_TRUE; <br>    multisampling.minSampleShading = <span class="hljs-number">.2f</span>; <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>之后，我们就可以在着色器中进行逐样本的颜色计算了，这可以通过一系列的GLSL内置变量（如<i><font color="Orange">gl_SampleID</font></i>、<i><font color="Orange">gl_SamplePosition</font></i>、<i><font color="Orange">gl_NumSamples</font></i>等）来完成，这里不对其进行深入讨论，仅作了解。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/12/23/CG_api/vulkan/vulkan_tutorial/%E7%94%9F%E6%88%90%E5%A4%9A%E7%BA%A7%E6%B8%90%E8%BF%9C%E7%BA%B9%E7%90%86/">上一篇：生成多级渐远纹理</a></p><p>--<a href="https://zpc-dsg.github.io/2024/12/27/CG_api/vulkan/vulkan_tutorial/%E5%90%8E%E8%AE%B0/">下一篇：后记</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>生成多级渐远纹理</title>
    <link href="/2024/12/23/CG_api/vulkan/vulkan_tutorial/%E7%94%9F%E6%88%90%E5%A4%9A%E7%BA%A7%E6%B8%90%E8%BF%9C%E7%BA%B9%E7%90%86/"/>
    <url>/2024/12/23/CG_api/vulkan/vulkan_tutorial/%E7%94%9F%E6%88%90%E5%A4%9A%E7%BA%A7%E6%B8%90%E8%BF%9C%E7%BA%B9%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>我们的程序现在已经可以渲染3D模型了。不过，在<a href="https://zpc-dsg.github.io/2024/12/21/CG_api/vulkan/vulkan_tutorial/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/">上一章</a>的最终效果图中，如果我们仔细观察，还是可以发现模型墙上的文字有些会呈现出锯齿状的生硬边界，这种缺陷叫做<strong>摩尔纹</strong>。本节中，我们将实现之前多次提及的多级渐远纹理，这将有助于解决摩尔纹的问题。</p><p>所谓多级渐远纹理，就是从一张初始图像合成出一系列像素更少的图像（一般来讲下一张图像宽高均是上一张的一半），这样在采样近处物体的纹理时我们可以使用分辨率高的图像，采样远处物体的时候可以使用分辨率低的图像，这样既不会对视觉体验造成较大的影响，又可以防止远处物体纹理采样点的不准确导致的一系列问题（摩尔纹等）。关于摩尔纹等问题和多级渐远纹理的详细介绍，以及更多关于纹理采样的细节，可以参考<a href="https://www.bilibili.com/video/BV1X7411F744?vd_source=96b763f75b621baa119e5118b6164aee&amp;spm_id_from=333.788.videopod.episodes&amp;p=9">games101</a>有关课程，这里不再赘述。</p><p>本节创建并使用多级渐远纹理的过程可以分为以下两步：</p><ul><li>生成纹理对应的多级渐远纹理</li><li>更改图像采样器以使用多级渐远纹理</li></ul><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Generating_Mipmaps#page_Sampler">GeneratingMipmaps</a>章节。</p><hr><h2 id="生成多级渐远纹理">生成多级渐远纹理</h2><p>首先要明确我们只有纹理需要使用多级渐远纹理，帧缓冲的颜色附件和深度附件是不需要的，因为我们并不会对这些附件进行采样。</p><p>为了使用多级渐远纹理，我们需要知道纹理需要的多级渐远层级数，这可以通过纹理本身的分辨率计算出来。在类内新添一个<i><font color="Orange">uint32_tmipLevels</font></i>来存储该层级数，然后在加载纹理的时候获取该层级数的具体值：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> texWidth, texHeight, texChannels;<br>stbi_uc* pixels = <span class="hljs-built_in">stbi_load</span>(TEXTURE_PATH.<span class="hljs-built_in">c_str</span>(), &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);<br>...<br>mipLevels = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(std::<span class="hljs-built_in">floor</span>(std::<span class="hljs-built_in">log2</span>(std::<span class="hljs-built_in">max</span>(texWidth, texHeight)))) + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></p><p>可以看到，这里我们采取的策略是通过宽、高中较大的那个是2的多少次方来确定有多少层，每一层的宽、高就是上一层除以2（如果宽、高中较小的那个在某一层是1了，那么在后续的所有层中它保持大小为1）。</p><p>现在我们需要修改所有图像创建和布局转换函数来添加上对多级渐远层级的使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createImage</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> width, <span class="hljs-type">uint32_t</span> height, <span class="hljs-type">uint32_t</span> mipLevels, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage&amp; image, VkDeviceMemory&amp; imageMemory)</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    imageInfo.mipLevels = mipLevels;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...</span><br><span class="hljs-function">VkImageView <span class="hljs-title">createImageView</span><span class="hljs-params">(VkImage image, VkFormat format, VkImageAspectFlags aspectFlags, <span class="hljs-type">uint32_t</span> mipLevels)</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    viewInfo.subresourceRange.levelCount = mipLevels;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transitionImageLayout</span><span class="hljs-params">(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout, <span class="hljs-type">uint32_t</span> mipLevels)</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    barrier.subresourceRange.levelCount = mipLevels;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同时我们需要更新所有使用到这些函数的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">createImage</span>(swapChainExtent.width, swapChainExtent.height, <span class="hljs-number">1</span>, depthFormat, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, depthImage, depthImageMemory);<br><span class="hljs-comment">//...</span><br><span class="hljs-built_in">createImage</span>(texWidth, texHeight, mipLevels, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);<br><span class="hljs-comment">//...</span><br>swapChainImageViews[i] = <span class="hljs-built_in">createImageView</span>(swapChainImages[i], swapChainImageFormat, VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">1</span>);<br><span class="hljs-comment">//...</span><br>depthImageView = <span class="hljs-built_in">createImageView</span>(depthImage, depthFormat, VK_IMAGE_ASPECT_DEPTH_BIT, <span class="hljs-number">1</span>);<br><span class="hljs-comment">//...</span><br>textureImageView = <span class="hljs-built_in">createImageView</span>(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_ASPECT_COLOR_BIT, mipLevels);<br><span class="hljs-comment">//...</span><br><span class="hljs-built_in">transitionImageLayout</span>(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, mipLevels);<br></code></pre></td></tr></table></figure><p>现在我们的图像已经具备了多个渐远层级，但是目前除了基础层级之外，其它的层级还没有任何内容，因为我们还没有将图像数据填充到这些新的层级中，接下来我们就来手动生成这些层级的图像内容。</p><p>为了填充每个层级的图像，我们可以使用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage.html"><code>vkCmdBlitImage</code></a>函数将某一个层级的内容经过滤后复制到另一个层级上。该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdBlitImage</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    VkImage                                     srcImage,</span><br><span class="hljs-params">    VkImageLayout                               srcImageLayout,</span><br><span class="hljs-params">    VkImage                                     dstImage,</span><br><span class="hljs-params">    VkImageLayout                               dstImageLayout,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    regionCount,<span class="hljs-comment">//过滤传输的区域数</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkImageBlit*                          pRegions,<span class="hljs-comment">//过滤传输的区域</span></span><br><span class="hljs-params">    VkFilter                                    filter)</span>;<br></code></pre></td></tr></table></figure><p>可以看到，我们可以将图像的多块数据分别进行过滤传输。其中，我们需要使用[<code>VkImageBlit</code>][id]类型的成员来指定每个传输区域的范围。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkImageBlit</span> &#123;</span><br>    VkImageSubresourceLayers    srcSubresource;<br>    VkOffset3D                  srcOffsets[<span class="hljs-number">2</span>];<br>    VkImageSubresourceLayers    dstSubresource;<br>    VkOffset3D                  dstOffsets[<span class="hljs-number">2</span>];<br>&#125; VkImageBlit;<br></code></pre></td></tr></table></figure><p>每个成员都是易于理解的。</p><p><i><font color="Orange">filter</font></i>用于指定如果传输源和目标图像的大小不同，那么在缩放的时候应该采取怎样的颜色过滤模式。</p><p>另外可以看到，在使用该函数时我们需要指定源图像和目标图像的布局。我们当然需要源图像布局是<i><font color="Red">VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</font></i>而目标图像的布局为<i><font color="Red">VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</font></i>。因此在生成多级渐远纹理的每个层级的时候，我们在使用该函数之前还需要将每个层级的图像转换到合适的布局。</p><p>总的来讲，生成某张纹理的多级渐远纹理的整个流程应该是这样的：首先创建存储纹理数据的图像和它的所有渐远层级，然后使用<i><font color="Green">transitionImageLayout</font></i>将所有层级的图像布局均设置为<i><font color="Red">VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</font></i>以接收临时缓冲中的图像数据。现在基础层图像已经有了相应的纹理数据，然后我们把该层数据通过<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage.html"><code>vkCmdBlitImage</code></a>函数传输给下一个层级，在传输之前，我们当然需要先将基础层的图像布局转换为<i><font color="Red">VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</font></i>。在传输结束后，我们可以立刻将基础层的图像布局转化为<i><font color="Red">VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</font></i>以供后续着色器读取。这样我们的第二层图像就具有了相应的纹理数据，循环进行这一步骤，直到所有的层级都填充好了纹理数据即可。</p><p>下面来实现这样的代码逻辑。我们需要将原来的<i><font color="Green">createTextureImage</font></i>修改为如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createTextureImage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> texWidth, texHeight, texChannels;<br>    stbi_uc* pixels = <span class="hljs-built_in">stbi_load</span>(TEXTURE_PATH.<span class="hljs-built_in">c_str</span>(), &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);<br>    VkDeviceSize imageSize = texWidth * texHeight * <span class="hljs-number">4</span>;<br>    mipLevels = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(std::<span class="hljs-built_in">floor</span>(std::<span class="hljs-built_in">log2</span>(std::<span class="hljs-built_in">max</span>(texWidth, texHeight)))) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (!pixels) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to load texture image!&quot;</span>);<br>    &#125;<br><br>    VkBuffer stagingBuffer;<br>    VkDeviceMemory stagingBufferMemory;<br>    <span class="hljs-built_in">createBuffer</span>(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);<br><br>    <span class="hljs-type">void</span>* data;<br>    <span class="hljs-built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="hljs-number">0</span>, imageSize, <span class="hljs-number">0</span>, &amp;data);<br>    <span class="hljs-built_in">memcpy</span>(data, pixels, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(imageSize));<br>    <span class="hljs-built_in">vkUnmapMemory</span>(device, stagingBufferMemory);<br><br>    <span class="hljs-built_in">stbi_image_free</span>(pixels);<br><br>    <span class="hljs-built_in">createImage</span>(texWidth, texHeight, mipLevels, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);<br><br>    <span class="hljs-built_in">transitionImageLayout</span>(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, mipLevels);<br>    <span class="hljs-built_in">copyBufferToImage</span>(stagingBuffer, textureImage, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(texWidth), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(texHeight));<br>    <br>    <span class="hljs-built_in">vkDestroyBuffer</span>(device, stagingBuffer, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">vkFreeMemory</span>(device, stagingBufferMemory, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-built_in">generateMipmaps</span>(textureImage, VK_FORMAT_R8G8B8A8_SRGB, texWidth, texHeight, mipLevels);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们添加了一个<i><font color="Green">generateMipmaps</font></i>函数来处理从图像生成它的所有多级渐远纹理的代码逻辑。按照我们之前的叙述，这段代码应该如下编写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">generateMipmaps</span><span class="hljs-params">(VkImage image, VkFormat imageFormat, <span class="hljs-type">int32_t</span> texWidth, <span class="hljs-type">int32_t</span> texHeight, <span class="hljs-type">uint32_t</span> mipLevels)</span> </span>&#123;<br>    VkFormatProperties formatProperties;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceFormatProperties</span>(physicalDevice, imageFormat, &amp;formatProperties);<br><br>    <span class="hljs-keyword">if</span> (!(formatProperties.optimalTilingFeatures &amp; VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT)) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;texture image format does not support linear blitting!&quot;</span>);<br>    &#125;<br><br>    VkCommandBuffer commandBuffer = <span class="hljs-built_in">beginSingleTimeCommands</span>();<br><br>    VkImageMemoryBarrier barrier&#123;&#125;;<br>    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;<br>    barrier.image = image;<br>    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;<br>    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;<br>    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br>    barrier.subresourceRange.baseArrayLayer = <span class="hljs-number">0</span>;<br>    barrier.subresourceRange.layerCount = <span class="hljs-number">1</span>;<br>    barrier.subresourceRange.levelCount = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">int32_t</span> mipWidth = texWidth;<br>    <span class="hljs-type">int32_t</span> mipHeight = texHeight;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">1</span>; i &lt; mipLevels; i++) &#123;<br>        barrier.subresourceRange.baseMipLevel = i - <span class="hljs-number">1</span>;<br>        barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;<br>        barrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;<br>        barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;<br>        barrier.dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;<br><br>        <span class="hljs-built_in">vkCmdPipelineBarrier</span>(commandBuffer,<br>            VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, <span class="hljs-number">0</span>,<br>            <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>            <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>            <span class="hljs-number">1</span>, &amp;barrier);<br><br>        VkImageBlit blit&#123;&#125;;<br>        blit.srcOffsets[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        blit.srcOffsets[<span class="hljs-number">1</span>] = &#123;mipWidth, mipHeight, <span class="hljs-number">1</span>&#125;;<br>        blit.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br>        blit.srcSubresource.mipLevel = i - <span class="hljs-number">1</span>;<br>        blit.srcSubresource.baseArrayLayer = <span class="hljs-number">0</span>;<br>        blit.srcSubresource.layerCount = <span class="hljs-number">1</span>;<br>        blit.dstOffsets[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        blit.dstOffsets[<span class="hljs-number">1</span>] = &#123; mipWidth &gt; <span class="hljs-number">1</span> ? mipWidth / <span class="hljs-number">2</span> : <span class="hljs-number">1</span>, mipHeight &gt; <span class="hljs-number">1</span> ? mipHeight / <span class="hljs-number">2</span> : <span class="hljs-number">1</span>, <span class="hljs-number">1</span> &#125;;<br>        blit.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br>        blit.dstSubresource.mipLevel = i;<br>        blit.dstSubresource.baseArrayLayer = <span class="hljs-number">0</span>;<br>        blit.dstSubresource.layerCount = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-built_in">vkCmdBlitImage</span>(commandBuffer,<br>            image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,<br>            image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,<br>            <span class="hljs-number">1</span>, &amp;blit,<br>            VK_FILTER_LINEAR);<br><br>        barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;<br>        barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;<br>        barrier.srcAccessMask = VK_ACCESS_TRANSFER_READ_BIT;<br>        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;<br><br>        <span class="hljs-built_in">vkCmdPipelineBarrier</span>(commandBuffer,<br>            VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, <span class="hljs-number">0</span>,<br>            <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>            <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>            <span class="hljs-number">1</span>, &amp;barrier);<br><br>        <span class="hljs-keyword">if</span> (mipWidth &gt; <span class="hljs-number">1</span>) mipWidth /= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (mipHeight &gt; <span class="hljs-number">1</span>) mipHeight /= <span class="hljs-number">2</span>;<br>    &#125;<br><br>    barrier.subresourceRange.baseMipLevel = mipLevels - <span class="hljs-number">1</span>;<br>    barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;<br>    barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;<br>    barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;<br>    barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;<br><br>    <span class="hljs-built_in">vkCmdPipelineBarrier</span>(commandBuffer,<br>        VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, <span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>        <span class="hljs-number">1</span>, &amp;barrier);<br><br>    <span class="hljs-built_in">endSingleTimeCommands</span>(commandBuffer); &#125;<br><br></code></pre></td></tr></table></figure><p>下面我们来逐步解释代码细节：</p><p>这段代码首先检查了硬件是否支持线性过滤功能。事实上，如果需要使用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage.html"><code>vkCmdBlitImage</code></a>函数，那么所处理的图像格式一定需要支持线性过滤，这可以通过查询物理设备支持的格式特性来完成，我们在<a href="https://zpc-dsg.github.io/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/">深度缓冲</a>章节中已经看到相应的做法，这里不再赘述。</p><p>接下来我们需要创建一个图像内存屏障来显式同步和各层图像布局转换有关的操作。由于有多层图像需要生成，我们会创建一个for循环来生成所有的层级，并且在这些层级的生成过程中重用同一个内存屏障以提高效率。循环的开始，我们首先将当前处理层级的图像布局从一开始的传输目的地转变为传输源。注意，如果当前层是第一层，那么该层会作为从缓冲区复制图像数据的目的地；如果不是第一层，那么该层会是前一层传输过滤后图像数据的目的地（也就是[]<code>vkCmdBlitImage</code>]<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage.html">id4</a>操作的目的地），不管是哪种情况，当前层图像布局一开始都会是<i><font color="Red">VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</font></i>（因为<i><font color="Green">transitionImageLayout</font></i>将每一层布局都变成了这个），我们都需要将当前层布局转化为<i><font color="Red">VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</font></i>以执行后续操作（即将当前层数据传输给下一层的操作）。</p><p>在当前层布局转换完成后，我们就可以开始向下一层传输数据了。通过<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage.html"><code>vkCmdBlitImage</code></a>函数原型可知我们需要填写一个[<code>VkImageBlit</code>][id]结构体来指定传输范围。这一段的代码比较直观。</p><p>在循环的最后，我们已经完成了当前层数据的传输，接下来不再需要在传输中使用当前层了，我们可以将其布局转换为适合之后着色器读取的布局<i><font color="Red">VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</font></i>。</p><p>不过可以发现，在该函数的末尾我们还单独对最后一层进行了处理，将它的布局转换为<i><font color="Red">VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</font></i>。这是因为最后一层不会作为传输源将数据传输给下一层了，我们的for循环中实际上没有处理最后一层的图像布局转换。因此最后我们需要在循环外单独将最后一层的布局转换为需要的布局。</p><p>这样我们就完成了生成多级渐远纹理的各个层级的操作！</p><hr><h2 id="更改图像采样器">更改图像采样器</h2><p>还记得在<a href="https://zpc-dsg.github.io/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/">图像视图和采样器</a>章节中我们在填写创建采样器的信息结构体<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerCreateInfo.html"><code>VkSamplerCreateInfo</code></a>时没有填写和多级渐远有关的成员<i><font color="Orange">minLod</font></i>，<i><font color="Orange">maxLod</font></i>，<i><font color="Orange">mipLodBias</font></i>和<i><font color="Orange">mipmapMode</font></i>吗？这几个成员用于控制着色器将如何使用多级渐远纹理以及采样器在什么时候选择哪个层级的纹理。事实上，在指定了这几个成员后，采样器选择层级以及着色器渲染得到最终颜色的伪代码大概是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">lod = <span class="hljs-built_in">getLodLevelFromScreenSize</span>(); <br>lod = <span class="hljs-built_in">clamp</span>(lod + mipLodBias, minLod, maxLod);<br><br>level = <span class="hljs-built_in">clamp</span>(<span class="hljs-built_in">floor</span>(lod), <span class="hljs-number">0</span>, texture.mipLevels - <span class="hljs-number">1</span>);  <br><br><span class="hljs-keyword">if</span> (mipmapMode == VK_SAMPLER_MIPMAP_MODE_NEAREST) &#123;<br>    color = <span class="hljs-built_in">sample</span>(level);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    color = <span class="hljs-built_in">blend</span>(<span class="hljs-built_in">sample</span>(level), <span class="hljs-built_in">sample</span>(level + <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，在采样过程中，采样使用的过滤方式也会受到<strong>Lod(Level ofDetail)</strong>的影响，大致原理用伪代码表示如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (lod &lt;= <span class="hljs-number">0</span>) &#123;<br>    color = <span class="hljs-built_in">readTexture</span>(uv, magFilter);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    color = <span class="hljs-built_in">readTexture</span>(uv, minFilter);<br>&#125;<br></code></pre></td></tr></table></figure><p>于是在我们的程序中，为了使用多级渐远纹理，我们需要正确设置采样器对纹理层级的采样方式。设置代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createTextureSampler</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <br>    samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;<br>    samplerInfo.minLod = <span class="hljs-number">0.0f</span>; <br>    samplerInfo.maxLod = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(mipLevels);<br>    samplerInfo.mipLodBias = <span class="hljs-number">0.0f</span>; <br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以使用所有层级的渐远纹理了。</p><p>下图对比了使用多级渐远纹理和不使用多级渐远纹理得到图像的区别：</p><figure><img src="/2024/12/23/CG_api/vulkan/vulkan_tutorial/%E7%94%9F%E6%88%90%E5%A4%9A%E7%BA%A7%E6%B8%90%E8%BF%9C%E7%BA%B9%E7%90%86/mipmap.png" alt="有无渐远纹理（左无右有）"><figcaption aria-hidden="true">有无渐远纹理（左无右有）</figcaption></figure><p>乍一看没有什么区别，不过仔细观察上图中斧子的边缘还是可以发现多级渐远纹理的使用使得斧头的边缘有了一定程度的平滑和模糊。</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/12/21/CG_api/vulkan/vulkan_tutorial/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/">上一篇：加载模型</a></p><p>--<a href="https://zpc-dsg.github.io/2024/12/26/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7/">下一篇：多重采样</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>加载模型</title>
    <link href="/2024/12/21/CG_api/vulkan/vulkan_tutorial/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/12/21/CG_api/vulkan/vulkan_tutorial/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在结束了<a href="https://zpc-dsg.github.io/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/">深度缓冲</a>章节后，我们终于可以正确地渲染3D场景了。本章我们将在程序中渲染3D模型而不再是简单的四边形。为此，我们会用到<a href="https://github.com/tinyobjloader/tinyobjloader">tinyobjloader</a>库来进行模型的加载。本节主要分为两步</p><ul><li>选择想要渲染模型</li><li>获取模型顶点信息以进行渲染</li></ul><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Loading_models">Loadingmodels</a>章节。</p><hr><h2 id="选择模型">选择模型</h2><p>教程提供了一个获取OBJ格式3D模型的网站<a href="https://sketchfab.com/">Sketchfab</a>，并且使用了其中一个模型：</p><ul><li><a href="https://vulkan-tutorial.com/resources/viking_room.obj">viking_room.obj</a></li><li><a href="https://vulkan-tutorial.com/resources/viking_room.png">viking_room.png</a></li></ul><p>该模型会使用到一个相应的纹理。因为目前我们并没有给程序添加上光照效果，所以需要一个提前烘焙好光照信息的纹理来展示模型的颜色。将该模型保存到程序根目录的<strong>models</strong>文件夹下。</p><p>我们可以利用之前使用过的<a href="https://github.com/nothings/stb">stb</a>库将纹理首先加载到程序中来。为此，我们先添加两个全局变量<i><font color="Orange">MODEL_PATH</font></i>和<i><font color="Orange">TEXTURE_PATH</font></i>分别代表模型和纹理的路径，并且更新<i><font color="Green">createTextureImage</font></i>的纹理加载代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">stbi_uc* pixels = <span class="hljs-built_in">stbi_load</span>(TEXTURE_PATH.<span class="hljs-built_in">c_str</span>(), &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);<br></code></pre></td></tr></table></figure><hr><h2 id="获取顶点">获取顶点</h2><p>下面我们开始将模型加载到程序中来并获取模型顶点信息供渲染使用。在类内新添两个成员<i><font color="Orange">std::vector<Vertex>vertices</Vertex></font></i>和<i><font color="Orange">std::vector<uint32_t>indices</uint32_t></font></i>代替原来程序中相应的全局变量。之所以这里索引使用<strong>uint_32_t</strong>而非原来的<strong>uint_16_t</strong>是因为模型的顶点数很有可能会超过<strong>uint16_t</strong>所能容纳的最大数目65535。因此相应地，录制命令函数<i><font color="Green">recordCommandBuffer</font></i>中在录制顶点索引绑定命令时也要使用<strong>uint32</strong>格式的索引值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdBindIndexBuffer</span>(commandBuffer, indexBuffer, <span class="hljs-number">0</span>, VK_INDEX_TYPE_UINT32);<br></code></pre></td></tr></table></figure><p>接下来我们在类内新建一个函数<i><font color="Green">voidloadModel()</font></i>来加载需要的模型。同时，我们需要包含加载模型需要使用的头文件<strong>tiny_obj_loader.h</strong>，并且定义宏<i><font color="Red">TINYOBJLOADER_IMPLEMENTATION</font></i>来获取头文件内函数的函数体。</p><p>加载模型的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loadModel</span><span class="hljs-params">()</span> </span>&#123;<br>    tinyobj::<span class="hljs-type">attrib_t</span> attrib;<br>    std::vector&lt;tinyobj::<span class="hljs-type">shape_t</span>&gt; shapes;<br>    std::vector&lt;tinyobj::<span class="hljs-type">material_t</span>&gt; materials;<br>    std::string warn, err;<br><br>    <span class="hljs-keyword">if</span> (!tinyobj::<span class="hljs-built_in">LoadObj</span>(&amp;attrib, &amp;shapes, &amp;materials, &amp;warn, &amp;err, MODEL_PATH.<span class="hljs-built_in">c_str</span>())) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(warn + err);<br>    &#125;<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们从模型中获取了三种信息，其中<i><font color="Orange">attrib</font></i>包含了该模型的所有顶点信息，包括顶点位置，顶点法线，顶点纹理坐标等；<i><font color="Orange">shapes</font></i>包含了所有模型中包含的不同部件以及每个部件中的所有面的信息，每个面由一列顶点数组组成，每个顶点包含它的位置、法线、纹理坐标等属性在<i><font color="Orange">attrib</font></i>中的索引；<i><font color="Orange">materials</font></i>包含了每个面的材质信息，本节中我们将暂时忽略这些材质的使用。另外，理论上<i><font color="Orange">shapes</font></i>中可以包含任意形状的面，但是目前我们的程序只能渲染三角形的面，不过好在<strong>tinyobj::LoadObj</strong>提供了一个可选的参数来对模型中的所有面片进行三角剖分，而这个参数是默认启用的。</p><p>下面我们准备获取该模型所有顶点和索引的信息。如果我们暂时不考虑顶点重复的情形（也就是收暂时认为所有顶点索引互不相同），那么填充类内<i><font color="Orange">vertices</font></i>和<i><font color="Orange">indices</font></i>成员的代码应该如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; shape : shapes) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; index : shape.mesh.indices) &#123;<br>        Vertex vertex&#123;&#125;;<br><br>        vertex.pos = &#123;<br>    attrib.vertices[<span class="hljs-number">3</span> * index.vertex_index + <span class="hljs-number">0</span>],<br>    attrib.vertices[<span class="hljs-number">3</span> * index.vertex_index + <span class="hljs-number">1</span>],<br>    attrib.vertices[<span class="hljs-number">3</span> * index.vertex_index + <span class="hljs-number">2</span>]<br>&#125;;<br><br>        vertex.texCoord = &#123;<br>    attrib.texcoords[<span class="hljs-number">2</span> * index.texcoord_index + <span class="hljs-number">0</span>],<br>    <span class="hljs-number">1.0f</span> - attrib.texcoords[<span class="hljs-number">2</span> * index.texcoord_index + <span class="hljs-number">1</span>]<br>&#125;;<br><br>    vertex.color = &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>&#125;;<br>        <br>        vertices.<span class="hljs-built_in">push_back</span>(vertex);<br>        indices.<span class="hljs-built_in">push_back</span>(indices.<span class="hljs-built_in">size</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先注意，因为我们已经对加载的模型面片进行了三角剖分，因此顶点应该是三个一组构成一个面。另外，可以看到顶底纹理坐标的第二个坐标并非直接取用<i><font color="Orange">attrib.texcoords</font></i>中存储的坐标，这是因为在Vulkan中<strong>0.0</strong>代表的竖直纹理坐标是在屏幕最上方的，所以我们需要将这个坐标颠倒一下以获得正确的纹理效果。</p><p>在获取到所有顶点和索引信息后，其它渲染流程不变，这样程序应该就能正常运行并且显示出我们选择的模型了！但是事实上我们这么做还不够高效，因为模型中很多顶点是会重复的，也就是说很多顶点其实会共用一个索引，但是我们在上述代码中将这些重复的顶点信息全部储存了起来，浪费了大量的内存空间。因此接下来我们将实现获取所有无重顶点信息的代码。</p><p>为此，我们可以使用一个<a href="https://en.cppreference.com/w/cpp/container/unordered_map">unordered_map</a>来存储所有已经出现过的顶点，然后通过将当前加载的顶点信息和这些已经出现过的顶点信息进行比较以决定该顶点是否是第一次出现，如果是则将其加入<i><font color="Orange">vertices</font></i>中，否则只添加该顶点的索引信息到<i><font color="Orange">indices</font></i>中，代码逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::unordered_map&lt;Vertex, <span class="hljs-type">uint32_t</span>&gt; uniqueVertices&#123;&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; shape : shapes) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; index : shape.mesh.indices) &#123;<br>        Vertex vertex&#123;&#125;;<br><br>        vertex.pos = &#123;<br>            attrib.vertices[<span class="hljs-number">3</span> * index.vertex_index + <span class="hljs-number">0</span>],<br>            attrib.vertices[<span class="hljs-number">3</span> * index.vertex_index + <span class="hljs-number">1</span>],<br>            attrib.vertices[<span class="hljs-number">3</span> * index.vertex_index + <span class="hljs-number">2</span>]<br>        &#125;;<br><br>        vertex.texCoord = &#123;<br>            attrib.texcoords[<span class="hljs-number">2</span> * index.texcoord_index + <span class="hljs-number">0</span>],<br>            <span class="hljs-number">1.0f</span> - attrib.texcoords[<span class="hljs-number">2</span> * index.texcoord_index + <span class="hljs-number">1</span>]<br>        &#125;;<br><br>        vertex.color = &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>&#125;;<br><br>        <span class="hljs-keyword">if</span> (uniqueVertices.<span class="hljs-built_in">count</span>(vertex) == <span class="hljs-number">0</span>) &#123;<br>            uniqueVertices[vertex] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertices.<span class="hljs-built_in">size</span>());<br>            vertices.<span class="hljs-built_in">push_back</span>(vertex);<br>        &#125;<br><br>        indices.<span class="hljs-built_in">push_back</span>(uniqueVertices[vertex]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过这里需要注意的是，我们使用自定义结构体<i><font color="Orange">Vertex</font></i>作为<a href="https://en.cppreference.com/w/cpp/container/unordered_map">unordered_map</a>的键，c++规定一个结构体要作为<a href="https://en.cppreference.com/w/cpp/container/unordered_map">unordered_map</a>的键，它必须具有等于运算符<a href="https://en.cppreference.com/w/cpp/language/operators">operator==</a>以及是可哈希的。因此我们必须为该结构体定义相应的取等运算符以及哈希运算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在Vertex类内</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Vertex&amp; other) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> pos == other.pos &amp;&amp; color == other.color &amp;&amp; texCoord == other.texCoord;<br>&#125;<br><br><span class="hljs-comment">//在Vertex类外</span><br><span class="hljs-keyword">namespace</span> std &#123;<br>    <span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hash</span>&lt;Vertex&gt; &#123;<br>        <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Vertex <span class="hljs-type">const</span>&amp; vertex)</span> <span class="hljs-type">const</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> ((<span class="hljs-built_in">hash</span>&lt;glm::vec3&gt;()(vertex.pos) ^<br>                   (<span class="hljs-built_in">hash</span>&lt;glm::vec3&gt;()(vertex.color) &lt;&lt; <span class="hljs-number">1</span>)) &gt;&gt; <span class="hljs-number">1</span>) ^<br>                   (<span class="hljs-built_in">hash</span>&lt;glm::vec2&gt;()(vertex.texCoord) &lt;&lt; <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>哈希运算的定义涉及到模板偏特化、函数对象等c++高级主题，不熟悉的读者可以翻阅<strong><i>C++Primer</i></strong>一书来了解这些主题。另外注意到，我们在定义<i><font color="Orange">Vertex</font></i>的哈希函数的时候使用到了<strong>glm::vec2</strong>和<strong>glm::vec3</strong>的哈希函数，这需要我们引入相应得头文件<strong>glm/gtx/hash.hpp</strong>并且启用宏<i><font color="Red">GLM_ENABLE_EXPERIMENTAL</font></i>之后才能使用。</p><p>大功告成！现在我们的程序应该会高效很多。事实上，在我们的程序中，这么做能将顶点数从1,500,000减少到265,645！最终我们得到的结果如下：</p><figure><img src="/2024/12/21/CG_api/vulkan/vulkan_tutorial/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/model.png" alt="3D模型"><figcaption aria-hidden="true">3D模型</figcaption></figure><hr><p>--<a href="https://zpc-dsg.github.io/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/">上一篇：深度缓冲</a></p><p>--<a href="https://zpc-dsg.github.io/2024/12/23/CG_api/vulkan/vulkan_tutorial/%E7%94%9F%E6%88%90%E5%A4%9A%E7%BA%A7%E6%B8%90%E8%BF%9C%E7%BA%B9%E7%90%86/">下一篇：生成多级渐远纹理</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深度缓冲</title>
    <link href="/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/"/>
    <url>/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>当我们需要在屏幕上渲染多个三维空间中的物体时，如何正确地表现它们之间的遮挡关系就成了绕不开的问题。一个自然的想法是按照距离视点的远近从近到远排序，然后按顺序绘制每个物体，但这样的方式存在诸多问题，最直接的问题就是物体之间可能没有严格的顺序可言，比如物体A一部分在物体B后，但另一部分在B前。因此，我们引入深度缓冲来解决（非透明）物体的渲染顺序问题。当使用深度缓冲时，我们不再需要按照固定的顺序渲染物体，因为深度缓冲会将当前渲染像素的深度与像素中储存的深度值进行比较，保留较近的那一个。本节我们就来为程序添加上深度缓冲支持，这主要可以分为七步：</p><ul><li>修改顶点属性和着色器代码以加入深度值</li><li>创建深度图像和相应视图</li><li>修改渲染通道以添加深度附件</li><li>修改帧缓冲以添加深度附件</li><li>修改命令录制函数以添加深度清除值</li><li>修改渲染管线以添加深度模板状态</li><li>修改交换链重建函数以添加深度图像重建代码</li></ul><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Depth_buffering">Depthbuffering</a>章节。</p><hr><h2 id="修改顶点和着色器">修改顶点和着色器</h2><p>我们现在希望使用具有深度的物体，因此顶点坐标应该改为用一个三维向量表示，并且更新获取顶点属性的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vertex</span> &#123;<br>    glm::vec3 pos;<br>    glm::vec3 color;<br>    glm::vec2 texCoord;<br><br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-function"><span class="hljs-type">static</span> std::array&lt;VkVertexInputAttributeDescription, 3&gt; <span class="hljs-title">getAttributeDescriptions</span><span class="hljs-params">()</span> </span>&#123;<br>        std::array&lt;VkVertexInputAttributeDescription, 3&gt; attributeDescriptions&#123;&#125;;<br><br>        attributeDescriptions[<span class="hljs-number">0</span>].binding = <span class="hljs-number">0</span>;<br>        attributeDescriptions[<span class="hljs-number">0</span>].location = <span class="hljs-number">0</span>;<br>        attributeDescriptions[<span class="hljs-number">0</span>].format = VK_FORMAT_R32G32B32_SFLOAT;<br>        attributeDescriptions[<span class="hljs-number">0</span>].offset = <span class="hljs-built_in">offsetof</span>(Vertex, pos);<br><br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>为了展示深度缓冲对顺序无关渲染的作用，我们现在绘制两个重叠的四边形，先绘制底下的那个再绘制顶上的那个，因此相应修改实际的顶点数据如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;Vertex&gt; vertices = &#123;<br>    &#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;,<br><br>    &#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;<br>&#125;;<br><br><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">uint16_t</span>&gt; indices = &#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>着色器代码同样需要修改以正确传入三维向量表示的顶点坐标：<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inPosition;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">void</span> main() &#123;<br>    <span class="hljs-built_in">gl_Position</span> = ubo.proj * ubo.view * ubo.model * <span class="hljs-type">vec4</span>(inPosition, <span class="hljs-number">1.0</span>);<br>    fragColor = inColor;<br>    fragTexCoord = inTexCoord;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这里需要注意的是，我们需要通过<strong>glm::perspective</strong>构建透视投影矩阵并传递给着色器。如果我们保持GLM的默认行为的话那么这样创建的投影矩阵作用后会使得深度值在[-1,1]之间，这是符合OpenGL规范的，但是Vulkan要求深度值插值后需要在[0,1]之间，因此我们还需要在程序头定义宏<i><font color="Red">GLM_FORCE_DEPTH_ZERO_TO_ONE</font></i>以使得这样创建的投影矩阵满足Vulkan的需求。</p><p>如果我们不使用深度缓冲直接渲染，那么结果如下：</p><figure><img src="/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/without.png" alt="不使用深度缓冲"><figcaption aria-hidden="true">不使用深度缓冲</figcaption></figure><p>显然这样的渲染结果是不正确的，下面的图像反而遮挡住了上面的图像，这是因为我们没有对哪个图像应该渲染在上面做任何指定，因此后渲染的图像就会覆盖之前渲染的图像，不管它们实际顺序如何。下面我们就使用深度缓冲来解决这一问题。</p><hr><h2 id="创建深度缓冲有关资源">创建深度缓冲有关资源</h2><p>深度附件和颜色附件一样是基于图像的，但是和颜色附件不同的是交换链并不会为我们自动创建深度附件，因此我们需要手动创建一个深度附件（之所以只用创建一个附件，是因为不会有两个渲染操作同时进行，因此我们只需要令所有的颜色附件共用一个深度附件即可）。在类内添加一个<i><font color="Green">voidcreateDepthResources()</font></i>函数来创建深度附件有关的资源，包括深度图像，深度视图和深度图像的内存，因此在类内新添三个成员来保存这些资源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkImage depthImage;<br>VkDeviceMemory depthImageMemory;<br>VkImageView depthImageView;<br></code></pre></td></tr></table></figure><p>创建这些资源的流程和之前创建图像的流程基本一致，只不过我们需要设置对应于深度缓冲的图像格式，下面列举出一些适用于深度缓冲的图像格式：</p><ul><li><code>VK_FORMAT_D32_SFLOAT</code>: 32位浮点深度值</li><li><code>VK_FORMAT_D32_SFLOAT_S8_UINT</code>:32位符号浮点深度值和8位无符号整型模板值</li><li><code>VK_FORMAT_D24_UNORM_S8_UINT</code>:24位无符号归一化深度值和8位无符号整型模板值</li></ul><p>在不同的情境下，我们可能希望使用不同的深度图像格式（比如说有时候我们可能需要使用模板测试有时不需要，关于模板测试的更多介绍，可以参考<a href="https://learnopengl.com/Advanced-OpenGL/Stencil-testing">这个页面</a>，本教程不会涉及到模板测试），因此为了灵活性起见我们创建一个函数<i><font color="Green">VkFormatfindSupportedFormat(const std::vector<VkFormat>&amp; candidates,VkImageTiling tiling, VkFormatFeatureFlagsfeatures)</VkFormat></font></i>来挑选所需的格式。</p><p>对于形参<i><font color="Orange">candidates</font></i>中的每个格式，我们需要查询硬件上该格式所具有的特性和支持的操作以判断该格式是否满足我们的需求，这个查询操作通过调用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFormatProperties.html"><code>vkGetPhysicalDeviceFormatProperties</code></a>完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (VkFormat format : candidates) &#123;<br>    VkFormatProperties props;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceFormatProperties</span>(physicalDevice, format, &amp;props);<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>查询得到的<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkFormatProperties.html"><code>VkFormatProperties</code></a>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkFormatProperties</span> &#123;</span><br>    VkFormatFeatureFlags    linearTilingFeatures;<span class="hljs-comment">//tiling mode为VK_IMAGE_TILING_LINEAR的该格式图像支持的特性</span><br>    VkFormatFeatureFlags    optimalTilingFeatures;<span class="hljs-comment">//tiling mode为VK_IMAGE_TILING_OPTIMAL的该格式图像支持的特性</span><br>    VkFormatFeatureFlags    bufferFeatures;<span class="hljs-comment">//该格式缓冲区支持的特性</span><br>&#125; VkFormatProperties;<br></code></pre></td></tr></table></figure><p>只有前两个成员是和图像有关的，于是我们完整的查询代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkFormat <span class="hljs-title">findSupportedFormat</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;VkFormat&gt;&amp; candidates, VkImageTiling tiling, VkFormatFeatureFlags features)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (VkFormat format : candidates) &#123;<br>        VkFormatProperties props;<br>        <span class="hljs-built_in">vkGetPhysicalDeviceFormatProperties</span>(physicalDevice, format, &amp;props);<br><br>        <span class="hljs-keyword">if</span> (tiling == VK_IMAGE_TILING_LINEAR &amp;&amp; (props.linearTilingFeatures &amp; features) == features) &#123;<br>            <span class="hljs-keyword">return</span> format;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tiling == VK_IMAGE_TILING_OPTIMAL &amp;&amp; (props.optimalTilingFeatures &amp; features) == features) &#123;<br>            <span class="hljs-keyword">return</span> format;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to find supported format!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>假设我们需要寻找的合适的深度图像格式就是上文列举的三种格式之一，于是我们创建一个<i><font color="Green">VkFormatfindDepthFormat()</font></i>函数来专门处理深度图像格式的寻找，它只需要简单地调用<i><font color="Green">findSupportedFormat</font></i>函数即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkFormat <span class="hljs-title">findDepthFormat</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">findSupportedFormat</span>(<br>        &#123;VK_FORMAT_D32_SFLOAT, VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT&#125;,<br>        VK_IMAGE_TILING_OPTIMAL,<br>        VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkFormatFeatureFlagBits.html"><code>VkFormatFeatureFlags</code></a>和<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageUsageFlagBits.html"><code>VkImageUsageFlags</code></a>的区别：前者指定的是某图像格式所支持的使用方式，后者指定的是图像实际上的使用方式。我们这里当然需要该图像格式支持用作深度（模板）附件，因此需要传递<i><font color="Red">VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT</font></i>参数。</p><p>现在就可以在<i><font color="Green">createDepthResources</font></i>函数中使用<i><font color="Green">findDepthFormat</font></i>函数寻找满足要求的深度图像格式，然后据此创建所有的深度附件资源了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createDepthResources</span><span class="hljs-params">()</span> </span>&#123;<br>    VkFormat depthFormat = <span class="hljs-built_in">findDepthFormat</span>();<br><br>    <span class="hljs-built_in">createImage</span>(swapChainExtent.width, swapChainExtent.height, depthFormat, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, depthImage, depthImageMemory);<br>    depthImageView = <span class="hljs-built_in">createImageView</span>(depthImage, depthFormat, VK_IMAGE_ASPECT_DEPTH_BIT);<br>&#125;<br></code></pre></td></tr></table></figure><p>不过这里需要注意的是，我们对<i><font color="Green">createImageView</font></i>函数进行了更改，新添了一个参数用来传递视图反映的图像方面（之前我们使用的图像方面一直是<i><font color="Red">VK_IMAGE_ASPECT_COLOR_BIT</font></i>，但是深度图像需要的图像方面是<i><font color="Red">VK_IMAGE_ASPECT_DEPTH_BIT</font></i>），也就是说新的<i><font color="Green">createImageView</font></i>函数要做出如下更改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkImageView <span class="hljs-title">createImageView</span><span class="hljs-params">(VkImage image, VkFormat format, VkImageAspectFlags aspectFlags)</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    viewInfo.subresourceRange.aspectMask = aspectFlags;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然，这个函数改变后用到该函数的代码也需要做出相应的改变：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">swapChainImageViews[i] = <span class="hljs-built_in">createImageView</span>(swapChainImages[i], swapChainImageFormat, VK_IMAGE_ASPECT_COLOR_BIT);<br><span class="hljs-comment">//...</span><br>depthImageView = <span class="hljs-built_in">createImageView</span>(depthImage, depthFormat, VK_IMAGE_ASPECT_DEPTH_BIT);<br><span class="hljs-comment">//...</span><br>textureImageView = <span class="hljs-built_in">createImageView</span>(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_ASPECT_COLOR_BIT);<br></code></pre></td></tr></table></figure><p>最后需要注意的是，我们并不需要显式地转换深度附件图像的布局以用作深度附件，这个过程渲染通道会帮我们自动完成（根据<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentDescription.html"><code>VkAttachmentDescription</code></a>结构体中的<i><font color="Orange">initialLayout</font></i>和<i><font color="Orange">finalLayout</font></i>成员指定的布局），就像颜色附件的图像布局转换一样。</p><hr><h2 id="修改渲染通道">修改渲染通道</h2><p>创建好深度附件资源后，我们就需要在渲染通道中引用这个深度附件。在<i><font color="Green">createRenderPass</font></i>中添加引创建深度附件引用的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br><br>VkAttachmentDescription depthAttachment&#123;&#125;;<br>depthAttachment.format = <span class="hljs-built_in">findDepthFormat</span>();<br>depthAttachment.samples = VK_SAMPLE_COUNT_1_BIT;<br>depthAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;<br>depthAttachment.storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>depthAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;<br>depthAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>depthAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;<br>depthAttachment.finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;<br><br>VkAttachmentReference depthAttachmentRef&#123;&#125;;<br>depthAttachmentRef.attachment = <span class="hljs-number">1</span>;<br>depthAttachmentRef.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;<br></code></pre></td></tr></table></figure><p>我们并不关系渲染开始前深度缓冲中的内容是什么，因为这个内容会被清除颜色清除掉，所以<i><font color="Orange">initialLayout</font><?i>可以设置为<i><font color="Red">VK_IMAGE_LAYOUT_UNDEFINED</font></i>，另外，我们也不需要在渲染结束后存储得到的深度值，因此<i><font color="Orange">storeOp</font></i>设置为<i><font color="Red">VK_ATTACHMENT_STORE_OP_DONT_CARE</font></i>即可。</i></p><p>然后，我们需要将深度缓冲的引用添加到子通道和渲染通道中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSubpassDescription subpass&#123;&#125;;<br>subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;<br>subpass.colorAttachmentCount = <span class="hljs-number">1</span>;<br>subpass.pColorAttachments = &amp;colorAttachmentRef;<br>subpass.pDepthStencilAttachment = &amp;depthAttachmentRef;<br><br>std::array&lt;VkAttachmentDescription, 2&gt; attachments = &#123;colorAttachment, depthAttachment&#125;;<br>VkRenderPassCreateInfo renderPassInfo&#123;&#125;;<br>renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;<br>renderPassInfo.attachmentCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attachments.<span class="hljs-built_in">size</span>());<br>renderPassInfo.pAttachments = attachments.<span class="hljs-built_in">data</span>();<br>renderPassInfo.subpassCount = <span class="hljs-number">1</span>;<br>renderPassInfo.pSubpasses = &amp;subpass;<br>renderPassInfo.dependencyCount = <span class="hljs-number">1</span>;<br>renderPassInfo.pDependencies = &amp;dependency;<br></code></pre></td></tr></table></figure><p>注意在<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassDescription.html"><code>VkSubpassDescription</code></a>中我们可以指定多个颜色附件，但是深度模板附件只能指定一个，这是合理的，因为使用多个深度附件没有多大意义。</p><p>另外，子通道之间的依赖关系也需要适当修改以保证在深度值输出到深度缓冲的时候深度附件已经准备好了（和颜色附件一样），因此需要更新填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassDependency.html"><code>VkSubpassDependency</code></a>的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;<br>dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;<br>dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;<br></code></pre></td></tr></table></figure><p>我们希望在早期片段测试之前深度附件已经准备好了（不然无法使用附件中的深度数据执行测试），因此我们呢需要添加渲染子通道的等待阶段<i><font color="Red">VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT</font></i>和相应的等待操作<i><font color="Red">VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT</font></i>。</p><hr><h2 id="修改帧缓冲">修改帧缓冲</h2><p>接下来我们需要修改创建帧缓冲的代码以将深度图像绑定到帧缓冲的深度附件上。在<i><font color="Green">createFramebuffers</font></i>函数中修改代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::array&lt;VkImageView, 2&gt; attachments = &#123;<br>    swapChainImageViews[i],<br>    depthImageView<br>&#125;;<br><br>VkFramebufferCreateInfo framebufferInfo&#123;&#125;;<br>framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;<br>framebufferInfo.renderPass = renderPass;<br>framebufferInfo.attachmentCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attachments.<span class="hljs-built_in">size</span>());<br>framebufferInfo.pAttachments = attachments.<span class="hljs-built_in">data</span>();<br>framebufferInfo.width = swapChainExtent.width;<br>framebufferInfo.height = swapChainExtent.height;<br>framebufferInfo.layers = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>当然，这个函数需要在<i><font color="Green">createDepthResources</font></i>之后调用以确保深度附件所需的资源都已经创建好了。</p><hr><h2 id="修改命令录制函数">修改命令录制函数</h2><p>回忆在<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/">命令缓冲</a>章节中，我们在录制命令时首先需要录制启动渲染通道的命令然后才能开始渲染，为了录制开始渲染通道的命令<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRenderPass.html"><code>vkCmdBeginRenderPass</code></a>我们需要填写相应的信息结构体<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/VkRenderPassBeginInfo.html"><code>VkRenderPassBeginInfo</code></a>，该结构体中有两个和清除颜色有关的成员<i><font color="Orange">clearValueCount</font></i>和<i><font color="Orange">pClearValues</font></i>，由于我们现在有多个在渲染通道开始时<i><font color="Orange">loadOp</font></i>设置为<i><font color="Red">VK_ATTACHMENT_LOAD_OP_CLEAR</font></i>的附件，我们就需要为每个这样的附件指定一个清除色，相应代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::array&lt;VkClearValue, 2&gt; clearValues&#123;&#125;;<br>clearValues[<span class="hljs-number">0</span>].color = &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;;<br>clearValues[<span class="hljs-number">1</span>].depthStencil = &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0</span>&#125;;<br><br>renderPassInfo.clearValueCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(clearValues.<span class="hljs-built_in">size</span>());<br>renderPassInfo.pClearValues = clearValues.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>颜色附件我们使用黑色作为清除色，深度附件我们使用最大深度值1.0作为清除值以保证所有渲染物体的深度都可以写入。</p><p>另外注意，在指定多个清除颜色时，清除色的顺序需要和相应帧缓冲中的附件顺序保持一致。</p><hr><h2 id="修改渲染管线">修改渲染管线</h2><p>深度附件现在已经准备好了，但是我们还需要在构建渲染管线时显式地指定开启深度测试和深度写入才能使用深度附件。为此我们需要在创建渲染管线的函数<i><font color="Green">createGraphicsPipeline</font></i>中填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineDepthStencilStateCreateInfo.html"><code>VkPipelineDepthStencilStateCreateInfo</code></a>结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineDepthStencilStateCreateInfo</span> &#123;</span><br>    VkStructureType                           sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                               pNext;<br>    VkPipelineDepthStencilStateCreateFlags    flags;<br>    VkBool32                                  depthTestEnable;<br>    VkBool32                                  depthWriteEnable;<br>    VkCompareOp                               depthCompareOp;<br>    VkBool32                                  depthBoundsTestEnable;<span class="hljs-comment">//是否启用保留深度范围</span><br>    VkBool32                                  stencilTestEnable;<br>    VkStencilOpState                          front;<br>    VkStencilOpState                          back;<br>    <span class="hljs-type">float</span>                                     minDepthBounds;<span class="hljs-comment">//被保留的最小深度</span><br>    <span class="hljs-type">float</span>                                     maxDepthBounds;<span class="hljs-comment">//被保留的最大深度</span><br>&#125; VkPipelineDepthStencilStateCreateInfo;<br></code></pre></td></tr></table></figure><p>所有成员都是易于理解的，我们这里不需要进行模板测试，所以不填写模板测试有关的信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br><br>VkPipelineDepthStencilStateCreateInfo depthStencil&#123;&#125;;<br><br>depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;<br>depthStencil.depthTestEnable = VK_TRUE;<br>depthStencil.depthWriteEnable = VK_TRUE;<br>depthStencil.depthCompareOp = VK_COMPARE_OP_LESS;<br>depthStencil.depthBoundsTestEnable = VK_FALSE;<br>depthStencil.minDepthBounds = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span><br>depthStencil.maxDepthBounds = <span class="hljs-number">1.0f</span>; <span class="hljs-comment">// Optional</span><br>depthStencil.stencilTestEnable = VK_FALSE;<br>depthStencil.front = &#123;&#125;; <span class="hljs-comment">// Optional</span><br>depthStencil.back = &#123;&#125;; <span class="hljs-comment">// Optional</span><br><br>pipelineInfo.pDepthStencilState = &amp;depthStencil;<br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><hr><h2 id="修改重建交换链函数">修改重建交换链函数</h2><p>最后，因为深度图像的分辨率也需要和屏幕保持一致，所以在窗口大小缩放的时候我们也需要重建深度附件有关的资源。在<i><font color="Green">recreateSwapChain</font></i>函数中添加重建深度资源的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recreateSwapChain</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> width = <span class="hljs-number">0</span>, height = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (width == <span class="hljs-number">0</span> || height == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);<br>        <span class="hljs-built_in">glfwWaitEvents</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">vkDeviceWaitIdle</span>(device);<br><br>    <span class="hljs-built_in">cleanupSwapChain</span>();<br><br>    <span class="hljs-built_in">createSwapChain</span>();<br>    <span class="hljs-built_in">createImageViews</span>();<br>    <span class="hljs-built_in">createDepthResources</span>();<br>    <span class="hljs-built_in">createFramebuffers</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>大功告成！我们现在运行程序就可以看到正确的渲染结果了：</p><figure><img src="/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/right.png" alt="正确的渲染结果"><figcaption aria-hidden="true">正确的渲染结果</figcaption></figure><p>这样我们就为真正的3D渲染做好了准备。<a href="https://zpc-dsg.github.io/2024/12/21/CG_api/vulkan/vulkan_tutorial/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/">下一章</a>我们将加载模型到我们的程序中，开启丰富多彩的3D渲染大门！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E7%BB%84%E5%90%88%E5%9B%BE%E5%83%8F%E9%87%87%E6%A0%B7%E5%99%A8/">上一篇：组合图像采样器</a></p><p>--<a href="https://zpc-dsg.github.io/2024/12/21/CG_api/vulkan/vulkan_tutorial/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/">下一篇：加载模型</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>组合图像采样器</title>
    <link href="/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E7%BB%84%E5%90%88%E5%9B%BE%E5%83%8F%E9%87%87%E6%A0%B7%E5%99%A8/"/>
    <url>/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E7%BB%84%E5%90%88%E5%9B%BE%E5%83%8F%E9%87%87%E6%A0%B7%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>现在我们已经准备好了采样纹理所需的一切对象，包括纹理本身、纹理视图和纹理采样器。本节我们会将这些对象通过组合图像采样器这一特殊的描述符连结起来，最终完成着色器纹理采样的工作。主要过程可以分为三步：</p><ul><li>创建组合图像采样器描述符</li><li>调整顶点结构以传递纹理坐标</li><li>在着色器中使用纹理采样</li></ul><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Texture_mapping/Combined_image_sampler">Combinedimage sampler</a>章节。</p><hr><h2 id="创建组合图像采样器">创建组合图像采样器</h2><p>我们可以将创建组合图像采样器的代码放在之前创建统一缓冲区描述符的代码一起。首先修改<i><font color="Green">createDescriptorSetLayout</font></i>函数添加相应代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br><br>VkDescriptorSetLayoutBinding samplerLayoutBinding&#123;&#125;;<br>samplerLayoutBinding.binding = <span class="hljs-number">1</span>;<br>samplerLayoutBinding.descriptorCount = <span class="hljs-number">1</span>;<br>samplerLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;<br>samplerLayoutBinding.pImmutableSamplers = <span class="hljs-literal">nullptr</span>;<br>samplerLayoutBinding.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;<br><br>std::array&lt;VkDescriptorSetLayoutBinding, 2&gt; bindings = &#123;uboLayoutBinding, samplerLayoutBinding&#125;;<br>VkDescriptorSetLayoutCreateInfo layoutInfo&#123;&#125;;<br>layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;<br>layoutInfo.bindingCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(bindings.<span class="hljs-built_in">size</span>());<br>layoutInfo.pBindings = bindings.<span class="hljs-built_in">data</span>();<br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>我们将组合图像采样器的绑定点设置为统一缓冲描述符绑定点的后一个（即1），并且注意要正确设置描述符类型和使用该描述符的着色器阶段（我们目前需要在片段着色器中使用纹理采样，因此<i><font color="Orange">stageFlags</font></i>设置为<i><font color="Red">VK_SHADER_STAGE_FRAGMENT_BIT</font></i>，不过有时候我们也可能需要在顶点着色器中进行纹理采样，比如使用高度贴图的时候）。</p><p>在更改描述符布局以包含组合图像采样器后，我们还需要增大描述符池的大小以分配所需的组合图像采样器。于是我们更改<i><font color="Green">createDescriptorPool</font></i>函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br><br>std::array&lt;VkDescriptorPoolSize, 2&gt; poolSizes&#123;&#125;;<br>poolSizes[<span class="hljs-number">0</span>].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;<br>poolSizes[<span class="hljs-number">0</span>].descriptorCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(MAX_FRAMES_IN_FLIGHT);<br>poolSizes[<span class="hljs-number">1</span>].type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;<br>poolSizes[<span class="hljs-number">1</span>].descriptorCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(MAX_FRAMES_IN_FLIGHT);<br><br>VkDescriptorPoolCreateInfo poolInfo&#123;&#125;;<br>poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;<br>poolInfo.poolSizeCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(poolSizes.<span class="hljs-built_in">size</span>());<br>poolInfo.pPoolSizes = poolSizes.<span class="hljs-built_in">data</span>();<br>poolInfo.maxSets = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(MAX_FRAMES_IN_FLIGHT);<br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>最后，我们需要更改<i><font color="Green">createDescriptorSets</font></i>函数来添加所需的组合图像采样器描述符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123;<br>    VkDescriptorBufferInfo bufferInfo&#123;&#125;;<br>    bufferInfo.buffer = uniformBuffers[i];<br>    bufferInfo.offset = <span class="hljs-number">0</span>;<br>    bufferInfo.range = <span class="hljs-built_in">sizeof</span>(UniformBufferObject);<br><br>    VkDescriptorImageInfo imageInfo&#123;&#125;;<br>    imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;<br>    imageInfo.imageView = textureImageView;<br>    imageInfo.sampler = textureSampler;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//...</span><br><br>std::array&lt;VkWriteDescriptorSet, 2&gt; descriptorWrites&#123;&#125;;<br><br>descriptorWrites[<span class="hljs-number">0</span>].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;<br>descriptorWrites[<span class="hljs-number">0</span>].dstSet = descriptorSets[i];<br>descriptorWrites[<span class="hljs-number">0</span>].dstBinding = <span class="hljs-number">0</span>;<br>descriptorWrites[<span class="hljs-number">0</span>].dstArrayElement = <span class="hljs-number">0</span>;<br>descriptorWrites[<span class="hljs-number">0</span>].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;<br>descriptorWrites[<span class="hljs-number">0</span>].descriptorCount = <span class="hljs-number">1</span>;<br>descriptorWrites[<span class="hljs-number">0</span>].pBufferInfo = &amp;bufferInfo;<br><br>descriptorWrites[<span class="hljs-number">1</span>].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;<br>descriptorWrites[<span class="hljs-number">1</span>].dstSet = descriptorSets[i];<br>descriptorWrites[<span class="hljs-number">1</span>].dstBinding = <span class="hljs-number">1</span>;<br>descriptorWrites[<span class="hljs-number">1</span>].dstArrayElement = <span class="hljs-number">0</span>;<br>descriptorWrites[<span class="hljs-number">1</span>].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;<br>descriptorWrites[<span class="hljs-number">1</span>].descriptorCount = <span class="hljs-number">1</span>;<br>descriptorWrites[<span class="hljs-number">1</span>].pImageInfo = &amp;imageInfo;<br><br><span class="hljs-built_in">vkUpdateDescriptorSets</span>(device, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(descriptorWrites.<span class="hljs-built_in">size</span>()), descriptorWrites.<span class="hljs-built_in">data</span>(), <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br></code></pre></td></tr></table></figure><p>创建相应描述符的过程和创建统一缓冲描述符的过程几乎一致，只不过统一缓冲描述符所持有的对象是统一缓冲区，因此需要填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorBufferInfo.html"><code>VkDescriptorBufferInfo</code></a>信息，而组合图像采样器持有的是纹理对象，所以需要填写<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/VkDescriptorImageInfo.html"><code>VkDescriptorImageInfo</code></a>信息，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDescriptorImageInfo</span> &#123;</span><br>    VkSampler        sampler;<br>    VkImageView      imageView;<br>    VkImageLayout    imageLayout;<br>&#125; VkDescriptorImageInfo;<br></code></pre></td></tr></table></figure><p>每个成员都是易于理解的。</p><p>这样就完成了组合图像采样器的创建和配置。</p><hr><h2 id="调整顶点结构">调整顶点结构</h2><p>为了在着色器中使用纹理，我们需要给着色器传递相应图像的纹理坐标。于是，修改<i><font color="Orange">Vertex</font></i>结构体以包含一个2维向量表示的纹理坐标：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vertex</span> &#123;<br>    glm::vec2 pos;<br>    glm::vec3 color;<br>    glm::vec2 texCoord;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> VkVertexInputBindingDescription <span class="hljs-title">getBindingDescription</span><span class="hljs-params">()</span> </span>&#123;<br>        VkVertexInputBindingDescription bindingDescription&#123;&#125;;<br>        bindingDescription.binding = <span class="hljs-number">0</span>;<br>        bindingDescription.stride = <span class="hljs-built_in">sizeof</span>(Vertex);<br>        bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;<br><br>        <span class="hljs-keyword">return</span> bindingDescription;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> std::array&lt;VkVertexInputAttributeDescription, 3&gt; <span class="hljs-title">getAttributeDescriptions</span><span class="hljs-params">()</span> </span>&#123;<br>        std::array&lt;VkVertexInputAttributeDescription, 3&gt; attributeDescriptions&#123;&#125;;<br><br>        attributeDescriptions[<span class="hljs-number">0</span>].binding = <span class="hljs-number">0</span>;<br>        attributeDescriptions[<span class="hljs-number">0</span>].location = <span class="hljs-number">0</span>;<br>        attributeDescriptions[<span class="hljs-number">0</span>].format = VK_FORMAT_R32G32_SFLOAT;<br>        attributeDescriptions[<span class="hljs-number">0</span>].offset = <span class="hljs-built_in">offsetof</span>(Vertex, pos);<br><br>        attributeDescriptions[<span class="hljs-number">1</span>].binding = <span class="hljs-number">0</span>;<br>        attributeDescriptions[<span class="hljs-number">1</span>].location = <span class="hljs-number">1</span>;<br>        attributeDescriptions[<span class="hljs-number">1</span>].format = VK_FORMAT_R32G32B32_SFLOAT;<br>        attributeDescriptions[<span class="hljs-number">1</span>].offset = <span class="hljs-built_in">offsetof</span>(Vertex, color);<br><br>        attributeDescriptions[<span class="hljs-number">2</span>].binding = <span class="hljs-number">0</span>;<br>        attributeDescriptions[<span class="hljs-number">2</span>].location = <span class="hljs-number">2</span>;<br>        attributeDescriptions[<span class="hljs-number">2</span>].format = VK_FORMAT_R32G32_SFLOAT;<br>        attributeDescriptions[<span class="hljs-number">2</span>].offset = <span class="hljs-built_in">offsetof</span>(Vertex, texCoord);<br><br>        <span class="hljs-keyword">return</span> attributeDescriptions;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同时我们也需要修改<i><font color="Green">getAttributeDescriptions</font></i>静态函数以向顶点着色器正确传递更改后的顶点属性。</p><p>最后不要忘了更改实际传递给顶点着色器的顶点数据以包含实际的纹理坐标数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;Vertex&gt; vertices = &#123;<br>    &#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="着色器纹理采样">着色器纹理采样</h2><p>现在我们终于可以在着色器中使用纹理进行采样了！首先我们需要将顶点着色器中输入的纹理坐标传递给片段着色器使用：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inPosition;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inColor;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inTexCoord;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fragColor;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> fragTexCoord;<br><br><span class="hljs-type">void</span> main() &#123;<br>    <span class="hljs-built_in">gl_Position</span> = ubo.proj * ubo.view * ubo.model * <span class="hljs-type">vec4</span>(inPosition, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fragColor = inColor;<br>    fragTexCoord = inTexCoord;<br>&#125;<br></code></pre></td></tr></table></figure><p>在纹理坐标传递给片段着色器之前，光栅化器会插值这些纹理坐标到每个片段上，于是我们在片段着色器中就可以使用插值后的纹理坐标对每一个片段进行纹理采样了：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texSampler;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> fragColor;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> fragTexCoord;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outColor;<br><br><span class="hljs-type">void</span> main() &#123;<br>    outColor = <span class="hljs-built_in">texture</span>(texSampler, fragTexCoord);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终我们可以看到具有纹理的四边形显示在屏幕上：</p><figure><img src="/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E7%BB%84%E5%90%88%E5%9B%BE%E5%83%8F%E9%87%87%E6%A0%B7%E5%99%A8/texture.png" alt="纹理四边形"><figcaption aria-hidden="true">纹理四边形</figcaption></figure><p>大功告成！当然，我们可以在片段着色器中调整图像采样的方式，颜色混合的方式等等来实现各种各样有趣的效果！</p><p>纹理采样部分就此告一段落，接下来教程会开启几个独立的小主题作为本基础教程的收尾。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/">上一篇：图像视图和采样器</a></p><p>--<a href="https://zpc-dsg.github.io/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/">下一篇：深度缓冲</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图像视图和采样器</title>
    <link href="/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/"/>
    <url>/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>本章我们将创建纹理采样所必须的两个资源——图像视图和采样器。图像视图在<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/">图像视图</a>章节已经介绍过了，不过采样器对我们而言仍然是一个全新的知识，它主要控制着色器如何对纹理进行采样。本节我们就来分别创建<a href="https://zpc-dsg.github.io/2024/12/12/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F/">上一章</a>创建好的纹理所对应的这两个对象。</p><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Texture_mapping/Image_view_and_sampler">Imageview and sampler</a>章节。</p><hr><h2 id="创建纹理图像视图">创建纹理图像视图</h2><p>在<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/">图像视图</a>章节中我们已经创建了一个工具函数<i><font color="Green">createImageViews</font></i>来创建交换链中所有图像各自所需的图像视图。这里我们完全可以重用其中的代码来创建<a href="https://zpc-dsg.github.io/2024/12/12/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F/">上一章</a>创建的纹理对象对应的图像视图。在类内新建一个<i><font color="Green">VkImageViewcreateImageView(VkImage image, VkFormatformat)</font></i>函数来提取出创建一个图像视图所需的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkImageView <span class="hljs-title">createImageView</span><span class="hljs-params">(VkImage image, VkFormat format)</span> </span>&#123;<br>    VkImageViewCreateInfo viewInfo&#123;&#125;;<br>    viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;<br>    viewInfo.image = image;<br>    viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;<br>    viewInfo.format = format;<br>    viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br>    viewInfo.subresourceRange.baseMipLevel = <span class="hljs-number">0</span>;<br>    viewInfo.subresourceRange.levelCount = <span class="hljs-number">1</span>;<br>    viewInfo.subresourceRange.baseArrayLayer = <span class="hljs-number">0</span>;<br>    viewInfo.subresourceRange.layerCount = <span class="hljs-number">1</span>;<br><br>    VkImageView imageView;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateImageView</span>(device, &amp;viewInfo, <span class="hljs-literal">nullptr</span>, &amp;imageView) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create texture image view!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> imageView;<br>&#125;<br></code></pre></td></tr></table></figure><p>在类内新添一个成员<i><font color="Orange">textureImageView</font></i>来保存将要构建的纹理图像视图对象，并且新添一个<i><font color="Green">voidcreateTextureImageView()</font></i>函数来进行创建纹理视图有关的工作，于是该函数的代码可以简单地写成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createTextureImageView</span><span class="hljs-params">()</span> </span>&#123;<br>    textureImageView = <span class="hljs-built_in">createImageView</span>(textureImage, VK_FORMAT_R8G8B8A8_SRGB);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/">图像视图</a>章节创建的<i><font color="Green">createImageViews</font></i>函数现在也可以简化为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createImageViews</span><span class="hljs-params">()</span> </span>&#123;<br>    swapChainImageViews.<span class="hljs-built_in">resize</span>(swapChainImages.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainImages.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        swapChainImageViews[i] = <span class="hljs-built_in">createImageView</span>(swapChainImages[i], swapChainImageFormat);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就创建好了纹理对象的图像视图。</p><hr><h2 id="创建采样器">创建采样器</h2><p>事实上着色器也可以直接采样纹理，但是使用采样器进行采样几乎总是更好的选择，因为采样器会对图片进行合适的过滤和变换，然后将处理后的颜色递交给着色器以达到更好的图像质量。当图像过采样或者采样不足时，采样器会自动使用设置好的过滤模式对图像颜色进行过滤；当着色器采样到图像之外的点时，采样器会使用预先设置好的<strong>解决模式（Addressingmode）</strong>来决定此时的采样行为和最终结果。关于这一部分内容，这里假设读者已经有了一个基本的概念，不再赘述，不熟悉的读者可以参考<a href="https://learnopengl.com/Getting-started/Textures">这篇文章</a>。</p><p>接下来我们在类内创建一个<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkSampler.html"><code>VkSampler</code></a>类型的<i><font color="Orange">textureSampler</font></i>成员来储存纹理采样器，并且创建一个<i><font color="Green">voidcreateTextureSampler()</font></i>函数来创建该采样器。创建采样器的过程很简单，我们只需要填写相应的信息结构体<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerCreateInfo.html"><code>VkSamplerCreateInfo</code></a>即可，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSamplerCreateInfo</span> &#123;</span><br>    VkStructureType         sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*             pNext;<br>    VkSamplerCreateFlags    flags;<br>    VkFilter                magFilter;<br>    VkFilter                minFilter;<br>    VkSamplerMipmapMode     mipmapMode;<br>    VkSamplerAddressMode    addressModeU;<br>    VkSamplerAddressMode    addressModeV;<br>    VkSamplerAddressMode    addressModeW;<br>    <span class="hljs-type">float</span>                   mipLodBias;<br>    VkBool32                anisotropyEnable;<br>    <span class="hljs-type">float</span>                   maxAnisotropy;<br>    VkBool32                compareEnable;<br>    VkCompareOp             compareOp;<br>    <span class="hljs-type">float</span>                   minLod;<br>    <span class="hljs-type">float</span>                   maxLod;<br>    VkBorderColor           borderColor;<br>    VkBool32                unnormalizedCoordinates;<br>&#125; VkSamplerCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>可能的取值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkSamplerCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_EXT_fragment_density_map</span><br>    VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//表示采样器支持子采样（即从原始图像中选择一部分像素进行处理，而忽略其他像素）。这通常用于减少渲染负担，特别是在高分辨率的场景中</span><br>  <span class="hljs-comment">// Provided by VK_EXT_fragment_density_map</span><br>    VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//表示采样器支持粗略重建的子采样</span><br>  <span class="hljs-comment">// Provided by VK_EXT_descriptor_buffer</span><br>    VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//表示采样器支持描述符缓冲区的捕获和重放（指将描述符缓冲区的状态（即绑定的资源和参数）保存下来，以便在后续的渲染操作中重新使用）。这有助于在图形管线中更高效地管理资源</span><br>  <span class="hljs-comment">// Provided by VK_EXT_non_seamless_cube_map</span><br>    VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//表示采样器支持非无缝的立方体贴图。这意味着在采样立方体贴图时，边缘可能会有可见的接缝</span><br>  <span class="hljs-comment">// Provided by VK_QCOM_image_processing</span><br>    VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM = <span class="hljs-number">0x00000010</span>,<span class="hljs-comment">//表示采样器支持图像处理功能。这可能涉及对图像进行各种处理操作，例如滤波或转换</span><br>&#125; VkSamplerCreateFlagBits;<br></code></pre></td></tr></table></figure><p>接下来的<i><font color="Orange">magFilter</font></i>和<i><font color="Orange">minFilter</font></i>分别指定放大和缩小图像时的过滤模式。可能选取的过滤模式有以下几种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkFilter</span> &#123;</span><br>    VK_FILTER_NEAREST = <span class="hljs-number">0</span>,<br>    VK_FILTER_LINEAR = <span class="hljs-number">1</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_filter_cubic</span><br>    VK_FILTER_CUBIC_EXT = <span class="hljs-number">1000015000</span>,<br>  <span class="hljs-comment">// Provided by VK_IMG_filter_cubic</span><br>    VK_FILTER_CUBIC_IMG = VK_FILTER_CUBIC_EXT,<br>&#125; VkFilter;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">mipmapMode</font></i>、<i><font color="Orange">mipLodBias</font></i>、<i><font color="Orange">minLod</font></i>、<i><font color="Orange">maxLod</font></i>均与多级渐远纹理有关，在后续介绍Vulkan中的多级渐远时我们会详细介绍这一部分。</p><p>接下来的三个addressMode用于指定采样超出图像范围的解决模式，可能的取值有如下几种，它们的作用和效果基本上在<a href="https://learnopengl.com/Getting-started/Textures">这篇文章</a>中都有提及：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkSamplerAddressMode</span> &#123;</span><br>    VK_SAMPLER_ADDRESS_MODE_REPEAT = <span class="hljs-number">0</span>,<br>    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = <span class="hljs-number">1</span>,<br>    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = <span class="hljs-number">2</span>,<br>    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = <span class="hljs-number">3</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2, VK_KHR_sampler_mirror_clamp_to_edge</span><br>    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = <span class="hljs-number">4</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_sampler_mirror_clamp_to_edge</span><br>  <span class="hljs-comment">// VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR is a deprecated alias</span><br>    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,<br>&#125; VkSamplerAddressMode;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">compareEnable</font></i>和<i><font color="Orange">compareOp</font></i>指定图像颜色和一个固定颜色的比较操作，这在有些应用情景下是有用的，比如<strong>PCF(percentage-closerfiltering)</strong>（可以参考<a href="https://developer.nvidia.com/gpugems/gpugems/part-ii-lighting-and-shadows/chapter-11-shadow-map-antialiasing">这篇文章</a>或者<a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">这篇文章</a>来初步了解PCF，<a href="https://www.bilibili.com/video/BV1YK4y1T7yY?vd_source=96b763f75b621baa119e5118b6164aee&amp;p=3&amp;spm_id_from=333.788.videopod.episodes">games202</a>中有包括PCF在内的更多关于阴影处理技术的拓展）。</p><p><i><font color="Orange">borderColor</font></i>指定当解决模式设置为夹紧到边界有关的模式时使用的边界颜色。事实上这个颜色不能是任意值，而是必须为以下取值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkBorderColor</span> &#123;</span><br>    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = <span class="hljs-number">0</span>,<br>    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = <span class="hljs-number">1</span>,<br>    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = <span class="hljs-number">2</span>,<br>    VK_BORDER_COLOR_INT_OPAQUE_BLACK = <span class="hljs-number">3</span>,<br>    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = <span class="hljs-number">4</span>,<br>    VK_BORDER_COLOR_INT_OPAQUE_WHITE = <span class="hljs-number">5</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_custom_border_color</span><br>    VK_BORDER_COLOR_FLOAT_CUSTOM_EXT = <span class="hljs-number">1000287003</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_custom_border_color</span><br>    VK_BORDER_COLOR_INT_CUSTOM_EXT = <span class="hljs-number">1000287004</span>,<br>&#125; VkBorderColor;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">unnormalizedCoordinates</font></i>决定纹理坐标的范围。如果设置为<i><font color="Red">VK_TRUE</font></i>则代表纹理各维度坐标将是0到该维度像素数这个范围，一般我们都设置为<i><font color="Red">VK_FALSE</font></i>，此时纹理坐标范围为[0,1)，与图像像素多少无关。</p><p>最后我们来看成员<i><font color="Orange">anisotrophyEnable</font></i>和<i><font color="Orange">maxAnisotropy</font></i>，这两个成员和各向异性滤波有关。所谓各向异性滤波，指的是一种纹理过滤技术，通过动态调整过滤级别和加权平均样本从而改善斜角表面上纹理的质量。与之前成员不同的是，各向异性滤波涉及到GPU特性，需要我们手动开启才能使用（如果不开启直接使用验证层会报错），于是我们需要首先在<i><font color="Green">createLogicalDevice</font></i>函数中手动启用这个特性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPhysicalDeviceFeatures deviceFeatures&#123;&#125;;<br>deviceFeatures.samplerAnisotropy = VK_TRUE;<br><br><span class="hljs-comment">//...</span><br><br>VkDeviceCreateInfo createInfo&#123;&#125;;<br>createInfo.pEnabledFeatures = &amp;deviceFeatures;<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>当然，严格来讲我们应该还需要在开启这个特性之前先检查一下GPU是否支持该特性（这个特性几乎被所有的现代GPU所支持，所以大多数情况不去检查也没有大问题，不过为了完整性和严谨性起见我们还是添加上检查代码），于是在<i><font color="Green">isDeviceSuitable</font></i>中添加上检查硬件是否支持该特性的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br><br>VkPhysicalDeviceFeatures supportedFeatures;<br><span class="hljs-built_in">vkGetPhysicalDeviceFeatures</span>(device, &amp;supportedFeatures);<br><br><span class="hljs-keyword">return</span> indices.<span class="hljs-built_in">isComplete</span>() &amp;&amp; extensionsSupported &amp;&amp; swapChainAdequate &amp;&amp; supportedFeatures.samplerAnisotropy;<br></code></pre></td></tr></table></figure><p>这样我们就可以在创建采样器时开启该特性了。当然，除非出于性能考虑，不然我们没有理由不开启各向异性过滤来提高纹理采样质量。另外，启用该特性后，我们还需要查询设备所支持的各向异性滤波采样数目的最大值以填写<i><font color="Orange">maxAnisotropy</font></i>成员，这同样可以通过查询GPU特性来实现。于是我们填写该信息结构体的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSamplerCreateInfo samplerInfo&#123;&#125;;<br>samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;<br>samplerInfo.magFilter = VK_FILTER_LINEAR;<br>samplerInfo.minFilter = VK_FILTER_LINEAR;<br>samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;<br>samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;<br>samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;<br><br>samplerInfo.anisotropyEnable = VK_TRUE;<br>VkPhysicalDeviceProperties properties&#123;&#125;;<br><span class="hljs-built_in">vkGetPhysicalDeviceProperties</span>(physicalDevice, &amp;properties);<br>samplerInfo.maxAnisotropy = properties.limits.maxSamplerAnisotropy;<br><br>samplerInfo.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;<br>samplerInfo.unnormalizedCoordinates = VK_FALSE;<br>samplerInfo.compareEnable = VK_FALSE;<br>samplerInfo.compareOp = VK_COMPARE_OP_ALWAYS;<br><br>samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;<br>samplerInfo.mipLodBias = <span class="hljs-number">0.0f</span>;<br>samplerInfo.minLod = <span class="hljs-number">0.0f</span>;<br>samplerInfo.maxLod = <span class="hljs-number">0.0f</span>;<br></code></pre></td></tr></table></figure><p>然后我们就可以使用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSampler.html"><code>vkCreateSampler</code></a>创建所需的采样器对象了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateSampler</span>(device, &amp;samplerInfo, <span class="hljs-literal">nullptr</span>, &amp;textureSampler) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create texture sampler!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/12/12/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F/">上一篇：图像</a></p><p>--<a href="https://zpc-dsg.github.io/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E7%BB%84%E5%90%88%E5%9B%BE%E5%83%8F%E9%87%87%E6%A0%B7%E5%99%A8/">下一篇：组合图像采样器</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图像</title>
    <link href="/2024/12/12/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F/"/>
    <url>/2024/12/12/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>接下来的几个章节我们将开始纹理使用的学习。使用纹理可以给我们原本枯燥无味的程序添加大量有趣的细节。在Vulkan中使用纹理大致可以分为四步：</p><ul><li>创建纹理对象并且为其分配内存</li><li>将图片数据上传并复制到纹理中</li><li>创建图像视图和采样器</li><li>创建相应的组合图像采样器描述符（<strong>combined image samplerdescriptor</strong>）以便着色器采样纹理</li></ul><p>本节我们将首先完成前两步的工作。在之前的<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/">交换链</a>章节中我们提到过，在创建交换链对象的时候Vulkan会自动帮我们创建交换链使用的图像而无需我们自己创建，而在使用纹理的时候我们就需要自己完成创建图像的有关工作和细节了。创建纹理并且上传图片数据的过程主要可以细分为以下：</p><ul><li>将图片加载到程序中</li><li>将加载到程序中的图片数据复制给临时缓冲</li><li>创建纹理对象并且为其分配内存</li><li>在复制缓冲数据之前处理好图像布局的转换</li><li>将临时缓冲中的数据复制到纹理中</li></ul><p>可以看出构建并填充一个纹理对象的过程和构建并填充顶点缓冲的过程十分类似，不过最大的不同之处在于在将数据复制到纹理对象之前，我们需要处理好纹理布局。事实上，指定不同的图像布局会影响Vulkan对该图像执行操作的方式，一般在使用图像之前我们需要将图像布局转换为最适合接下来操作的那一个。在之前的<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/">渲染通道</a>章节中我们已经介绍过一些图像布局有关的知识，（这里有一个小疑点：<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/">渲染通道</a>章节中我们指定了帧缓冲的图像附件在渲染开始和结束后应该具备的布局，并且在之后的渲染过程中我们也并没有手动去进行布局的转换，但是GPT说即使在<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentDescription.html"><code>VkAttachmentDescription</code></a>中指定了附件的初始和最终布局，我们仍然需要在录制命令的时候手动进行布局转换以满足设置的布局要求，但是显然教程中没有这么做，我并不清楚是GPT说明有误还是教程漏写了。。。）。当我们需要自己处理布局转换有关的细节的时候，我们往往会采用管线屏障（<strong>pipelinebarrier</strong>）来同步转换前后需要指定顺序的操作，这同样会在本文的主要内容中介绍。</p><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Texture_mapping/Images#page_Preparing-the-texture-image">images</a>章节。</p><hr><h2 id="加载图片">加载图片</h2><p>有很多的库可以用于将图片加载至程序中，当然，自己写一个这样的库也并不困难。不过，为了性能和稳定性以及适用范围的考量，我们在这里还是选取一个十分通用的图像加载库：<a href="https://github.com/nothings/stb">stb_image</a>。这个库最大的特点和方便之处在于所有的代码都集中在一个文件中，省去了很多构建依赖关系的麻烦。想要使用这个库，我们只需要在程序中包含<strong>stb_image.h</strong>头文件，然后在程序头定义宏<i><font color="Red">STB_IMAGE_IMPLEMENTATION</font></i>即可。关于这个库提供的API以及有关使用方式我们不做过多介绍，想要详细了解的读者可以参考<strong>stb_image.h</strong>头文件中的<strong>DOCUMENTATION</strong>注释部分。</p><p>假设我们使用一张名为<strong>texture.jpg</strong>的图像，并且将其放在程序根目录下的子文件夹<strong>textures</strong>中。我们添加一个构建纹理的成员函数<i><font color="Green">voidcreateTextureImage()</font></i>，那么这个函数首先要做的就是加载图像到程序中来，加载图像的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createTextureImage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> texWidth, texHeight, texChannels;<br>    stbi_uc* pixels = <span class="hljs-built_in">stbi_load</span>(<span class="hljs-string">&quot;textures/texture.jpg&quot;</span>, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);<br>    VkDeviceSize imageSize = texWidth * texHeight * <span class="hljs-number">4</span>;<br><br>    <span class="hljs-keyword">if</span> (!pixels) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to load texture image!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里我们在<strong>stbi_load</strong>函数中使用了参数<i><font color="Red">STBI_rgb_alpha</font></i>，这意味着我们强制要求加载图片的透明通道，即使图片本身不具备该通道，这样加载的图片数据具有所有的四个通道。这么做可以使用统一的代码加载具有透明通道和不具有透明通道的图片。另外，加载后的图片数据大小<i><font color="Orange">imageSize</font></i>被定义为4倍的图像大小，因为加载后图片的每个像素都有4个通道，每个通道占一字节。</p><hr><h2 id="填充临时缓冲">填充临时缓冲</h2><p>填充临时缓冲的操作和<a href="https://zpc-dsg.github.io/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/">临时缓冲区</a>章节所述的步骤没什么区别：首先创建一个CPU可见且一致的临时缓冲对象并且为它分配内存，然后将该缓冲映射到CPU端，再将程序中的数据复制到该缓冲中，最后解除映射。整个代码流程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createTextureImage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <br>    VkBuffer stagingBuffer;<br>VkDeviceMemory stagingBufferMemory;<br>    <br>    <span class="hljs-built_in">createBuffer</span>(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);<br>    <br>    <span class="hljs-type">void</span>* data;<br><span class="hljs-built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="hljs-number">0</span>, imageSize, <span class="hljs-number">0</span>, &amp;data);<br>    <span class="hljs-built_in">memcpy</span>(data, pixels, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(imageSize));<br><span class="hljs-built_in">vkUnmapMemory</span>(device, stagingBufferMemory);<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然，不要忘了在图像数据复制到缓冲区后清理掉不再使用的<i><font color="Orange">pixels</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">stbi_image_free</span>(pixels);<br></code></pre></td></tr></table></figure><p>值得一提的是，实际上我们也可以使用临时图像来作为最终图像和CPU端数据的中介，不过在某些硬件上使用缓冲区作为中介的速度更快效果更好，所以我们还是使用临时缓冲区来传递数据。</p><hr><h2 id="创建纹理对象并分配内存">创建纹理对象并分配内存</h2><p>尽管在Vulkan中我们也可以使用缓冲区来存储并使用图像数据，但是Vulkan提供了专门用于使用图像的图像对象，通过图像对象我们就可以使用直观的坐标来获取像素颜色而无需通过字节来获取颜色信息，这显然是更方便的。并且Vulkan的图像对象还提供了各种布局以优化各种使用方式的效率。因此，使用图像对象来访问图片数据一般来讲是一个更好的选择。</p><p>现在我们已经将图片数据复制到了临时缓冲中，接下来我们需要创建GPU端真正用于存储数据的图像对象。为了创建这样一个图像对象，我们需要填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCreateInfo.html"><code>VkImageCreateInfo</code></a>结构体，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkImageCreateInfo</span> &#123;</span><br>    VkStructureType          sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*              pNext;<br>    VkImageCreateFlags       flags;<br>    VkImageType              imageType;<br>    VkFormat                 format;<br>    VkExtent3D               extent;<br>    <span class="hljs-type">uint32_t</span>                 mipLevels;<br>    <span class="hljs-type">uint32_t</span>                 arrayLayers;<br>    VkSampleCountFlagBits    samples;<br>    VkImageTiling            tiling;<br>    VkImageUsageFlags        usage;<br>    VkSharingMode            sharingMode;<br>    <span class="hljs-type">uint32_t</span>                 queueFamilyIndexCount;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*          pQueueFamilyIndices;<br>    VkImageLayout            initialLayout;<br>&#125; VkImageCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>指定了很多特性，详细可以参考<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCreateFlagBits.html">这个页面</a>，这里不做过多介绍。</p><p><i><font color="Orange">imageType</font></i>指定创建的图像对象类型，总共有三种类型：1D，2D和3D图像：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkImageType</span> &#123;</span><br>    VK_IMAGE_TYPE_1D = <span class="hljs-number">0</span>,<br>    VK_IMAGE_TYPE_2D = <span class="hljs-number">1</span>,<br>    VK_IMAGE_TYPE_3D = <span class="hljs-number">2</span>,<br>&#125; VkImageType;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">format</font></i>指定图像数据的格式，这个格式一般需要和临时缓冲区中存储图像的格式一致，不然的话在后续复制缓冲数据容易得到无法预知的错误结果。Vulkan支持的完整的图像格式可以参考<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkFormat.html">这个页面</a>。</p><p><i><font color="Orange">extent</font></i>是一个<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkExtent3D.html"><code>VkExtent3D</code></a>类型的成员，用于指定图像基础层级每个维度的像素数量，<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkExtent3D.html"><code>VkExtent3D</code></a>是一个包含三个维度像素数量成员的简单结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkExtent3D</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>    width;<br>    <span class="hljs-type">uint32_t</span>    height;<br>    <span class="hljs-type">uint32_t</span>    depth;<br>&#125; VkExtent3D;<br></code></pre></td></tr></table></figure><p>接下来的<i><font color="Orange">mipLevels</font></i>、<i><font color="Orange">arrayLayers</font></i>和<i><font color="Orange">samples</font></i>分别指定图像的多级渐远层级、图像层数以及多重采样采样数，我们暂时不需要使用多级渐远和多层图像，也暂时不会使用多重采样技术。</p><p><i><font color="Orange">tiling</font></i>指定了图像中的像素在内存中实际上的存储方式，它可以有以下取值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkImageTiling</span> &#123;</span><br>    VK_IMAGE_TILING_OPTIMAL = <span class="hljs-number">0</span>,<br>    VK_IMAGE_TILING_LINEAR = <span class="hljs-number">1</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_image_drm_format_modifier</span><br>    VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = <span class="hljs-number">1000158000</span>,<span class="hljs-comment">//主要用于支持 DRM（Direct Rendering Manager）格式修饰符的图像，这些修饰符允许驱动程序更好地利用硬件特性，以优化图像存储和访问。这个扩展使得 Vulkan 可以更好地与 Linux 的图形栈（如 Wayland 和 X11）集成</span><br>&#125; VkImageTiling;<br></code></pre></td></tr></table></figure><p>如果我们希望在后续的CPU端操作中获取图像中的内容，那么我们应该将<i><font color="Orange">tiling</font></i>设置为<i><font color="Red">VK_IMAGE_TILING_OPTIMAL</font></i>，但是如果我们希望在GPU端使用该图像，比如用于渲染采样等操作，那么应该将其设置为<i><font color="Red">VK_IMAGE_TILING_OPTIMAL</font></i>。注意铺砌方式和布局还是有所不同的：铺砌方式指定了图像数据在内存中的具体存储格式，而布局则是指定图像允许的使用方式。</p><p><i><font color="Orange">usage</font></i>指定图像的用途，关于Vulkan中图像允许的所有用途可以参考<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageUsageFlagBits.html">这个页面</a>。</p><p><i><font color="Orange">sharingMode</font></i>指定图像的共享模式，也就是是否能被多个队列家族所共享，下方的<i><font color="Orange">queueFamilyIndexCount</font></i>和<i><font color="Orange">pQueueFamilyIndices</font></i>就指定了可以共享该图像的队列家族索引。当然，如果共享模式不是<i><font color="Red">VK_SHARING_MODE_CONCURRENT</font></i>的话，这两个成员会被忽略，因此也就无需填写。</p><p><i><font color="Orange">initialLayout</font></i>指定图像的初始布局，也就是创建之初的布局。事实上，对于该变量我们的取值只有两种：</p><ul><li><i><font color="Red">VK_IMAGE_LAYOUT_UNDEFINED</font></i>：不可为GPU所用，并且在初次使用的布局转换之前会丢弃所有纹素内容。</li><li><i><font color="Red">VK_IMAGE_LAYOUT_PREINITIALIZED</font></i>：不可为GPU所用，但是在初次使用的布局转换之前会保存所有纹素内容。</li></ul><p>事实上，很少有情况需要我们在第一次布局转换之前保留纹素内容，不过也并没没有这种情况：比如我们使用临时图像传递图像数据，在将临时图像布局转换为适用于传递源的布局之前我们当然需要保留图像中复制而来的像素数据。不过在我们的应用程序中，我们将图像对象用作传输目的地，我们并不关心在接受临时缓冲里的图像数据之前该图像对象纹素中的内容是什么，因此我们应该将其初始布局设置为<i><font color="Red">VK_IMAGE_LAYOUT_UNDEFINED</font></i>。</p><p>于是创建我们所需要的纹理对象相应代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkImage textureImage;<br>VkDeviceMemory textureImageMemory;<br><br>VkImageCreateInfo imageInfo&#123;&#125;;<br>imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;<br>imageInfo.imageType = VK_IMAGE_TYPE_2D;<br>imageInfo.extent.width = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(texWidth);<br>imageInfo.extent.height = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(texHeight);<br>imageInfo.extent.depth = <span class="hljs-number">1</span>;<br>imageInfo.mipLevels = <span class="hljs-number">1</span>;<br>imageInfo.arrayLayers = <span class="hljs-number">1</span>;<br>imageInfo.format = VK_FORMAT_R8G8B8A8_SRGB;<br>imageInfo.tiling = VK_IMAGE_TILING_OPTIMAL;<br>imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;<br>imageInfo.usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;<br>imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;<br>imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateImage</span>(device, &amp;imageInfo, <span class="hljs-literal">nullptr</span>, &amp;textureImage) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create image!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们需要为创建好的图像分配内存，为图像分配内存的过程和为缓冲对象分配内存几乎一致，不熟悉的读者可以参考<a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/">创建顶点缓冲</a>章节有关内容。我们这里直接给出分配纹理内存的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkMemoryRequirements memRequirements;<br><span class="hljs-built_in">vkGetImageMemoryRequirements</span>(device, textureImage, &amp;memRequirements);<br><br>VkMemoryAllocateInfo allocInfo&#123;&#125;;<br>allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;<br>allocInfo.allocationSize = memRequirements.size;<br>allocInfo.memoryTypeIndex = <span class="hljs-built_in">findMemoryType</span>(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkAllocateMemory</span>(device, &amp;allocInfo, <span class="hljs-literal">nullptr</span>, &amp;textureImageMemory) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to allocate image memory!&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">vkBindImageMemory</span>(device, textureImage, textureImageMemory, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>终于完成了对图像对象的创建和分配内存操作。不过此时<i><font color="Green">createTextureImage</font></i>函数已经变得比较臃肿了，我们可以将其中创建图像和分配内存的代码放到一个新的工具函数<i><font color="Green">voidcreateImage(uint32_t width, uint32_t height, VkFormat format,VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlagsproperties, VkImage&amp; image, VkDeviceMemory&amp;imageMemory)</font></i>中来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createImage</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> width, <span class="hljs-type">uint32_t</span> height, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage&amp; image, VkDeviceMemory&amp; imageMemory)</span> </span>&#123;<br>    VkImageCreateInfo imageInfo&#123;&#125;;<br>    imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;<br>    imageInfo.imageType = VK_IMAGE_TYPE_2D;<br>    imageInfo.extent.width = width;<br>    imageInfo.extent.height = height;<br>    imageInfo.extent.depth = <span class="hljs-number">1</span>;<br>    imageInfo.mipLevels = <span class="hljs-number">1</span>;<br>    imageInfo.arrayLayers = <span class="hljs-number">1</span>;<br>    imageInfo.format = format;<br>    imageInfo.tiling = tiling;<br>    imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;<br>    imageInfo.usage = usage;<br>    imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;<br>    imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateImage</span>(device, &amp;imageInfo, <span class="hljs-literal">nullptr</span>, &amp;image) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create image!&quot;</span>);<br>    &#125;<br><br>    VkMemoryRequirements memRequirements;<br>    <span class="hljs-built_in">vkGetImageMemoryRequirements</span>(device, image, &amp;memRequirements);<br><br>    VkMemoryAllocateInfo allocInfo&#123;&#125;;<br>    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;<br>    allocInfo.allocationSize = memRequirements.size;<br>    allocInfo.memoryTypeIndex = <span class="hljs-built_in">findMemoryType</span>(memRequirements.memoryTypeBits, properties);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkAllocateMemory</span>(device, &amp;allocInfo, <span class="hljs-literal">nullptr</span>, &amp;imageMemory) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to allocate image memory!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">vkBindImageMemory</span>(device, image, imageMemory, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样<i><font color="Green">createTextureImage</font></i>函数就可以简化为以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createTextureImage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> texWidth, texHeight, texChannels;<br>    stbi_uc* pixels = <span class="hljs-built_in">stbi_load</span>(<span class="hljs-string">&quot;textures/texture.jpg&quot;</span>, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);<br>    VkDeviceSize imageSize = texWidth * texHeight * <span class="hljs-number">4</span>;<br><br>    <span class="hljs-keyword">if</span> (!pixels) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to load texture image!&quot;</span>);<br>    &#125;<br><br>    VkBuffer stagingBuffer;<br>    VkDeviceMemory stagingBufferMemory;<br>    <span class="hljs-built_in">createBuffer</span>(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);<br><br>    <span class="hljs-type">void</span>* data;<br>    <span class="hljs-built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="hljs-number">0</span>, imageSize, <span class="hljs-number">0</span>, &amp;data);<br>        <span class="hljs-built_in">memcpy</span>(data, pixels, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(imageSize));<br>    <span class="hljs-built_in">vkUnmapMemory</span>(device, stagingBufferMemory);<br><br>    <span class="hljs-built_in">stbi_image_free</span>(pixels);<br><br>    <span class="hljs-built_in">createImage</span>(texWidth, texHeight, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="布局转换">布局转换</h2><p>在创建好图像对象以及分配好相应的内存之后，我们接下来要做的就是将临时缓冲中的数据复制到图像对象中来。但是在复制之前，我们首先需要调整图像对象的布局以使其能够作为复制操作的目的地。</p><p>要实现布局的转换，我们同样需要将相应的命令提交到队列中执行。因此我们需要首先录制执行转换的命令。如今我们的程序中已经有多处需要用到命令缓冲了，因此不妨将相应代码提取出来重构成两个新的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkCommandBuffer <span class="hljs-title">beginSingleTimeCommands</span><span class="hljs-params">()</span> </span>&#123;<br>    VkCommandBufferAllocateInfo allocInfo&#123;&#125;;<br>    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;<br>    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;<br>    allocInfo.commandPool = commandPool;<br>    allocInfo.commandBufferCount = <span class="hljs-number">1</span>;<br><br>    VkCommandBuffer commandBuffer;<br>    <span class="hljs-built_in">vkAllocateCommandBuffers</span>(device, &amp;allocInfo, &amp;commandBuffer);<br><br>    VkCommandBufferBeginInfo beginInfo&#123;&#125;;<br>    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;<br>    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;<br><br>    <span class="hljs-built_in">vkBeginCommandBuffer</span>(commandBuffer, &amp;beginInfo);<br><br>    <span class="hljs-keyword">return</span> commandBuffer;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">endSingleTimeCommands</span><span class="hljs-params">(VkCommandBuffer commandBuffer)</span> </span>&#123;<br>    <span class="hljs-built_in">vkEndCommandBuffer</span>(commandBuffer);<br><br>    VkSubmitInfo submitInfo&#123;&#125;;<br>    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;<br>    submitInfo.commandBufferCount = <span class="hljs-number">1</span>;<br>    submitInfo.pCommandBuffers = &amp;commandBuffer;<br><br>    <span class="hljs-built_in">vkQueueSubmit</span>(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, VK_NULL_HANDLE);<br>    <span class="hljs-built_in">vkQueueWaitIdle</span>(graphicsQueue);<br><br>    <span class="hljs-built_in">vkFreeCommandBuffers</span>(device, commandPool, <span class="hljs-number">1</span>, &amp;commandBuffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>这些代码是从<i><font color="Green">copyBuffer</font></i>函数中提取出来的，这样<i><font color="Green">copyBuffer</font></i>函数就可以简化为以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copyBuffer</span><span class="hljs-params">(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size)</span> </span>&#123;<br>    VkCommandBuffer commandBuffer = <span class="hljs-built_in">beginSingleTimeCommands</span>();<br><br>    VkBufferCopy copyRegion&#123;&#125;;<br>    copyRegion.size = size;<br>    <span class="hljs-built_in">vkCmdCopyBuffer</span>(commandBuffer, srcBuffer, dstBuffer, <span class="hljs-number">1</span>, &amp;copyRegion);<br><br>    <span class="hljs-built_in">endSingleTimeCommands</span>(commandBuffer<br></code></pre></td></tr></table></figure><p>现在，我们创建一个<i><font color="Green">voidtransitionImageLayout(VkImage image, VkFormat format, VkImageLayoutoldLayout, VkImageLayoutnewLayout)</font></i>函数来完成布局转换相应的工作。我们将使用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageMemoryBarrier.html"><code>VkImageMemoryBarrier</code></a>（管线屏障的一种）来完成图像布局转换前后的同步操作。<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageMemoryBarrier.html"><code>VkImageMemoryBarrier</code></a>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkImageMemoryBarrier</span> &#123;</span><br>    VkStructureType            sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                pNext;<br>    VkAccessFlags              srcAccessMask;<br>    VkAccessFlags              dstAccessMask;<br>    VkImageLayout              oldLayout;<br>    VkImageLayout              newLayout;<br>    <span class="hljs-type">uint32_t</span>                   srcQueueFamilyIndex;<br>    <span class="hljs-type">uint32_t</span>                   dstQueueFamilyIndex;<br>    VkImage                    image;<br>    VkImageSubresourceRange    subresourceRange;<br>&#125; VkImageMemoryBarrier;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">srcAccessMask</font></i>和<i><font color="Orange">dstAccessMask</font></i>分别指定栅栏前需要完成的操作和栅栏后等待前述操作完成的操作，可能的取值可以参考<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/VkAccessFlagBits.html">这个页面</a>。</p><p><i><font color="Orange">srcQueueFamilyIndex</font></i>和<i><font color="Orange">dstQueueFamilyIndex</font></i>分别指定图像归属权转移操作中的源队列和目标队列。在这里我们并不会将该管线屏障用于图像归属权转移操作，但是这两个成员的默认值并不是屏蔽该用法，因此我们仍然需要赋予这两个成员<i><font color="Red">VK_QUEUE_FAMILY_IGNORED</font></i>以显式指定我们不进行队列间归属转移。</p><p><i><font color="Orange">subresourceRange</font></i>用于指定图像中被该屏障影响的部分。<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/VkImageSubresourceRange.html"><code>VkImageSubresourceRange</code></a>结构体的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkImageSubresourceRange</span> &#123;</span><br>    VkImageAspectFlags    aspectMask;<span class="hljs-comment">//图像的哪个方面（颜色、深度、模板等）会被影响</span><br>    <span class="hljs-type">uint32_t</span>              baseMipLevel;<span class="hljs-comment">//从哪个渐远层级开始被影响</span><br>    <span class="hljs-type">uint32_t</span>              levelCount;<span class="hljs-comment">//被影响的层级数</span><br>    <span class="hljs-type">uint32_t</span>              baseArrayLayer;<span class="hljs-comment">//从哪个图层开始被影响</span><br>    <span class="hljs-type">uint32_t</span>              layerCount;<span class="hljs-comment">//被影响的图像层数</span><br>&#125; VkImageSubresourceRange;<br></code></pre></td></tr></table></figure><p>随着我们程序的复杂化，我们可能需要处理多种不同类型的布局转换。就目前而言，我们需要处理的转换有两个：</p><ul><li>由最初的布局转换为数据传输目标布局</li><li>由传输目标布局转化为适合着色器读写布局</li></ul><p>于是在这两种转换中，填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageMemoryBarrier.html"><code>VkImageMemoryBarrier</code></a>结构体过程中唯一的不同就是对<i><font color="Orange">srcAccessMask</font></i>和<i><font color="Orange">dstAccessMask</font></i>的指定。对于从最初的布局到数据传输目标布局的转换，我们并不需要在复制数据到图像对象之前等待什么特别的操作先完成，于是<i><font color="Orange">srcAccessMask</font></i>直接填写为0即可。而<i><font color="Orange">dstAccessMask</font></i>显然应该指定为我们的复制写入操作，因此将其设置为<i><font color="Red">VK_ACCESS_TRANSFER_WRITE_BIT</font></i>比较合理。在成功复制数据之后，图像将供后续着色器读取纹理用，此时我们应该对其进行第二次的转换，即将其布局转换为适合着色器读取的布局。在进行这个转换时我们应该在转换前等待完成的操作是数据的写入操作，因为我们不希望在数据还未完全写入的时候就开始对图像进行转换操作，因此此时<i><font color="Orange">srcAccessMask</font></i>应该为<i><font color="Red">VK_ACCESS_TRANSFER_WRITE_BIT</font></i>，而<i><font color="Orange">dstAccessMask</font></i>应该为<i><font color="Red">VK_ACCESS_SHADER_READ_BIT</font></i>，因为后续着色器读取数据需要等待数据的填充完成之后才能进行。</p><p>在填写好这个信息结构体之后，我们需要使用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPipelineBarrier.html"><code>vkCmdPipelineBarrier</code></a>函数来完成管线屏障的提交工作，提交后队列会处理屏障所保障的布局转换操作。该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdPipelineBarrier</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    VkPipelineStageFlags                        srcStageMask,</span><br><span class="hljs-params">    VkPipelineStageFlags                        dstStageMask,</span><br><span class="hljs-params">    VkDependencyFlags                           dependencyFlags,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    memoryBarrierCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkMemoryBarrier*                      pMemoryBarriers,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    bufferMemoryBarrierCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkBufferMemoryBarrier*                pBufferMemoryBarriers,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    imageMemoryBarrierCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkImageMemoryBarrier*                 pImageMemoryBarriers)</span>;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">srcStageMask</font></i>和<i><font color="Orange">dstStageMask</font></i>分别指定屏障前需要完成的管线阶段和屏障后需要等待的管线阶段，这和之前在填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageMemoryBarrier.html"><code>VkImageMemoryBarrier</code></a>结构体中设置的<i><font color="Orange">srcAccessMask</font></i>和<i><font color="Orange">dstAccessMask</font></i>是相互对应的。在第一次转换中，我们无需等待任何操作，因此<i><font color="Orange">srcStageMask</font></i>可以直接设置为<i><font color="Red">VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</font></i>，而处于等待状态的操作是写入操作，因此<i><font color="Orange">dstStageMask</font></i>应该指定为<i><font color="Red">VK_PIPELINE_STAGE_TRANSFER_BIT</font></i>。不过这里注意，<i><font color="Red">VK_PIPELINE_STAGE_TRANSFER_BIT</font></i>实际上并不是一个真正存在的管线阶段，我们称其为一个<strong>伪阶段</strong>，它们是一种逻辑上存在的阶段，用于描述一些逻辑上的操作，阶段发生时间并不是固定的。<a href="https://docs.vulkan.org/spec/latest/chapters/synchronization.html#VkPipelineStageFlagBits">这个页面</a>有更多关于Vulkan中的伪阶段的信息。</p><p>接下来的<i><font color="Orange">dependencyFlags</font></i>用于指定执行和内存上的一些依赖关系。它可能的取值如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDependencyFlagBits</span> &#123;</span><br>    VK_DEPENDENCY_BY_REGION_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//当一个命令依赖于另一个命令的执行时，如果使用该标志，表示只需在依赖的区域内进行同步，而不是整个资源。这可以提高性能，因为只需同步必要的部分</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_DEPENDENCY_DEVICE_GROUP_BIT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//在多视图渲染中，该标志指示依赖关系仅适用于特定的视图。这意味着资源的访问和修改仅限于特定的视图，其他视图不受影响</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_DEPENDENCY_VIEW_LOCAL_BIT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//在使用多个 GPU 的情况下，该标志指示依赖关系涉及设备组中的多个设备。这有助于在多个设备之间管理资源的访问和同步，确保数据一致性</span><br>  <span class="hljs-comment">// Provided by VK_EXT_attachment_feedback_loop_layout</span><br>    VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//在某些渲染场景中，可能存在反馈循环（如图像处理），该标志指示依赖关系与这种反馈循环相关。使用该标志可以确保在处理反馈循环时适当地管理资源的依赖关系</span><br>  <span class="hljs-comment">// Provided by VK_KHR_multiview</span><br>    VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = VK_DEPENDENCY_VIEW_LOCAL_BIT,<br>  <span class="hljs-comment">// Provided by VK_KHR_device_group</span><br>    VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = VK_DEPENDENCY_DEVICE_GROUP_BIT,<br>&#125; VkDependencyFlagBits;<br></code></pre></td></tr></table></figure><p>接下来的六个成员分别对应三种不同的管线屏障。我们需要使用的是图像内存屏障，因此只需填写最后两个成员即可。</p><p>于是当前我们的<i><font color="Green">transitionImageLayout</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transitionImageLayout</span><span class="hljs-params">(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout)</span> </span>&#123;<br>    VkCommandBuffer commandBuffer = <span class="hljs-built_in">beginSingleTimeCommands</span>();<br><br>    VkImageMemoryBarrier barrier&#123;&#125;;<br>    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;<br>    barrier.oldLayout = oldLayout;<br>    barrier.newLayout = newLayout;<br>    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;<br>    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;<br>    barrier.image = image;<br>    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br>    barrier.subresourceRange.baseMipLevel = <span class="hljs-number">0</span>;<br>    barrier.subresourceRange.levelCount = <span class="hljs-number">1</span>;<br>    barrier.subresourceRange.baseArrayLayer = <span class="hljs-number">0</span>;<br>    barrier.subresourceRange.layerCount = <span class="hljs-number">1</span>;<br><br>    VkPipelineStageFlags sourceStage;<br>    VkPipelineStageFlags destinationStage;<br><br>    <span class="hljs-keyword">if</span> (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) &#123;<br>        barrier.srcAccessMask = <span class="hljs-number">0</span>;<br>        barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;<br><br>        sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;<br>        destinationStage = VK_PIPELINE_STAGE_TRANSFER_BIT;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL &amp;&amp; newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) &#123;<br>        barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;<br>        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;<br><br>        sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT;<br>        destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;unsupported layout transition!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">vkCmdPipelineBarrier</span>(<br>        commandBuffer,<br>        sourceStage, destinationStage,<br>        <span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>        <span class="hljs-number">1</span>, &amp;barrier<br>    );<br><br>    <span class="hljs-built_in">endSingleTimeCommands</span>(commandBuffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就完成了图像布局转换有关的工作。</p><hr><h2 id="复制数据到纹理">复制数据到纹理</h2><p>图像完成第一次布局转换后，我们就可以将临时缓冲中的数据复制到图像对象中来了。同样创建一个<i><font color="Green">voidcopyBufferToImage(VkBuffer buffer, VkImage image, uint32_t width,uint32_t height)</font></i>函数来完成相应的工作。</p><p>如同<a href="https://zpc-dsg.github.io/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/">临时缓冲区</a>章节中复制缓冲区到缓冲区时需要填写<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferCopy.html"><code>VkBufferCopy</code></a>结构体以指定复制区域，从缓冲区复制到图像同样需要指定复制区域和接收复制数据的图像区域，这是通过结构体<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferImageCopy.html"><code>VkBufferImageCopy</code></a>来指定的，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkBufferImageCopy</span> &#123;</span><br>    VkDeviceSize                bufferOffset;<br>    <span class="hljs-type">uint32_t</span>                    bufferRowLength;<br>    <span class="hljs-type">uint32_t</span>                    bufferImageHeight;<br>    VkImageSubresourceLayers    imageSubresource;<br>    VkOffset3D                  imageOffset;<br>    VkExtent3D                  imageExtent;<br>&#125; VkBufferImageCopy;<br></code></pre></td></tr></table></figure><p>大多数的成员含义是显而易见的，这里需要解释一下的是<i><font color="Orange">bufferRowLength</font></i>和<i><font color="Orange">bufferImageHeight</font></i>，这两个成员如果设置为非0值，则分别代表缓冲区的图像数据行宽度、列高度超过了实际图像每一行、每一列的像素数，这在处理图像填充或多层次图像时会比较有用。如果二者均设置为0，则代表不会有多余的填充，图像像素是紧密排列的。</p><p>于是我们填写该结构体的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkBufferImageCopy region&#123;&#125;;<br>region.bufferOffset = <span class="hljs-number">0</span>;<br>region.bufferRowLength = <span class="hljs-number">0</span>;<br>region.bufferImageHeight = <span class="hljs-number">0</span>;<br><br>region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br>region.imageSubresource.mipLevel = <span class="hljs-number">0</span>;<br>region.imageSubresource.baseArrayLayer = <span class="hljs-number">0</span>;<br>region.imageSubresource.layerCount = <span class="hljs-number">1</span>;<br><br>region.imageOffset = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>region.imageExtent = &#123;<br>    width,<br>    height,<br>    <span class="hljs-number">1</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>接下来就可以使用<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/vkCmdCopyBufferToImage.html"><code>vkCmdCopyBufferToImage</code></a>来录制图像数据的复制命令了，该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdCopyBufferToImage</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    VkBuffer                                    srcBuffer,</span><br><span class="hljs-params">    VkImage                                     dstImage,</span><br><span class="hljs-params">    VkImageLayout                               dstImageLayout,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    regionCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkBufferImageCopy*                    pRegions)</span>;<br></code></pre></td></tr></table></figure><p>这些参数的含义都是显而易见的。需要注意一下的是该函数原型的最后两个参数提示我们实际上可以同时将一个缓冲区的数据复制到图像的多个子区域上，不过这里我们并不需要，只需要复制完整的图像数据即可。</p><p>于是我们的<i><font color="Green">copyBufferToImage</font></i>函数代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">copyBufferToImage</span><span class="hljs-params">(VkBuffer buffer, VkImage image, <span class="hljs-type">uint32_t</span> width, <span class="hljs-type">uint32_t</span> height)</span> &#123;<br>    VkCommandBuffer commandBuffer = beginSingleTimeCommands();<br><br>    VkBufferImageCopy region&#123;&#125;;<br>    region.bufferOffset = <span class="hljs-number">0</span>;<br>    region.bufferRowLength = <span class="hljs-number">0</span>;<br>    region.bufferImageHeight = <span class="hljs-number">0</span>;<br>    region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br>    region.imageSubresource.mipLevel = <span class="hljs-number">0</span>;<br>    region.imageSubresource.baseArrayLayer = <span class="hljs-number">0</span>;<br>    region.imageSubresource.layerCount = <span class="hljs-number">1</span>;<br>    region.imageOffset = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    region.imageExtent = &#123;<br>        width,<br>        height,<br>        <span class="hljs-number">1</span><br>    &#125;;<br><br>    vkCmdCopyBufferToImage(commandBuffer, buffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, <span class="hljs-number">1</span>, &amp;region);<br><br>    endSingleTimeCommands(commandBuffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就准备好了构建着色器所需纹理的所有准备工作，利用这些工具函数我们终于可以完成<i><font color="Green">createTextureImage</font></i>函数了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createTextureImage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> texWidth, texHeight, texChannels;<br>    stbi_uc* pixels = <span class="hljs-built_in">stbi_load</span>(<span class="hljs-string">&quot;textures/texture.jpg&quot;</span>, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);<br>    VkDeviceSize imageSize = texWidth * texHeight * <span class="hljs-number">4</span>;<br><br>    <span class="hljs-keyword">if</span> (!pixels) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to load texture image!&quot;</span>);<br>    &#125;<br><br>    VkBuffer stagingBuffer;<br>    VkDeviceMemory stagingBufferMemory;<br>    <span class="hljs-built_in">createBuffer</span>(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);<br><br>    <span class="hljs-type">void</span>* data;<br>    <span class="hljs-built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="hljs-number">0</span>, imageSize, <span class="hljs-number">0</span>, &amp;data);<br>    <span class="hljs-built_in">memcpy</span>(data, pixels, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(imageSize));<br>    <span class="hljs-built_in">vkUnmapMemory</span>(device, stagingBufferMemory);<br><br>    <span class="hljs-built_in">stbi_image_free</span>(pixels);<br><br>    <span class="hljs-built_in">createImage</span>(texWidth, texHeight, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);<br><br>    <span class="hljs-built_in">transitionImageLayout</span>(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);<br>    <span class="hljs-built_in">copyBufferToImage</span>(stagingBuffer, textureImage, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(texWidth), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(texHeight));<br>    <span class="hljs-built_in">transitionImageLayout</span>(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);<br><br>    <span class="hljs-built_in">vkDestroyBuffer</span>(device, stagingBuffer, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">vkFreeMemory</span>(device, stagingBufferMemory, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/12/06/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B1%A0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86/">上一篇：描述符池和描述符集</a></p><p>--<a href="https://zpc-dsg.github.io/2024/12/20/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/">下一篇：图像视图和采样器</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>描述符池和描述符集</title>
    <link href="/2024/12/06/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B1%A0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86/"/>
    <url>/2024/12/06/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B1%A0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>本章我们将创建包含统一缓冲的描述符集。主要过程分三步</p><ul><li>创建描述符池</li><li>创建描述符集</li><li>使用并绑定描述符集</li></ul><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Uniform_buffers/Descriptor_pool_and_sets#page_Multiple-descriptor-sets">Descriptorpool and sets</a>章节。</p><hr><h2 id="创建描述符池">创建描述符池</h2><p>如同命令缓冲需要从命令池中分配，描述符集也需要从描述符池中分配，不过不同的是，一个描述符池中可以分配多种描述符，但是一个命令池中只能分配提交给一种队列家族的命令缓冲。创建描述符池同样需要填写相应信息结构体<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolCreateInfo.html"><code>VkDescriptorPoolCreateInfo</code></a>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDescriptorPoolCreateInfo</span> &#123;</span><br>    VkStructureType                sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                    pNext;<br>    VkDescriptorPoolCreateFlags    flags;<br>    <span class="hljs-type">uint32_t</span>                       maxSets;<span class="hljs-comment">//最多分配的描述符集个数</span><br>    <span class="hljs-type">uint32_t</span>                       poolSizeCount;<br>    <span class="hljs-type">const</span> VkDescriptorPoolSize*    pPoolSizes;<br>&#125; VkDescriptorPoolCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>可能的取值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDescriptorPoolCreateFlagBits</span> &#123;</span><br>    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//允许在描述符池中自由释放描述符集。这意味着当一个描述符集不再使用时，可以将其释放回池中，而不需要在分配时保持特定的顺序</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//允许在绑定描述符集后更新描述符集引用的资源。使用此标志时，应用程序可以在描述符集绑定后对其进行更新，而不需要重新分配描述符集</span><br>  <span class="hljs-comment">// Provided by VK_EXT_mutable_descriptor_type</span><br>    VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//此标志指示描述符池仅用于主机访问的资源。这意味着该描述符池中的资源不会被分配给设备（GPU），而是仅在主机（CPU）上使用</span><br>  <span class="hljs-comment">// Provided by VK_NV_descriptor_pool_overallocation</span><br>    VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//允许描述符池的描述符集超分配。这意味着可以分配比池中实际可用的描述符更多的描述符集</span><br>  <span class="hljs-comment">// Provided by VK_NV_descriptor_pool_overallocation</span><br>    VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV = <span class="hljs-number">0x00000010</span>,<span class="hljs-comment">//允许描述符池本身超分配。这意味着可以创建一个描述符池，其中的描述符数量超过了实际分配的数量</span><br>  <span class="hljs-comment">// Provided by VK_EXT_descriptor_indexing</span><br>    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,<br>  <span class="hljs-comment">// Provided by VK_VALVE_mutable_descriptor_type</span><br>    VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE = VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT,<br>&#125; VkDescriptorPoolCreateFlagBits;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">poolSizeCount</font></i>指定池中子池的个数，每个子池只包含一种描述符集。<i><font color="Orange">pPoolSizes</font></i>指定实际的子池信息，其类型为<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolSize.html"><code>VkDescriptorPoolSize</code></a>结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDescriptorPoolSize</span> &#123;</span><br>    VkDescriptorType    type;<br>    <span class="hljs-type">uint32_t</span>            descriptorCount;<br>&#125; VkDescriptorPoolSize;<br></code></pre></td></tr></table></figure><p>成员含义都非常好理解。</p><p>我们需要给每帧分配一个不同的描述符，因此我们需要在类内添加一个<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPool.html"><code>VkDescriptorPool</code></a>类型成员，然后创建一个<i><font color="Green">voidcreateDescriptorPool()</font></i>成员函数来进行创建工作。将该函数置于<i><font color="Green">createUniformBuffers()</font></i>函数后，其代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createDescriptorPool</span><span class="hljs-params">()</span> </span>&#123;<br>VkDescriptorPoolSize poolSize&#123;&#125;;<br>poolSize.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;<br>poolSize.descriptorCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(MAX_FRAMES_IN_FLIGHT);<br><br>VkDescriptorPoolCreateInfo poolInfo&#123;&#125;;<br>poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;<br>poolInfo.poolSizeCount = <span class="hljs-number">1</span>;<br>poolInfo.pPoolSizes = &amp;poolSize;<br>poolInfo.maxSets = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(MAX_FRAMES_IN_FLIGHT);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateDescriptorPool</span>(device, &amp;poolInfo, <span class="hljs-literal">nullptr</span>, &amp;descriptorPool) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create descriptor pool!&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="创建描述符集">创建描述符集</h2><p>在创建好描述符池后，我们就可以从中分配描述符集了。在类内新添成员<i><font color="Orange">std::vector<VkDescriptorSet>descriptorSets</VkDescriptorSet></font></i>用于保存分配的描述符集，并且创建<i><font color="Green">voidcreateDescriptorSets()</font></i>函数来进行分配工作。</p><p>分配描述符集需要填写信息结构体<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetAllocateInfo.html"><code>VkDescriptorSetAllocateInfo</code></a>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDescriptorSetAllocateInfo</span> &#123;</span><br>    VkStructureType                 sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                     pNext;<br>    VkDescriptorPool                descriptorPool;<br>    <span class="hljs-type">uint32_t</span>                        descriptorSetCount;<br>    <span class="hljs-type">const</span> VkDescriptorSetLayout*    pSetLayouts;<br>&#125; VkDescriptorSetAllocateInfo;<br></code></pre></td></tr></table></figure><p>每个成员都是易于理解的。需要注意的是在分配描述符集的时候我们需要对每个分配的描述符集都指定其相应的描述符布局。分配描述符集代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;VkDescriptorSetLayout&gt; <span class="hljs-title">layouts</span><span class="hljs-params">(MAX_FRAMES_IN_FLIGHT, descriptorSetLayout)</span></span>;<br>VkDescriptorSetAllocateInfo allocInfo&#123;&#125;;<br>allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;<br>allocInfo.descriptorPool = descriptorPool;<br>allocInfo.descriptorSetCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(MAX_FRAMES_IN_FLIGHT);<br>allocInfo.pSetLayouts = layouts.<span class="hljs-built_in">data</span>();<br><br>descriptorSets.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkAllocateDescriptorSets</span>(device, &amp;allocInfo, descriptorSets.<span class="hljs-built_in">data</span>()) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to allocate descriptor sets!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意我们不需要在<i><font color="Green">cleanUp</font></i>函数中清理分配的描述符集，因为清理描述符池会自动清理掉其中分配的描述符集。</p><p>仅仅分配好描述符集是不够的。为了能够使用这些描述符集我们还需要指定这些描述符集引用的资源以及是如何更新这些资源的。我们需要指定的描述符资源是统一缓冲，于是我们需要为每个描述符填写<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/VkWriteDescriptorSet.html"><code>VkDescriptorBufferInfo</code></a>来指定这些描述符各自对应的资源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123;<br>    VkDescriptorBufferInfo bufferInfo&#123;&#125;;<br>    bufferInfo.buffer = uniformBuffers[i];<br>    bufferInfo.offset = <span class="hljs-number">0</span>;<br>    bufferInfo.range = <span class="hljs-built_in">sizeof</span>(UniformBufferObject);<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们需要指定怎么更新描述符集。可以指定的更新方式有两种：写入和复制。我们这里只需要填写写入方式，它使用<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/VkWriteDescriptorSet.html"><code>VkWriteDescriptorSet</code></a>结构体来指定，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkWriteDescriptorSet</span> &#123;</span><br>    VkStructureType                  sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                      pNext;<br>    VkDescriptorSet                  dstSet;<br>    <span class="hljs-type">uint32_t</span>                         dstBinding;<br>    <span class="hljs-type">uint32_t</span>                         dstArrayElement;<br>    <span class="hljs-type">uint32_t</span>                         descriptorCount;<br>    VkDescriptorType                 descriptorType;<br>    <span class="hljs-type">const</span> VkDescriptorImageInfo*     pImageInfo;<br>    <span class="hljs-type">const</span> VkDescriptorBufferInfo*    pBufferInfo;<br>    <span class="hljs-type">const</span> VkBufferView*              pTexelBufferView;<br>&#125; VkWriteDescriptorSet;<br></code></pre></td></tr></table></figure><p>每个成员都是易于理解的。我们这里指定的资源是统一缓冲，所以最后三个成员只需填写<i><font color="Orange">pBufferInfo</font></i>即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkWriteDescriptorSet descriptorWrite&#123;&#125;;<br>descriptorWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;<br>descriptorWrite.dstSet = descriptorSets[i];<br>descriptorWrite.dstBinding = <span class="hljs-number">0</span>;<br>descriptorWrite.dstArrayElement = <span class="hljs-number">0</span>;<br>descriptorWrite.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;<br>descriptorWrite.descriptorCount = <span class="hljs-number">1</span>;<br>descriptorWrite.pBufferInfo = &amp;bufferInfo;<br></code></pre></td></tr></table></figure><p>最后，我们使用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateDescriptorSets.html"><code>vkUpdateDescriptorSets</code></a>来更新描述符集：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkUpdateDescriptorSets</span>(device, <span class="hljs-number">1</span>, &amp;descriptorWrite, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br></code></pre></td></tr></table></figure><p>可以看出我们可以使用一个该命令同时更新多个描述符集，并且还可以指定两种更新方式。这里我们只指定了写入更新，未指定复制更新，所以后两个成员保持默认。</p><p>由于在我们当前的应用程序中，我们在运行时不需要更新描述符集绑定的资源，每个描述符集从头到尾使用的都是同一个统一缓冲，因此这里我们在<i><font color="Green">initVulkan</font></i>中就直接指定好了资源及更新方式。如果需要每帧更新描述符集引用的资源的话，我们就需要在每帧录制命令的时候指定引用资源及更新方式，然后再将描述符集绑定到管线上。</p><hr><h2 id="使用描述符集">使用描述符集</h2><p>在分配以及配置好描述符集之后，我们就可以在渲染管线中使用这些描述符集传递统一资源了。这只需要在录制命令中的绘制命令之前调用<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/vkCmdBindDescriptorSets.html"><code>vkCmdBindDescriptorSets</code></a>绑定描述符集即可，该函数原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdBindDescriptorSets</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    VkPipelineBindPoint                         pipelineBindPoint,</span><br><span class="hljs-params">    VkPipelineLayout                            layout,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    firstSet,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    descriptorSetCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkDescriptorSet*                      pDescriptorSets,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    dynamicOffsetCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*                             pDynamicOffsets)</span>;<br></code></pre></td></tr></table></figure></p><p>和顶点缓冲以及索引缓冲不同的是，描述符引用的资源可以用于渲染管线，也可以用于计算管线，所以在使用该函数绑定描述符集时我们需要显式指定<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineBindPoint.html"><code>VkPipelineBindPoint</code></a>。</p><p>显然，该函数原型告诉我们在绑定时我们可以使用一个命令同时绑定多个描述符集，并且我们可以在着色器中使用类似下面的语法来指定使用绑定点上的哪一个描述符集：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span>(set = <span class="hljs-number">0</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> UniformBufferObject &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>这里<strong>set</strong>对应的索引引用的描述符集就是<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/vkCmdBindDescriptorSets.html"><code>vkCmdBindDescriptorSets</code></a>命令中按照绑定顺序对应索引的描述符集。不过需要注意的是，如果在一次录制命令中调用多次<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/vkCmdBindDescriptorSets.html"><code>vkCmdBindDescriptorSets</code></a>，那么最后的调用中位于同一绑定点<strong>binding</strong>的描述符集会覆盖前几次调用在这个绑定点绑定的描述符集，当然，如果几次调用中描述符集对应的绑定点不重合，那么不会发生覆盖现象。</p><p>于是在录制命令函数<i><font color="Green">recordCommandBuffer</font></i>中的绘制命令<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexed.html"><code>vkCmdDrawIndexed</code></a>前添加上绑定统一缓冲的代码即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdBindDescriptorSets</span>(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;descriptorSets[currentFrame], <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br><span class="hljs-built_in">vkCmdDrawIndexed</span>(commandBuffer, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(indices.<span class="hljs-built_in">size</span>()), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>但是事实上此时我们运行应用程序会发现屏幕全黑，这是因为我们在之前为了图像上下方向的正确性翻转了y轴坐标，但是这同时也使得面片的正反方向对调了一下，于是之前我们设置的面剔除此时剔除了四边形的正面！所以为了得到正确的图像，我们应该将管线布局中光栅化阶段的面剔除方向设置为<i><font color="Red">VK_CULL_MODE_FRONT_BIT</font></i>或者将正面定义为<i><font color="Red">VK_FRONT_FACE_COUNTER_CLOCKWISE</font></i>。（有关面片的正面背面是怎么定义的，以及面剔除有关介绍，可以参考<a href="https://learnopengl.com/Advanced-OpenGL/Face-culling">这篇文章</a>。</p><p>现在我们就可以显示出正确的图像了！</p><figure><img src="/2024/12/06/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B1%A0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86/rectangle.png" alt="旋转四边形"><figcaption aria-hidden="true">旋转四边形</figcaption></figure><hr><h2 id="对齐要求">对齐要求</h2><p>最后我们其实还有一部分重要但较为隐晦的内容没有说明，那就是c++中的结构和着色器中对应的结构之间的数据匹配对齐问题。</p><p>事实上，Vulkan希望程序自定义的结构体中的成员能够按照某种特定的方式对齐，具体而言主要有以下几条：</p><ul><li>标量按N字节对齐（如果是32位浮点数那么N就是4）</li><li><strong>vec2</strong>按2N对齐</li><li><strong>vec3</strong>和<strong>vec4</strong>按4N对齐</li><li><strong>mat4</strong>对齐方式和<strong>vec4</strong>一致</li><li>内嵌结构体必须按照它成员的基础对齐（调整到16的倍数）对齐</li></ul><p>在<a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-resources-layout">这里</a>可以找到完整的对齐要求。</p><p>在我们的程序中，回忆一下我们对统一缓冲数据结构体以及着色器中相应结构体的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UniformBufferObject</span> &#123;<br>    glm::mat4 model;<br>    glm::mat4 view;<br>    glm::mat4 proj;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> UniformBufferObject &#123;<br>    <span class="hljs-type">mat4</span> model;<br>    <span class="hljs-type">mat4</span> view;<br>    <span class="hljs-type">mat4</span> proj;<br>&#125; ubo;<br></code></pre></td></tr></table></figure><p>即使我们不刻意调整对齐，它们也能完美符合要求，因为一开始成员<i><font color="Orange">model</font></i>的偏移为0，而一个<strong>mat4</strong>变量是64字节，因此成员<i><font color="Orange">view</font></i>成员的偏移是64字节，是16的整数倍，<i><font color="Orange">proj</font></i>同理，因此不会出现什么问题。</p><p>但是，如果我们改变一下这个结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UniformBufferObject</span> &#123;<br>    glm::vec2 foo;<br>    glm::mat4 model;<br>    glm::mat4 view;<br>    glm::mat4 proj;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> UniformBufferObject &#123;<br>    <span class="hljs-type">vec2</span> foo;<br>    <span class="hljs-type">mat4</span> model;<br>    <span class="hljs-type">mat4</span> view;<br>    <span class="hljs-type">mat4</span> proj;<br>&#125; ubo;<br></code></pre></td></tr></table></figure><p>我们会发现屏幕又黑了！这是因为<strong>vec2</strong>变量大小8字节，因此此时<i><font color="Orange">model</font></i>的偏移为8字节，并非要求的16字节的整数倍！</p><p>当然，有多种方法来解决这个问题，一种简单粗暴的方法是直接借助GLM为我们提供的宏<i><font color="Red">GLM_FORCE_DEFAULT_ALIGNED_GENTYPES</font></i>，这样GLM就会我们提供符合对齐要求的向量和矩阵对象；另一种方式是使用c++11为我们提供的<strong>alignas</strong>标志：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UniformBufferObject</span> &#123;<br>    glm::vec2 foo;<br>    <span class="hljs-built_in">alignas</span>(<span class="hljs-number">16</span>) glm::mat4 model;<br>    glm::mat4 view;<br>    glm::mat4 proj;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在大多数情况下这两种方法都可以工作地很好，但是实际上第一种方式仍然可能会有隐藏的问题。考虑下面这种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123;<br>    glm::vec2 v;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UniformBufferObject</span> &#123;<br>    Foo f1;<br>    Foo f2;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl">struct Foo &#123;<br>    <span class="hljs-type">vec2</span> v;<br>&#125;;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> UniformBufferObject &#123;<br>    Foo f1;<br>    Foo f2;<br>&#125; ubo;<br></code></pre></td></tr></table></figure><p>这种情况下<i><font color="Orange">UniformBufferObject</font></i>结构体中<i><font color="Orange">f2</font></i>的偏移会是8，但是规范要求该结构体的对齐必须上调至16的倍数，这样还是会引发错误的结果！因此，我们还是推荐使用第二种方法，不管怎样总是显式地指定对齐总是十分稳妥的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UniformBufferObject</span> &#123;<br>    <span class="hljs-built_in">alignas</span>(<span class="hljs-number">16</span>) glm::mat4 model;<br>    <span class="hljs-built_in">alignas</span>(<span class="hljs-number">16</span>) glm::mat4 view;<br>    <span class="hljs-built_in">alignas</span>(<span class="hljs-number">16</span>) glm::mat4 proj;<br>&#125;;<br></code></pre></td></tr></table></figure><p>终于大功告成！我们成功地显示出了第一个立体的图像！接下来的几章我们将开启一个新的主题：纹理映射。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/30/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%92%8C%E7%BB%9F%E4%B8%80%E7%BC%93%E5%86%B2/">上一篇：描述符布局和统一缓冲</a></p><p>--<a href="https://zpc-dsg.github.io/2024/12/12/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F/">下一篇：图像</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>描述符布局和统一缓冲</title>
    <link href="/2024/11/30/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%92%8C%E7%BB%9F%E4%B8%80%E7%BC%93%E5%86%B2/"/>
    <url>/2024/11/30/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%92%8C%E7%BB%9F%E4%B8%80%E7%BC%93%E5%86%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>当我们开始考虑更加复杂的程序功能时，比如说显示一个3D图像，我们不可避免地要在着色器中使用一些由程序传递的不断变动（甚至每一帧都可能在变动，比如MVP矩阵）的全局变量，这些变量当然不方便作为顶点缓冲的一部分传递给着色器，因为顶点缓冲的数据被设置为渲染管线的一部分，它在程序运行过程中是几乎不变动的。于是，我们需要一种新方式来传递这样一些不断变动的数据，这就是描述符。</p><p>描述符是一种帮助着色器获取并使用缓冲区、图像等数据的结构，一般而言使用描述符分为三步：</p><ul><li>在渲染管线构建过程中指定描述符布局</li><li>从描述符池中分配描述符集</li><li>在渲染的时候绑定描述符集到着色器</li></ul><p>描述符布局用于指定管线使用的资源类型有关的信息，就像渲染通道用于指定渲染管线使用的附件类型一样；同样地，描述符集用于指定实际渲染中会使用的资源（缓冲区或图像），一如帧缓冲用于指定实际绑定作为渲染附件的图像。</p><p>Vulkan包含许多种描述符，本节介绍其中的一种——<strong>统一缓冲（UBO）</strong>。本节以及下一节将开始迈向3D的世界，我们将实现一个旋转的三角形，本节内容主要分三部分：</p><ul><li>填写描述符布局以指定所用资源类型</li><li>定义实际所用的资源，即储存着色器全局变量的统一缓冲</li><li>改写着色器代码使用程序传递的缓冲数据</li></ul><p>下一节将着重于构建作为描述符布局和统一缓冲资源之间桥梁的描述符集。</p><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Uniform_buffers/Descriptor_layout_and_buffer">Descriptorlayout and buffer</a>章节。</p><hr><h2 id="填写描述符布局">填写描述符布局</h2><p>为了构建好所有管线需要的描述符布局，我们创建一个<i><font color="Green">voidcreateDescriptorSetLayout()</font></i>函数并在<i><font color="Green">initVulkan</font></i>中将其置于<i><font color="Green">createGraphicsPipeline</font></i>之前，因为我们在创建管线的时候需要使用到这些布局（通过<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkGraphicsPipelineCreateInfo.html"><code>VkGraphicsPipelineCreateInfo</code></a>的<i><font color="Orange">VkPipelineLayoutlayout</font></i>成员指定，参考<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/">渲染管线</a>章节）。</p><p>为了在渲染管线中指定描述符布局，我们需要填写相应的信息结构体<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayoutCreateInfo.html"><code>VkPipelineLayoutCreateInfo</code></a>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineLayoutCreateInfo</span> &#123;</span><br>    VkStructureType                 sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                     pNext;<br>    VkPipelineLayoutCreateFlags     flags;<br>    <span class="hljs-type">uint32_t</span>                        setLayoutCount;<br>    <span class="hljs-type">const</span> VkDescriptorSetLayout*    pSetLayouts;<br>    <span class="hljs-type">uint32_t</span>                        pushConstantRangeCount;<br>    <span class="hljs-type">const</span> VkPushConstantRange*      pPushConstantRanges;<br>&#125; VkPipelineLayoutCreateInfo;<br></code></pre></td></tr></table></figure><p>这个结构体我们曾在<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/">固定管线</a>章节中简单介绍过。由于目前我们只使用描述符，所以和<strong>pushconstant</strong>有关的成员无需填写。</p><p><i><font color="Orange">flags</font></i>可能的取值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_graphics_pipeline_library</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkPipelineLayoutCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_EXT_graphics_pipeline_library</span><br>    VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT = <span class="hljs-number">0x00000002</span>,<br>&#125; VkPipelineLayoutCreateFlagBits;<br></code></pre></td></tr></table></figure><p><i><font color="Red">VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT</font></i>要求实现确保某个特定描述符集的属性或缺失不会影响管道布局的其他属性。这意味着：</p><ul><li><strong>独立性</strong>：每个描述符集的配置是独立的，互不影响。这对于在创建管道布局时非常重要，特别是在使用管道库（pipelinelibraries）进行链接时。</li><li><strong>灵活性</strong>：即使没有启用<i><font color="Red">VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT</font></i>标志，开发者仍然可以创建一个只使用总描述符集子集的管道。这增加了在不同上下文中重用和组合管道的灵活性。</li></ul><p>目前我们希望使用一个包含MVP矩阵数据的描述符以供着色器使用，于是我们需要在类内创建一个[<code>VkDescriptorSetLayout</code>][id]类型的成员<i><font color="Orange">descriptorSetLayout</font></i>来指定相应的描述符布局，并且在创建描述符布局的信息结构体中指定使用该描述符布局，填写描述符布局信息过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineLayoutCreateInfo pipelineLayoutInfo&#123;&#125;;<br>pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;<br>pipelineLayoutInfo.setLayoutCount = <span class="hljs-number">1</span>;<br>pipelineLayoutInfo.pSetLayouts = &amp;descriptorSetLayout;<br></code></pre></td></tr></table></figure><p>在渲染管线构造中我们就可以指定管线布局包含上述描述符布局（原来我们是将这一项设为空的），然后像<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/">固定管线</a>章节一样使用<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineLayout.html"><code>vkCreatePipelineLayout</code></a>构造管线布局就可以了。</p><p>现在我们来构造实际的描述符布局。</p><p>为了构建实际的描述符布局，我们同样需要填写相应的信息结构体<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutCreateInfo.html"><code>VkDescriptorSetLayoutCreateInfo</code></a>，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDescriptorSetLayoutCreateInfo</span> &#123;</span><br>    VkStructureType                        sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                            pNext;<br>    VkDescriptorSetLayoutCreateFlags       flags;<br>    <span class="hljs-type">uint32_t</span>                               bindingCount;<br>    <span class="hljs-type">const</span> VkDescriptorSetLayoutBinding*    pBindings;<br>&#125; VkDescriptorSetLayoutCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>较多，我们这里不做一一介绍，读者可以参考<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutCreateFlagBits.html">这个页面</a>。</p><p>可以看到<i><font color="Orange">pBindings</font></i>指向一个<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutBinding.html"><code>VkDescriptorSetLayoutBinding</code></a>对象，该类型同样是一个结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDescriptorSetLayoutBinding</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>              binding;<br>    VkDescriptorType      descriptorType;<br>    <span class="hljs-type">uint32_t</span>              descriptorCount;<br>    VkShaderStageFlags    stageFlags;<br>    <span class="hljs-type">const</span> VkSampler*      pImmutableSamplers;<br>&#125; VkDescriptorSetLayoutBinding;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">binding</font></i>指定该描述符的绑定点，它对应于着色器中使用该资源时指定的绑定点（我们在后文改写着色器的时候会看到）。</p><p><i><font color="Orange">descriptorType</font></i>指定描述符类型，我们需要使用的是统一缓冲类型的描述符，于是该变量应该指定为<i><font color="Red">VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</font></i>。</p><p><i><font color="Orange">descriptorCount</font></i>指定绑定到同一个绑定点的描述符个数，着色器将以数组的形式访问这些描述符（这在一些场景下是有用处的，比如说骨骼动画中，当我们希望传递给同一个对象的不同骨骼部分不同的变换矩阵时就需要用到多个描述符）。需要注意的是，如果描述符类型指定为<i><font color="Red">VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</font></i>，那么<i><font color="Orange">descriptorCount</font></i>用于指定内联统一块的字节数（内联统一块允许应用程序将小型的、常量的uniform数据直接嵌入到描述符集中，而不需要单独的缓冲区。这种方式可以提高性能，减少内存占用，并简化资源管理）。另外，如果<i><font color="Orange">descriptorCount</font></i>设置为0，则意味着这个绑定条目仍然存在于描述符集布局中，但它不对应任何实际的资源。它可以用于将来的扩展或占位符用途，但在当前的管线中，任何试图通过这个绑定访问资源的行为都是非法的。</p><p><i><font color="Orange">stageFlags</font></i>用于指定需要使用该描述符资源的着色器阶段，我们可以简单地使用<i><font color="Red">VK_SHADER_STAGE_ALL</font></i>来代指所有阶段。如果在该成员中没有指定某个阶段，那么那个阶段一定不能访问该描述符资源。在我们的应用程序中，我们希望在顶点着色器中使用MVP矩阵对位置进行变换，因此该成员应该设置为<i><font color="Red">VK_SHADER_STAGE_VERTEX_BIT</font></i>。</p><p>最后一个成员<i><font color="Orange">pImmutableSamplers</font></i>与图像采样有关，这里暂不介绍，我们会在后续有关纹理的章节中详细介绍这一部分。</p><p>综上，我们应该如下填写信息结构体并创建<i><font color="Orange">descriptorSetLayout</font></i>成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkDescriptorSetLayoutBinding uboLayoutBinding&#123;&#125;;<br>uboLayoutBinding.binding = <span class="hljs-number">0</span>;<br>uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;<br>uboLayoutBinding.descriptorCount = <span class="hljs-number">1</span>;<br>uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;<br>uboLayoutBinding.pImmutableSamplers = <span class="hljs-literal">nullptr</span>; <br><br>VkDescriptorSetLayoutCreateInfo layoutInfo&#123;&#125;;<br>layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;<br>layoutInfo.bindingCount = <span class="hljs-number">1</span>;<br>layoutInfo.pBindings = &amp;uboLayoutBinding;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateDescriptorSetLayout</span>(device, &amp;layoutInfo, <span class="hljs-literal">nullptr</span>, &amp;descriptorSetLayout) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create descriptor set layout!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="构建统一缓冲">构建统一缓冲</h2><p>接下来我们需要构建描述符引用的实际存储数据的缓冲对象。首先创建一个结构体来指定该缓冲中应该包含的数据信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UniformBufferObject</span> &#123;<br>    glm::mat4 model;<br>    glm::mat4 view;<br>    glm::mat4 proj;<br>&#125;;<br></code></pre></td></tr></table></figure><p>关于MVP矩阵以及坐标变换，我们假设读者已经十分熟悉，这里不做过多介绍，不熟悉的读者可以参考图形学入门圣经<a href="https://www.bilibili.com/video/BV1X7411F744/">games101课程</a>。</p><p>然后我们来创建保存MVP矩阵数据的统一缓冲。首先在类内添加几个成员<i><font color="Orange">std::vector<VkBuffer>uniformBuffers; std::vector<VkDeviceMemory> uniformBuffersMemory;std::vector&lt;void*&gt;uniformBuffersMapped;</VkDeviceMemory></VkBuffer></font></i>，然后创建一个<font color="Green">voidcreateUniformBuffers()</font>成员函数来创建统一缓冲。创建统一缓冲的逻辑和之前创建顶点缓冲、索引缓冲基本一致，只不过这里我们不再需要借助临时缓冲了，因为我们每一帧都需要向该缓冲传递新的数据，使用临时缓冲使得传输过程复杂化，可能反而会影响数据更新的效率。该函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createUniformBuffers</span><span class="hljs-params">()</span> </span>&#123;<br>    VkDeviceSize bufferSize = <span class="hljs-built_in">sizeof</span>(UniformBufferObject);<br><br>    uniformBuffers.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br>    uniformBuffersMemory.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br>    uniformBuffersMapped.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123;<br>        <span class="hljs-built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, uniformBuffers[i], uniformBuffersMemory[i]);<br><br>        <span class="hljs-built_in">vkMapMemory</span>(device, uniformBuffersMemory[i], <span class="hljs-number">0</span>, bufferSize, <span class="hljs-number">0</span>, &amp;uniformBuffersMapped[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码有两点需要注意：一是我们对每一帧使用了一个单独的统一缓冲，而顶点和索引数据却没有这么做，因为顶点和索引数据是始终不变的，我们不会在渲染过程中写入该缓冲新的数据，但是统一缓冲中的MVP数据每帧都可能会变动，我们每帧都需要更新该缓冲的数据，因此为了避免某一帧在更新统一缓冲时上一帧还在读取该缓冲数据内容，我们给每一帧分配一个单独的统一缓冲；二是代码并没有在映射完统一缓冲后解映射该缓冲，这种做法叫做<strong>持续映射（persistentmapping）</strong>，这样我们就不需要在每次需要更新这个缓冲的时候都重新映射一遍，我们可以在每帧更新时直接复制数据到该缓冲中。</p><p>在创建好统一缓冲后，我们顺便把每帧更新统一缓冲的逻辑给写好。创建一个<i><font color="Green">voidupdateUniformBuffer(uint32_tcurrentImage)</font></i>函数来完成这项工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateUniformBuffer</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> currentImage)</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> startTime = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br><br>    <span class="hljs-keyword">auto</span> currentTime = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-type">float</span> time = std::chrono::<span class="hljs-built_in">duration</span>&lt;<span class="hljs-type">float</span>, std::chrono::seconds::period&gt;(currentTime - startTime).<span class="hljs-built_in">count</span>();<br>    <br>    UniformBufferObject ubo&#123;&#125;;<br>ubo.model = glm::<span class="hljs-built_in">rotate</span>(glm::<span class="hljs-built_in">mat4</span>(<span class="hljs-number">1.0f</span>), time * glm::<span class="hljs-built_in">radians</span>(<span class="hljs-number">90.0f</span>), glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>));<br>    ubo.view = glm::<span class="hljs-built_in">lookAt</span>(glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">2.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">2.0f</span>), glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>), glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>));<br>    ubo.proj = glm::<span class="hljs-built_in">perspective</span>(glm::<span class="hljs-built_in">radians</span>(<span class="hljs-number">45.0f</span>), swapChainExtent.width / (<span class="hljs-type">float</span>) swapChainExtent.height, <span class="hljs-number">0.1f</span>, <span class="hljs-number">10.0f</span>);<br>    ubo.proj[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] *= <span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-built_in">memcpy</span>(uniformBuffersMapped[currentImage], &amp;ubo, <span class="hljs-built_in">sizeof</span>(ubo));<br>&#125;<br></code></pre></td></tr></table></figure><p>关于计时器<a href="https://en.cppreference.com/w/cpp/header/chrono"><code>std::chrono</code></a>以及更多的c++计时系统，读者可以参考<a href="https://en.cppreference.com/w/cpp/chrono">这个页面</a>。关于代码中使用glm库构建MVP矩阵的部分，读者可以在<a href="https://learnopengl.com/Getting-started/Coordinate-Systems">这篇文章</a>中找到详细的说明。</p><p>不过这里需要注意的是，我们这里对投影矩阵的y坐标取反，这是因为glm是为OpenGL设计的，OpenGL的坐标系统在竖直方向和Vulkan是相反的，为了保证渲染的图像不会颠倒我们必须将y坐标取反。</p><hr><h2 id="改写着色器">改写着色器</h2><p>为了在着色器中使用该统一缓冲区数据，我们需要改写原来的顶点着色器代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> UniformBufferObject &#123;<br>    <span class="hljs-type">mat4</span> model;<br>    <span class="hljs-type">mat4</span> view;<br>    <span class="hljs-type">mat4</span> proj;<br>&#125; ubo;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inPosition;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inColor;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fragColor;<br><br><span class="hljs-type">void</span> main() &#123;<br>    <span class="hljs-built_in">gl_Position</span> = ubo.proj * ubo.view * ubo.model * <span class="hljs-type">vec4</span>(inPosition, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fragColor = inColor;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们指定uniform变量的绑定点和之前在<a href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutBinding.html"><code>VkDescriptorSetLayoutBinding</code></a>中设定的绑定点一致。片段着色器不需要改变。最后不要忘记重新编译着色器代码以更新SPIR-V文件。</p><p>大功告成！</p><p>下一章我们将创建真正用于绑定的描述符集对象。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/">上一篇：索引缓冲</a></p><p>--<a href="https://zpc-dsg.github.io/2024/12/06/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B1%A0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86/">下一篇：描述符池和描述符集</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>索引缓冲</title>
    <link href="/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/"/>
    <url>/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>实际应用中我们绘制的3D图形的面片之间会共享很多顶点，如果每个面片的每个顶点都需要存储一份数据的话将浪费过多的内存空间。为了减少重复量，我们可以使用索引缓冲。索引缓冲本质上就是一列指向顶点缓冲的指针，这样我们就可以在顶点缓冲中存储所有互不相同的顶点，并且在索引缓冲中指定每个面片中顶点对应在顶点缓冲中的索引，从而大大减少了重复存储耗费的空间。</p><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Vertex_buffers/Index_buffer">Indexbuffer</a>章节。</p><hr><h2 id="创建并使用索引缓冲">创建并使用索引缓冲</h2><p>作为索引缓冲的使用示例，我们将绘制一个长方形到屏幕上。</p><p>为了使用索引缓冲，首先我们需要定义好顶点数据对应的索引数据。顶点数据也需要修改一下，剔除掉重复的顶点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;Vertex&gt; vertices = &#123;<br>    &#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>添加上索引构成长方形的两个三角形顶点（右上和左下）对应的索引数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">uint16_t</span>&gt; indices = &#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>现在，索引数据已经准备完毕了，接下来我们创建一个<i><font color="Green">voidcreateIndexBuffer(()</font></i>函数来创建需要的索引缓冲，同时在类内添加两个成员<i><font color="Orange">indexBuffer</font></i>和<i><font color="Orange">indexBufferMemory</font></i>来分别存储索引缓冲及其内存。创建索引缓冲的过程几乎和创建顶点缓冲的过程一致，也是先通过一个临时缓冲接受索引数据，然后将临时缓冲中的数据复制到高性能索引缓冲中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createIndexBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>    VkDeviceSize bufferSize = <span class="hljs-built_in">sizeof</span>(indices[<span class="hljs-number">0</span>]) * indices.<span class="hljs-built_in">size</span>();<br><br>    VkBuffer stagingBuffer;<br>    VkDeviceMemory stagingBufferMemory;<br>    <span class="hljs-built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);<br><br>    <span class="hljs-type">void</span>* data;<br>    <span class="hljs-built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="hljs-number">0</span>, bufferSize, <span class="hljs-number">0</span>, &amp;data);<br>    <span class="hljs-built_in">memcpy</span>(data, indices.<span class="hljs-built_in">data</span>(), (<span class="hljs-type">size_t</span>) bufferSize);<br>    <span class="hljs-built_in">vkUnmapMemory</span>(device, stagingBufferMemory);<br><br>    <span class="hljs-built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, indexBuffer, indexBufferMemory);<br><br>    <span class="hljs-built_in">copyBuffer</span>(stagingBuffer, indexBuffer, bufferSize);<br><br>    <span class="hljs-built_in">vkDestroyBuffer</span>(device, stagingBuffer, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">vkFreeMemory</span>(device, stagingBufferMemory, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里索引缓冲的使用方式应该设置为<i><font color="Red">VK_BUFFER_USAGE_INDEX_BUFFER_BIT</font></i>而不再是<i><font color="Red">VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</font></i>。</p><p>这样，我们就创建好了绘制长方形所需的索引缓冲，接下来只需在录制绘制命令之前将索引缓冲同顶点缓冲一起绑定到着色器绑定点上即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdBindVertexBuffers</span>(commandBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, vertexBuffers, offsets);<br><span class="hljs-built_in">vkCmdBindIndexBuffer</span>(commandBuffer, indexBuffer, <span class="hljs-number">0</span>, VK_INDEX_TYPE_UINT16);<br><br><span class="hljs-built_in">vkCmdDrawIndexed</span>(commandBuffer, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(indices.<span class="hljs-built_in">size</span>()), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindIndexBuffer.html"><code>vkCmdBindIndexBuffer</code></a>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdBindIndexBuffer</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    VkBuffer                                    buffer,</span><br><span class="hljs-params">    VkDeviceSize                                offset,<span class="hljs-comment">//读取索引缓冲的起点偏移字节数</span></span><br><span class="hljs-params">    VkIndexType                                 indexType)</span>;<span class="hljs-comment">//索引缓冲数据格式</span><br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexed.html"><code>vkCmdDrawIndexed</code></a>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdDrawIndexed</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    indexCount,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    instanceCount,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    firstIndex,</span><br><span class="hljs-params">    <span class="hljs-type">int32_t</span>                                     vertexOffset,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    firstInstance)</span>;<br></code></pre></td></tr></table></figure><p>这里我们并不使用实例渲染，因此<i><font color="Orange">instanceCount</font></i>设置为1，<i><font color="Orange">firstInstance</font></i>设置为0即可。另外这里需要注意的是<i><font color="Orange">firstIndex</font></i>指的是绘制索引起始处的偏移，这个偏移是按索引值而不是像<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexed.html"><code>vkCmdDrawIndexed</code></a>函数中<i><font color="Orange">offset</font></i>那样指定的偏移字节数。</p><p>其他操作不需要改变，这样我们就渲染出了一个长方形！</p><figure><img src="/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/rectangle.png" alt="索引缓冲绘制长方形"><figcaption aria-hidden="true">索引缓冲绘制长方形</figcaption></figure><p>大功告成！</p><p>最后我们需要提一嘴的是，在实际应用中我们不但提倡像<a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/">创建顶点缓冲</a>章节中所说的那样尽量将多个内存分配操作合并为一个，更进一步地，驱动开发人员还建议我们将多个缓冲区合并为一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBuffer.html"><code>VkBuffer</code></a>对象，然后在<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCmdBindVertexBuffers.html"><code>vkCmdBindVertexBuffers</code></a>等调用中通过偏移值来获取相应的缓冲，这样可以使我们的缓冲数据排列更加紧密从而使得缓存命中率提高，不失为一个提高应用程序效率的方法。另外，我们甚至可以在不同时发生的渲染等操作中重用同一块内存，只不过在不同的操作中赋予内存不同的数据，这叫做<strong>aliasing</strong>，也是提高程序效率的方法之一。</p><p>接下来我们将开启一个新的篇章：统一缓冲区。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/">上一篇：临时缓冲区</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/30/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%92%8C%E7%BB%9F%E4%B8%80%E7%BC%93%E5%86%B2/">下一篇：描述符布局和统一缓冲</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>临时缓冲区</title>
    <link href="/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/"/>
    <url>/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p><a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/">上一章</a>中，我们将GPU中的顶点缓冲内存映射到了一个CPU可见且一致的内存中，然后将顶点数据复制到这个映射后内存中。这么做当然可行，但是一般来讲可映射GPU内存对于GPU操作而言都不是最高性能的，而高性能内存又不支持内存映射。因此，为了能够更高效地使用顶点缓冲，这节我们将使用一个临时缓冲区接受复制后的顶点数据，然后再将这份数据复制到高性能缓冲区中供GPU使用。完成这个过程主要分为两步：</p><ul><li>创建临时缓冲区接受顶点数据</li><li>将临时缓冲区数据复制到高性能缓冲区中</li></ul><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Vertex_buffers/Staging_buffer">Stagingbuffer</a>章节。</p><hr><h2 id="创建临时缓冲区">创建临时缓冲区</h2><p>现在我们需要首先创建一个临时缓冲区，然后创建所需的顶点缓冲区。既然我们现在需要创建多个缓冲区，那么可以将创建缓冲区所需的公共代码提取出来构成一个新函数<i><font color="Green">voidcreateBuffer(VkDeviceSize size, VkBufferUsageFlags usage,VkMemoryPropertyFlags properties, VkBuffer&amp; buffer,VkDeviceMemory&amp; bufferMemory)</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createBuffer</span><span class="hljs-params">(VkDeviceSize size, VkBufferUsageFlags usage, VkMemoryPropertyFlags properties, VkBuffer&amp; buffer, VkDeviceMemory&amp; bufferMemory)</span> </span>&#123;<br>    VkBufferCreateInfo bufferInfo&#123;&#125;;<br>    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;<br>    bufferInfo.size = size;<br>    bufferInfo.usage = usage;<br>    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateBuffer</span>(device, &amp;bufferInfo, <span class="hljs-literal">nullptr</span>, &amp;buffer) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create buffer!&quot;</span>);<br>    &#125;<br><br>    VkMemoryRequirements memRequirements;<br>    <span class="hljs-built_in">vkGetBufferMemoryRequirements</span>(device, buffer, &amp;memRequirements);<br><br>    VkMemoryAllocateInfo allocInfo&#123;&#125;;<br>    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;<br>    allocInfo.allocationSize = memRequirements.size;<br>    allocInfo.memoryTypeIndex = <span class="hljs-built_in">findMemoryType</span>(memRequirements.memoryTypeBits, properties);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkAllocateMemory</span>(device, &amp;allocInfo, <span class="hljs-literal">nullptr</span>, &amp;bufferMemory) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to allocate buffer memory!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">vkBindBufferMemory</span>(device, buffer, bufferMemory, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以在<i><font color="Green">createVertexBuffer</font></i>函数中使用该函数以简化代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createVertexBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>    VkDeviceSize bufferSize = <span class="hljs-built_in">sizeof</span>(vertices[<span class="hljs-number">0</span>]) * vertices.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, vertexBuffer, vertexBufferMemory);<br><br>    <span class="hljs-type">void</span>* data;<br>    <span class="hljs-built_in">vkMapMemory</span>(device, vertexBufferMemory, <span class="hljs-number">0</span>, bufferSize, <span class="hljs-number">0</span>, &amp;data);<br>        <span class="hljs-built_in">memcpy</span>(data, vertices.<span class="hljs-built_in">data</span>(), (<span class="hljs-type">size_t</span>) bufferSize);<br>    <span class="hljs-built_in">vkUnmapMemory</span>(device, vertexBufferMemory);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们要在<i><font color="Green">createVertexBuffer</font></i>函数中添加创建临时缓冲区的代码，新的<i><font color="Green">createVertexBuffer</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createVertexBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>    VkDeviceSize bufferSize = <span class="hljs-built_in">sizeof</span>(vertices[<span class="hljs-number">0</span>]) * vertices.<span class="hljs-built_in">size</span>();<br><br>    VkBuffer stagingBuffer;<br>    VkDeviceMemory stagingBufferMemory;<br>    <span class="hljs-built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);<br><br>    <span class="hljs-type">void</span>* data;<br>    <span class="hljs-built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="hljs-number">0</span>, bufferSize, <span class="hljs-number">0</span>, &amp;data);<br>        <span class="hljs-built_in">memcpy</span>(data, vertices.<span class="hljs-built_in">data</span>(), (<span class="hljs-type">size_t</span>) bufferSize);<br>    <span class="hljs-built_in">vkUnmapMemory</span>(device, stagingBufferMemory);<br><br>    <span class="hljs-built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, vertexBuffer, vertexBufferMemory);<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>首先注意到我们并没有将临时缓冲区保存为类的一个成员，因为该缓冲区只负责暂时的数据交接工作，完成工作后就会被释放，我们并不需要保存它的句柄。</p><p>另外，我们设置临时缓冲区的使用方式为<i><font color="Red">VK_BUFFER_USAGE_TRANSFER_SRC_BIT</font></i>，这代表该缓冲区可以用作数据复制源使用。同样，我们也为顶点缓冲添加了一个使用方式<i><font color="Red">VK_BUFFER_USAGE_TRANSFER_DST_BIT</font></i>，也就是说它可以用作接受数据复制的缓冲。</p><p>这样我们就创建好了临时缓冲区并且将顶点数据复制到了该缓冲区内，接下来就要将这部分数据复制到高性能顶点缓冲中去了。</p><hr><h2 id="复制数据到高性能缓冲区">复制数据到高性能缓冲区</h2><p>复制缓冲区内容实际上也是一个需要队列来执行的命令，它需要的是一个能够执行缓冲复制的队列（<strong>Transferqueue</strong>）。不过一般来讲图形队列和计算队列都支持缓冲你复制命令，因此接下来我们将直接使用已有的图形队列执行缓冲复制工作。不过这里我们也还是大致梳理一下如果想要使用一个单独的转移队列（<strong>Transferqueue</strong>）来执行复制工作的话需要哪些步骤：</p><ul><li>在<i><font color="Green">findQueueFamilies</font></i>函数中添加寻找具有<i><font color="Red">VK_QUEUE_TRANSFER_BIT</font></i>标志位的队列家族的代码，并且将相应的队列家族索引保存在<i><font color="Orange">QueueFamilyIndices</font></i>中。</li><li>在<i><font color="Green">createLogicalDevice</font></i>中为逻辑设备添加上述寻找到的转移队列。</li><li>创建一个单独的命令池用于录制提交到该转移队列的命令</li><li>将顶点缓冲的<i><font color="Orange">sharingMode</font></i>改为<i><font color="Red">VK_SHARING_MODE_CONCURRENT</font></i>，并且指定图形队列和转移队列都可以使用该顶点缓冲（或者如教程评论区所说使用内存屏障，这个主题会在后续纹理有关章节中涉及到）。</li><li>将所有复制转移命令提交到该转移队列执行。</li></ul><p>回到本教程的方案上，我们希望将复制命令提交给图形队列执行，不过在此之前我们当然需要先录制好复制命令。创建一个成员函数<i><font color="Green">voidcopyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSizesize)</font></i>来执行复制命令的录制工作。</p><p>首先，我们需要从命令池中分配出供录制命令使用的命令缓冲：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copyBuffer</span><span class="hljs-params">(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size)</span> </span>&#123;<br>    VkCommandBufferAllocateInfo allocInfo&#123;&#125;;<br>    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;<br>    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;<br>    allocInfo.commandPool = commandPool;<br>    allocInfo.commandBufferCount = <span class="hljs-number">1</span>;<br><br>    VkCommandBuffer commandBuffer;<br>    <span class="hljs-built_in">vkAllocateCommandBuffers</span>(device, &amp;allocInfo, &amp;commandBuffer);<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们也不需要将该命令缓冲保存为类的一个成员，因为在复制完数据后这个命令缓冲就可以释放掉了。</p><p>接下来我们就可以开始录制命令了。首先还是填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBufferBeginInfo.html"><code>VkCommandBufferBeginInfo</code></a>，这部分内容在<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/">命令缓冲</a>章节中有详细讲解，这里不过多赘述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkCommandBufferBeginInfo beginInfo&#123;&#125;;<br>beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;<br>beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;<br><br><span class="hljs-built_in">vkBeginCommandBuffer</span>(commandBuffer, &amp;beginInfo);<br></code></pre></td></tr></table></figure><p>我们只需要录制复制缓冲区的命令，这是通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBuffer.html"><code>vkCmdCopyBuffer</code></a>实现的，该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdCopyBuffer</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    VkBuffer                                    srcBuffer,</span><br><span class="hljs-params">    VkBuffer                                    dstBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    regionCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkBufferCopy*                         pRegions)</span>;<br></code></pre></td></tr></table></figure><p>所有参数都是易于理解的。这里注意，根据函数原型，我们要复制缓冲，还需要填写复制区域<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferCopy.html"><code>VkBufferCopy</code></a>的信息，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkBufferCopy</span> &#123;</span><br>    VkDeviceSize    srcOffset;<br>    VkDeviceSize    dstOffset;<br>    VkDeviceSize    size;<br>&#125; VkBufferCopy;<br></code></pre></td></tr></table></figure><p>所有成员同样是易于理解的，于是我们录制部分代码代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkBufferCopy copyRegion&#123;&#125;;<br>copyRegion.srcOffset = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>copyRegion.dstOffset = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>copyRegion.size = size;<br><span class="hljs-built_in">vkCmdCopyBuffer</span>(commandBuffer, srcBuffer, dstBuffer, <span class="hljs-number">1</span>, &amp;copyRegion);<br><br><span class="hljs-built_in">vkEndCommandBuffer</span>(commandBuffer);<br></code></pre></td></tr></table></figure><p>在录制完命令后，我们将其提交至图形队列执行，提交命令在<a href="https://zpc-dsg.github.io/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/">渲染和显示</a>章节中已经详细介绍过了，我们这里同样不再赘述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSubmitInfo submitInfo&#123;&#125;;<br>submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;<br>submitInfo.commandBufferCount = <span class="hljs-number">1</span>;<br>submitInfo.pCommandBuffers = &amp;commandBuffer;<br><br><span class="hljs-built_in">vkQueueSubmit</span>(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, VK_NULL_HANDLE);<br><span class="hljs-built_in">vkQueueWaitIdle</span>(graphicsQueue);<br></code></pre></td></tr></table></figure><p>注意这里我们使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueueWaitIdle.html"><code>vkQueueWaitIdle</code></a>来等待复制操作执行完毕，以免出现还未完成数据复制就开始使用顶点缓冲或者销毁临时缓冲的情况。当然，这里我们并没有指定在CPU端等待的栅栏，读者可以想象，我们也可以在提交命令时附带一个栅栏来等待复制操作执行完毕，然后在CPU端等待该栅栏被点亮，这是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueueWaitIdle.html"><code>vkQueueWaitIdle</code></a>的一种替代方案。</p><p>最后，我们需要释放掉临时分配的命令缓冲：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkFreeCommandBuffers</span>(device, commandPool, <span class="hljs-number">1</span>, &amp;commandBuffer);<br></code></pre></td></tr></table></figure><p>现在，我们可以在<i><font color="Green">createVertexBuffer</font></i>中使用上面创建好的<i><font color="Green">copyBuffer</font></i>函数来完成从临时缓冲区复制顶点数据到顶点缓冲区的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createVertexBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <br><span class="hljs-built_in">copyBuffer</span>(stagingBuffer, vertexBuffer, bufferSize);<br><br>    <span class="hljs-built_in">vkDestroyBuffer</span>(device, stagingBuffer, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">vkFreeMemory</span>(device, stagingBufferMemory, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然不要忘记销毁临时缓冲并释放为之分配的内存。</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/">上一篇：创建顶点缓冲</a></p><p>--<a href>下一篇：索引缓冲</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>创建顶点缓冲</title>
    <link href="/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/"/>
    <url>/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在<a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0/">上一章</a>创建好实际的顶点数据以及顶点描述之后，现在我们需要创建用于读取、写入和存储这些数据以供GPU使用的部件，那就是顶点缓冲。创建和使用顶点缓冲可以分为四步：</p><ul><li>创建缓冲对象</li><li>分配缓冲内存</li><li>填充顶点数据</li><li>绑定顶点缓冲</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Vertex_buffers/Vertex_buffer_creation">Vertexbuffer creation</a>章节。</p><hr><h2 id="创建缓冲对象">创建缓冲对象</h2><p>首先，在<i><font color="Green">initVulkan</font></i>函数中的<i><font color="Green">createCommandBuffers</font></i>函数之前添加一个成员函数<i><font color="Green">voidcreateVertexBuffer()</font></i>用来完成顶点缓冲对象的创建，并且在类内新增一个成员<i><font color="Orange">VkBuffervertexBuffer</font></i>来保存创建的顶点缓冲对象。</p><p>要创建顶点缓冲，我们当然需要首先填写创建结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferCreateInfo.html"><code>VkBufferCreateInfo</code></a>有关信息，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkBufferCreateInfo</span> &#123;</span><br>    VkStructureType        sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*            pNext;<br>    VkBufferCreateFlags    flags;<br>    VkDeviceSize           size;<br>    VkBufferUsageFlags     usage;<br>    VkSharingMode          sharingMode;<br>    <span class="hljs-type">uint32_t</span>               queueFamilyIndexCount;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*        pQueueFamilyIndices;<br>&#125; VkBufferCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>涉及到稀疏内存等特殊的缓冲参数，这里我们不会使用到，不做过多介绍。</p><p><i><font color="Orange">usage</font></i>代表该缓冲区的使用方式，它的可能取值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkBufferUsageFlagBits</span> &#123;</span><br>    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = <span class="hljs-number">0x00000001</span>,<br>    VK_BUFFER_USAGE_TRANSFER_DST_BIT = <span class="hljs-number">0x00000002</span>,<br>    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = <span class="hljs-number">0x00000004</span>,<br>    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = <span class="hljs-number">0x00000008</span>,<br>    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = <span class="hljs-number">0x00000010</span>,<br>    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = <span class="hljs-number">0x00000020</span>,<br>    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = <span class="hljs-number">0x00000040</span>,<br>    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = <span class="hljs-number">0x00000080</span>,<br>    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = <span class="hljs-number">0x00000100</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = <span class="hljs-number">0x00020000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_decode_queue</span><br>    VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR = <span class="hljs-number">0x00002000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_decode_queue</span><br>    VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR = <span class="hljs-number">0x00004000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_transform_feedback</span><br>    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = <span class="hljs-number">0x00000800</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_transform_feedback</span><br>    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = <span class="hljs-number">0x00001000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_conditional_rendering</span><br>    VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = <span class="hljs-number">0x00000200</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> VK_ENABLE_BETA_EXTENSIONS</span><br>  <span class="hljs-comment">// Provided by VK_AMDX_shader_enqueue</span><br>    VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX = <span class="hljs-number">0x02000000</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br>    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = <span class="hljs-number">0x00080000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br>    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = <span class="hljs-number">0x00100000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_ray_tracing_pipeline</span><br>    VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR = <span class="hljs-number">0x00000400</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_encode_queue</span><br>    VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR = <span class="hljs-number">0x00008000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_encode_queue</span><br>    VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = <span class="hljs-number">0x00010000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_descriptor_buffer</span><br>    VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = <span class="hljs-number">0x00200000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_descriptor_buffer</span><br>    VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = <span class="hljs-number">0x00400000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_descriptor_buffer</span><br>    VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = <span class="hljs-number">0x04000000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_opacity_micromap</span><br>    VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = <span class="hljs-number">0x00800000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_opacity_micromap</span><br>    VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT = <span class="hljs-number">0x01000000</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_ray_tracing</span><br>    VK_BUFFER_USAGE_RAY_TRACING_BIT_NV = VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR,<br>  <span class="hljs-comment">// Provided by VK_EXT_buffer_device_address</span><br>    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,<br>  <span class="hljs-comment">// Provided by VK_KHR_buffer_device_address</span><br>    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,<br>&#125; VkBufferUsageFlagBits;<br></code></pre></td></tr></table></figure><p>可能的取值较多，我们不做一一介绍，这里我们希望将该缓冲区用作顶点缓冲，在之后的章节中我们会涉及到一些其它的缓冲类型。</p><p><i><font color="Orange">sharingMode</font></i>代表该缓冲的共享模式，缓冲区和交换链的图像一样可以被多个队列家族共享，我们这里只有一个队列家族需要使用该缓冲区，即图像队列家族，所以该成员设置为<i><font color="Red">VK_SHARING_MODE_EXCLUSIVE</font></i>即可。</p><p>最后的两个成员用于指定共享该缓冲的队列家族的数量及各自对应的索引，如果共享模式设置为<i><font color="Red">VK_SHARING_MODE_EXCLUSIVE</font></i>，那么这两个成员无需显式指定。</p><p>因此，我们的<i><font color="Green">createVertexBuffer</font></i>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createVertexBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>    VkBufferCreateInfo bufferInfo&#123;&#125;;<br>    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;<br>    bufferInfo.size = <span class="hljs-built_in">sizeof</span>(vertices[<span class="hljs-number">0</span>]) * vertices.<span class="hljs-built_in">size</span>();<br>    bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;<br>    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateBuffer</span>(device, &amp;bufferInfo, <span class="hljs-literal">nullptr</span>, &amp;vertexBuffer) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create vertex buffer!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="分配缓冲内存">分配缓冲内存</h2><p>与我们之前创建的那些Vulkan对象不同，缓冲对象在创建后Vulkan并不会为其自动分配内存，我们需要手动为缓冲对象分配内存。</p><p>在分配内存之前，我们首先需要查询创建的顶点缓冲对象对分配的内存有什么要求以及我们使用的物理设备可以分配的内存种类中是否有满足这些要求的种类，在查询有内存种类满足要求后我们才能真正为缓冲对象分配内存，下面我们依次进行这三步。</p><h4 id="查询内存要求">查询内存要求</h4><p>查询内存要求可以简单地通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetBufferMemoryRequirements.html"><code>vkGetBufferMemoryRequirements</code></a>函数来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkMemoryRequirements memRequirements;<br><span class="hljs-built_in">vkGetBufferMemoryRequirements</span>(device, vertexBuffer, &amp;memRequirements);<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkMemoryRequirements.html"><code>VkMemoryRequirements</code></a>结构体包含了缓冲对象对内存的要求明细，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkMemoryRequirements</span> &#123;</span><br>    VkDeviceSize    size;<br>    VkDeviceSize    alignment;<br>    <span class="hljs-type">uint32_t</span>        memoryTypeBits;<br>&#125; VkMemoryRequirements;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">size</font></i>描述需要分配内存的大小，这个大小有可能和内存中真正存储的缓冲数据大小不一致（因为存储在这块内存中的数据可能会有偏移）。</p><p><i><font color="Orange">alignment</font></i>代表缓冲数据的起始位置相对于缓冲内存的起始位置的偏移，这个数值取决于缓冲区的使用方式（<i><font color="Orange">usage</font></i>成员）以及标志位（<i><font color="Orange">flags</font></i>成员）。</p><p><i><font color="Orange">memoryTypeBits</font></i>代表适用于该缓冲的内存类型，它是一些内存类型的位组合，具体来说就是如果查询物理设备内存属性（使用<a href="https://vkdoc.net/man/vkGetPhysicalDeviceMemoryProperties"><code>VkGetPhysicalDeviceMemoryProperties</code></a>，也就是接下来的第二步）得到的结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryProperties.html"><code>VkPhysicalDeviceMemoryProperties</code></a>中的内存类型i （用位<strong>1&lt;&lt;i</strong>表示）支持用于该缓冲对象时，位 i就会被置位。</p><h4 id="寻找满足要求的内存类型">寻找满足要求的内存类型</h4><p>接下来我们需要寻找物理设备支持的内存类型中是否有满足顶点缓冲需求的类型。我们创建一个<i><font color="Green">uint32_tfindMemoryType(uint32_t typeFilter, VkMemoryPropertyFlagsproperties)</font></i>函数来完成有关工作。</p><p>首先，我们当然需要查询物理设备所支持的所有内存属性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPhysicalDeviceMemoryProperties memProperties;<br><span class="hljs-built_in">vkGetPhysicalDeviceMemoryProperties</span>(physicalDevice, &amp;memProperties);<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryProperties.html"><code>VkPhysicalDeviceMemoryProperties</code></a>结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VkPhysicalDeviceMemoryProperties</span> &#123;<br>    <span class="hljs-type">uint32_t</span>        memoryTypeCount;<br>    VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];<br>    <span class="hljs-type">uint32_t</span>        memoryHeapCount;<br>    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];<br>&#125; VkPhysicalDeviceMemoryProperties;<br></code></pre></td></tr></table></figure><p>该结构体主要包含两方面内存信息：内存类型和内存所属堆。内存堆指的是一些内存资源，如专用的显存（VRAM）和当显存不足时用于交换的RAM空间，不同种类的内存可能从不同种类的内存堆中分配。这里我们只考虑内存类型。</p><p>接下来我们从这些支持类型中寻找满足缓冲区需求的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; memProperties.memoryTypeCount; i++) &#123;<br>    <span class="hljs-keyword">if</span> ((typeFilter &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) &amp;&amp; (memProperties.memoryTypes[i].propertyFlags &amp; properties) == properties) &#123;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断一个类型是否满足需求分为两个方面：一是判断该类型对应的位i是否在缓冲区的<i><font color="Orange">memoryTypeBits</font></i>中置位，如果置位说明该类型可供缓冲区使用；二是判断该类型是否具有我们需要的内存属性，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkMemoryType.html"><code>VkMemoryType</code></a>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkMemoryType</span> &#123;</span><br>    VkMemoryPropertyFlags    propertyFlags;<br>    <span class="hljs-type">uint32_t</span>                 heapIndex;<br>&#125; VkMemoryType;<br></code></pre></td></tr></table></figure><p>有关属性的部分我们会在下一步详细描述。</p><h4 id="分配缓冲区内存">分配缓冲区内存</h4><p>如果寻找到了满足缓冲区要求的内存类型。接下来我们就可以分配相应的内存了。分配缓冲区内存需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkMemoryAllocateInfo.html"><code>VkMemoryAllocateInfo</code></a>结构体，其定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkMemoryAllocateInfo</span> &#123;</span><br>    VkStructureType    sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*        pNext;<br>    VkDeviceSize       allocationSize;<br>    <span class="hljs-type">uint32_t</span>           memoryTypeIndex;<br>&#125; VkMemoryAllocateInfo;<br></code></pre></td></tr></table></figure></p><p>每个成员的含义都是易于理解的，我们的分配代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkMemoryAllocateInfo allocInfo&#123;&#125;;<br>allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;<br>allocInfo.allocationSize = memRequirements.size;<br>allocInfo.memoryTypeIndex = <span class="hljs-built_in">findMemoryType</span>(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);<br></code></pre></td></tr></table></figure><p>这里我们传递给<i><font color="Green">findMemoryType</font></i>函数的属性参数为<i><font color="Red">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT|VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</font></i>。我们这里列举出属性所有可能的取值，并且大致解释以下它们每一个的含义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkMemoryPropertyFlagBits</span> &#123;</span><br>    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//分配的内存能够被设备高效使用</span><br>    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//分配的内存可以映射给CPU使用</span><br>    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//CPU上对该内存的一切修改操作都能立刻一致地同步到GPU上而不需要显式使用vkFlushMappedMemoryRanges和vkInvalidateMappedMemoryRanges同步内存数据一致性</span><br>    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//映射后的内存会置于CPU的高速缓存区，具有更快的访问效率，但是置于主内存的映射后内存一定是host coherent的</span><br>    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = <span class="hljs-number">0x00000010</span>,<span class="hljs-comment">//内存只允许设备访问，并且该内存可能是懒分配的，这个标志不能和VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT set同时使用</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_MEMORY_PROPERTY_PROTECTED_BIT = <span class="hljs-number">0x00000020</span>,<span class="hljs-comment">//内存只允许设备访问，并且只允许具有保护权限的队列操作访问。这个标志不能和VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT、VK_MEMORY_PROPERTY_HOST_COHERENT_BIT或者VK_MEMORY_PROPERTY_HOST_CACHED_BIT 中的任意一个同时使用</span><br>  <span class="hljs-comment">// Provided by VK_AMD_device_coherent_memory</span><br>    VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = <span class="hljs-number">0x00000040</span>,<span class="hljs-comment">//设备对内存的任何修改对CPU立即可见并且一致，一般作调试用，会影响内存使用效率，如非必要不建议使用</span><br>  <span class="hljs-comment">// Provided by VK_AMD_device_coherent_memory</span><br>    VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = <span class="hljs-number">0x00000080</span>,<span class="hljs-comment">//内存不会置于GPU高速缓存区，这样的内存一定是device coherent的</span><br>  <span class="hljs-comment">// Provided by VK_NV_external_memory_rdma</span><br>    VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = <span class="hljs-number">0x00000100</span>,<span class="hljs-comment">//其它设备可以直接访问这块内存</span><br>&#125; VkMemoryPropertyFlagBits;<br></code></pre></td></tr></table></figure><p>我们希望能够将CPU中的顶点数据复制给GPU，因此我们需要分配的缓冲区内存能够将自己映射到CPU上供CPU填充数据，因此我们需要设置<i><font color="Red">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</font></i>；另外，我们希望CPU将数据复值给映射后内存后，GPU能够立即同步该内存信息到自己的内存区域并且开始使用，因此我们需要设置<i><font color="Red">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</font></i>。</p><p>然后我们使用这份信息来分配顶点缓冲内存。首先在类内创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceMemory.html"><code>VkDeviceMemory</code></a>类型的成员<i><font color="Orange">vertexBufferMemory</font></i>，然后调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAllocateMemory.html"><code>vkAllocateMemory</code></a>即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkAllocateMemory</span>(device, &amp;allocInfo, <span class="hljs-literal">nullptr</span>, &amp;vertexBufferMemory) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to allocate vertex buffer memory!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们需要将这块分配好的内存绑定到对应的顶点缓冲区上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkBindBufferMemory</span>(device, vertexBuffer, vertexBufferMemory, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>最后一个参数代表缓冲在该内存中的偏移。我们的内存块中只有一个顶点缓冲，因此偏移设置为0即可，如果该值不为0，那么它一定需要被<i><font color="Orange">memRequirements.alignment</font></i>整除。</p><hr><h2 id="填充顶点数据">填充顶点数据</h2><p>现在我们需要将顶点数据填充至顶点缓存中，这需要我们首先将分配的顶点缓冲内存（在GPU中）映射到CPU可见的内存上，然后将CPU中的顶点数据复制到映射后内存中，之后设备会将该内存中的数据同步到缓冲区中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">void</span>* data;<br><span class="hljs-built_in">vkMapMemory</span>(device, vertexBufferMemory, <span class="hljs-number">0</span>, bufferInfo.size, <span class="hljs-number">0</span>, &amp;data);<br>    <span class="hljs-built_in">memcpy</span>(data, vertices.<span class="hljs-built_in">data</span>(), (<span class="hljs-type">size_t</span>) bufferInfo.size);<br><span class="hljs-built_in">vkUnmapMemory</span>(device, vertexBufferMemory);<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkMapMemory.html"><code>vkMapMemory</code></a>的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkMapMemory</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDevice                                    device,<span class="hljs-comment">//设备</span></span><br><span class="hljs-params">    VkDeviceMemory                              memory,<span class="hljs-comment">//映射的内存</span></span><br><span class="hljs-params">    VkDeviceSize                                offset,<span class="hljs-comment">//映射开始位置在内存中的偏移</span></span><br><span class="hljs-params">    VkDeviceSize                                size,<span class="hljs-comment">//映射内存的范围大小，还可以指定一个特殊值VK_WHOLE_SIZE，代表从偏移处到结尾的所有内存</span></span><br><span class="hljs-params">    VkMemoryMapFlags                            flags,<span class="hljs-comment">//标志位，指定特殊的操作</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span>**                                      ppData)</span>;<span class="hljs-comment">//映射后内存地址</span><br></code></pre></td></tr></table></figure><p>这样就完成了顶点数据的填充。</p><hr><h2 id="绑定顶点缓冲">绑定顶点缓冲</h2><p>最后，我们需要在绘制三角形命令之前将顶点缓冲绑定到着色器的绑定点以供着色器使用，这可以通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers.html"><code>vkCmdBindVertexBuffers</code></a>来完成，该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdBindVertexBuffers</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    firstBinding,<span class="hljs-comment">//第一个绑定点索引</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    bindingCount,<span class="hljs-comment">//绑定点总数</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkBuffer*                             pBuffers,<span class="hljs-comment">//需要绑定的一系列缓冲区</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkDeviceSize*                         pOffsets)</span>;<span class="hljs-comment">//每个缓冲区对应的开始读取数据的偏移</span><br><br></code></pre></td></tr></table></figure><p>然后在录制命令的函数<i><font color="Green">recordCommandBuffer</font></i>中添加录制绑定顶点缓冲区的代码即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdBindPipeline</span>(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);<br><br>VkBuffer vertexBuffers[] = &#123;vertexBuffer&#125;;<br>VkDeviceSize offsets[] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">vkCmdBindVertexBuffers</span>(commandBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, vertexBuffers, offsets);<br><br><span class="hljs-built_in">vkCmdDraw</span>(commandBuffer, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertices.<span class="hljs-built_in">size</span>()), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>大功告成！</p><p><a href="https://zpc-dsg.github.io/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/">下一章</a>我们将看到如何通过临时缓冲区更高效地使用顶点缓冲。</p><p>最后，还需要提一嘴的是，在实际应用中，我们的应用程序不可能仅仅绘制一个三角形，它可能会需要同时为很多的顶点缓冲分配内存，这时我们一般不可能像本节做的那样对每个分配内存操作调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAllocateMemory.html"><code>vkAllocateMemory</code></a>，因为事实上物理设备在同一时间段支持分配内存函数调用的次数是有上限的，而且这个上限可能并不高（4096），因此更可行的做法是一次<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAllocateMemory.html"><code>vkAllocateMemory</code></a>调用为多个缓冲区分配内存，这可能需要我们书写自己的内存分配器，并使用该分配器来合理分割分配得到的一大块内存区域以供多个缓冲使用，当然，你也可以使用一些开源的内存分配器（如<a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">VulkanMemoryAllocator</a>）来达到这个目的。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0/">上一篇：顶点输入描述</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/">下一篇：临时缓冲区</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>顶点输入描述</title>
    <link href="/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0/"/>
    <url>/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在接下来的几个章节中，我们将用顶点缓冲代替之前硬编码在着色器中的顶点数据。这一节中，我们首先关注顶点输入数据的描述。创建对顶点数据的描述可以分为三步：</p><ul><li>在CPU中准备好需要传入顶点着色器的数据</li><li>在顶点着色器中添加对输入数据的引用代码</li><li>创建对应于引用代码的两种顶点描述结构体供创建渲染管线时顶点输入阶段使用</li></ul><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Vertex_buffers/Vertex_input_description">Vertexinput description</a>章节。</p><hr><h2 id="定义顶点数据">定义顶点数据</h2><p>为了在CPU中定义我们需要的顶点数据，我们可以使用<a href="https://github.com/g-truc/glm">GLM数学库</a>作为辅助。在程序中新添一个表示每个顶点所包含数据的结构体<i><font color="Orange">Vertex</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vertex</span> &#123;<br>    glm::vec2 pos;<br>    glm::vec3 color;<br>&#125;;<br></code></pre></td></tr></table></figure><p>目前该结构体十分简单，因为我们绘制三角形的程序只需要每个顶点的二维坐标和颜色值。</p><p>然后，在程序代码中添加我们需要传递给顶点着色器的具体的顶点数据即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;Vertex&gt; vertices = &#123;<br>    &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">-0.5f</span>&#125;, &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>    &#123;&#123;<span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>&#125;, &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="着色器添加顶点引用">着色器添加顶点引用</h2><p>现在我们可以去掉顶点着色器中硬编码的顶点数据了。为了引用我们在CPU中定义的顶点数据，我们需要在顶点着色器中添加如下代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inPosition;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inColor;<br></code></pre></td></tr></table></figure><p>顶点着色器代码现在如下所示：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> inPosition;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> inColor;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fragColor;<br><br><span class="hljs-type">void</span> main() &#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(inPosition, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fragColor = inColor;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>in</strong>关键字代表这些数据将从顶点缓冲读入，<strong>location</strong>关键字代表了对应顶点属性在顶点数据中的位置，这个位置将在后文创建顶点描述结构体的时候被引用以和CPU中定义的顶点数据形成正确的对应从而确保输入着色器数据的正确性。</p><hr><h2 id="创建描述结构体">创建描述结构体</h2><p>下面我们就可以创建与着色器中顶点输入数据格式相匹配的顶点输入描述结构体了。我们需要创建两种结构体：<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkVertexInputBindingDescription.html"><code>VkVertexInputBindingDescription</code></a>和<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkVertexInputAttributeDescription.html"><code>VkVertexInputAttributeDescription</code></a>。</p><h4 id="vkvertexinputbindingdescription">VkVertexInputBindingDescription</h4><p>该结构体用于描述每个顶点的字节大小，即从一个顶点到下一个顶点在缓冲区中的字节距离，并且指定数据是逐顶点的还是逐实例提供的，它的定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkVertexInputBindingDescription</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>             binding;<span class="hljs-comment">//绑定的索引，表示在顶点输入阶段使用的顶点缓冲区的编号</span><br>    <span class="hljs-type">uint32_t</span>             stride;<span class="hljs-comment">//每个顶点的字节大小</span><br>    VkVertexInputRate    inputRate;<span class="hljs-comment">//指定数据是每个顶点（VK_VERTEX_INPUT_RATE_VERTEX）还是每个实例（VK_VERTEX_INPUT_RATE_INSTANCE）提供的</span><br>&#125; VkVertexInputBindingDescription;<br></code></pre></td></tr></table></figure></p><p>每个成员的含义都是易于理解的。为了创建这个描述结构体，我们在<i><font color="Orange">Vertex</font></i>结构体中新增一个创建该结构体的静态函数<i><font color="Green">staticVkVertexInputBindingDescription getBindingDescription()</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> VkVertexInputBindingDescription <span class="hljs-title">getBindingDescription</span><span class="hljs-params">()</span> </span>&#123;<br>    VkVertexInputBindingDescription bindingDescription&#123;&#125;;<br>    <br>    VkVertexInputBindingDescription bindingDescription&#123;&#125;;<br>bindingDescription.binding = <span class="hljs-number">0</span>;<br>bindingDescription.stride = <span class="hljs-built_in">sizeof</span>(Vertex);<br>bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;<br>    <br>    <span class="hljs-keyword">return</span> bindingDescription;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="vkvertexinputattributedescription">VkVertexInputAttributeDescription</h4><p>该结构体用于描述顶点属性，帮助开发者定义如何从顶点缓冲区中提取和解释数据，它的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VkVertexInputAttributeDescription</span> &#123;<br>    <span class="hljs-type">uint32_t</span>    location;<span class="hljs-comment">//属性的索引，表示在着色器中的位置，通常与顶点着色器中的输入变量对应</span><br>    <span class="hljs-type">uint32_t</span>    binding;<span class="hljs-comment">//绑定的索引，指向 VkVertexInputBindingDescription 中定义的绑定，表明该属性属于哪个顶点缓冲区</span><br>    VkFormat    format;<span class="hljs-comment">//属性的数据格式</span><br>    <span class="hljs-type">uint32_t</span>    offset;<span class="hljs-comment">//相对于绑定缓冲区中每个顶点的起始位置的偏移量，指明该属性在顶点数据中的具体位置</span><br>&#125; VkVertexInputAttributeDescription;<br></code></pre></td></tr></table></figure><p>有多少个顶点属性，我们就需要定义多少个相应的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkVertexInputAttributeDescription.html"><code>VkVertexInputAttributeDescription</code></a>结构体。该结构体中的第一个成员<i><font color="Orange">location</font></i>就对应了着色器代码中对应输入顶点属性的location。另外，结构体中的属性格式也要和着色器代码中对应属性数据格式相对应。一般来讲，该结构体中属性格式的颜色通道数应该要和着色器中属性数据的向量长度一致。同样，我们在<i><font color="Orange">Vertex</font></i>结构体中新增一个创建该结构体的静态函数<i><font color="Green">staticstd::array&lt;VkVertexInputAttributeDescription, 2&gt;getAttributeDescriptions()</font></i>（因为我们有两种属性，所以返回一个二元数组）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> std::array&lt;VkVertexInputAttributeDescription, 2&gt; <span class="hljs-title">getAttributeDescriptions</span><span class="hljs-params">()</span> </span>&#123;<br>    std::array&lt;VkVertexInputAttributeDescription, 2&gt; attributeDescriptions&#123;&#125;;<br><br>    attributeDescriptions[<span class="hljs-number">0</span>].binding = <span class="hljs-number">0</span>;<br>attributeDescriptions[<span class="hljs-number">0</span>].location = <span class="hljs-number">0</span>;<br>attributeDescriptions[<span class="hljs-number">0</span>].format = VK_FORMAT_R32G32_SFLOAT;<br>attributeDescriptions[<span class="hljs-number">0</span>].offset = <span class="hljs-built_in">offsetof</span>(Vertex, pos);<br>    <br>    attributeDescriptions[<span class="hljs-number">1</span>].binding = <span class="hljs-number">0</span>;<br>attributeDescriptions[<span class="hljs-number">1</span>].location = <span class="hljs-number">1</span>;<br>attributeDescriptions[<span class="hljs-number">1</span>].format = VK_FORMAT_R32G32B32_SFLOAT;<br>attributeDescriptions[<span class="hljs-number">1</span>].offset = <span class="hljs-built_in">offsetof</span>(Vertex, color);<br>    <br>    <span class="hljs-keyword">return</span> attributeDescriptions;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们准备好了所有顶点输入阶段需要的顶点数据描述结构体，最后我们只需要在创建渲染管线的顶点输入阶段时引用这两个结构体即可（之前我们是没有设置顶点输入阶段的，因为当时顶点数据硬编码在着色器中）。在<i><font color="Green">createGraphicsPipeline</font></i>函数中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> bindingDescription = Vertex::<span class="hljs-built_in">getBindingDescription</span>();<br><span class="hljs-keyword">auto</span> attributeDescriptions = Vertex::<span class="hljs-built_in">getAttributeDescriptions</span>();<br><br>vertexInputInfo.vertexBindingDescriptionCount = <span class="hljs-number">1</span>;<br>vertexInputInfo.vertexAttributeDescriptionCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attributeDescriptions.<span class="hljs-built_in">size</span>());<br>vertexInputInfo.pVertexBindingDescriptions = &amp;bindingDescription;<br>vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/22/CG_api/vulkan/vulkan_tutorial/%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/">上一篇：重建交换链</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/">下一篇：创建顶点缓冲</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>重建交换链</title>
    <link href="/2024/11/22/CG_api/vulkan/vulkan_tutorial/%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/"/>
    <url>/2024/11/22/CG_api/vulkan/vulkan_tutorial/%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>我们的绘制三角形程序已经基本完成了，但仍然有一些问题需要解决。其中一个重要的问题就是当窗口表面发生改变（如缩放）的时候，交换链就不再和窗口表面兼容了。此时为了显示正确的图像到屏幕上我们需要重新构建一个和当下窗口表面兼容的交换链。重建交换链主要需要考虑如下几个问题：</p><ul><li>怎么检测重建交换链的时机</li><li>如何重建交换链</li></ul><p>我们将创建一个<i><font color="Green">voidrecreateSwapchain()</font></i>函数来执行交换链的重建工作。</p><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Swap_chain_recreation">Swapchain recreation</a>章节。</p><hr><h2 id="检测时机方式">检测时机方式</h2><p>还记得我们在<a href="https://zpc-dsg.github.io/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/">渲染和显示</a>这篇文章中曾经提到我们会在之后完善对<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html"><code>vkAcquireNextImageKHR</code></a>和<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>的调试工作吗？事实上，这两个函数也会返回一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkResult.html"><code>VkResult</code></a>类型的值来反映函数执行情况。其中，有两个特殊的可能返回值就和当前交换链是否和窗口表面兼容有关，分别为：</p><ul><li><i><font color="Red">VK_ERROR_OUT_OF_DATE_KHR</font></i>：交换链和表面不兼容并且已经无法继续用于渲染了。</li><li><i><font color="Red">VK_SUBOPTIMAL_KHR</font></i>：交换链仍可用于渲染和显示，但是它和表面的属性已经不完全匹配了。</li></ul><p>因此，我们可以对这两个函数的返回值进行侦测并据此进一步判断是否需要重建交换链。本教程中对应的检测代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br><br>VkResult result = <span class="hljs-built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);<br><br><span class="hljs-keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR) &#123;<br>    <span class="hljs-built_in">recreateSwapChain</span>();<br>    <span class="hljs-keyword">return</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != VK_SUCCESS &amp;&amp; result != VK_SUBOPTIMAL_KHR) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to acquire swap chain image!&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br>result = <span class="hljs-built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);<br><br><span class="hljs-keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR) &#123;<br>    <span class="hljs-built_in">recreateSwapChain</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to present swap chain image!&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure></p><p>然而，这么写代码其实会诱发死锁：注意到栅栏已经在该代码之前重置为未点亮状态，并且需要后续的命令缓冲中的所有命令完成后才能点亮，如果我们缩放了窗口大小，函数会在重建交换链之后直接返回，然而此时栅栏就永远不会被点亮了！于是代码就卡死在了<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html"><code>vkWaitForFences</code></a>上。</p><p>为了解决这个问题，我们可以将<a href="https://registry.khronos.org/VulkanSC/specs/1.0-extensions/man/html/vkResetFences.html"><code>vkResetFences</code></a>放在对<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html"><code>vkAcquireNextImageKHR</code></a>返回结果的处理代码后，这样即使因为重建交换链返回了也可以保证此时栅栏仍然是点亮状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkWaitForFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);<br><br><span class="hljs-type">uint32_t</span> imageIndex;<br>VkResult result = <span class="hljs-built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);<br><br><span class="hljs-keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR) &#123;<br>    <span class="hljs-built_in">recreateSwapChain</span>();<br>    <span class="hljs-keyword">return</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != VK_SUCCESS &amp;&amp; result != VK_SUBOPTIMAL_KHR) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to acquire swap chain image!&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">vkResetFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame]);<br></code></pre></td></tr></table></figure><p>不过这还不算结束。尽管许多平台在窗口大小调整之后会自动触发<i><font color="Red">VK_ERROR_OUT_OF_DATE_KHR</font></i>，但并非所有的硬件都会保证这一点。因此，为了真正在所有平台上都能精准检测到窗口大小的变化，我们还应该显式地获取窗口大小信息以检测其大小变化。为了显式地获取窗口信息并据此决定是否重建交换链，我们需要设置一个窗口回调函数<i><font color="Green">staticvoid framebufferResizeCallback(GLFWwindow* window, int width, intheight)</font></i>以供<a href="https://www.glfw.org/docs/3.3/group__window.html#ga3c96d80d363e67d13a41b5d1821f3242"><code>GLFWwindow</code></a>对象在侦测到窗口大小改变时调用，并且在类内新建一个成员<i><font color="Orange">boolframebufferResized</font></i>用于指示窗口大小是否发生了变换。之所以将这个函数设置为静态函数是因为<a href="https://www.glfw.org/docs/3.3/group__window.html#ga3c96d80d363e67d13a41b5d1821f3242"><code>GLFWwindow</code></a>对象并不知道如何正确调用一个带有this指针的成员回调函数。</p><p>尽管<a href="https://www.glfw.org/docs/3.3/group__window.html#ga3c96d80d363e67d13a41b5d1821f3242"><code>GLFWwindow</code></a>对象不能正确处理this指针，但它允许使用<a href="https://www.glfw.org/docs/3.3/group__window.html#ga3d2fc6026e690ab31a13f78bc9fd3651"><code>glfwSetWindowUserPointer</code></a>在该对象内保存一个任意类型的指针。我们可以利用这个指针保存我们的this指针以便在回调函数中改变应用程序类中的<i><font color="Orange">framebufferResized</font></i>的值。</p><p>回调函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">framebufferResizeCallback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> app = <span class="hljs-built_in">reinterpret_cast</span>&lt;HelloTriangleApplication*&gt;(<span class="hljs-built_in">glfwGetWindowUserPointer</span>(window));<br>    app-&gt;framebufferResized = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们需要在GLFW窗口系统中设置这个回调函数，这可以通过在窗口初始化成员函数<i><font color="Green">initWindow</font></i>中使用<a href="https://www.glfw.org/docs/3.3/group__window.html#gab3fb7c3366577daef18c0023e2a8591f"><code>glfwSetFramebufferSizeCallback</code></a>函数来完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initWindow</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">glfwInit</span>();<br><br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CLIENT_API, GLFW_NO_API);<br><br>    window = <span class="hljs-built_in">glfwCreateWindow</span>(WIDTH, HEIGHT, <span class="hljs-string">&quot;Vulkan&quot;</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(window, framebufferResizeCallback);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们需要在检测<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>返回结果的代码中加入对<i><font color="Orange">framebufferResized</font></i>值的检测，一旦它变为真，就重建交换链：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">result = <span class="hljs-built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);<br><br><span class="hljs-keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || framebufferResized) &#123;<br>   framebufferResized = <span class="hljs-literal">false</span>;<br>   <span class="hljs-built_in">recreateSwapChain</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != VK_SUCCESS) &#123;<br>   <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to present swap chain image!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就处理好了因为窗口大小改变造成的交换链图像失效问题。</p><hr><h2 id="重建交换链">重建交换链</h2><p>重建交换链的函数<i><font color="Green">recreateSwapChain</font></i>完全可以重用我们之前创建交换链所使用的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recreateSwapChain</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">vkDeviceWaitIdle</span>(device);<br><br>    <span class="hljs-built_in">cleanupSwapChain</span>();<br>    <br>    <span class="hljs-built_in">createSwapChain</span>();<br>    <span class="hljs-built_in">createImageViews</span>();<br>    <span class="hljs-built_in">createFramebuffers</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>想要重建交换链，只需重新创建交换链对象，以及它对应的图像视图和帧缓冲对象即可。图像不用手动重新创建，因为交换链对象的创建本身会自动生成相应的图像。另外，我们在函数头也需要首先等待设备完成其它正在进行的工作，因为我们不希望在旧的交换链仍然有工作没有完成时就清除掉旧的交换链。</p><p>这里我们新创建了一个成员函数<i><font color="Green">voidcleanupSwapChain()</font></i>来完成对交换链的销毁工作，它同样可以重用<i><font color="Green">cleanup</font></i>函数中销毁交换链有关的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cleanupSwapChain</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainFramebuffers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-built_in">vkDestroyFramebuffer</span>(device, swapChainFramebuffers[i], <span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainImageViews.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-built_in">vkDestroyImageView</span>(device, swapChainImageViews[i], <span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">vkDestroySwapchainKHR</span>(device, swapChain, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就完成了重建交换链的工作。好吧，实际上还有一种特殊的情况我们没有给予关注，那就是最小化窗口的时候。窗口最小化的时候，我们有理由希望此时我们的应用程序暂时停止渲染有关的一切工作，直到用户再次打开应用界面。因此，我们可以在<i><font color="Green">recreateSwapChain</font></i>函数的开头处加入以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recreateSwapChain</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> width = <span class="hljs-number">0</span>, height = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);<br>    <span class="hljs-keyword">while</span> (width == <span class="hljs-number">0</span> || height == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);<br>        <span class="hljs-built_in">glfwWaitEvents</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">vkDeviceWaitIdle</span>(device);<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果最小化，那么帧缓冲大小会变为0，这样我们就可以通过判断该大小是否为0来决定是否需要暂时挂起我们的程序。</p><p>另外，教程评论区有人发现这段处理最小化的代码仍然有疏漏之处：如果在最小化窗口时右键点击任务栏程序图标关闭程序，那么此时尽管窗口关闭了，但<a href="https://www.glfw.org/docs/3.3/group__window.html#ga554e37d781f0a997656c26b2c56c835e"><code>glfwWaitEvents</code></a>仍然处于等待状态，因此此时程序并不会终止而是仍然处于挂起运行的状态。于是，我们需要在处理最小化的代码中显式处理窗口关闭的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (width == <span class="hljs-number">0</span> || height == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwWindowShouldClose</span>(window))<br>        <span class="hljs-keyword">return</span>;<br>    <br>        <span class="hljs-built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);<br>        <span class="hljs-built_in">glfwWaitEvents</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><p>终于大功告成！</p><p>接下来的章节我们将开启一个新的主题：顶点缓冲。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/20/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E5%B8%A7%E5%90%8C%E6%97%B6%E6%B8%B2%E6%9F%93/">上一篇：多帧同时渲染</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0/">下一篇：顶点输入描述</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多帧同时渲染</title>
    <link href="/2024/11/20/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E5%B8%A7%E5%90%8C%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    <url>/2024/11/20/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E5%B8%A7%E5%90%8C%E6%97%B6%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在<a href="https://zpc-dsg.github.io/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/">上一章</a>我们提到，目前应用程序只支持一帧一帧地渲染，但是我们会更希望下一帧的命令录制等操作可以和上一帧的渲染同时进行以提高效率。因此，本节就来实现多帧同时渲染。</p><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Frames_in_flight">Framesin flight</a>章节。</p><hr><h2 id="多帧同时渲染">多帧同时渲染</h2><p>首先，我们来指定需要多少帧同时进行工作，在类外定义一个帧数常量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_FRAMES_IN_FLIGHT = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>我们这里指定两帧。</p><p>接下来，我们需要将命令缓冲、信号量、栅栏资源数目均翻倍，因为我们希望每一帧拥有自己独立的命令和同步资源，这样两帧同时工作的时候就不会互相干扰。因此，将类内相应成员改动如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;VkCommandBuffer&gt; commandBuffers;<br><br>std::vector&lt;VkSemaphore&gt; imageAvailableSemaphores;<br>std::vector&lt;VkSemaphore&gt; renderFinishedSemaphores;<br>std::vector&lt;VkFence&gt; inFlightFences;<br></code></pre></td></tr></table></figure><p>现在，我们需要修改一下相应资源的构建函数。首先将构建命令缓冲的成员函数<i><font color="Green">createCommandBuffer</font></i>改为<i><font color="Green">createCommandBuffers</font></i>，将函数体做如下改动即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createCommandBuffers</span><span class="hljs-params">()</span> </span>&#123;<br>    commandBuffers.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br>    <span class="hljs-comment">//...</span><br>    allocInfo.commandBufferCount = (<span class="hljs-type">uint32_t</span>) commandBuffers.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkAllocateCommandBuffers</span>(device, &amp;allocInfo, commandBuffers.<span class="hljs-built_in">data</span>()) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to allocate command buffers!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样，<i><font color="Green">createSyncObjects</font></i>函数也需要做如下改动以创建多个信号量和栅栏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createSyncObjects</span><span class="hljs-params">()</span> </span>&#123;<br>    imageAvailableSemaphores.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br>    renderFinishedSemaphores.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br>    inFlightFences.<span class="hljs-built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);<br><br>    VkSemaphoreCreateInfo semaphoreInfo&#123;&#125;;<br>    semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;<br><br>    VkFenceCreateInfo fenceInfo&#123;&#125;;<br>    fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;<br>    fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;imageAvailableSemaphores[i]) != VK_SUCCESS ||<br>            <span class="hljs-built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;renderFinishedSemaphores[i]) != VK_SUCCESS ||<br>            <span class="hljs-built_in">vkCreateFence</span>(device, &amp;fenceInfo, <span class="hljs-literal">nullptr</span>, &amp;inFlightFences[i]) != VK_SUCCESS) &#123;<br><br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create synchronization objects for a frame!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>资源创建完毕了，接下来我们就可以着手多帧渲染了。首先在类内添加一个成员<i><font color="Orange">currentFrame</font></i>代表初始帧索引：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> currentFrame = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>由于我们想要同时渲染两帧，因此每一帧的最后我们都需要将索引切换到另一个并且在该帧内使用相应索引的资源。对<i><font color="Green">drawFrame</font></i>函数的改动部分如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">vkWaitForFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);<br>    <span class="hljs-built_in">vkResetFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame]);<br><br>    <span class="hljs-built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);<br><br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-built_in">vkResetCommandBuffer</span>(commandBuffers[currentFrame],  <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">recordCommandBuffer</span>(commandBuffers[currentFrame], imageIndex);<br><br>    <span class="hljs-comment">//...</span><br><br>    submitInfo.pCommandBuffers = &amp;commandBuffers[currentFrame];<br><br>    <span class="hljs-comment">//...</span><br><br>    VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphores[currentFrame]&#125;;<br><br>    <span class="hljs-comment">//...</span><br><br>    VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphores[currentFrame]&#125;;<br><br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkQueueSubmit</span>(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//...</span><br>    <br>    currentFrame = (currentFrame + <span class="hljs-number">1</span>) % MAX_FRAMES_IN_FLIGHT;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们给出教程中<i><font color="Green">drawFrame</font></i>函数的完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">vkWaitForFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);<br>    <span class="hljs-built_in">vkResetFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFences[currentFrame]);<br><br>    <span class="hljs-type">uint32_t</span> imageIndex;<br>    <span class="hljs-built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);<br><br>    <span class="hljs-built_in">vkResetCommandBuffer</span>(commandBuffers[currentFrame], <span class="hljs-comment">/*VkCommandBufferResetFlagBits*/</span> <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">recordCommandBuffer</span>(commandBuffers[currentFrame], imageIndex);<br><br>    VkSubmitInfo submitInfo&#123;&#125;;<br>    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;<br><br>    VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphores[currentFrame]&#125;;<br>    VkPipelineStageFlags waitStages[] = &#123;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&#125;;<br>    submitInfo.waitSemaphoreCount = <span class="hljs-number">1</span>;<br>    submitInfo.pWaitSemaphores = waitSemaphores;<br>    submitInfo.pWaitDstStageMask = waitStages;<br><br>    submitInfo.commandBufferCount = <span class="hljs-number">1</span>;<br>    submitInfo.pCommandBuffers = &amp;commandBuffers[currentFrame];<br><br>    VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphores[currentFrame]&#125;;<br>    submitInfo.signalSemaphoreCount = <span class="hljs-number">1</span>;<br>    submitInfo.pSignalSemaphores = signalSemaphores;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkQueueSubmit</span>(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to submit draw command buffer!&quot;</span>);<br>    &#125;<br><br>    VkPresentInfoKHR presentInfo&#123;&#125;;<br>    presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;<br><br>    presentInfo.waitSemaphoreCount = <span class="hljs-number">1</span>;<br>    presentInfo.pWaitSemaphores = signalSemaphores;<br><br>    VkSwapchainKHR swapChains[] = &#123;swapChain&#125;;<br>    presentInfo.swapchainCount = <span class="hljs-number">1</span>;<br>    presentInfo.pSwapchains = swapChains;<br><br>    presentInfo.pImageIndices = &amp;imageIndex;<br><br>    <span class="hljs-built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);<br><br>    currentFrame = (currentFrame + <span class="hljs-number">1</span>) % MAX_FRAMES_IN_FLIGHT;<br>&#125;<br></code></pre></td></tr></table></figure><p>大功告成！</p><hr><h2 id="一些疑点">一些疑点</h2><p>关于本篇教程我有一点同样百思不得其解。</p><p>显然在上文<i><font color="Green">drawFrame</font></i>代码中，索引不同的两帧之间的工作是互不干扰的，因为它们各自具有独立的一套命令缓冲和同步对象。但是问题在于如果这样的话，那么本应先后渲染的两帧最后渲染和显示的顺序不是也就不确定了吗？比如说有两帧在同时工作，本应先显示的前一帧因为某种原因工作时长较长，但是因为它和后一帧使用不同的信号量，因此前一帧还在工作并不能迫使后一帧等待前一帧完成工作，那么这不就可能出现后一帧先渲染显示的情况了吗？</p><p>在我看来，本篇教程的目的应该在于充分调动CPU，使得GPU在工作的时候已经完成本帧工作的CPU可以继续进行下一帧的工作，而GPU仍然应该按照顺序一帧一帧地运行。那么如果按照这么理解的话不是应该栅栏要有多个，而每个信号量成员仍然只有一个吗？这样才能在保证GPU上的运行顺序的同时让CPU进行更多的工作吧？大惑不解，望高人指点~</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/">上一篇：渲染和显示</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/22/CG_api/vulkan/vulkan_tutorial/%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/">下一篇：重建交换链</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>渲染和显示</title>
    <link href="/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/"/>
    <url>/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>现在我们已经做好了绘制三角形所需要的所有准备工作，下面我们将创建一个<i><font color="Green">voiddrawFrame()</font></i>函数用于渲染循环中来进行真正的绘制和显示三角形的工作。</p><p>一帧中需要进行的工作主要分为以下五步：</p><ul><li>等待上一帧结束</li><li>从交换链获取一张图像用于渲染</li><li>录制命令</li><li>提交命令进行渲染</li><li>显示渲染好的图像</li></ul><p>在这五步中，第二、四、五步的部分或全部工作在GPU上完成，但是Vulkan中许多在GPU上工作的函数都是异步的，也就是说这种函数返回时函数内部的指令可能仍然在运行。因此，我们需要适当的同步手段来保证这三步一定是按顺序进行的，后者只有在前者完成工作时才会继续执行。</p><p>另外，我们还希望在开始下一帧的渲染之前上一帧命令缓冲中的命令都已经执行完毕了，这样才能保证下一帧开始录制命令时不会重置或覆盖正在执行的命令。这种情形和上文描述的GPU同步略有不同，因为等待上一帧结束这个过程应该发生在CPU端，所以我们还希望能够有一种同步机制来调节GPU和CPU间的操作顺序。</p><p>本文将首先介绍为达到上述同步目的应该使用的同步机制与同步对象，然后再顺次介绍渲染一帧的完整流程。最后，我将给出一个对本章节自己百思不得其解的疑点，当作一个有待日后解答的开放性问题。</p><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Rendering_and_presentation#page_What-to-choose">Renderingand presentation</a>章节。</p><hr><h2 id="同步操作概述">同步操作概述</h2><p>概述部分我们已经看到了，需要同步的操作可以分成两类：交换链上的操作（获取图像和显示图像）以及等待上一帧结束的操作。这两种操作需要两种不同的同步量，因为前者完全发生在GPU上，后者涉及GPU和CPU的通信。这里我们将分别使用<strong>信号量（Semaphore）</strong>和<strong>栅栏（Fence）</strong>作为这两种操作的同步工具，下面分别介绍这两种同步量并且创建需要的对应同步对象。</p><hr><h2 id="同步对象创建">同步对象创建</h2><p>我们将在类内创建一个<i><font color="Green">voidcreateSyncObjects()</font></i>函数来创建所需的同步对象。</p><h4 id="信号量简介semaphore">信号量简介（Semaphore）</h4><p>事实上，Vulkan中的信号量包含两种：二进制信号量（BinarySemaphore）以及时间线信号量（TimelineSemaphore）。二进制信号量只能取两个值：0 或1。它通常用于实现互斥锁或简单的资源访问控制，而时间线信号量是一种更复杂的信号量，允许多个值，并且可以用于更复杂的同步场景。它通常用于图形编程和GPU任务调度。我们之后仅使用二进制信号量，因此后文但凡涉及信号量指的都是二进制信号量。</p><p>如没有任何特殊设置，信号量一开始是未点亮的（unsignaled），它的使用方法一般是需要先完成的操作负责点亮这个信号量，该操作会在完成后点亮信号量，而需要后完成的操作等待这个信号量被点亮，一旦它发现该信号量被点亮，该操作就可以开始执行了，并且此时信号量自动复位为未点亮状态，这样它就可以被继续使用了。</p><h4 id="栅栏简介fence">栅栏简介（Fence）</h4><p>栅栏和信号量的作用类似，但是它是用来同步CPU，也就是所谓的<strong>host</strong>上操作的顺序的。简单来讲，当CPU端需要知道GPU端什么时候完成了指定工作时，我们就可以使用栅栏。</p><p>栅栏的使用方式一般是给GPU上某一项工作指定一个栅栏对象，该对象会在该工作完成时被点亮，CPU端会等待这个栅栏被点亮之后再执行下一步的工作。但是使用栅栏会阻塞CPU端的工作，也就是说GPU端的工作没有完成的话，CPU端是无法做任何工作的（这与信号量不同，信号量并不会阻塞GPU执行其它工作）。另外，栅栏也并不会自动复位为未点亮状态，而是需要CPU端手动复位。</p><h4 id="创建所需信号量">创建所需信号量</h4><p>前面我们提到了，我们需要在从交换链获取图像和在渲染完毕后准备显示这两个节点处设置信号量以固定它们的执行顺序。因此，我们在类内创建两个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSemaphore.html"><code>VkSemaphore</code></a>成员<i><font color="Orange">imageAvailableSemaphore</font></i>和<i><font color="Orange">renderFinishedSemaphore</font></i>。为了创建信号量，我们同样需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSemaphoreCreateInfo.html"><code>VkSemaphoreCreateInfo</code></a>结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSemaphoreCreateInfo</span> &#123;</span><br>    VkStructureType           sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*               pNext;<br>    VkSemaphoreCreateFlags    flags;<span class="hljs-comment">//目前还没有</span><br>&#125; VkSemaphoreCreateInfo;<br></code></pre></td></tr></table></figure><p>这个信息结构体只包含最基本的几个成员，因此填写十分简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSemaphoreCreateInfo semaphoreInfo&#123;&#125;;<br>semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;<br></code></pre></td></tr></table></figure><p>接下来只需调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateSemaphore.html"><code>vkCreateSemaphore</code></a>创建相应对象即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;imageAvailableSemaphore) != VK_SUCCESS ||<br>    <span class="hljs-built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;renderFinishedSemaphore) != VK_SUCCESS || &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create semaphores!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建所需栅栏">创建所需栅栏</h4><p>我们需要创建一个用于告知CPU端GPU上的命令缓冲中的命令已经执行完毕，可以开启下一帧了。因此，在类内添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFence.html"><code>VkFence</code></a>类型的对象<i><font color="Orange">inFlightFence</font></i>，然后在<i><font color="Green">createSyncObjects</font></i>函数中填写创建信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFenceCreateInfo.html"><code>VkFenceCreateInfo</code></a>。其中<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFenceCreateInfo.html"><code>VkFenceCreateInfo</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkFenceCreateInfo</span> &#123;</span><br>    VkStructureType       sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*           pNext;<br>    VkFenceCreateFlags    flags;<br>&#125; VkFenceCreateInfo;<br></code></pre></td></tr></table></figure><p>这里<i><font color="Orange">flags</font></i>成员可能的取值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkFenceCreateFlagBits</span> &#123;</span><br>    VK_FENCE_CREATE_SIGNALED_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//指定栅栏在创建时为被点亮状态</span><br>&#125; VkFenceCreateFlagBits;<br></code></pre></td></tr></table></figure><p>于是填写栅栏信息和创建栅栏的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkFenceCreateInfo fenceInfo&#123;&#125;;<br>fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;<br>fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateFence</span>(device, &amp;fenceInfo, <span class="hljs-literal">nullptr</span>, &amp;inFlightFence) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create semaphores!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>至于这里为什么需要设置栅栏在创建时为点亮状态，我们将在<a href="#上一帧">等待上一帧小节</a>中 加以说明。</p><hr><h2 id="上一帧">等待上一帧</h2><p>在<i><font color="Green">drawFrame</font></i>函数的开头，我们首先需要等待上一帧的结束。为此，我们可以调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html"><code>vkWaitForFences</code></a>函数来等待上一帧的<i><font color="Orange">inFlightFence</font></i>被点亮（点亮操作会在渲染完成后执行）。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html"><code>vkWaitForFences</code></a>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkWaitForFences</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDevice                                    device,    <span class="hljs-comment">//栅栏所属逻辑设备</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    fenceCount,<span class="hljs-comment">//栅栏数目</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkFence*                              pFences,   <span class="hljs-comment">//栅栏</span></span><br><span class="hljs-params">    VkBool32                                    waitAll,   <span class="hljs-comment">//是否等待所有栅栏都被点亮</span></span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span>                                    timeout)</span>;  <span class="hljs-comment">//等待时长  </span><br></code></pre></td></tr></table></figure><p>可以看到，我们可以指定CPU端等待多个栅栏，<i><font color="Orange">waitAll</font></i>参数可以指定我们需要等待其中所有栅栏都被点亮还是等待其中任意一个被点亮。<i><font color="Orange">timeout</font></i>指定最长的等待时限，如果在该时限内等待的栅栏被点亮了，那么该函数将返回<i><font color="Red">VK_SUCCESS</font></i>，否则，该函数会返回<i><font color="Red">VK_TIMEOUT</font></i>。</p><p>在我们的应用程序中，我们只有一个栅栏，并且不需要设置等待时限，于是我们可以如下调用该函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">vkWaitForFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFence, VK_TRUE, UINT64_MAX);<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，在栅栏被成功点亮后，我们需要手动重置其为非点亮状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkResetFences</span>(device, <span class="hljs-number">1</span>, &amp;inFlightFence);<br></code></pre></td></tr></table></figure><p>等待上一帧的操作就结束了。不过，细心的读者可能会注意到一个违和之处：每次进入下一帧的时候都要等待上一帧的栅栏被点亮，但如果是第一帧呢？它没办法等待上一帧点亮栅栏，因此在第一次循环进入到该函数时栅栏就处于未点亮的状态，那么<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html"><code>vkWaitForFences</code></a>永远无法成功返回！这个问题其实有很多的解决方案，在本教程中我们是通过上文创建栅栏时将其初始状态设置为点亮状态来实现的，这样就可以轻松解决这个问题~</p><hr><h2 id="获取交换链图像">获取交换链图像</h2><p>在上一帧命令执行结束后，我们就可以获取这一帧渲染需要的图像了。这通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html"><code>vkAcquireNextImageKHR</code></a>来完成。该函数原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br>VkResult <span class="hljs-title function_">vkAcquireNextImageKHR</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDevice                                    device,      <span class="hljs-comment">//需要获取图片的逻辑设备</span></span><br><span class="hljs-params">    VkSwapchainKHR                              swapchain,   <span class="hljs-comment">//图片所在交换链</span></span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span>                                    timeout,     <span class="hljs-comment">//等待获取时长</span></span><br><span class="hljs-params">    VkSemaphore                                 semaphore,   <span class="hljs-comment">//等待操作完成后点亮的信号量</span></span><br><span class="hljs-params">    VkFence                                     fence,       <span class="hljs-comment">//等待操作完成后点亮的栅栏</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>*                                   pImageIndex)</span>;<span class="hljs-comment">//获取的图片的索引</span><br></code></pre></td></tr></table></figure></p><p>我们只需设置一个信号量<i><font color="Orange">imageAvailableSemaphore</font></i>用于等待获取图像操作的结束，因此获取交换链图像的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> imageIndex;<br><span class="hljs-built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphore, VK_NULL_HANDLE, &amp;imageIndex);<br></code></pre></td></tr></table></figure><p>另外需要注意的是，这个函数保证在返回<i><font color="Red">VK_SUCCESS</font></i>时，<i><font color="Orange">imageIndex</font></i>一定是有效且正确的，但是并不保证返回时该函数所进行的一切工作都结束了。</p><hr><h2 id="录制命令">录制命令</h2><p>接下来我们可以录制对获取到的图像所需要进行的命令了（之前提到了尽管先前的<i><font color="Green">vkAcquireNextImageKHR</font></i>可能还没有执行完所有工作，但是图像索引已经得到了，录制命令这步工作是在CPU端进行的，并且只需要用到图像的索引，GPU端还有其它的工作未完成并不影响继续录制命令），因此我们调用<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/"><code>命令缓冲</code></a>章节添加的<i><font color="Green">recordCommandBuffer</font></i>函数来完成所需命令的录制。当然，在此之前我们需要先使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkResetCommandBuffer.html"><code>vkResetCommandBuffer</code></a>重置命令缓冲以清除上一帧录制的命令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkResetCommandBuffer</span>(commandBuffer, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">recordCommandBuffer</span>(commandBuffer, imageIndex);<br></code></pre></td></tr></table></figure><hr><h2 id="提交命令并渲染">提交命令并渲染</h2><p>录制好命令后我们就可以将命令缓冲中的命令提交给队列执行了。提交命令同样需要填写相应的信息<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo.html"><code>VkSubmitInfo</code></a>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSubmitInfo</span> &#123;</span><br>    VkStructureType                sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                    pNext;<br>    <span class="hljs-type">uint32_t</span>                       waitSemaphoreCount;<br>    <span class="hljs-type">const</span> VkSemaphore*             pWaitSemaphores;<br>    <span class="hljs-type">const</span> VkPipelineStageFlags*    pWaitDstStageMask;<br>    <span class="hljs-type">uint32_t</span>                       commandBufferCount;<br>    <span class="hljs-type">const</span> VkCommandBuffer*         pCommandBuffers;<br>    <span class="hljs-type">uint32_t</span>                       signalSemaphoreCount;<br>    <span class="hljs-type">const</span> VkSemaphore*             pSignalSemaphores;<br>&#125; VkSubmitInfo;<br></code></pre></td></tr></table></figure><p>这里唯一需要解释一下的参数就是<i><font color="Orange">pWaitDstStageMask</font></i>，它用于指定每个等待信号量对应在管线中等待的阶段，也就是管线中哪个阶段需要等待该信号量被点亮后才能继续执行。注意，如果渲染管线中对应阶段被执行了多次（比如一个渲染通道中有多个子通道），那么每个该阶段的执行都需要等待该信号量被点亮。</p><p>在我们的应用程序中，我们需要在绘制前等待图像获取完毕，于是我们需要等待的信号量为<i><font color="Orange">imageAvailableSemaphore</font></i>，等待的管线阶段可以设置为<i><font color="Red">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>（全部的管线阶段及其相关信息可以参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlagBits.html">这个页面</a>），这意味着我们只要求在绘制到帧缓冲之前图像必须获取完毕，而在之前的管线阶段，比如顶点着色器运行阶段等则并不要求图像获取完毕，这么做延长了图像获取操作的允许时长，提高了时间利用效率。在命令缓冲中的命令全部执行完毕后，我们还需要点亮<i><font color="Orange">renderFinishedSemaphore</font></i>以告知程序渲染已经完成，可以进行后续的显示操作了。因此，该信息结构体的填写代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSubmitInfo submitInfo&#123;&#125;;<br>submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;<br><br>VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphore&#125;;<br>VkPipelineStageFlags waitStages[] = &#123;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&#125;;<br>submitInfo.waitSemaphoreCount = <span class="hljs-number">1</span>;<br>submitInfo.pWaitSemaphores = waitSemaphores;<br>submitInfo.pWaitDstStageMask = waitStages;<br>submitInfo.commandBufferCount = <span class="hljs-number">1</span>;<br>submitInfo.pCommandBuffers = &amp;commandBuffer;<br>VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphore&#125;;<br>submitInfo.signalSemaphoreCount = <span class="hljs-number">1</span>;<br>submitInfo.pSignalSemaphores = signalSemaphores;<br></code></pre></td></tr></table></figure><p>接下来我们需要调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit.html"><code>vkQueueSubmit</code></a>函数执行提交操作，该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkQueueSubmit</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkQueue                                     <span class="hljs-built_in">queue</span>,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    submitCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkSubmitInfo*                         pSubmits,</span><br><span class="hljs-params">    VkFence                                     fence)</span>;<br></code></pre></td></tr></table></figure><p>每一个参数都是易于理解的，其中最后一个参数代表一个可选的在提交的命令运行结束后会被点亮的栅栏。我们显然应该将<i><font color="Orange">inFlightFence</font></i>赋予这个参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkQueueSubmit</span>(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, inFlightFence) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to submit draw command buffer!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，命令提交结束，渲染可以开始了。但是事实上这里仍然存在一个很隐晦的问题：还记得我们的渲染通道中指定了一个子通道吗？事实上，除了这个我们显式设置的通道之外，还存在两个隐式的通道，一个位于渲染通道的开始处，一个位于渲染通道的结束处，这些子通道会通过一种叫做<strong>Subpassdependencies</strong>的结构控制子通道之间图像格式的转换。如果不显式设置这种依赖关系，那么默认的开始处的子通道到我们设置的子通道之间格式的转换将发生在渲染管线的开始阶段（该阶段对应Vulkan中管线阶段的枚举值为<i><font color="Red">VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</font></i>），但是问题是，我们之前设置的提交命令的等待阶段为输出到帧缓冲的阶段，也就是说在<i><font color="Red">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>之前，我们甚至不能保证图像获取操作已经完全结束了，也就是说我们不能保证在这个阶段之前图象是完全有效的，甚至渲染管线开始的时候图像可能还根本没有获取到！当然，我们可以将之前<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo.html"><code>VkSubmitInfo</code></a>中的<i><font color="Orange">pWaitDstStageMask</font></i>设置为<i><font color="Red">VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</font></i>，但是一来这样会使得时间利用率降低，二来我们也希望借此机会探索一下<strong>Subpassdependencies</strong>的结构和设置方式。因此，我们接下来就在<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/"><code>渲染通道</code></a>章节中创建的<i><font color="Green">createRenderPass</font></i>函数中添加手动设置<strong>Subpassdependencies</strong>的相关代码：</p><p>首先还是来看一下依赖关系结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubpassDependency.html"><code>VkSubpassDependency</code></a>的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSubpassDependency</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>                srcSubpass;<span class="hljs-comment">//依赖关系的源子通道的索引。如果设置为 VK_SUBPASS_EXTERNAL，则表示依赖于外部命令（即在渲染通道开始之前的命令）</span><br>    <span class="hljs-type">uint32_t</span>                dstSubpass;<span class="hljs-comment">//依赖关系的目标子通道的索引。如果设置为 VK_SUBPASS_EXTERNAL，则表示依赖于外部命令（即在渲染通道结束之后的命令）。另外，该索引值一定要大于等于srcSubpass表示的索引值以避免循环依赖（除非dstSubpass为VK_SUBPASS_EXTERNAL）</span><br>    VkPipelineStageFlags    srcStageMask;<span class="hljs-comment">//指定源子通道中需要同步的管线阶段。这决定了哪些阶段的操作需要在目标子通道开始之前完成</span><br>    VkPipelineStageFlags    dstStageMask;<span class="hljs-comment">//指定目标子通道中需要同步的管线阶段。这决定了目标子通道中哪些阶段的操作需要等待源子通道的完成</span><br>    VkAccessFlags           srcAccessMask;<span class="hljs-comment">//指定在源子通道中访问的资源类型（如读取、写入等）。这用于确定在源子通道中需要等待的访问类型</span><br>    VkAccessFlags           dstAccessMask;<span class="hljs-comment">//指定在目标子通道中访问的资源类型。这用于确定目标子通道中需要等待的访问类型</span><br>    VkDependencyFlags       dependencyFlags;<span class="hljs-comment">//指定依赖关系的标志，控制依赖行为的特性</span><br>&#125; VkSubpassDependency;<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAccessFlagBits.html"><code>VkAccessFlagBits</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkAccessFlagBits</span> &#123;</span><br>    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = <span class="hljs-number">0x00000001</span>,<br>    VK_ACCESS_INDEX_READ_BIT = <span class="hljs-number">0x00000002</span>,<br>    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = <span class="hljs-number">0x00000004</span>,<br>    VK_ACCESS_UNIFORM_READ_BIT = <span class="hljs-number">0x00000008</span>,<br>    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = <span class="hljs-number">0x00000010</span>,<br>    VK_ACCESS_SHADER_READ_BIT = <span class="hljs-number">0x00000020</span>,<br>    VK_ACCESS_SHADER_WRITE_BIT = <span class="hljs-number">0x00000040</span>,<br>    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = <span class="hljs-number">0x00000080</span>,<br>    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = <span class="hljs-number">0x00000100</span>,<br>    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = <span class="hljs-number">0x00000200</span>,<br>    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = <span class="hljs-number">0x00000400</span>,<br>    VK_ACCESS_TRANSFER_READ_BIT = <span class="hljs-number">0x00000800</span>,<br>    VK_ACCESS_TRANSFER_WRITE_BIT = <span class="hljs-number">0x00001000</span>,<br>    VK_ACCESS_HOST_READ_BIT = <span class="hljs-number">0x00002000</span>,<br>    VK_ACCESS_HOST_WRITE_BIT = <span class="hljs-number">0x00004000</span>,<br>    VK_ACCESS_MEMORY_READ_BIT = <span class="hljs-number">0x00008000</span>,<br>    VK_ACCESS_MEMORY_WRITE_BIT = <span class="hljs-number">0x00010000</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_ACCESS_NONE = <span class="hljs-number">0</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_transform_feedback</span><br>    VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = <span class="hljs-number">0x02000000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_transform_feedback</span><br>    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = <span class="hljs-number">0x04000000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_transform_feedback</span><br>    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = <span class="hljs-number">0x08000000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_conditional_rendering</span><br>    VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = <span class="hljs-number">0x00100000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_blend_operation_advanced</span><br>    VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = <span class="hljs-number">0x00080000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br>    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = <span class="hljs-number">0x00200000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br>    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = <span class="hljs-number">0x00400000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_fragment_density_map</span><br>    VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = <span class="hljs-number">0x01000000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_fragment_shading_rate</span><br>    VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = <span class="hljs-number">0x00800000</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_device_generated_commands</span><br>    VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV = <span class="hljs-number">0x00020000</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_device_generated_commands</span><br>    VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV = <span class="hljs-number">0x00040000</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_shading_rate_image</span><br>    VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR,<br>  <span class="hljs-comment">// Provided by VK_NV_ray_tracing</span><br>    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR,<br>  <span class="hljs-comment">// Provided by VK_NV_ray_tracing</span><br>    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR,<br>  <span class="hljs-comment">// Provided by VK_KHR_synchronization2</span><br>    VK_ACCESS_NONE_KHR = VK_ACCESS_NONE,<br>  <span class="hljs-comment">// Provided by VK_EXT_device_generated_commands</span><br>    VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT = VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV,<br>  <span class="hljs-comment">// Provided by VK_EXT_device_generated_commands</span><br>    VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT = VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV,<br>&#125; VkAccessFlagBits;<br></code></pre></td></tr></table></figure><p>每一个枚举都代表一种资源访问类型，我们这里不做过多解释。</p><p><a href="https://www.zhihu.com/question/424430509/answer/1632072443"><code>VkDependencyFlagBits</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDependencyFlagBits</span> &#123;</span><br>    VK_DEPENDENCY_BY_REGION_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//表示依赖关系是基于区域的。这意味着在源和目标子通道之间的依赖关系是区域相关的，确保在访问同一区域时不会发生数据竞争</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_DEPENDENCY_DEVICE_GROUP_BIT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//表示依赖关系涉及设备组。这在使用多个 GPU 时特别有用，确保在设备组中的不同设备之间的操作顺序</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_DEPENDENCY_VIEW_LOCAL_BIT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//表示依赖关系是视图局部的。这通常用于多视图渲染，确保在不同视图之间的依赖关系是局部的，适合多视图场景的渲染</span><br>  <span class="hljs-comment">// Provided by VK_EXT_attachment_feedback_loop_layout</span><br>    VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//这是一个扩展标志，表示存在反馈循环的依赖关系。这通常用于处理需要在多个渲染通道之间进行反馈的场景</span><br>  <span class="hljs-comment">// Provided by VK_KHR_multiview</span><br>    VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = VK_DEPENDENCY_VIEW_LOCAL_BIT,<br>  <span class="hljs-comment">// Provided by VK_KHR_device_group</span><br>    VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = VK_DEPENDENCY_DEVICE_GROUP_BIT,<br>&#125; VkDependencyFlagBits;<br></code></pre></td></tr></table></figure><p>根据前文的叙述，我们需要重新设置开始处子通道和我们设置的子通道之间的依赖关系。相应的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSubpassDependency dependency&#123;&#125;;<br><br>dependency.srcSubpass = VK_SUBPASS_EXTERNAL;<br>dependency.dstSubpass = <span class="hljs-number">0</span>;<br>dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;<br>dependency.srcAccessMask = <span class="hljs-number">0</span>;<br>dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;<br>dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;<br></code></pre></td></tr></table></figure><p>我们将<i><font color="Orange">srcStageMask</font></i>设置为<i><font color="Red">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>，这样开始时的图像格式转换就会发生在该阶段之后，此时可以保证图像是存在有效的。另外，将<i><font color="Orange">srcAccessMask</font></i>设置为0意味着我们并不需要等待开始处子通道完成任何资源访问操作，事实上我们也没有在该子通道处有什么特别的操作要进行。之后<i><font color="Orange">dstStageMask</font></i>同样设置为<i><font color="Red">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>，资源访问操作<i><font color="Orange">dstAccessMask</font></i>设置为<i><font color="Red">VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</font></i>以指定将渲染结果写入帧缓冲的操作要在图像格式已经成功转换之后再执行。（不过知乎上的<a href="https://www.zhihu.com/question/424430509/answer/1632072443">一篇文章</a>里说这部分其实写的有问题，我也始终感觉这一部分想得不明不白的。。。望高人指点</p><p>最后不要忘了在<i><font color="Orange">renderPassInfo</font></i>中指定依赖关系成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">renderPassInfo.dependencyCount = <span class="hljs-number">1</span>;<br>renderPassInfo.pDependencies = &amp;dependency;<br></code></pre></td></tr></table></figure><hr><h2 id="显示图像">显示图像</h2><p>最后，我们只需要将渲染好的图像显示到屏幕上即可。为此，我们需要首先填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPresentInfoKHR.html"><code>VkPresentInfoKHR</code></a>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPresentInfoKHR</span> &#123;</span><br>    VkStructureType          sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*              pNext;<br>    <span class="hljs-type">uint32_t</span>                 waitSemaphoreCount;<br>    <span class="hljs-type">const</span> VkSemaphore*       pWaitSemaphores;<br>    <span class="hljs-type">uint32_t</span>                 swapchainCount;<br>    <span class="hljs-type">const</span> VkSwapchainKHR*    pSwapchains;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*          pImageIndices;<br>    VkResult*                pResults;<br>&#125; VkPresentInfoKHR;<br></code></pre></td></tr></table></figure><p>这里只需要解释一下最后一个成员<i><font color="Orange">pResults</font></i>，该参数会返回每个对应交换链显示图像的结果是否成功。如果只有一个交换链（事实上绝大多数的情况也是如此），那么就没有必要指定这个成员，因为我们可以直接使用显示函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>的返回值来查看图像显示是否成功。</p><p>我们的填写代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPresentInfoKHR presentInfo&#123;&#125;;<br>presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;<br><br>presentInfo.waitSemaphoreCount = <span class="hljs-number">1</span>;<br>presentInfo.pWaitSemaphores = signalSemaphores;<br><br>VkSwapchainKHR swapChains[] = &#123;swapChain&#125;;<br>presentInfo.swapchainCount = <span class="hljs-number">1</span>;<br>presentInfo.pSwapchains = swapChains;<br>presentInfo.pImageIndices = &amp;imageIndex;<br></code></pre></td></tr></table></figure><p>由于我们需要等待渲染操作结束才能显示图像，因此<i><font color="Orange">pWaitSemaphores</font></i>应该设置为<i><font color="Orange">renderFinishedSemaphore</font></i>。</p><p>最后，使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>显示图像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);<br></code></pre></td></tr></table></figure><p>注意到这里我们并没有使用这个函数调用的返回值，包括之前在调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html"><code>vkAcquireNextImageKHR</code></a>的时候我们也没有这么做，因为和之前的函数不同，这两个函数即使返回错误值，也不意味着我们需要立即终止我们的程序，所以我们会在之后的章节中单独处理这两个函数的调试。</p><p>这样，我们终于成功绘制了Vulkan中的第一个三角形！天哪，这真是一段漫长的旅程。。。</p><figure><img src="/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/first_triangle.png" alt="第一个三角形"><figcaption aria-hidden="true">第一个三角形</figcaption></figure><p>不过没有那么多时间沉浸在自我感动中了，因为接下来赶到战场的是验证层的报错。。。是的，心满意足地欣赏完近1000行代码编写出来的“鸿篇巨制”之后，准备退出程序的你此时却必然会受到验证层的最后一击：</p><figure><img src="/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/validation_error.png" alt="不老实的验证层"><figcaption aria-hidden="true">不老实的验证层</figcaption></figure><p>这是为什么？</p><p>事实上原因在于我们在最后一帧结束程序时，退出循环后CPU会执行<i><font color="Green">cleanup</font></i>函数来清理掉所有Vulkan对象，但是还记得我们之前说GPU上的一些函数在返回后相应的工作还可能在运行吗？问题就出在这里！有些GPU上的工作还没执行完毕我们就清理掉了相应的资源！</p><p>解决方法也有很多，我们这里采取一种简单粗暴的方式即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mainLoop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">glfwWindowShouldClose</span>(window)) &#123;<br>        <span class="hljs-built_in">glfwPollEvents</span>();<br>        <span class="hljs-built_in">drawFrame</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">vkDeviceWaitIdle</span>(device);<br>&#125;<br></code></pre></td></tr></table></figure><p>在渲染循环之后加入<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDeviceWaitIdle.html"><code>vkDeviceWaitIdle</code></a>来等待所有的队列操作执行完毕再进行清理工作，这样我们终于可以安心退出程序而不用担心验证层的抱怨了！太棒了！</p><hr><h2 id="一个小疑点">一个小疑点</h2><p>关于这一节我仍然有一个疑问没有解决，那就是关于显示图像的同步问题。</p><p>假设这么一种情况：当前帧运行到了<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>，由于该函数运行在GPU上，它可能没有完成显示就已经返回了，此时<i><font color="Green">drawFrame</font></i>函数进入下一帧，由于此时所有的信号量、栅栏、命令缓冲等都处于可用状态，因此下一帧会畅通无阻地运行到<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html"><code>vkQueuePresentKHR</code></a>，那么万一此时上一帧的显示因为种种原因还没有完成呢？岂不是会同时显示两帧图像？</p><p>我发现Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Rendering_and_presentation#page_What-to-choose">Renderingand presentation</a>章节评论区中有人也提出了类似的问题：</p><figure><img src="/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/comments.png" alt="疑点"><figcaption aria-hidden="true">疑点</figcaption></figure><p>可以看到有人给出了一些可能的解释，不过也并没有完全回答这种类似的问题。因此暂时保留该疑问，以待日后思考~</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/">上一篇：命令缓冲</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/20/CG_api/vulkan/vulkan_tutorial/%E5%A4%9A%E5%B8%A7%E5%90%8C%E6%97%B6%E6%B8%B2%E6%9F%93/">下一篇：多帧同时渲染</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>命令缓冲</title>
    <link href="/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/"/>
    <url>/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在Vulkan中，执行命令不是简单地通过调用函数来实现的。我们需要将命令记录在命令缓冲中，然后将该缓冲提交给队列执行。这么做的优点是我们可以将所有命令统一打包提交以便Vulkan优化执行过程。</p><p>记录下绘制一个三角形需要的命令主要分为三步：</p><ul><li>创建命令池<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandPool.html"><code>VkCommandPool</code></a></li><li>从命令池分配出需要数目的命令缓冲<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html"><code>VkCommandBuffer</code></a></li><li>录制需要执行的命令到分配出的命令缓冲</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Command_buffers">Commandbuffers</a>章节。</p><hr><h2 id="创建命令池">创建命令池</h2><p>命令缓冲必须从某个管理缓冲内存的内存池中分配。因此我们在应用程序类内添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandPool.html"><code>VkCommandPool</code></a>类型的成员<i><font color="Orange">commandPool</font></i>，并且创建一个<i><font color="Green">voidcreateCommandPool()</font></i>函数来构建该对象。</p><p>首先我们当然需要填写构建信息<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateInfo.html"><code>VkCommandPoolCreateInfo</code></a>，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkCommandPoolCreateInfo</span> &#123;</span><br>    VkStructureType             sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                 pNext;<br>    VkCommandPoolCreateFlags    flags;<br>    <span class="hljs-type">uint32_t</span>                    queueFamilyIndex;<br>&#125; VkCommandPoolCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>可以是以下值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkCommandPoolCreateFlagBits</span> &#123;</span><br>    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = <span class="hljs-number">0x00000001</span>,<br>    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = <span class="hljs-number">0x00000002</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_COMMAND_POOL_CREATE_PROTECTED_BIT = <span class="hljs-number">0x00000004</span>,<br>&#125; VkCommandPoolCreateFlagBits;<br></code></pre></td></tr></table></figure><p>我们来详细解释一下这些标志位：</p><ul><li><p><i><font color="Red">VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</font></i>标志位表明从这个命令池分配的命令缓冲都是临时的，也就是说它们会经常地被重置或释放再分配。这可以帮助命令池调整它的内存管理行为，适合于动态场景中快速更换命令缓冲区的情况。</p></li><li><p><i><font color="Red">VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</font></i>标志位设置后，将允许显示使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkResetCommandBuffer.html"><code>vkResetCommandBuffer</code></a>重置单个命令缓冲（如果该标志位没有设置，则一定不能使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkResetCommandBuffer.html"><code>vkResetCommandBuffer</code></a>重置命令缓冲，只能隐式通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkBeginCommandBuffer.html">vkBeginCommandBuffer</a>重置或者直接释放并重新分配新的缓冲）。这一版用于需要反复使用相同命令缓冲区的场景。</p></li><li><p><i><font color="Red">VK_COMMAND_POOL_CREATE_PROTECTED_BIT</font></i>用于创建保护模式命令池从而分配保护模式命令缓冲区，这些缓冲区只能在具有保护访问权限的设备上执行。这通常用于处理敏感数据的场景，例如加密或DRM（数字版权管理）内容，确保数据不会被未授权的访问所读取或修改。</p></li></ul><p>我们在绘制三角形时每一帧使用的都是相同的命令，因此可以将该标志设置为<i><font color="Red">VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</font></i>。</p><p>接下来，<i><font color="Orange">queueFamilyIndex</font></i>指定从该命令池分配的命令缓冲的提交队列。每个命令池分配的缓冲只能提交至一种队列。我们希望录制绘制三角形的命令，因此应该将该成员设置为图形队列。</p><p>最终填写代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">QueueFamilyIndices queueFamilyIndices = <span class="hljs-built_in">findQueueFamilies</span>(physicalDevice);<br><br>VkCommandPoolCreateInfo poolInfo&#123;&#125;;<br>poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;<br>poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;<br>poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily.<span class="hljs-built_in">value</span>();<br></code></pre></td></tr></table></figure><p>然后就可以创建命令池了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateCommandPool</span>(device, &amp;poolInfo, <span class="hljs-literal">nullptr</span>, &amp;commandPool) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create command pool!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="分配命令缓冲">分配命令缓冲</h2><p>构建好命令池后，我们就可以分配命令缓冲了。</p><p>我们目前只需要一个命令缓冲区，因此在类内创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html"><code>VkCommandBuffer</code></a>类型的成员<i><font color="Orange">commandBuffer</font></i>，并且创建一个<i><font color="Green">voidcreateCommandBuffer()</font></i>来分配该对象。</p><p>为了从命令池分配该对象，我们需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBufferAllocateInfo.html"><code>VkCommandBufferAllocateInfo</code></a>信息。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkCommandBufferAllocateInfo</span> &#123;</span><br>    VkStructureType         sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*             pNext;<br>    VkCommandPool           commandPool;<br>    VkCommandBufferLevel    level;<br>    <span class="hljs-type">uint32_t</span>                commandBufferCount;<br>&#125; VkCommandBufferAllocateInfo;<br></code></pre></td></tr></table></figure><p>这里唯一需要解释的成员是<i><font color="Orange">level</font></i>。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBufferLevel.html"><code>VkCommandBufferLevel</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkCommandBufferLevel</span> &#123;</span><br>    VK_COMMAND_BUFFER_LEVEL_PRIMARY = <span class="hljs-number">0</span>,<br>    VK_COMMAND_BUFFER_LEVEL_SECONDARY = <span class="hljs-number">1</span>,<br>&#125; VkCommandBufferLevel;<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><i><font color="Red">VK_COMMAND_BUFFER_LEVEL_PRIMARY</font></i>指定该命令缓冲区为初级命令缓冲，意味着该缓冲区可以直接提交队列执行，但不能被其它命令缓冲调用</li><li><i><font color="Red">VK_COMMAND_BUFFER_LEVEL_SECONDARY</font></i>指定该命令缓冲区为次级命令缓冲，意味着该缓冲区不能直接提交队列执行，但是可以被初级命令缓冲调用</li></ul><p>我们无需使用次级命令缓冲，因此<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBufferAllocateInfo.html"><code>VkCommandBufferAllocateInfo</code></a>信息填写与缓冲区分配代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkCommandBufferAllocateInfo allocInfo&#123;&#125;;<br>allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;<br>allocInfo.commandPool = commandPool;<br>allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;<br>allocInfo.commandBufferCount = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkAllocateCommandBuffers</span>(device, &amp;allocInfo, &amp;commandBuffer) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to allocate command buffers!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="录制命令">录制命令</h2><p>接下来我们可以开始录制命令了。创建一个<i><font color="Green">voidrecordCommandBuffer(VkCommandBuffer commandBuffer, uint32_timageIndex)</font></i>函数用于命令的录制。使用图像索引作为参数是因为我们希望给每个图像绘制都录制好相应的绘制命令。</p><p>为了开始录制，我们总是需要填写一个指定命令缓冲使用上的一些细节的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandBufferBeginInfo.html"><code>VkCommandBufferBeginInfo</code></a>结构体。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkCommandBufferBeginInfo</span> &#123;</span><br>    VkStructureType                          sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                              pNext;<br>    VkCommandBufferUsageFlags                flags;<br>    <span class="hljs-type">const</span> VkCommandBufferInheritanceInfo*    pInheritanceInfo;<br>&#125; VkCommandBufferBeginInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>指定命令缓冲的用法有关信息，它可以是如下值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkCommandBufferUsageFlagBits</span> &#123;</span><br>    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = <span class="hljs-number">0x00000001</span>,<br>    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = <span class="hljs-number">0x00000002</span>,<br>    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = <span class="hljs-number">0x00000004</span>,<br>&#125; VkCommandBufferUsageFlagBits;<br></code></pre></td></tr></table></figure><p>我们分别解释每个枚举的含义：</p><ul><li><i><font color="Red">VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</font></i>表明该命令缓冲只会被提交一次，提交后该缓冲区立刻变得无效。在两次提交之间该缓冲区一定要被重置并且重新录制。</li><li><i><font color="Red">VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</font></i>针对次级缓冲区，表明该缓冲完全处于一个渲染通道中。这意味着该次级命令缓冲区的命令可以在当前渲染通道中继续执行，而不需要结束当前的渲染通道。这允许Vulkan驱动程序在执行命令时进行更高效的优化。如果不设置该标志位则一定要在一个新的渲染通道中执行该次级缓冲中的命令（也就是说如果当前已经使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html"><code>vkCmdBeginRenderPass</code></a>开启了一个渲染通道并且还未结束，那么如果要调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdExecuteCommands.html"><code>vkCmdExecuteCommands</code></a>录制执行次级缓冲的命令，那么一定要在这之前使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdEndRenderPass.html"><code>vkCmdEndRenderPass</code></a>结束当前渲染通道并开启一个新的渲染通道来执行次级缓冲命令）。如果针对一个初级缓冲设置该标志位，则该标志位会被忽略。</li><li><i><font color="Red">VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</font></i>针对次级缓冲，表明该命令缓冲区可以在它处于待处理（pending）状态时被多次提交到同一个队列族的任何队列。这意味着我们可以在命令缓冲区尚未被执行完成时，重新提交它。这个标志位还允许一个命令缓冲区被录制到多个主命令缓冲区中。这意味着我们可以在不同的主命令缓冲区中重复使用同一个次级命令缓冲区，而不需要重新录制（如果不设置该标志位，那么次级缓冲一旦在某个初级缓冲中使用过后就立马变成无效状态）。</li></ul><p>我们目前不需要设置任何标志位。</p><p>接下来的<i><font color="Orange">pInheritanceInfo</font></i>仅用于次级缓冲区，它用于指定该次级缓冲从调用它的初级缓冲中继承的一些渲染通道状态信息。我们这里无需指定。</p><p>填写好该结构体后，我们就可以开启录制了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkCommandBufferBeginInfo beginInfo&#123;&#125;;<br>beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;<br>beginInfo.flags = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>beginInfo.pInheritanceInfo = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkBeginCommandBuffer</span>(commandBuffer, &amp;beginInfo) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to begin recording command buffer!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们希望录制绘制命令，那么首先需要开启绘制使用的渲染通道，这通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html"><code>vkCmdBeginRenderPass</code></a>完成（Vulkan中所有的录制命令名称中都带有<strong>Cmd</strong>）。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html"><code>vkCmdBeginRenderPass</code></a>的主要功能包括：</p><ul><li><strong>设置渲染状态</strong>：通过指定渲染通道的描述符，设置当前的渲染状态，包括使用的帧缓冲、附件格式等。</li><li><strong>绑定帧缓冲</strong>：绑定与渲染通道相关的帧缓冲对象，这些帧缓冲将用于存储渲染结果。</li><li><strong>初始化附件</strong>：根据渲染通道的设置，初始化颜色、深度和模板附件。这些附件会被清空或设置为特定的初始值（如清除颜色）。</li><li><strong>开始绘制命令</strong>：一旦渲染通道开始，后续的绘制命令（如绘制三角形、绑定管线等）将被记录并在该渲染通道内执行。</li></ul><p>为了实现这些功能，我们需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRenderPassBeginInfo.html"><code>VkRenderPassBeginInfo</code></a>结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkRenderPassBeginInfo</span> &#123;</span><br>    VkStructureType        sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*            pNext;<br>    VkRenderPass           renderPass;<br>    VkFramebuffer          framebuffer;<br>    VkRect2D               renderArea;<span class="hljs-comment">//着色器绘制的区域，此区域之外的像素颜色将未定义</span><br>    <span class="hljs-type">uint32_t</span>               clearValueCount;<br>    <span class="hljs-type">const</span> VkClearValue*    pClearValues;<br>&#125; VkRenderPassBeginInfo;<br></code></pre></td></tr></table></figure><p>每个成员都是易于理解的，我们如下填写该结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkRenderPassBeginInfo renderPassInfo&#123;&#125;;<br>renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;<br>renderPassInfo.renderPass = renderPass;<br>renderPassInfo.framebuffer = swapChainFramebuffers[imageIndex];<br>renderPassInfo.renderArea.offset = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>renderPassInfo.renderArea.extent = swapChainExtent;<br>VkClearValue clearColor = &#123;&#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;&#125;;<span class="hljs-comment">//使用完全不透明的黑色作为清除色（我们之前指定了渲染开始前图像的颜色将会重置为清除色）</span><br>renderPassInfo.clearValueCount = <span class="hljs-number">1</span>;<br>renderPassInfo.pClearValues = &amp;clearColor;<br></code></pre></td></tr></table></figure><p>接下来只需调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html"><code>vkCmdBeginRenderPass</code></a>即可。该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdBeginRenderPass</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkRenderPassBeginInfo*                pRenderPassBegin,</span><br><span class="hljs-params">    VkSubpassContents                           contents)</span>;<br></code></pre></td></tr></table></figure><p>需要解释的是第三个参数。<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/"><code>VkSubpassContents</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkSubpassContents</span> &#123;</span><br>    VK_SUBPASS_CONTENTS_INLINE = <span class="hljs-number">0</span>,<span class="hljs-comment">//表示在渲染通道中使用的是内联命令。这意味着所有的绘制命令和状态设置都直接在主命令缓冲区中执行，而不涉及任何次级命令缓冲区的调用。</span><br>    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = <span class="hljs-number">1</span>,<span class="hljs-comment">//表示在渲染通道中将使用次级命令缓冲区。也就是说，主命令缓冲区会调用一个或多个次级命令缓冲区来执行绘制命令和状态设置。在这种模式下，主命令缓冲区只能使用 vkCmdExecuteCommands 这个命令来执行次级命令缓冲区的内容。也就是说，您不能在这个命令缓冲区中执行其他类型的命令，直到调用 vkCmdNextSubpass 或 vkCmdEndRenderPass。</span><br>  <span class="hljs-comment">// Provided by VK_KHR_maintenance7</span><br>    VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR = <span class="hljs-number">1000451000</span>,<span class="hljs-comment">//表示在同一个渲染通道中可以同时使用内联命令和次级命令缓冲区。这允许更灵活的命令组织，可以在同一个渲染通道中混合使用这两种类型的命令。</span><br>  <span class="hljs-comment">// Provided by VK_EXT_nested_command_buffer</span><br>    VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT = VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR,<br>&#125; VkSubpassContents;<br></code></pre></td></tr></table></figure><p>我们只使用初级缓冲，因此该参数应该设定为<i><font color="Red">VK_SUBPASS_CONTENTS_INLINE</font></i>。</p><p>然后调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html"><code>vkCmdBeginRenderPass</code></a>绑定渲染通道：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdBeginRenderPass</span>(commandBuffer, &amp;renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);<br></code></pre></td></tr></table></figure><p>现在我们就可以录制绘制命令了。首先需要绑定渲染管线对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdBindPipeline</span>(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);<br></code></pre></td></tr></table></figure><p>第二个参数指定我们绑定的是图形渲染管线而不是计算管线。</p><p>另外，在之前的<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/">固定管线</a>章节，我们指定视口裁剪阶段为动态阶段，这也就意味着在渲染管线对象中我们并没有设置关于它们的信息，这里在录制绘制命令之前我们必须把这些动态阶段信息也给录制好，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkViewport viewport&#123;&#125;;<br>viewport.x = <span class="hljs-number">0.0f</span>;<br>viewport.y = <span class="hljs-number">0.0f</span>;<br>viewport.width = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(swapChainExtent.width);<br>viewport.height = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(swapChainExtent.height);<br>viewport.minDepth = <span class="hljs-number">0.0f</span>;<br>viewport.maxDepth = <span class="hljs-number">1.0f</span>;<br><span class="hljs-built_in">vkCmdSetViewport</span>(commandBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;viewport);<br><br>VkRect2D scissor&#123;&#125;;<br>scissor.offset = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>scissor.extent = swapChainExtent;<br><span class="hljs-built_in">vkCmdSetScissor</span>(commandBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;scissor);<br></code></pre></td></tr></table></figure><p>现在渲染管线和渲染通道都已经就绪，我们就可以录制最终的绘制命令了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdDraw</span>(commandBuffer, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDraw.html"><code>vkCmdDraw</code></a>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdDraw</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    vertexCount,<span class="hljs-comment">//顶点数</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    instanceCount,<span class="hljs-comment">//实例数</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    firstVertex,<span class="hljs-comment">//首顶点偏移</span></span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    firstInstance<span class="hljs-comment">//首实例偏移);</span></span><br></code></pre></td></tr></table></figure><p>所有参数的含义都是一目了然的。我们的应用程序并不使用实例渲染，因此第三个参数指定为1即可。对实例渲染不熟的读者可以参考<a href="https://learnopengl.com/Advanced-OpenGL/Instancing">这篇文章</a>。</p><p>现在我们已经完成了绘制一个基本的三角形所有命令的录制，最后结束渲染管线与命令录制即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkCmdEndRenderPass</span>(commandBuffer);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkEndCommandBuffer</span>(commandBuffer) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to record command buffer!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%B8%A7%E7%BC%93%E5%86%B2/">上一篇：帧缓冲</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/">下一篇：渲染和显示</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>帧缓冲</title>
    <link href="/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%B8%A7%E7%BC%93%E5%86%B2/"/>
    <url>/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%B8%A7%E7%BC%93%E5%86%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在之前的章节中我们已经提到多次帧缓冲了，但直到现在我们也还没有创建一个真正的帧缓冲对象。本节就来创建相应的帧缓冲对象。</p><p>帧缓冲对象可以看成是对渲染通道中指定的附件以及之前创建的图像视图的收纳箱。对于每一个交换链中的图像，我们都将创建一个与之相对应的帧缓冲对象。因此，我们需要在类内添加一个向量成员：<i><font color="Orange">std::vector<VkFramebuffer>swapChainFramebuffers</VkFramebuffer></font></i>，并且添加一个成员函数<i><font color="Green">voidcreateFramebuffers()</font></i>来完成帧缓冲的构建。</p><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Framebuffers">Framebuffers</a>章节。</p><hr><h2 id="创建帧缓冲对象">创建帧缓冲对象</h2><p>首先，我们还是需要将帧缓冲向量大小调整为图像视图向量的大小：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createFramebuffers</span><span class="hljs-params">()</span> </span>&#123;<br>    swapChainFramebuffers.<span class="hljs-built_in">resize</span>(swapChainImageViews.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们需要循环填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFramebufferCreateInfo.html"><code>VkFramebufferCreateInfo</code></a>，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkFramebufferCreateInfo</span> &#123;</span><br>    VkStructureType             sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                 pNext;<br>    VkFramebufferCreateFlags    flags;<br>    VkRenderPass                renderPass;     <span class="hljs-comment">//兼容的渲染管线</span><br>    <span class="hljs-type">uint32_t</span>                    attachmentCount;<span class="hljs-comment">//图像视图数量</span><br>    <span class="hljs-type">const</span> VkImageView*          pAttachments;<span class="hljs-comment">//图像视图</span><br>    <span class="hljs-type">uint32_t</span>                    width;<br>    <span class="hljs-type">uint32_t</span>                    height;<br>    <span class="hljs-type">uint32_t</span>                    layers;    <span class="hljs-comment">//图像层数</span><br>&#125; VkFramebufferCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>可以是下面列出的枚举值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkFramebufferCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//表示帧缓冲的附件不需要在创建帧缓冲时关联具体的图像视图。这意味着帧缓冲可以在创建时不直接指定图像，而是通过其他方式（如在渲染过程中）动态创建或绑定图像。</span><br>  <span class="hljs-comment">// Provided by VK_KHR_imageless_framebuffer</span><br>    VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR = VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT,<br>&#125; VkFramebufferCreateFlagBits;<br></code></pre></td></tr></table></figure><p>这里需要解释一下所谓“兼容的渲染管线”的意思：在 Vulkan中，判断一个帧缓冲和一个渲染通道是否兼容主要涉及以下几个方面：</p><ul><li><strong>颜色、深度和模板附件格式</strong>：帧缓冲中的每个附件的格式必须与渲染通道中定义的相应附件格式匹配。你可以通过检查帧缓冲创建时指定的图像视图的格式与渲染通道中附件描述符的格式是否一致来确认。</li><li><strong>样本数</strong>：帧缓冲中的每个附件的样本数必须与渲染通道中相应附件的样本数相同。这意味着，如果渲染通道中的某个附件是多重采样的，帧缓冲中的对应附件也必须是多重采样的，并且样本数必须一致。</li><li><strong>附件数量</strong>：帧缓冲中的附件数量必须与渲染通道中定义的附件数量相同。如果渲染通道定义了多个颜色附件，帧缓冲也必须提供相同数量的颜色附件。</li><li><strong>图像视图的维度</strong>：帧缓冲中的图像视图的维度（例如，2D、3D、立方体等）必须与渲染通道中相应的附件类型匹配。</li><li><strong>图像视图的大小</strong>：帧缓冲中每个图像视图的宽度和高度必须与渲染通道中的相应附件的宽度和高度匹配。</li></ul><p>于是，我们的帧缓冲创建过程如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainImageViews.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    VkImageView attachments[] = &#123;<br>        swapChainImageViews[i]<br>    &#125;;<br><br>    VkFramebufferCreateInfo framebufferInfo&#123;&#125;;<br>    framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;<br>    framebufferInfo.renderPass = renderPass;<br>    framebufferInfo.attachmentCount = <span class="hljs-number">1</span>;<br>    framebufferInfo.pAttachments = attachments;<br>    framebufferInfo.width = swapChainExtent.width;<br>    framebufferInfo.height = swapChainExtent.height;<br>    framebufferInfo.layers = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateFramebuffer</span>(device, &amp;framebufferInfo, <span class="hljs-literal">nullptr</span>, &amp;swapChainFramebuffers[i]) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create framebuffer!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/">上一篇：渲染管线</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2/">下一篇：命令缓冲</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>渲染管线</title>
    <link href="/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
    <url>/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>现在我们已经准备好了一切创建渲染管线需要的信息，主要包括四大块：</p><ul><li>可编程管线阶段（我们只指定了顶点着色器和片段着色器）</li><li>固定管线阶段</li><li>管线布局</li><li>渲染通道</li></ul><p>下面我们在类内新增一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipeline.html"><code>VkPipeline</code></a>类型的成员<i><font color="Orange">graphicsPipeline</font></i>来保存渲染管线对象，并且在<i><font color="Green">createGraphicsPipeline</font></i>函数中创建该对象（注意创建代码要放在销毁着色器模型之前，因为在创建管线对象的时候还需要将着色器模型包含的字节码编译为机器码）。</p><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Conclusion">Conclusion</a>章节。</p><hr><h2 id="创建渲染管线">创建渲染管线</h2><p>首先填写创建信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkGraphicsPipelineCreateInfo.html"><code>VkGraphicsPipelineCreateInfo</code></a>，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkGraphicsPipelineCreateInfo</span> &#123;</span><br>    VkStructureType                                  sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                      pNext;<br>    VkPipelineCreateFlags                            flags;<br>    <span class="hljs-type">uint32_t</span>                                         stageCount;<br>    <span class="hljs-type">const</span> VkPipelineShaderStageCreateInfo*           pStages;<br>    <span class="hljs-type">const</span> VkPipelineVertexInputStateCreateInfo*      pVertexInputState;<br>    <span class="hljs-type">const</span> VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;<br>    <span class="hljs-type">const</span> VkPipelineTessellationStateCreateInfo*     pTessellationState;<br>    <span class="hljs-type">const</span> VkPipelineViewportStateCreateInfo*         pViewportState;<br>    <span class="hljs-type">const</span> VkPipelineRasterizationStateCreateInfo*    pRasterizationState;<br>    <span class="hljs-type">const</span> VkPipelineMultisampleStateCreateInfo*      pMultisampleState;<br>    <span class="hljs-type">const</span> VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;<br>    <span class="hljs-type">const</span> VkPipelineColorBlendStateCreateInfo*       pColorBlendState;<br>    <span class="hljs-type">const</span> VkPipelineDynamicStateCreateInfo*          pDynamicState;<br>    VkPipelineLayout                                 layout;<br>    VkRenderPass                                     renderPass;<br>    <span class="hljs-type">uint32_t</span>                                         subpass;<br>    VkPipeline                                       basePipelineHandle;<br>    <span class="hljs-type">int32_t</span>                                          basePipelineIndex;<br>&#125; VkGraphicsPipelineCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>比较复杂，可以参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCreateFlagBits.html">这个页面</a>。我们这里并不需要额外的标志功能。</p><p>除了最后两个成员之外，其它的成员分别指定我们之前已经设定好的各个阶段的信息，我们只需引用那些我们已经设定好的信息和对象就好了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkGraphicsPipelineCreateInfo pipelineInfo&#123;&#125;;<br>pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;<br>pipelineInfo.stageCount = <span class="hljs-number">2</span>;<br>pipelineInfo.pStages = shaderStages;<br>pipelineInfo.pVertexInputState = &amp;vertexInputInfo;<br>pipelineInfo.pInputAssemblyState = &amp;inputAssembly;<br>pipelineInfo.pViewportState = &amp;viewportState;<br>pipelineInfo.pRasterizationState = &amp;rasterizer;<br>pipelineInfo.pMultisampleState = &amp;multisampling;<br>pipelineInfo.pDepthStencilState = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br>pipelineInfo.pColorBlendState = &amp;colorBlending;<br>pipelineInfo.pDynamicState = &amp;dynamicState;<br>pipelineInfo.layout = pipelineLayout;<br>pipelineInfo.renderPass = renderPass;<br>pipelineInfo.subpass = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>这里注意，每个渲染管线中只能指定一个子通道（即使指定的渲染通道有多个子通道也只能指定其中一个子通道）！这意味着如果有多个<code>subpass</code>，我们需要为每个子通道创建单独的图形管线。</p><p>最后，<i><font color="Orange">basePipelineHandle</font></i>指定一个构建好的渲染管线对象，新的渲染管线对象将会从这个对象衍生出来；同样，<i><font color="Orange">basePipelineIndex</font></i>指定某个基础管线的索引，新的管线将从它衍生相互来，如果指定一个负数，则代表不使用该衍生功能。注意，这两个成员是互斥的，也就是说我们不能同时指定这二者为一个有效的对象。我们这里并不需要派生，因此只需如下设置即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; <span class="hljs-comment">// Optional</span><br>pipelineInfo.basePipelineIndex = <span class="hljs-number">-1</span>; <span class="hljs-comment">// Optional</span><br></code></pre></td></tr></table></figure><p>最后我们可以创建渲染管线对象了！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateGraphicsPipelines</span>(device, VK_NULL_HANDLE, <span class="hljs-number">1</span>, &amp;pipelineInfo, <span class="hljs-literal">nullptr</span>, &amp;graphicsPipeline) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create graphics pipeline!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateGraphicsPipelines.html"><code>vkCreateGraphicsPipelines</code></a>比我们之前见过的一般的Vulkan构建函数多了两个参数。该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkCreateGraphicsPipelines</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDevice                                    device,</span><br><span class="hljs-params">    VkPipelineCache                             pipelineCache,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    createInfoCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkGraphicsPipelineCreateInfo*         pCreateInfos,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkAllocationCallbacks*                pAllocator,</span><br><span class="hljs-params">    VkPipeline*                                 pPipelines)</span>;<br></code></pre></td></tr></table></figure><p>第二个参数指定一个<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineCache.html"><code>VkPipelineCache</code></a>类型的管线缓冲对象。管线缓冲对象可以存储多次管线构造函数调用有关的数据和信息以便加速之后的管线构造过程。本教程不涉及该对象的使用。</p><p>下面的的<i><font color="Orange">createInfoCount</font></i>指定管线构建信息的个数。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateGraphicsPipelines.html"><code>vkCreateGraphicsPipelines</code></a>允许我们一次性构建多个渲染管线以提高效率，因此我们需要指定管线个数。</p><p>大功告成！接下来我们终于可以开始着手构建帧缓冲并且为最后的绘制做好准备了！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/">上一篇：渲染通道</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%B8%A7%E7%BC%93%E5%86%B2/">下一篇：帧缓冲</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>渲染通道</title>
    <link href="/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/"/>
    <url>/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在创建渲染管线对象之前，我们还需要指定渲染目标需要的颜色附件、深度附件、模板附件的数目，以及它们使用的采样数和被使用的方式。这些信息将通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRenderPass.html"><code>VkRenderPass</code></a>来指定。接下来我们将创建一个<i><font color="Green">voidcreateRenderPass()</font></i>函数来创建这个对象。主要的创建过程分三步：</p><ul><li>指定附件信息</li><li>指定子通道附件引用并创建子通道（subPass）</li><li>创建渲染通道</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes"><code>Render passes</code></a>章节。</p><hr><h2 id="指定附件描述">指定附件描述</h2><p>附件描述<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescription.html"><code>VkAttachmentDescription</code></a>结构体的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkAttachmentDescription</span> &#123;</span><br>    VkAttachmentDescriptionFlags    flags;<br>    VkFormat                        format;<br>    VkSampleCountFlagBits           samples;<br>    VkAttachmentLoadOp              loadOp;<br>    VkAttachmentStoreOp             storeOp;<br>    VkAttachmentLoadOp              stencilLoadOp;<br>    VkAttachmentStoreOp             stencilStoreOp;<br>    VkImageLayout                   initialLayout;<br>    VkImageLayout                   finalLayout;<br>&#125; VkAttachmentDescription;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>可以是如下枚举：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkAttachmentDescriptionFlagBits</span> &#123;</span><br>    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = <span class="hljs-number">0x00000001</span>,<br>&#125; VkAttachmentDescriptionFlagBits;<br></code></pre></td></tr></table></figure><p>若设置了这个唯一的枚举<i><font color="Red">VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT</font></i>，则Vulkan可以优化资源的使用，因为它可以假设某些附件可能会重用同一块内存。</p><p>对于我们的应用而言，我们只需要一个颜色附件，它的格式一定要和交换链的图像格式匹配。因此<i><font color="Orange">format</font></i>需要设置为之前在<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/">交换链</a>章节我们保存在类内的成员<i><font color="Orange">swapChainImageFormat</font></i>的值。</p><p>由于我们不进行多重采样，因此<i><font color="Orange">samples</font></i>设置为<i><font color="Red">VK_SAMPLE_COUNT_1_BIT</font></i>即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createRenderPass</span><span class="hljs-params">()</span> </span>&#123;<br>    VkAttachmentDescription colorAttachment&#123;&#125;;<br>    colorAttachment.format = swapChainImageFormat;<br>    colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来的<i><font color="Orange">loadOp</font></i>和<i><font color="Orange">storeOp</font></i>分别代表在渲染前后应该如何处理图像上的信息，它们针对的是颜色和深度附件。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAttachmentLoadOp.html"><code>VkAttachmentLoadOp</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkAttachmentLoadOp</span> &#123;</span><br>    VK_ATTACHMENT_LOAD_OP_LOAD = <span class="hljs-number">0</span>,<span class="hljs-comment">//保存图像信息不变</span><br>    VK_ATTACHMENT_LOAD_OP_CLEAR = <span class="hljs-number">1</span>,<span class="hljs-comment">//将图像内容重置为特定颜色值，该颜色值可以通过VkClearValue在VkRenderPassBeginInfo中指定</span><br>    VK_ATTACHMENT_LOAD_OP_DONT_CARE = <span class="hljs-number">2</span>,<span class="hljs-comment">//图像内容不会保存，处于未知的状态</span><br>  <span class="hljs-comment">// Provided by VK_KHR_load_store_op_none</span><br>    VK_ATTACHMENT_LOAD_OP_NONE_KHR = <span class="hljs-number">1000400000</span>,<span class="hljs-comment">//不加载附件，不进行任何操作</span><br>  <span class="hljs-comment">// Provided by VK_EXT_load_store_op_none</span><br>    VK_ATTACHMENT_LOAD_OP_NONE_EXT = VK_ATTACHMENT_LOAD_OP_NONE_KHR,<br>&#125; VkAttachmentLoadOp;<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAttachmentStoreOp.html"><code>VkAttachmentStoreOp</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkAttachmentStoreOp</span> &#123;</span><br>    VK_ATTACHMENT_STORE_OP_STORE = <span class="hljs-number">0</span>,<span class="hljs-comment">//渲染内容会被保存在内存中</span><br>    VK_ATTACHMENT_STORE_OP_DONT_CARE = <span class="hljs-number">1</span>,<span class="hljs-comment">//渲染后的内容不会被保存，将处于未知状态</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_ATTACHMENT_STORE_OP_NONE = <span class="hljs-number">1000301000</span>,<span class="hljs-comment">//如果附件没有写入操作，则不进行任何储存操作，否则效果等同于VK_ATTACHMENT_STORE_OP_DONT_CARE</span><br>  <span class="hljs-comment">// Provided by VK_KHR_dynamic_rendering, VK_KHR_load_store_op_none</span><br>    VK_ATTACHMENT_STORE_OP_NONE_KHR = VK_ATTACHMENT_STORE_OP_NONE,<br>  <span class="hljs-comment">// Provided by VK_QCOM_render_pass_store_ops</span><br>    VK_ATTACHMENT_STORE_OP_NONE_QCOM = VK_ATTACHMENT_STORE_OP_NONE,<br>  <span class="hljs-comment">// Provided by VK_EXT_load_store_op_none</span><br>    VK_ATTACHMENT_STORE_OP_NONE_EXT = VK_ATTACHMENT_STORE_OP_NONE,<br>&#125; VkAttachmentStoreOp;<br></code></pre></td></tr></table></figure><p>对于我们的程序，可以如下指定这两个成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;<br>colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;<br></code></pre></td></tr></table></figure><p>对于模板附件，我们通过<i><font color="Orange">stencilLoadOp</font></i>和<i><font color="Orange">stencilStoreOp</font></i>单独指定它的加载和保存操作。本教程并不会用到模板缓冲，因此我们始终将这两个成员设置为<i><font color="Red">VK_ATTACHMENT_LOAD_OP_DONT_CARE</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;<br>colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br></code></pre></td></tr></table></figure><p>关于模板测试的简单介绍和应用，可以参考<a href="https://learnopengl.com/Advanced-OpenGL/Stencil-testing">这篇文章</a>。</p><p>最后，我们需要指定附件图像的初始布局和最终布局。Vulkan中图像像素的布局是可以改变的，这允许我们针对接下来要进行的操作设置最优的像素布局以优化性能。这个布局是通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html"><code>VkImageLayout</code></a>指定的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkImageLayout</span> &#123;</span><br>    VK_IMAGE_LAYOUT_UNDEFINED = <span class="hljs-number">0</span>,<br>    VK_IMAGE_LAYOUT_GENERAL = <span class="hljs-number">1</span>,<br>    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = <span class="hljs-number">2</span>,<br>    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = <span class="hljs-number">3</span>,<br>    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = <span class="hljs-number">4</span>,<br>    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = <span class="hljs-number">5</span>,<br>    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = <span class="hljs-number">6</span>,<br>    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = <span class="hljs-number">7</span>,<br>    VK_IMAGE_LAYOUT_PREINITIALIZED = <span class="hljs-number">8</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = <span class="hljs-number">1000117000</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = <span class="hljs-number">1000117001</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = <span class="hljs-number">1000241000</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = <span class="hljs-number">1000241001</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = <span class="hljs-number">1000241002</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_2</span><br>    VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = <span class="hljs-number">1000241003</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL = <span class="hljs-number">1000314000</span>,<br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL = <span class="hljs-number">1000314001</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br>    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = <span class="hljs-number">1000001002</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_decode_queue</span><br>    VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR = <span class="hljs-number">1000024000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_decode_queue</span><br>    VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR = <span class="hljs-number">1000024001</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_decode_queue</span><br>    VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR = <span class="hljs-number">1000024002</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_shared_presentable_image</span><br>    VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = <span class="hljs-number">1000111000</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_fragment_density_map</span><br>    VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = <span class="hljs-number">1000218000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_fragment_shading_rate</span><br>    VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = <span class="hljs-number">1000164003</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_dynamic_rendering_local_read</span><br>    VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR = <span class="hljs-number">1000232000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_encode_queue</span><br>    VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR = <span class="hljs-number">1000299000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_encode_queue</span><br>    VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR = <span class="hljs-number">1000299001</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_video_encode_queue</span><br>    VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR = <span class="hljs-number">1000299002</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_attachment_feedback_loop_layout</span><br>    VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT = <span class="hljs-number">1000339000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_maintenance2</span><br>    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_KHR_maintenance2</span><br>    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_NV_shading_rate_image</span><br>    VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV = VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR,<br>  <span class="hljs-comment">// Provided by VK_KHR_separate_depth_stencil_layouts</span><br>    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_KHR_separate_depth_stencil_layouts</span><br>    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_KHR_separate_depth_stencil_layouts</span><br>    VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_KHR_separate_depth_stencil_layouts</span><br>    VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_KHR_synchronization2</span><br>    VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL,<br>  <span class="hljs-comment">// Provided by VK_KHR_synchronization2</span><br>    VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL,<br>&#125; VkImageLayout;<br></code></pre></td></tr></table></figure><p>可以看到布局方式有非常多种。我们在后续的学习中会陆续遇到其中的一些，在遇到这些布局方式的时候我们再对其加以解释。</p><p>在这里，我们希望如下指定布局：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;<br>colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">initialLayout</font></i>指定了图像在渲染通道开始之前应该是怎么布局的。我们并不关系渲染开始前图像的布局与内容，因为根据我们对<i><font color="Orange">loadOp</font></i>的设置，它的内容会在加载的时候被清空。<i><font color="Orange">finalLayout</font></i>指定图像在渲染通道结束后被自动转化为的布局类型。我们在渲染结束后希望将图像显示到屏幕上，因此该布局应该设置为<i><font color="Red">VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</font></i>以获取显示最优的布局。</p><p>至此附件描述填写完毕。</p><hr><h2 id="创建子通道">创建子通道</h2><p>一个渲染通道可以包含多个子通道。子通道指的是一系列的渲染操作，每一个子通道可以使用上一个子通道的渲染结果进行后处理等操作。我们可以将许多连续的渲染操作分为多个子通道并整合在一个渲染通道中，这样Vulkan可以适当地重排操作顺序以节省内存和带宽从而优化性能。不过对于我们绘制三角形的程序而言，创建一个子通道就足够了。</p><p>每一个子通道都需要引用一些创建好的附件描述信息。附件引用结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAttachmentReference.html"><code>VkAttachmentReference</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkAttachmentReference</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>         attachment;<br>    VkImageLayout    layout;<br>&#125; VkAttachmentReference;<br></code></pre></td></tr></table></figure><p>我们只需要指定它引用的附件索引以及在引用它的子通道的操作中它应该具有的布局即可。由于我们只创建了一个附件描述信息，因此<i><font color="Orange">attachment</font></i>设置为0即可。由于在子通道中进行渲染时，我们希望把上述附件作为颜色附件使用，因此<i><font color="Orange">layout</font></i>应该设置为<i><font color="Red">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</font></i>。</p><p>接下来我们就可以填写子通道的描述信息<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubpassDescription.html"><code>VkSubpassDescription</code></a>了，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSubpassDescription</span> &#123;</span><br>    VkSubpassDescriptionFlags       flags;<br>    VkPipelineBindPoint             pipelineBindPoint;<br>    <span class="hljs-type">uint32_t</span>                        inputAttachmentCount;<br>    <span class="hljs-type">const</span> VkAttachmentReference*    pInputAttachments;<br>    <span class="hljs-type">uint32_t</span>                        colorAttachmentCount;<br>    <span class="hljs-type">const</span> VkAttachmentReference*    pColorAttachments;<br>    <span class="hljs-type">const</span> VkAttachmentReference*    pResolveAttachments;<br>    <span class="hljs-type">const</span> VkAttachmentReference*    pDepthStencilAttachment;<br>    <span class="hljs-type">uint32_t</span>                        preserveAttachmentCount;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*                 pPreserveAttachments;<br>&#125; VkSubpassDescription;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>所有可能的取值及其含义可以参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubpassDescriptionFlagBits.html">这个页面</a>，这里我们并不需要指定任何特殊的标志。</p><p>由于未来Vulkan有可能会指定计算子通道，因此为了这个可能的拓展，我们必须指定我们在该渲染通道中使用的是哪种子通道。我们使用的是图形子通道，因此填写<i><font color="Red">VK_PIPELINE_BIND_POINT_GRAPHICS</font></i>即可。</p><p>接下来的所有参数指定了子通道对不同种类的附件的绑定情况。子通道可以引用的附件类型包括：</p><ul><li>输入附件（Inputattachments）：允许在渲染通道的子通道中读取来自其他子通道的附件内容，它主要用于实现多通道渲染和后处理效果</li><li>颜色附件（Color attachments）：存储渲染输出的颜色数据</li><li>多重采样附件（Resolveattachments）：主要作用是将多重采样的结果解析（resolve）到一个单一的颜色附件中，从而实现抗锯齿效果</li><li>深度模板附件（DepthStencilattachments）：储存渲染输出的深度和模板数据</li><li>保留附件（Preserveattachments）：主要用于在渲染过程中保持其内容不被修改。这种附件通常在多个渲染通道之间共享，允许在不同的渲染操作中保留数据，这有助于提高渲染效率，避免不必要的内存操作，因为它们不需要在每次渲染时进行加载和存储</li></ul><p>我们这里只需要颜色附件的位置绑上之前指定的附件引用就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSubpassDescription subpass&#123;&#125;;<br>subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;<br>subpass.colorAttachmentCount = <span class="hljs-number">1</span>;<br>subpass.pColorAttachments = &amp;colorAttachmentRef;<br></code></pre></td></tr></table></figure><hr><h2 id="创建渲染通道">创建渲染通道</h2><p>现在我们可以创建真正的渲染通道对象了。在类内新添一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRenderPass.html"><code>VkRenderPass</code></a>类型的成员<i><font color="Orange">renderPass</font></i>，接下来我们来填写创建信息<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateInfo.html"><code>VkRenderPassCreateInfo</code></a>，该结构体定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkRenderPassCreateInfo</span> &#123;</span><br>    VkStructureType                   sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                       pNext;<br>    VkRenderPassCreateFlags           flags;<br>    <span class="hljs-type">uint32_t</span>                          attachmentCount;<br>    <span class="hljs-type">const</span> VkAttachmentDescription*    pAttachments;<br>    <span class="hljs-type">uint32_t</span>                          subpassCount;<br>    <span class="hljs-type">const</span> VkSubpassDescription*       pSubpasses;<br>    <span class="hljs-type">uint32_t</span>                          dependencyCount;<br>    <span class="hljs-type">const</span> VkSubpassDependency*        pDependencies;<br>&#125; VkRenderPassCreateInfo;<br></code></pre></td></tr></table></figure></p><p><i><font color="Orange">flags</font></i>可能的取值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkRenderPassCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_QCOM_render_pass_transform</span><br>    VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//该标志允许开发者在创建渲染通道时对渲染目标进行几何变换。这意味着可以在渲染时对图像进行旋转、翻转或其他变换操作，而无需在应用程序中手动处理这些变换</span><br>&#125; VkRenderPassCreateFlagBits;<br></code></pre></td></tr></table></figure><p>接下来我们需要指定该渲染通道绑定的附件（注意此时指定的是附件本身而不是附件引用）以及子通道。</p><p>最后如果有多于一个的子通道，我们还需要指定它们之间的依赖关系（dependency）以确保在一个子通道完成之前，另一个子通道不会开始执行。这对于处理资源的读写冲突和同步至关重要。由于我们这里只有一个子通道，所以不需要指定这部分内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkRenderPassCreateInfo renderPassInfo&#123;&#125;;<br>renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;<br>renderPassInfo.attachmentCount = <span class="hljs-number">1</span>;<br>renderPassInfo.pAttachments = &amp;colorAttachment;<br>renderPassInfo.subpassCount = <span class="hljs-number">1</span>;<br>renderPassInfo.pSubpasses = &amp;subpass;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateRenderPass</span>(device, &amp;renderPassInfo, <span class="hljs-literal">nullptr</span>, &amp;renderPass) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create render pass!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就设置好了渲染通道的信息，下一章我们终于可以创建真正的渲染管线对象了！</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/">上一篇：固定管线</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/">下一篇：渲染管线</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>固定管线</title>
    <link href="/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/"/>
    <url>/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p><a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/">上一章</a>中我们已经构建好了渲染管线中的可编程阶段。本节将继续构建管线中的固定函数阶段。我们需要分别构建：</p><ul><li>顶点输入</li><li>输入汇编阶段</li><li>视口和裁剪</li><li>光栅化阶段</li><li>多重采样</li><li>深度模板测试</li><li>颜色混合阶段</li><li>管线布局</li></ul><p>下面我们依次构建所有的固定函数和阶段。</p><p>本节对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions">Fixedfunctions</a>章节。</p><hr><h2 id="顶点输入">顶点输入</h2><p>首先我们需要指定顶点输入数据的格式。主要需要关注两部分：</p><ul><li>绑定方式：即数据之间的排列间隙以及数据是逐顶点的还是逐索引的</li><li>属性描述：即数据属性的类别以及它们对应的绑定点和在在数据块中的偏移</li></ul><p>指定数据输入格式是通过填写 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineVertexInputStateCreateInfo.html"><code>VkPipelineVertexInputStateCreateInfo</code></a>完成的，它的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineVertexInputStateCreateInfo</span> &#123;</span><br>    VkStructureType                             sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                 pNext;<br>    VkPipelineVertexInputStateCreateFlags       flags;<span class="hljs-comment">//暂时没有选项</span><br>    <span class="hljs-type">uint32_t</span>                                    vertexBindingDescriptionCount;<br>    <span class="hljs-type">const</span> VkVertexInputBindingDescription*      pVertexBindingDescriptions;<br>    <span class="hljs-type">uint32_t</span>                                    vertexAttributeDescriptionCount;<br>    <span class="hljs-type">const</span> VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;<br>&#125; VkPipelineVertexInputStateCreateInfo;<br></code></pre></td></tr></table></figure><p>其中<i><font color="Orange">pVertexBindingDescriptions</font></i>对应的就是绑定方式，<i><font color="Orange">pVertexAttributeDescriptions</font></i>对应的就是属性描述。</p><p>由于我们暂时是将顶点数据硬编码在顶点着色器中的，所以我们暂时不需要填写这些成员。在后续顶点缓冲章节我们会进行更详细得说明。</p><hr><h2 id="输入汇编阶段">输入汇编阶段</h2><p>输入汇编阶段通过 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineInputAssemblyStateCreateInfo.html"><code>VkPipelineInputAssemblyStateCreateInfo</code></a>指定。该结构体指定两方面的信息：</p><ul><li>顶点构成的图元种类</li><li>图元重启是否开启</li></ul><p>其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineInputAssemblyStateCreateInfo</span> &#123;</span><br>    VkStructureType                            sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                pNext;<br>    VkPipelineInputAssemblyStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    VkPrimitiveTopology                        topology;<br>    VkBool32                                   primitiveRestartEnable;<br>&#125; VkPipelineInputAssemblyStateCreateInfo;<br></code></pre></td></tr></table></figure><p>其中<i><font color="Orange">topology</font></i>指定的就是图元的种类，有关图元的所有种类可以参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPrimitiveTopology.html">这个页面</a>。</p><p><i><font color="Orange">primitiveRestartEnable</font></i>指定是否开启图元重启。图元重启（PrimitiveRestart）是图形渲染中的一种机制，用于在绘制图元（如三角形、线段等）时，允许在同一绘制调用中重启图元的绘制过程。这在处理复杂的几何体时非常有用，尤其是当使用索引缓冲区时。在绘制过程中，PrimitiveRestart 允许通过一个特殊的重启索引值（通常是一个特定的无效索引，如<code>0xFFFFFFFF</code>）来指示图元的重启。当遇到这个重启索引时，渲染管线会停止当前图元的绘制，并开始绘制一个新的图元。</p><p>为了绘制第一个三角形，这里我们只需如下指定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineInputAssemblyStateCreateInfo inputAssembly&#123;&#125;;<br>inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;<br>inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;<br>inputAssembly.primitiveRestartEnable = VK_FALSE;<br></code></pre></td></tr></table></figure><hr><h2 id="视口和裁剪">视口和裁剪</h2><p>视口和裁剪的设置比较特殊，它们既可以作为渲染管线的一部分被预先设置好并烘培至管线内，也可以在命令缓冲中动态设定以便在程序运行时动态改变而不重新建立渲染管线。</p><p>如果需要预先设置好，可以先分别填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkViewport.html"><code>VkViewport</code></a>和<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRect2D.html"><code>VkRect2D</code></a>结构体，它们的定义分别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkViewport</span> &#123;</span><br>    <span class="hljs-type">float</span>    x;<br>    <span class="hljs-type">float</span>    y;<br>    <span class="hljs-type">float</span>    width;<br>    <span class="hljs-type">float</span>    height;<br>    <span class="hljs-type">float</span>    minDepth;<br>    <span class="hljs-type">float</span>    maxDepth;<br>&#125; VkViewport;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkRect2D</span> &#123;</span><br>    VkOffset2D    offset;<br>    VkExtent2D    extent;<br>&#125; VkRect2D;<br></code></pre></td></tr></table></figure><p>先看<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkViewport.html"><code>VkViewport</code></a>：前两个坐标指定的是视口左上角的位置，最后两个值指定的是帧缓冲中坐标的深度范围，这个深度范围一定要在<strong>[0.0,1.0]</strong>中，但是最小深度允许在指定的时候大于最大深度。绝大多数情况下我们都希望视口范围和图像范围一样大，并且深度范围就是<strong>[0.0,1.0]</strong>，因此一般来讲可以这样填写该结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkViewport viewport&#123;&#125;;<br>viewport.x = <span class="hljs-number">0.0f</span>;<br>viewport.y = <span class="hljs-number">0.0f</span>;<br>viewport.width = (<span class="hljs-type">float</span>) swapChainExtent.width;<br>viewport.height = (<span class="hljs-type">float</span>) swapChainExtent.height;<br>viewport.minDepth = <span class="hljs-number">0.0f</span>;<br>viewport.maxDepth = <span class="hljs-number">1.0f</span>;<br></code></pre></td></tr></table></figure><p>对于裁剪范围，它由一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkRect2D.html"><code>VkRect2D</code></a>结构体指定，它的两个成员分别指定偏移量和范围大小。如果不需要特殊的效果，一般来讲我们不需要裁剪图像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkRect2D scissor&#123;&#125;;<br>scissor.offset = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>scissor.extent = swapChainExtent;<br></code></pre></td></tr></table></figure><p>如果需要将视口和裁剪设置为动态阶段（dynamicstate），那么我们需要使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineDynamicStateCreateInfo.html"><code>VkPipelineDynamicStateCreateInfo</code></a>指定动态阶段的信息。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineDynamicStateCreateInfo</span> &#123;</span><br>    VkStructureType                      sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                          pNext;<br>    VkPipelineDynamicStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    <span class="hljs-type">uint32_t</span>                             dynamicStateCount;<br>    <span class="hljs-type">const</span> VkDynamicState*                pDynamicStates;<br>&#125; VkPipelineDynamicStateCreateInfo;<br></code></pre></td></tr></table></figure><p>因此我们需要如下填写该结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;VkDynamicState&gt; dynamicStates = &#123;<br>    VK_DYNAMIC_STATE_VIEWPORT,<br>    VK_DYNAMIC_STATE_SCISSOR<br>&#125;;<br><br>VkPipelineDynamicStateCreateInfo dynamicState&#123;&#125;;<br>dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;<br>dynamicState.dynamicStateCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(dynamicStates.<span class="hljs-built_in">size</span>());<br>dynamicState.pDynamicStates = dynamicStates.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>不管采取哪种方式，在指定好视口和裁剪的信息后，我们都需要通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportStateCreateInfo.html"><code>VkPipelineViewportStateCreateInfo</code></a>结构体告诉渲染管线我们使用的视口和裁剪，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineViewportStateCreateInfo</span> &#123;</span><br>    VkStructureType                       sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                           pNext;<br>    VkPipelineViewportStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    <span class="hljs-type">uint32_t</span>                              viewportCount;<br>    <span class="hljs-type">const</span> VkViewport*                     pViewports;<br>    <span class="hljs-type">uint32_t</span>                              scissorCount;<br>    <span class="hljs-type">const</span> VkRect2D*                       pScissors;<br>&#125; VkPipelineViewportStateCreateInfo;<br></code></pre></td></tr></table></figure><p>如果视口和裁剪使用动态阶段，那么我们无需填写<i><font color="Orange">pViewports</font></i>和<i><font color="Orange">pScissors</font></i>成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineViewportStateCreateInfo viewportState&#123;&#125;;<br>viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;<br>viewportState.viewportCount = <span class="hljs-number">1</span>;<br>viewportState.scissorCount = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>否则我们还需指定使用的视口和裁剪范围：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">viewportState.pViewports = &amp;viewport;<br>viewportState.pScissors = &amp;scissor;<br></code></pre></td></tr></table></figure><p>另外，从结构体的定义不难看出渲染管线是允许指定多视口和裁剪区域的，但是要这么做要求GPU具有相应的特性，这可以通过查询物理设备特性的函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures.html"><code>vkGetPhysicalDeviceFeatures</code></a>来查询，大致的查询结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPhysicalDeviceFeatures features;<br><span class="hljs-built_in">vkGetPhysicalDeviceFeatures</span>(physicalDevice, &amp;features);<br><br><span class="hljs-keyword">if</span> (features.multiViewport) &#123;<br>    <span class="hljs-comment">// 支持多视口</span><br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-keyword">if</span> (features.multiDrawIndirect) &#123;<br>    <span class="hljs-comment">// 支持多裁剪区域</span><br>    <span class="hljs-comment">///...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们解释一下视口区域和裁剪区域的区别。视口实际上可以看成是由图像到帧缓冲区的一个变换，它并不会导致图像上部分区域的丢失，只会拉伸或者压缩图像；而裁剪区域指定的是图像哪些像素会被保留，裁剪区域之外的部分会在光栅化阶段丢弃，它更像是一个过滤器。下面这张图很好地说明了这两者的区别与联系：</p><figure><img src="/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF/视口裁剪.png" alt="视口和裁剪"><figcaption aria-hidden="true">视口和裁剪</figcaption></figure><hr><h2 id="光栅化阶段">光栅化阶段</h2><p>光栅化阶段将几何体分割为片段，并且执行提前深度测试、面剔除、裁剪测试等操作，它还决定了多边形绘制模式。这些信息都是通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateCreateInfo.html"><code>VkPipelineRasterizationStateCreateInfo</code></a>设定的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineRasterizationStateCreateInfo</span> &#123;</span><br>    VkStructureType                            sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                pNext;<br>    VkPipelineRasterizationStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    VkBool32                                   depthClampEnable;<br>    VkBool32                                   rasterizerDiscardEnable;<br>    VkPolygonMode                              polygonMode;<br>    VkCullModeFlags                            cullMode;<br>    VkFrontFace                                frontFace;<br>    VkBool32                                   depthBiasEnable;<br>    <span class="hljs-type">float</span>                                      depthBiasConstantFactor;<br>    <span class="hljs-type">float</span>                                      depthBiasClamp;<br>    <span class="hljs-type">float</span>                                      depthBiasSlopeFactor;<br>    <span class="hljs-type">float</span>                                      lineWidth;<br>&#125; VkPipelineRasterizationStateCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">depthClampEnable</font></i>指定深度值在<strong>[0.0,1.0]</strong>范围外的片段该如何处理，如果为<i><font color="Red">VK_TRUE</font></i>，那么相当于这些片段的深度值做clamp操作（这在阴影映射中有用，可以参考<a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">这篇文章</a>）；反之则简单地丢弃这些片段。启用该功能同样需要GPU特性<i><font color="Orange">VkPhysicalDeviceFeatures::depthClamp</font></i>为<i><font color="Red">VK_TRUE</font></i>。</p><p>接下来，如果<i><font color="Orange">rasterizerDiscardEnable</font></i>设置为<i><font color="Red">VK_TRUE</font></i>，那么意味着不会有任何几何形体通过光栅化阶段最终输出到帧缓冲上。为了得到渲染结果这个成员几乎总是设置为<i><font color="Red">VK_FALSE</font></i>。</p><p><i><font color="Orange">polygonMode</font></i>指定了多边形绘制模式，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPolygonMode.html"><code>VkPolygonMode</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkPolygonMode</span> &#123;</span><br>    VK_POLYGON_MODE_FILL = <span class="hljs-number">0</span>,<span class="hljs-comment">//以填充方式绘制多边形</span><br>    VK_POLYGON_MODE_LINE = <span class="hljs-number">1</span>,<span class="hljs-comment">//以线框方式绘制多边形</span><br>    VK_POLYGON_MODE_POINT = <span class="hljs-number">2</span>,<span class="hljs-comment">//以点模式绘制多边形</span><br>  <span class="hljs-comment">// Provided by VK_NV_fill_rectangle</span><br>    VK_POLYGON_MODE_FILL_RECTANGLE_NV = <span class="hljs-number">1000153000</span>,<span class="hljs-comment">//这是一个扩展的模式，专门用于填充矩形。这是由 VK_NV_fill_rectangle 扩展提供的，允许更高效地绘制矩形</span><br>&#125; VkPolygonMode;<br></code></pre></td></tr></table></figure><p>除了<i><font color="Red">VK_POLYGON_MODE_FILL</font></i>以外的模式都需要GPU具有相应的特性。</p><p><i><font color="Orange">lineWidth</font></i>成员指定多边形边界线宽度（以片段为单位）。一般来讲它设定为<strong>1.0</strong>，如果需要比这更宽的宽度则需要GPU具有特性<i><font color="Orange">wideLines</font></i>。</p><p>接下来的<i><font color="Orange">cullMode</font></i>和<i><font color="Orange">frontFace</font></i>指定了面剔除的方式。下面是它们可能的取值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkCullModeFlagBits</span> &#123;</span><br>    VK_CULL_MODE_NONE = <span class="hljs-number">0</span>,<br>    VK_CULL_MODE_FRONT_BIT = <span class="hljs-number">0x00000001</span>,<br>    VK_CULL_MODE_BACK_BIT = <span class="hljs-number">0x00000002</span>,<br>    VK_CULL_MODE_FRONT_AND_BACK = <span class="hljs-number">0x00000003</span>,<br>&#125; VkCullModeFlagBits;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkFrontFace</span> &#123;</span><br>    VK_FRONT_FACE_COUNTER_CLOCKWISE = <span class="hljs-number">0</span>,<br>    VK_FRONT_FACE_CLOCKWISE = <span class="hljs-number">1</span>,<br>&#125; VkFrontFace;<br></code></pre></td></tr></table></figure><p>这些枚举值的含义均易于理解，这里不再赘述。</p><p>最后的四个成员用于指定对深度值的一些操作，这些操作在阴影映射中有一定的运用，不过我们这里并不需要指定该功能。</p><p>最终，我们的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateCreateInfo.html"><code>VkPipelineRasterizationStateCreateInfo</code></a>结构体应该填写如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineRasterizationStateCreateInfo rasterizer&#123;&#125;;<br>rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;<br>rasterizer.depthClampEnable = VK_FALSE;<br>rasterizer.rasterizerDiscardEnable = VK_FALSE;<br>rasterizer.polygonMode = VK_POLYGON_MODE_FILL;<br>rasterizer.lineWidth = <span class="hljs-number">1.0f</span>;<br>rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;<br>rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;<br>rasterizer.depthBiasEnable = VK_FALSE;<br></code></pre></td></tr></table></figure><hr><h2 id="多重采样">多重采样</h2><p>对多重采样的指定通过填写 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineMultisampleStateCreateInfo.html"><code>VkPipelineMultisampleStateCreateInfo</code></a>来完成。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineMultisampleStateCreateInfo</span> &#123;</span><br>    VkStructureType                          sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                              pNext;<br>    VkPipelineMultisampleStateCreateFlags    flags;<span class="hljs-comment">//暂时没有</span><br>    VkSampleCountFlagBits                    rasterizationSamples;<br>    VkBool32                                 sampleShadingEnable;<br>    <span class="hljs-type">float</span>                                    minSampleShading;<br>    <span class="hljs-type">const</span> VkSampleMask*                      pSampleMask;<br>    VkBool32                                 alphaToCoverageEnable;<br>    VkBool32                                 alphaToOneEnable;<br>&#125; VkPipelineMultisampleStateCreateInfo;<br></code></pre></td></tr></table></figure><p>目前我们并不需要使用多重采样功能，所以只需禁用该功能即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineMultisampleStateCreateInfo multisampling&#123;&#125;;<br>multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;<br>multisampling.sampleShadingEnable = VK_FALSE;<br>multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;<br>multisampling.minSampleShading = <span class="hljs-number">1.0f</span>; <span class="hljs-comment">// Optional</span><br>multisampling.pSampleMask = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br>multisampling.alphaToCoverageEnable = VK_FALSE; <span class="hljs-comment">// Optional</span><br>multisampling.alphaToOneEnable = VK_FALSE; <span class="hljs-comment">// Optional</span><br></code></pre></td></tr></table></figure><p>多重采样是一种重要且高效的抗锯齿方式，它不需要像SSAA一样提高分辨率，而是只在边界上对一个像素的多个采样点运行多次片段着色器，最终对同一个像素中每个样本的颜色进行一个平均即可，可以大幅降低计算复杂度。关于MSAA原理的更详细的介绍可以阅读<a href="https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing">这篇文章</a>。</p><hr><h2 id="深度模板测试">深度模板测试</h2><p>由于我们目前希望渲染一个2D的三角形，这并不需要深度或者模板测试，因此我们暂时不需要填写相应的<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineDepthStencilStateCreateInfo.html"><code>VkPipelineDepthStencilStateCreateInfo</code></a>结构体，这部分会在之后开始绘制3维图像的时候介绍。</p><hr><h2 id="颜色混合阶段">颜色混合阶段</h2><p>在片段着色器计算出每个像素的颜色值之后，输出的颜色值需要和作为输出目标的帧缓冲中对应像素的颜色值进行混合。颜色混合有两种方式：</p><ul><li>直接混合两个颜色向量</li><li>对颜色值进行位运算</li></ul><p>设定颜色混合的信息结构体也有两个：<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>指定特定颜色附件的颜色混合设置，而<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendStateCreateInfo.html"><code>VkPipelineColorBlendStateCreateInfo</code></a>指定全局的颜色混合设置（适用于所有颜色附件）。它们的定义分别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineColorBlendAttachmentState</span> &#123;</span><br>    VkBool32                 blendEnable;<span class="hljs-comment">//如果为VK_FALSE，则着色器输出颜色直接覆盖帧缓冲对应像素上的颜色</span><br>    VkBlendFactor            srcColorBlendFactor;<br>    VkBlendFactor            dstColorBlendFactor;<br>    VkBlendOp                colorBlendOp;<br>    VkBlendFactor            srcAlphaBlendFactor;<br>    VkBlendFactor            dstAlphaBlendFactor;<br>    VkBlendOp                alphaBlendOp;<br>    VkColorComponentFlags    colorWriteMask;<span class="hljs-comment">//指定RGBA四通道分别是否可写</span><br>&#125; VkPipelineColorBlendAttachmentState;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">/ Provided by VK_VERSION_1_0<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineColorBlendStateCreateInfo</span> &#123;</span><br>    VkStructureType                               sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                   pNext;<br>    VkPipelineColorBlendStateCreateFlags          flags;<br>    VkBool32                                      logicOpEnable;<br>    VkLogicOp                                     logicOp;<br>    <span class="hljs-type">uint32_t</span>                                      attachmentCount;<br>    <span class="hljs-type">const</span> VkPipelineColorBlendAttachmentState*    pAttachments;<br>    <span class="hljs-type">float</span>                                         blendConstants[<span class="hljs-number">4</span>];<br>&#125; VkPipelineColorBlendStateCreateInfo;<br></code></pre></td></tr></table></figure><p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>允许我们指定每个颜色附件第一种混合方式的设置，该结构体除第一个成员和最后一个成员之外的所有成员均用于最后混合颜色的计算，计算的伪代码大致如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (blendEnable) &#123;<br>    finalColor.rgb = (srcColorBlendFactor * newColor.rgb) &lt;colorBlendOp&gt; (dstColorBlendFactor * oldColor.rgb);<br>    finalColor.a = (srcAlphaBlendFactor * newColor.a) &lt;alphaBlendOp&gt; (dstAlphaBlendFactor * oldColor.a);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    finalColor = newColor;<br>&#125;<br><br>finalColor = finalColor &amp; colorWriteMask;<br></code></pre></td></tr></table></figure><p>关于混合运算符<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBlendOp.html"><code>VkBlendOp</code></a>以及<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBlendFactor.html"><code>VkBlendFactor</code></a>，可以分别参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBlendOp.html"><code>这个页面</code></a>以及<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBlendFactor.html"><code>这个页面</code></a>，大多数的运算符以及运算因子的含义都是显而易见的，我们这里不再过多介绍。</p><p>接下来介绍一下全局设置结构体<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendStateCreateInfo.html"><code>VkPipelineColorBlendStateCreateInfo</code></a>。</p><p><i><font color="Orange">flags</font></i>是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendStateCreateFlagBits.html"><code>VkPipelineColorBlendStateCreateFlagBits</code></a>的位组合，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_rasterization_order_attachment_access</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkPipelineColorBlendStateCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_EXT_rasterization_order_attachment_access</span><br>    VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//指示颜色混合状态的创建将允许按照光栅化顺序访问附件。这意味着在处理多个颜色附件时，可以按照它们在渲染目标中的顺序进行访问，从而优化渲染性能。</span><br>  <span class="hljs-comment">// Provided by VK_ARM_rasterization_order_attachment_access</span><br>    VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM = VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT,<br>&#125; VkPipelineColorBlendStateCreateFlagBits;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">logicOpEnable</font></i>指定是否使用第二种方式混合颜色。这个成员设置为<i><font color="Red">VK_TRUE</font></i>的效果和所有颜色附件的<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>结构体中<i><font color="Orange">blendEnable</font></i>设置为<i><font color="Red">VK_FALSE</font></i>的效果是一样的，也就是说第一种颜色混合方式将被禁用。</p><p>逻辑运算符我们在这里也不过多介绍，可以参考<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkLogicOp.html">这个页面</a>。</p><p>下面的<i><font color="Orange">attachmentCount</font></i>和<i><font color="Orange">pAttachments</font></i>指定所有填写好的的颜色附件混合模式结构体<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>。最后的<i><font color="Orange">blendConstants</font></i>数组指定了<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>中指定的混合因子的具体值（<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a>中指定的是一个抽象的混合因子，这个因子具体的值由<i><font color="Orange">blendConstants</font></i>数组指定）。</p><p>对于我们绘制三角形的程序，我们只有一个颜色附件，也不需要有特殊的混合操作，因此我们只需如下设置即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineColorBlendAttachmentState colorBlendAttachment&#123;&#125;;<br>colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;<br>colorBlendAttachment.blendEnable = VK_FALSE;<br>colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; <span class="hljs-comment">// Optional</span><br>colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; <span class="hljs-comment">// Optional</span><br><br>VkPipelineColorBlendStateCreateInfo colorBlending&#123;&#125;;<br>colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;<br>colorBlending.logicOpEnable = VK_FALSE;<br>colorBlending.logicOp = VK_LOGIC_OP_COPY; <span class="hljs-comment">// Optional</span><br>colorBlending.attachmentCount = <span class="hljs-number">1</span>;<br>colorBlending.pAttachments = &amp;colorBlendAttachment;<br>colorBlending.blendConstants[<span class="hljs-number">0</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span><br>colorBlending.blendConstants[<span class="hljs-number">1</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span><br>colorBlending.blendConstants[<span class="hljs-number">2</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span><br>colorBlending.blendConstants[<span class="hljs-number">3</span>] = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// Optional</span><br></code></pre></td></tr></table></figure><hr><h2 id="管线布局">管线布局</h2><p>在程序运行过程中我们往往需要动态地向着色器传入某些值，比如说uniform变量。尽管我们现在并不需要这么做，我们仍然需要创建一个空的<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineLayout.html"><code>VkPipelineLayout</code></a>来指定这些值。</p><p>在类内创建一个<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineLayout.html"><code>VkPipelineLayout</code></a>类型的成员<i><font color="Orange">pipelineLayout</font></i>，然后在<i><font color="Green">createGraphicsPipeline</font></i>函数中构建这个对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineLayoutCreateInfo pipelineLayoutInfo&#123;&#125;;<br>pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;<br>pipelineLayoutInfo.setLayoutCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>pipelineLayoutInfo.pSetLayouts = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br>pipelineLayoutInfo.pushConstantRangeCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>pipelineLayoutInfo.pPushConstantRanges = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreatePipelineLayout</span>(device, &amp;pipelineLayoutInfo, <span class="hljs-literal">nullptr</span>, &amp;pipelineLayout) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create pipeline layout!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineLayoutCreateInfo.html"><code>VkPipelineLayoutCreateInfo</code></a>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineLayoutCreateInfo</span> &#123;</span><br>    VkStructureType                 sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                     pNext;<br>    VkPipelineLayoutCreateFlags     flags;<br>    <span class="hljs-type">uint32_t</span>                        setLayoutCount;<br>    <span class="hljs-type">const</span> VkDescriptorSetLayout*    pSetLayouts;<br>    <span class="hljs-type">uint32_t</span>                        pushConstantRangeCount;<br>    <span class="hljs-type">const</span> VkPushConstantRange*      pPushConstantRanges;<br>&#125; VkPipelineLayoutCreateInfo;<br></code></pre></td></tr></table></figure><p>注意这个结构体可以指定两种传递给着色器的变量：<strong>uniformvalues</strong>和<strong>push constants</strong>。<strong>pushconstants</strong>实际上就是比较小型的数据块，它们直接嵌入到指令流中，因此在性能上优于使用缓冲区对象。不过它们的大小受到限制，一般为128字节。</p><p>大功告成！我们终于完成了所有固定管线阶段信息的填写。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/">上一篇：着色器模块</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/">下一篇：渲染通道</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>渲染管线简介</title>
    <link href="/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/"/>
    <url>/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>本节主要简单介绍一下渲染管线的各个阶段及其所做的工作，本节对应VulkanTutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Introduction">Graphicspipeline basics/Introduction</a>章节。</p><hr><h2 id="流程梳理">流程梳理</h2><p>下图给出了渲染管线的基本流程：</p><figure><img src="/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/pipeline.png" alt="渲染管线"><figcaption aria-hidden="true">渲染管线</figcaption></figure><ul><li><p>输入汇编器（inputassembler）阶段收集用户在缓冲区中指定的定点信息和顶点索引信息。</p></li><li><p>顶点着色器（vertexshader）阶段对各个顶点进行坐标变换并且向后传递逐顶点信息。</p></li><li><p>曲面细分（tessellation）阶段允许用户进一步细分几何以增加面片质量和精细度。</p></li><li><p>几何着色器（geometryshader）阶段作用于每个基本图元，增加或丢弃部分图元。</p></li><li><p>光栅化（rasterization）阶段将图元打散成片段并且丢弃在屏幕外面的那些片段。</p></li><li><p>片段着色器（fragmentshader）阶段决定每个片段的输出位置以及它们各自的输出结果。</p></li><li><p>颜色混合（colorblending）阶段采用指定的方式混合对应于同一像素的不同片段的值。</p></li></ul><p>图中绿色的阶段代表该阶段不可编程，也就是说我们只能设置与该阶段运作有关的一些参数，但不能自己编写该阶段的运行逻辑；而橙色阶段代表该阶段可编程，也就是说我们可以自己书写代码来指定该阶段的工作流程。</p><p>Vulkan中的渲染管线不同于OpenGL，绝大多数情况下我们不能在运行时改变管线的设置，一旦发生变化，我们一般会需要重新建立一个管线，这么做的好处是由于对管线的操作是提前预知且固定的，硬件就可以对管线进行一些优化。</p><p>接下来的章节，我们将建立一个<i><font color="Green">voidcreateGraphicsPipeline()</font></i>成员函数来建立起一个基本的渲染管线。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/">上一篇：图像视图</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/">下一篇：着色器模块</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>着色器模块</title>
    <link href="/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/"/>
    <url>/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>这一章节我们将完成渲染管线中可编程阶段的构建。目前我们只简单地考虑构建顶点着色器和片段着色器阶段。</p><p>与之前的图形API不同，Vulkan使用的着色器代码需要是<a href="https://www.khronos.org/spir">SPIR-V</a>格式的，它的优点是相比于易于我们阅读的GLSL和HLSL代码，<a href="https://www.khronos.org/spir">SPIR-V</a>代码更容易被转化为GPU使用的机器码，并且GLSL和HLSL代码可能会因为GPU产商所设定的不同标准产生在不同机器上的不兼容现象，<a href="https://www.khronos.org/spir">SPIR-V</a>代码就不会出现这种问题。</p><p>不过幸运的是，我们并不需要自己手写<a href="https://www.khronos.org/spir">SPIR-V</a>代码，这里我们将使用VulkanSDK自带的glslc.exe来将GLSL代码编译为<a href="https://www.khronos.org/spir">SPIR-V</a>代码。</p><p>创建着色器模块主要分为四步：</p><ul><li>编写着色器代码</li><li>将着色器文件编译为<a href="https://www.khronos.org/spir">SPIR-V</a>代码</li><li>加载着色器文件到程序中并包裹在<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html"><code>VkShaderModule</code></a>对象中</li><li>填写渲染管线着色器阶段信息</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules">Shadermodules</a>章节。</p><hr><h2 id="编写着色器代码">编写着色器代码</h2><p>假设读者已经对GLSL基本语法比较熟悉了。由于我们的第一个应用程序只需要简单地绘制一个三角形，所以顶点着色器代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-type">vec2</span> positions[<span class="hljs-number">3</span>] = <span class="hljs-type">vec2</span>[](<br>    <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">-0.5</span>),<br>    <span class="hljs-type">vec2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>),<br>    <span class="hljs-type">vec2</span>(<span class="hljs-number">-0.5</span>, <span class="hljs-number">0.5</span>)<br>);<br><br><span class="hljs-type">vec3</span> colors[<span class="hljs-number">3</span>] = <span class="hljs-type">vec3</span>[](<br>    <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>),<br>    <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>),<br>    <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>)<br>);<br><br><span class="hljs-type">void</span> main() &#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(positions[gl_VertexIndex], <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fragColor = colors[gl_VertexIndex];<br>&#125;<br></code></pre></td></tr></table></figure><p>目前我们还没有介绍顶点缓冲，因此我们暂时将顶点数据硬编码在着色器文件中。另外，每个顶点我们都赋予不同的颜色，以便在后续光栅化阶段插值该颜色以形成渐变色的效果。</p><p>注意，<i><font color="Orange">gl_VertexIndex</font></i>代表的是当前处理的顶点对应的索引，这是一个glsl内建变量。</p><p>片段着色器代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outColor;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> fragColor;<br><br><span class="hljs-type">void</span> main() &#123;<br>    outColor = <span class="hljs-type">vec4</span>(fragColor, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>片段着色器的输入数据并不需要和顶点着色器中对应的输出数据名称一致，但是需要指定它们的location一致，这样才能将对应的输出输入链接到一起。</p><hr><h2 id="编译为spir-v代码">编译为SPIR-V代码</h2><p>windows下编译为<a href="https://www.khronos.org/spir">SPIR-V</a>代码很简单，我们可以将上面的两个文件（分别命名为<font color="Purple">shader.vert</font>，<font color="Purple">shader,frag</font>）保存在项目根目录下的一个文件夹<font color="Purple">shaders</font>中，然后在该文件下创建一个批处理文件<font color="Purple">compile.bat</font>：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bat"><span class="hljs-built_in">path</span>/to/glslc.exe shader.vert -o vert.spv<br><span class="hljs-built_in">path</span>/to/glslc.exe shader.frag -o frag.spv<br><span class="hljs-built_in">pause</span><br></code></pre></td></tr></table></figure><p>将<i><font color="Orange">path/to/glslc.exe</font></i>替换为自己电脑上对应的glslc.exe文件路径即可。</p><p>双击bat文件运行即可在同一文件夹下创建对应的<a href="https://www.khronos.org/spir">SPIR-V</a>文件。</p><p>当然，这只是创建<a href="https://www.khronos.org/spir">SPIR-V</a>文件的一种方式，VulkanSDK还提供了<a href="https://github.com/google/shaderc">libshaderc</a>，它允许我们在程序代码中将glsl文件编译为<a href="https://www.khronos.org/spir">SPIR-V</a>文件。</p><hr><h2 id="创建vkshadermodule">创建VkShaderModule</h2><p>接下来我们需要将编译好的<a href="https://www.khronos.org/spir">SPIR-V</a>文件加载到程序中来。创建一个静态函数<i><font color="Green">staticstd::vector<char> readFile(const std::string&amp;filename)</char></font></i>来完成这个工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> std::vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">readFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename)</span> </span>&#123;<br>    <span class="hljs-function">std::ifstream <span class="hljs-title">file</span><span class="hljs-params">(filename, std::ios::ate | std::ios::binary)</span></span>;<br><span class="hljs-comment">//ate代表指针定位到文件末尾，这样可以通过tellg知道文件的大小；binary代表以二进制文件格式读取文件</span><br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">is_open</span>()) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to open file!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-type">size_t</span> fileSize = (<span class="hljs-type">size_t</span>) file.<span class="hljs-built_in">tellg</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(fileSize)</span></span>;<br>    <br>    file.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//定位到文件头，准备开始读取文件</span><br>    file.<span class="hljs-built_in">read</span>(buffer.<span class="hljs-built_in">data</span>(), fileSize);<br>    <br>    file.<span class="hljs-built_in">close</span>();<br><br><span class="hljs-keyword">return</span> buffer;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，在<i><font color="Green">crearteGraphicsPipeline</font></i>函数中，我们就可以使用这个函数来读取我们写好的顶点着色器和片段着色器文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createGraphicsPipeline</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> vertShaderCode = <span class="hljs-built_in">readFile</span>(<span class="hljs-string">&quot;shaders/vert.spv&quot;</span>);<br>    <span class="hljs-keyword">auto</span> fragShaderCode = <span class="hljs-built_in">readFile</span>(<span class="hljs-string">&quot;shaders/frag.spv&quot;</span>);<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>读取文件之后，我们需要使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html"><code>VkShaderModule</code></a>包裹住这个文件内容才能使用，因此我们创建一个<i><font color="Green">VkShaderModulecreateShaderModule(const std::vector<char>&amp;code)</char></font></i>来完成这项工作。</p><p>为了创建[<code>VkShaderModule</code><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html">id0</a>对象，我们当然也需要填写相关的信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModuleCreateInfo.html"><code>VkShaderModuleCreateInfo</code></a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkShaderModuleCreateInfo</span> &#123;</span><br>    VkStructureType              sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                  pNext;<br>    VkShaderModuleCreateFlags    flags;   <span class="hljs-comment">//目前还没有</span><br>    <span class="hljs-type">size_t</span>                       codeSize;<span class="hljs-comment">//文件大小</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*              pCode;  <span class="hljs-comment">//文件内容</span><br>&#125; VkShaderModuleCreateInfo;<br></code></pre></td></tr></table></figure><p>这里需要注意的是，我们传给<i><font color="Green">createShaderModule</font></i>的参数为字符向量，但是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModuleCreateInfo.html"><code>VkShaderModuleCreateInfo</code></a>需要的参数<i><font color="Orange">pCode</font></i>是字节码，也就是一个指向<i><font color="Orange">uint32_t</font></i>的指针，因此我们需要如下编写代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkShaderModule <span class="hljs-title">createShaderModule</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">char</span>&gt;&amp; code)</span> </span>&#123;<br>VkShaderModuleCreateInfo createInfo&#123;&#125;;<br>createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;<br>createInfo.codeSize = code.<span class="hljs-built_in">size</span>();<br>createInfo.pCode = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*&gt;(code.<span class="hljs-built_in">data</span>());<br>    <br>    VkShaderModule shaderModule;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateShaderModule</span>(device, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;shaderModule) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create shader module!&quot;</span>);<br>&#125;<br>    <br>    <span class="hljs-keyword">return</span> shaderModule;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以使用这个函数在<i><font color="Green">crearteGraphicsPipeline</font></i>函数中构建着色器文件相应的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html"><code>VkShaderModule</code></a>对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createGraphicsPipeline</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> vertShaderCode = <span class="hljs-built_in">readFile</span>(<span class="hljs-string">&quot;shaders/vert.spv&quot;</span>);<br>    <span class="hljs-keyword">auto</span> fragShaderCode = <span class="hljs-built_in">readFile</span>(<span class="hljs-string">&quot;shaders/frag.spv&quot;</span>);<br><br>    VkShaderModule vertShaderModule = <span class="hljs-built_in">createShaderModule</span>(vertShaderCode);<br>    VkShaderModule fragShaderModule = <span class="hljs-built_in">createShaderModule</span>(fragShaderCode);<br>    <span class="hljs-comment">//...</span><br>    <br>    <span class="hljs-built_in">vkDestroyShaderModule</span>(device, fragShaderModule, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">vkDestroyShaderModule</span>(device, vertShaderModule, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，在使用完着色器模块后要使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyShaderModule.html"><code>vkDestroyShaderModule</code></a>清理掉相应对象。注意，这里我们并没有将着色器模块保存为类的成员，因为着色器模块在渲染管线构建完成之后会被GPU编译链接为真正执行用的机器码，此后着色器模块对象就不再需要了，因此我们可以在<i><font color="Green">crearteGraphicsPipeline</font></i>函数最后将其销毁掉，没有保存的必要。</p><hr><h2 id="填写着色器阶段信息">填写着色器阶段信息</h2><p>创建好着色器模块后，我们需要将这个模块插入到渲染管线对应的着色器阶段中。为此我们需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateInfo.html"><code>VkPipelineShaderStageCreateInfo</code></a>以供后续创建渲染管线对象时使用。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateInfo.html"><code>VkPipelineShaderStageCreateInfo</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineShaderStageCreateInfo</span> &#123;</span><br>    VkStructureType                     sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                         pNext;<br>    VkPipelineShaderStageCreateFlags    flags;<br>    VkShaderStageFlagBits               stage;<br>    VkShaderModule                      module;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                         pName;              <span class="hljs-comment">//着色器入口函数名称</span><br>    <span class="hljs-type">const</span> VkSpecializationInfo*         pSpecializationInfo;<span class="hljs-comment">//特化常量信息</span><br>&#125; VkPipelineShaderStageCreateInfo;<br></code></pre></td></tr></table></figure><p><a href="https://zpc-dsg.github.io/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/"><code>VkPipelineShaderStageCreateFlags</code></a>是<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E5%87%BD%E6%95%B0/"><code>VkPipelineShaderStageCreateFlagBits</code></a>的位组合，后者定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkPipelineShaderStageCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//允许在该着色器阶段使用可变大小的子组（subgroup）。这意味着在执行过程中，子组的大小可以变化，从而提供更大的灵活性，适用于某些计算任务。</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_3</span><br>    VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//要求该着色器阶段使用完整的子组。即所有子组的大小必须是指定的最大子组大小，这通常用于保证性能和一致性，确保所有线程在子组内都能得到相同的执行路径。</span><br>  <span class="hljs-comment">// Provided by VK_EXT_subgroup_size_control</span><br>    VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT,<br>  <span class="hljs-comment">// Provided by VK_EXT_subgroup_size_control</span><br>    VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT,<br>&#125; VkPipelineShaderStageCreateFlagBits;<br></code></pre></td></tr></table></figure><p>首先需要解释的是<i><font color="Orange">pName</font></i>成员，该形参指定着色器代码的入口点。一般来讲我们的glsl着色器代码入口点为<i><font color="Green">main</font></i>函数，但是Vulkan允许我们指定其它函数名作为入口函数，这也意味着我们可以在一个着色器模块中绑定多个具有不同入口名的着色器文件。</p><p>另外，<i><font color="Orange">pSpecializationInfo</font></i>指定的是需要传给着色器的特化常量的信息。特化常量是在着色器编译时指定的常量值。它们在着色器代码中声明为特化常量，并在编译时被替换为具体的值。这使得可以在不同的管线实例中使用不同的常量值，提高了性能，因为编译器能够针对这些常量进行优化。在GLSL 中，特化常量通常使用 <code>const</code> 关键字来声明，但在 Vulkan中，需要使用特化常量的机制来定义和传递这些值。特化常量与C中的预编译命令<code>#define</code>类似，不过特化常量是有类型的，编译器能够进行类型检查，并且特化常量的作用域通常局限于声明它们的着色器阶段，因此相比来讲特化常量具有类型安全和更好的作用域控制。</p><p>现在我们在<i><font color="Green">crearteGraphicsPipeline</font></i>函数中填写顶点着色器和片段着色器对应的着色器阶段信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPipelineShaderStageCreateInfo vertShaderStageInfo&#123;&#125;;<br>vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;<br>vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;<br>vertShaderStageInfo.<span class="hljs-keyword">module</span> = vertShaderModule;<br>vertShaderStageInfo.pName = <span class="hljs-string">&quot;main&quot;</span>;<br><br>VkPipelineShaderStageCreateInfo fragShaderStageInfo&#123;&#125;;<br>fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;<br>fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;<br>fragShaderStageInfo.<span class="hljs-keyword">module</span> = fragShaderModule;<br>fragShaderStageInfo.pName = <span class="hljs-string">&quot;main&quot;</span>;<br><br>VkPipelineShaderStageCreateInfo shaderStages[] = &#123;vertShaderStageInfo, fragShaderStageInfo&#125;;<br></code></pre></td></tr></table></figure><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/">上一篇：渲染管线简介</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/13/CG_api/vulkan/vulkan_tutorial/%E5%9B%BA%E5%AE%9A%E5%87%BD%E6%95%B0/">下一篇：固定管线</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图像视图</title>
    <link href="/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/"/>
    <url>/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>为了使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImage.html"><code>VkImage</code></a>，我们需要相应的视图<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageView.html"><code>VkImageView</code></a>。图像视图的作用是描述图像应该如何被使用以及图像的哪部分可以被使用。接下来我们将创建一个<i><font color="Green">voidcreateImageViews()</font></i>函数来创建所有的图像视图。创建图像视图的过程比较简单，主要分为两步：</p><ul><li>填写创建信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateInfo.html"><code>VkImageViewCreateInfo</code></a></li><li>创建图像视图对象</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Image_views">Imageviews</a>章节。</p><hr><h2 id="填写创建信息">填写创建信息</h2><p>由于对于每张图像我们都需要有对应的视图，因此我们在<i><font color="Green">createImageViews</font></i>函数中创建一个循环来填写每个视图的信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createImageViews</span><span class="hljs-params">()</span> </span>&#123;<br>    swapChainImageViews.<span class="hljs-built_in">resize</span>(swapChainImages.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainImages.<span class="hljs-built_in">size</span>(); i++) &#123;<br>VkImageViewCreateInfo createInfo&#123;&#125;;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateInfo.html"><code>VkImageViewCreateInfo</code></a>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkImageViewCreateInfo</span> &#123;</span><br>    VkStructureType            sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                pNext;<br>    VkImageViewCreateFlags     flags;<br>    VkImage                    image;<br>    VkImageViewType            viewType;<br>    VkFormat                   format;<br>    VkComponentMapping         components;<br>    VkImageSubresourceRange    subresourceRange;<br>&#125; VkImageViewCreateInfo;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">flags</font></i>是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateFlagBits.html"><code>VkImageViewCreateFlagBits</code></a>的位组合，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateFlagBits.html"><code>VkImageViewCreateFlagBits</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkImageViewCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_EXT_fragment_density_map</span><br>    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//此标志指示图像视图将用于动态片段密度映射（fragment density map）。动态片段密度映射允许在运行时调整每个像素的片段密度，以优化渲染性能和资源使用。</span><br>  <span class="hljs-comment">// Provided by VK_EXT_descriptor_buffer</span><br>    VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//表示图像视图将用于延迟片段密度映射。这种方式允许在后续渲染阶段处理片段密度，而不是在每个绘制调用中立即处理，从而提高效率。</span><br>  <span class="hljs-comment">// Provided by VK_EXT_fragment_density_map2</span><br>    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//此标志用于描述符缓冲区的捕获和重放。它指示图像视图可以在捕获和重放的上下文中使用，这对于调试和性能分析工具非常有用。</span><br>&#125; VkImageViewCreateFlagBits;<br></code></pre></td></tr></table></figure><p>我们在这里不指定任何标志。</p><p>接下来需要解释的是<i><font color="Orange">viewType</font></i>，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewType.html"><code>VkImageViewType</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkImageViewType</span> &#123;</span><br>    VK_IMAGE_VIEW_TYPE_1D = <span class="hljs-number">0</span>,<br>    VK_IMAGE_VIEW_TYPE_2D = <span class="hljs-number">1</span>,<br>    VK_IMAGE_VIEW_TYPE_3D = <span class="hljs-number">2</span>,<br>    VK_IMAGE_VIEW_TYPE_CUBE = <span class="hljs-number">3</span>,<br>    VK_IMAGE_VIEW_TYPE_1D_ARRAY = <span class="hljs-number">4</span>,<br>    VK_IMAGE_VIEW_TYPE_2D_ARRAY = <span class="hljs-number">5</span>,<br>    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = <span class="hljs-number">6</span>,<br>&#125; VkImageViewType;<br></code></pre></td></tr></table></figure><p>显然作为颜色缓冲的图像类型应该被指定为<i><font color="Red">VK_IMAGE_VIEW_TYPE_2D</font></i>。</p><p>之后的<i><font color="Orange">format</font></i>也应当和该视图对应的图像一致，因此我们将上一章保存在应用程序类内的成员<i><font color="Orange">swapChainImageFormat</font></i>为其赋值。</p><p><i><font color="Orange">components</font></i>指定了图像颜色通道的再映射。我们这里不需要任何特殊的映射，因此我们只需简单地指定映射为恒等变换即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;<br>createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;<br>createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;<br>createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;<br></code></pre></td></tr></table></figure><p>最后，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceRange.html"><code>VkImageSubresourceRange</code></a>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkImageSubresourceRange</span> &#123;</span><br>    VkImageAspectFlags    aspectMask;    <span class="hljs-comment">//图像的方面，即图像数据的不同特性或组成部分</span><br>    <span class="hljs-type">uint32_t</span>              baseMipLevel;  <span class="hljs-comment">//基础多级渐远级别</span><br>    <span class="hljs-type">uint32_t</span>              levelCount; <span class="hljs-comment">//多级渐远级数</span><br>    <span class="hljs-type">uint32_t</span>              baseArrayLayer;<span class="hljs-comment">//基础图像层</span><br>    <span class="hljs-type">uint32_t</span>              layerCount; <span class="hljs-comment">//图像层数目</span><br>&#125; VkImageSubresourceRange;<br></code></pre></td></tr></table></figure><p>我们希望交换链中的图像用作颜色缓冲，因此<i><font color="Orange">subresourceRange.aspectMask</font></i>应该指定为<i><font color="Red">VK_IMAGE_ASPECT_COLOR_BIT</font></i>。颜色缓冲不需要生成多级渐远纹理，因此<i><font color="Orange">subresourceRange.baseMipLevel</font></i>设为0，<i><font color="Orange">subresourceRange.levelCount</font></i>设为1。由于我们并非创建一个3D项目，因此并不需要多图像层，因此<i><font color="Orange">subresourceRange.baseArrayLayer</font></i>设为0，<i><font color="Orange">subresourceRange.layerCount</font></i>设为1即可。</p><p>这样我们就完成了信息的填写。</p><hr><h2 id="创建视图">创建视图</h2><p>创建过程一如以往：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateImageView</span>(device, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;swapChainImageViews[i]) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create image views!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，即使创建好了图像视图，也不意味着图像已经可以作为渲染目标使用了，我们还需要创建帧缓冲对象来存储图像视图才能进行渲染，后续章节会介绍这一部分内容。</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/">上一篇：交换链</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/">下一篇：渲染管线简介</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>交换链</title>
    <link href="/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/"/>
    <url>/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>Vulkan中并没有所谓的“默认帧缓冲”的概念，所以我们需要一个能够储存渲染后图像以便之后显示到屏幕上的设施，这个设施就是交换链（swapChain）。交换链本质上就是一列图像，我们的应用程序会不断获取其中的一张，显示到屏幕上，然后归还给交换链。</p><p>创建一个交换链主要分为三步：</p><ul><li>查询显卡是否支持交换链并启用相应拓展</li><li>填写创建交换链所需的必要信息</li><li>创建交换链并保存有关对象为类成员</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain#page_Surface-format">Swapchain</a>章节。</p><hr><h2 id="查询支持">查询支持</h2><p>查询硬件是否支持交换链可以分为两步：查询交换链是否可用，以及查询交换链是否完整地具有所需的功能。</p><h4 id="查询交换链可用性">查询交换链可用性</h4><p>首先来查询物理设备是否支持交换链。事实上，如果一个物理设备支持显示队列的话，那么它一定支持交换链拓展。不过，在Vulkan中清晰地展示出一切细节总不是件坏事。所以这里我们还是选择查询一下设备对交换链的支持。</p><p>交换链支持拓展名为<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_swapchain.html"><code>VK_KHR_swapchain</code></a>，它是一个设备层面的拓展。于是我们在类外创建一个全局变量保存我们可能需要的所有设备层面的拓展名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; deviceExtensions = &#123;<br>    VK_KHR_SWAPCHAIN_EXTENSION_NAME<span class="hljs-comment">//字符串&quot;VK_KHR_swapchain&quot;对应的宏，用它避免拼写错误</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>下面，我们需要查询物理设备是否支持这个拓展。于是添加一个<i><font color="Green">checkDeviceExtensionSupport</font></i>函数来统一处理设备层面拓展的支持查询：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkDeviceExtensionSupport</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> extensionCount;<br>    <span class="hljs-built_in">vkEnumerateDeviceExtensionProperties</span>(device, <span class="hljs-literal">nullptr</span>, &amp;extensionCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkExtensionProperties&gt; <span class="hljs-title">availableExtensions</span><span class="hljs-params">(extensionCount)</span></span>;<br>    <span class="hljs-built_in">vkEnumerateDeviceExtensionProperties</span>(device, <span class="hljs-literal">nullptr</span>, &amp;extensionCount, availableExtensions.<span class="hljs-built_in">data</span>());<br><br>    <span class="hljs-function">std::set&lt;std::string&gt; <span class="hljs-title">requiredExtensions</span><span class="hljs-params">(deviceExtensions.begin(), deviceExtensions.end())</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; extension : availableExtensions) &#123;<br>        requiredExtensions.<span class="hljs-built_in">erase</span>(extension.extensionName);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> requiredExtensions.<span class="hljs-built_in">empty</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是易于理解的。</p><p>接下来我们要做的就是在<i><font color="Green">isDeviceSuitable</font></i>函数中使用<i><font color="Green">checkDeviceExtensionSupport</font></i>检查给定的物理设备是否支持指定的拓展：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(device);<br><br>    <span class="hljs-type">bool</span> extensionsSupported = <span class="hljs-built_in">checkDeviceExtensionSupport</span>(device);<br><br>    <span class="hljs-keyword">return</span> indices.<span class="hljs-built_in">isComplete</span>() &amp;&amp; extensionsSupported;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，如果选择的物理设备支持交换链拓展，那么我们需要启用这个拓展。启用拓展只需略微修改逻辑设备的createInfo，将原来的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.enabledExtensionCount = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>改为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.enabledExtensionCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(deviceExtensions.<span class="hljs-built_in">size</span>());<br>createInfo.ppEnabledExtensionNames = deviceExtensions.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>即可。</p><h4 id="查询交换链完整性">查询交换链完整性</h4><p>仅仅查询交换链是否可用是不够的，我们还需要知道选定的支持交换链的物理设备是否具有所需的和显示有关的表面功能特性。我们需要查询的主要细节有三点：</p><ul><li>基本表面属性，包括交换链可以具有的最少/最多图像数目，图像的最小/最大尺寸等</li><li>表面格式，具体而言指的是像素格式和颜色空间</li><li>可用显示模式</li></ul><p>于是建立一个结构体<i><font color="Orange">SwapChainSupportDetails</font></i>来保存这些查询结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SwapChainSupportDetails</span> &#123;<br>    VkSurfaceCapabilitiesKHR capabilities;<br>    std::vector&lt;VkSurfaceFormatKHR&gt; formats;<br>    std::vector&lt;VkPresentModeKHR&gt; presentModes;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在类内建立一个成员函数<i><font color="Green">SwapChainSupportDetailsquerySwapChainSupport(VkPhysicalDevicedevice)</font></i>来负责具体的查询：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SwapChainSupportDetails <span class="hljs-title">querySwapChainSupport</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    SwapChainSupportDetails details;<br><br>    <span class="hljs-built_in">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</span>(device, surface, &amp;details.capabilities);<br>    <br>    <span class="hljs-type">uint32_t</span> formatCount;<br><span class="hljs-built_in">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(device, surface, &amp;formatCount, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-keyword">if</span> (formatCount != <span class="hljs-number">0</span>) &#123;<br>    details.formats.<span class="hljs-built_in">resize</span>(formatCount);<br>    <span class="hljs-built_in">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(device, surface, &amp;formatCount, details.formats.<span class="hljs-built_in">data</span>());<br>&#125;<br>    <br>    <span class="hljs-type">uint32_t</span> presentModeCount;<br><span class="hljs-built_in">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(device, surface, &amp;presentModeCount, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-keyword">if</span> (presentModeCount != <span class="hljs-number">0</span>) &#123;<br>    details.presentModes.<span class="hljs-built_in">resize</span>(presentModeCount);<br>    <span class="hljs-built_in">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(device, surface, &amp;presentModeCount, details.presentModes.<span class="hljs-built_in">data</span>());<br>&#125;<br>    <span class="hljs-keyword">return</span> details;<br>&#125;<br></code></pre></td></tr></table></figure><p>查询过程就是单纯地依次填充每个结构体成员。在这里我们只是简单地要求表面格式和显示模式均至少要有一种，这样就认为该物理设备的交换链是完整可用的。</p><p>现在我们需要再次修改一下<i><font color="Green">isDeviceSuitable</font></i>函数以添加检查交换链完整性的逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(device);<br><br>    <span class="hljs-type">bool</span> extensionsSupported = <span class="hljs-built_in">checkDeviceExtensionSupport</span>(device);<br><br>    <span class="hljs-type">bool</span> swapChainAdequate = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (extensionsSupported) &#123;<br>        SwapChainSupportDetails swapChainSupport = <span class="hljs-built_in">querySwapChainSupport</span>(device);<br>        swapChainAdequate = !swapChainSupport.formats.<span class="hljs-built_in">empty</span>() &amp;&amp; !swapChainSupport.presentModes.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> indices.<span class="hljs-built_in">isComplete</span>() &amp;&amp; extensionsSupported &amp;&amp; swapChainAdequate;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="填写创建信息">填写创建信息</h2><p>下面我们创建一个<i><font color="Green">voidcreateSwapChain()</font></i>函数来创建交换链。首先我们需要查询交换链有关的表面信息以方便后续交换链创建信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>的填写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createSwapChain</span><span class="hljs-params">()</span> </span>&#123;<br>    SwapChainSupportDetails swapChainSupport = <span class="hljs-built_in">querySwapChainSupport</span>(physicalDevice);<br><br>    VkSwapchainCreateInfoKHR createInfo&#123;&#125;;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>交换链创建信息需要指定的信息量相较于之前创建的对象要多得多，我们逐个填写。</p><p>首先总览一下交换链创建信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkSwapchainCreateInfoKHR</span> &#123;</span><br>    VkStructureType                  sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                      pNext;<br>    VkSwapchainCreateFlagsKHR        flags;<br>    VkSurfaceKHR                     surface; <span class="hljs-comment">//对应的表面</span><br>    <span class="hljs-type">uint32_t</span>                         minImageCount;<br>    VkFormat                         imageFormat;<br>    VkColorSpaceKHR                  imageColorSpace;<br>    VkExtent2D                       imageExtent;<br>    <span class="hljs-type">uint32_t</span>                         imageArrayLayers;<br>    VkImageUsageFlags                imageUsage;<br>    VkSharingMode                    imageSharingMode;<br>    <span class="hljs-type">uint32_t</span>                         queueFamilyIndexCount;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*                  pQueueFamilyIndices;<br>    VkSurfaceTransformFlagBitsKHR    preTransform;<br>    VkCompositeAlphaFlagBitsKHR      compositeAlpha;<br>    VkPresentModeKHR                 presentMode;<br>    VkBool32                         clipped;<br>    VkSwapchainKHR                   oldSwapchain;<br>&#125; VkSwapchainCreateInfoKHR;<br></code></pre></td></tr></table></figure><p>首先看第三个成员<i><font color="Orange">flags</font></i>，它是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateFlagBitsKHR.html"><code>VkSwapchainCreateFlagBitsKHR</code></a>的位组合。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateFlagBitsKHR.html"><code>VkSwapchainCreateFlagBitsKHR</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_swapchain</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkSwapchainCreateFlagBitsKHR</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1 with VK_KHR_swapchain, VK_KHR_device_group with VK_KHR_swapchain</span><br>    VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//表示交换链的图像可以在不同的实例中进行绑定，这对于多实例的设备组（Device Group）非常有用。它允许在不同的设备实例之间共享交换链图像</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1 with VK_KHR_swapchain</span><br>    VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = <span class="hljs-number">0x00000002</span>,<span class="hljs-comment">//指定交换链中的图像是受保护的。这意味着这些图像的内容在某些情况下（例如，受保护的内容播放）不会被访问或修改。这个标志通常用于需要内容保护的应用程序，如播放受版权保护的媒体</span><br>  <span class="hljs-comment">// Provided by VK_KHR_swapchain_mutable_format</span><br>    VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//允许交换链的格式在创建后进行更改。这对于需要动态调整图像格式的应用程序非常有用，比如在不同的显示设备上使用不同的格式</span><br>  <span class="hljs-comment">// Provided by VK_EXT_swapchain_maintenance1</span><br>    VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//指示交换链的图像内存分配可以延迟到实际使用时。这有助于优化内存使用，特别是在不确定图像会被使用的情况下</span><br>&#125; VkSwapchainCreateFlagBitsKHR;<br></code></pre></td></tr></table></figure><p>我们这里不需要设置任何标志位;</p><p>接下来要填写<i><font color="Orange">minImageCount</font></i>成员。这可以通过查询我们之前自定义的结构体<i><font color="Orange">SwapChainSupportDetails</font></i>的成员<i><font color="Orange">capabilities</font></i>的<i><font color="Orange">minImageCount</font></i>和<i><font color="Orange">maxImageCount</font></i>成员来决定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> imageCount = swapChainSupport.capabilities.minImageCount + <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span> (swapChainSupport.capabilities.maxImageCount &gt; <span class="hljs-number">0</span> &amp;&amp; imageCount &gt; swapChainSupport.capabilities.maxImageCount) &#123;<br>    imageCount = swapChainSupport.capabilities.maxImageCount;<br>&#125;<br><br>createInfo.minImageCount = imageCount;<br></code></pre></td></tr></table></figure><p>这里有两个需要解释的地方：第一行中加1是因为如果仅仅使用最少数量的图像可能意味着我们有时可能需要等待驱动程序完成内部操作，才能获取另一个图像进行渲染，因此我们要求至少多一张图像；另外maxImageCount==0其实意味着交换链可以拥有的图像没有上界，因此当这个值大于0时，我们需要控制要求的交换链图像数目不超过其可能上界。</p><p>接下来，对于<i><font color="Orange">imageFormat</font></i>和<i><font color="Orange">imageColorSpace</font></i>成员，我们可以通过<i><font color="Orange">SwapChainSupportDetails</font></i>结构体的成员<i><font color="Orange">formats</font></i>成员来获取相关信息。<i><font color="Orange">formats</font></i>包含了交换链支持的所有表面图像格式信息，我们需要从中挑选最符合我们要求的那个格式。因此，我们创建一个<i><font color="Green">VkSurfaceFormatKHRchooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>&amp;availableFormats)</VkSurfaceFormatKHR></font></i>函数来达到上述目的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkSurfaceFormatKHR <span class="hljs-title">chooseSwapSurfaceFormat</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;VkSurfaceFormatKHR&gt;&amp; availableFormats)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; availableFormat : availableFormats) &#123;<br>        <span class="hljs-keyword">if</span> (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB &amp;&amp; availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) &#123;<br>            <span class="hljs-keyword">return</span> availableFormat;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> availableFormats[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>我们希望挑选的颜色格式是<i><font color="Red">VK_FORMAT_B8G8R8A8_SRGB</font></i>，希望图像所处的颜色空间为sRGB颜色空间<i><font color="Red">VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</font></i>（关于sRGB空间和伽马矫正的原理介绍，可以参考<a href="https://learnopengl.com/Introduction">LearnOpenGL</a>教程的<a href="https://learnopengl.com/Advanced-Lighting/Gamma-Correction">GammaCorrection</a>章节），如果不支持这种格式的图像的话，那就退而求其次，直接返回第一个支持的格式（当然我们可以自定义一些更复杂的选择逻辑）。</p><p>这样，我们就可以填写<i><font color="Orange">imageFormat</font></i>和<i><font color="Orange">imageColorSpace</font></i>成员的信息了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkSurfaceFormatKHR surfaceFormat = <span class="hljs-built_in">chooseSwapSurfaceFormat</span>(swapChainSupport.formats);<br><br>createInfo.imageFormat = surfaceFormat.format;<br>createInfo.imageColorSpace = surfaceFormat.colorSpace;<br></code></pre></td></tr></table></figure><p>然后我们来填写<i><font color="Orange">imageExtent</font></i>成员。这个形参代表的是交换链图像的分辨率。一般来讲，这个分辨率要和屏幕的分辨率一致，此时我们可以直接通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilitiesKHR.html"><code>VkSurfaceCapabilitiesKHR</code></a>结构体的<i><font color="Orange">currentExtent</font></i>成员来获取图像的尺寸。但是有的窗口系统会允许交换链图像的分辨率与屏幕分辨率不一致，此时<i><font color="Orange">currentExtent</font></i>会被设置为<a href="https://en.cppreference.com/w/cpp/types/numeric_limits/max"><code>std::numeric_limits&lt;uint32_t&gt;::max()</code></a>，这种时候我们就必须自己决定最匹配屏幕的图像分辨率了。我们可以创建一个<i><font color="Green">VkExtent2DchooseSwapExtent(const VkSurfaceCapabilitiesKHR&amp;capabilities)</font></i>函数来决定图像分辨率：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkExtent2D <span class="hljs-title">chooseSwapExtent</span><span class="hljs-params">(<span class="hljs-type">const</span> VkSurfaceCapabilitiesKHR&amp; capabilities)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (capabilities.currentExtent.width != std::numeric_limits&lt;<span class="hljs-type">uint32_t</span>&gt;::<span class="hljs-built_in">max</span>()) &#123;<br>        <span class="hljs-keyword">return</span> capabilities.currentExtent;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> width, height;<br>        <span class="hljs-built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);<br><br>        VkExtent2D actualExtent = &#123;<br>            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(width),<br>            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(height)<br>        &#125;;<br><br>        actualExtent.width = std::<span class="hljs-built_in">clamp</span>(actualExtent.width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width);<br>        actualExtent.height = std::<span class="hljs-built_in">clamp</span>(actualExtent.height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height);<br><br>        <span class="hljs-keyword">return</span> actualExtent;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要注意，GLFW有两种分辨率单位，一种是屏幕坐标，另一种是像素个数，这二者未必总是相同的，例如在高DPI设备上实际像素数就要高于屏幕坐标范围。由于Vulkan指定的图像分辨率是通过像素个数指定的，所以我们需要使用<a href="https://www.glfw.org/docs/3.3/group__window.html#ga0e2637a4161afb283f5300c7f94785c9"><code>glfwGetFramebufferSize</code></a>来获取当前屏幕的像素数。另外，我们需要控制选取的图像像素数不超过[minImageExtent,maxImageExtent]的范围，这通过<a href="https://en.cppreference.com/w/cpp/algorithm/clamp"><code>std::clamp</code></a>实现。</p><p>这样我们就可以使用该函数得到createInfo中需要的图像尺寸了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkExtent2D extent = <span class="hljs-built_in">chooseSwapExtent</span>(swapChainSupport.capabilities);<br><br>createInfo.imageExtent = extent;<br></code></pre></td></tr></table></figure><p><i><font color="Orange">VkSwapchainCreateInfoKHR</font></i>结构体中接下来的成员<i><font color="Orange">imageArrayLayers</font></i>是多视图/立体表面中的视图数量。对于非立体3D应用程序，这个值为1。我们直接将其设为1即可。</p><p>接下来我们需要指定交换链中图像的用途。我们目前希望交换链中的图像用作渲染目标，于是可以给<i><font color="Orange">imageUsage</font></i>成员赋予<i><font color="Red">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</font></i>，也就是指定图像作为渲染的颜色缓冲。之后我们会接触到更多的图像使用方式。</p><p>下面我们要指定交换链中的图像要怎么用于多个队列家族中。当我们之前选定的图像队列和显示队列不一致的时候，我们就有两个不同队列家族种的队列了，此时我们需要指定这两个队列共享图像的模式，这通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html"><code>VkSharingMode</code></a>来指定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkSharingMode</span> &#123;</span><br>    VK_SHARING_MODE_EXCLUSIVE = <span class="hljs-number">0</span>,<span class="hljs-comment">//不允许同时有多个队列家族的队列访问图像</span><br>    VK_SHARING_MODE_CONCURRENT = <span class="hljs-number">1</span>,<span class="hljs-comment">//可以同时有多个队列家族的队列访问图像</span><br>&#125; VkSharingMode;<br></code></pre></td></tr></table></figure><p>如果有多个队列家族都需要访问交换链图像，此时如果选择<i><font color="Red">VK_SHARING_MODE_EXCLUSIVE</font></i>，那么我们还需要处理图像所有权在不同队列之间的转移问题。因此在这种情况下我们就简单地使用<i><font color="Red">VK_SHARING_MODE_CONCURRENT</font></i>模式就好了。如果只有一个队列家族（图像队列和显示队列一致），那么直接使用<i><font color="Red">VK_SHARING_MODE_EXCLUSIVE</font></i>就可以了。当然，在指定了共享模式之后，我们还需要指定共享这些图像的队列家族个数和索引：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(physicalDevice);<br><span class="hljs-type">uint32_t</span> queueFamilyIndices[] = &#123;indices.graphicsFamily.<span class="hljs-built_in">value</span>(), indices.presentFamily.<span class="hljs-built_in">value</span>()&#125;;<br><br><span class="hljs-keyword">if</span> (indices.graphicsFamily != indices.presentFamily) &#123;<br>    createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;<br>    createInfo.queueFamilyIndexCount = <span class="hljs-number">2</span>;<br>    createInfo.pQueueFamilyIndices = queueFamilyIndices;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;<br>    createInfo.queueFamilyIndexCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Optional</span><br>    createInfo.pQueueFamilyIndices = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Optional</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们可以指定显示图像之前作用于交换链图像上的变换<i><font color="Orange">preTransform</font></i>。我们目前并不需要任何预变换，所以像下面这样设置就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.preTransform = swapChainSupport.capabilities.currentTransform;<br></code></pre></td></tr></table></figure><p>我们还需要填写<i><font color="Orange">compositeAlpha</font></i>成员，该成员指定alpha通道是否可以用来和窗口系统中的其它窗口混合，这几乎总是被忽略的，因此我们只需赋予它<i><font color="Red">VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR</font></i>即可。</p><p>接下来我们需要指定交换链的显示类型。通过<i><font color="Green">querySwapChainSupport</font></i>函数我们可以获得交换链所支持的所有显示类型，我们可以从其中选择所需的类型。</p><p>显示类型由一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html"><code>VkPresentModeKHR</code></a>枚举类型表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_surface</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkPresentModeKHR</span> &#123;</span><br>    VK_PRESENT_MODE_IMMEDIATE_KHR = <span class="hljs-number">0</span>,<br>    VK_PRESENT_MODE_MAILBOX_KHR = <span class="hljs-number">1</span>,<br>    VK_PRESENT_MODE_FIFO_KHR = <span class="hljs-number">2</span>,<br>    VK_PRESENT_MODE_FIFO_RELAXED_KHR = <span class="hljs-number">3</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_shared_presentable_image</span><br>    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = <span class="hljs-number">1000111000</span>,<br>  <span class="hljs-comment">// Provided by VK_KHR_shared_presentable_image</span><br>    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = <span class="hljs-number">1000111001</span>,<br>  <span class="hljs-comment">// Provided by VK_EXT_present_mode_fifo_latest_ready</span><br>    VK_PRESENT_MODE_FIFO_LATEST_READY_EXT = <span class="hljs-number">1000361000</span>,<br>&#125; VkPresentModeKHR;<br></code></pre></td></tr></table></figure><p>我们不详细解释每种类型的含义，只具体解释两种经常使用的类型：<i><font color="Red">VK_PRESENT_MODE_FIFO_KHR</font></i>和<i><font color="Red">VK_PRESENT_MODE_MAILBOX_KHR</font></i>。前者指定当屏幕刷新的时候从队列头获取一张图像，同时程序将渲染好的图像放到队列的尾部，如果队列已经满了，那么程序就需要等待队列出现空间时再插入新图片。后者和前者基本相同，区别在于当队列满的时候，程序会直接使用新渲染的图像替代队列尾的图像，这可以提高渲染效率并降低延迟，但相应的开销也会更大。因此很多移动设备仍然会选择前者作为显示模式。另外，<i><font color="Red">VK_PRESENT_MODE_FIFO_KHR</font></i>被保证在任何支持交换链的设备上都是一定可用的，因此我们可以写一个选择显示模式的函数<i><font color="Green">VkPresentModeKHRchooseSwapPresentMode(const std::vector<VkPresentModeKHR>&amp;availablePresentModes)</VkPresentModeKHR></font></i>，它优先选择<i><font color="Red">VK_PRESENT_MODE_MAILBOX_KHR</font></i>，如果该模式不可用，那么再选择<i><font color="Red">VK_PRESENT_MODE_FIFO_KHR</font></i>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkPresentModeKHR <span class="hljs-title">chooseSwapPresentMode</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;VkPresentModeKHR&gt;&amp; availablePresentModes)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; availablePresentMode : availablePresentModes) &#123;<br>        <span class="hljs-keyword">if</span> (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) &#123;<br>            <span class="hljs-keyword">return</span> availablePresentMode;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> VK_PRESENT_MODE_FIFO_KHR;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>结构体的<i><font color="Orange">presentMode</font></i>成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">createInfo.presentMode = presentMode;<br></code></pre></td></tr></table></figure><p>然后我们需要指定<i><font color="Orange">createInfo</font></i>的<i><font color="Orange">clipped</font></i>成员。这个成员如果为<i><font color="Red">VK_TRUE</font></i>，就表明我们不在乎那些被其它窗口挡住的应用程序窗口的像素，那部分可以不进行显示。为了性能起见这个选项一般会设为<i><font color="Red">VK_TRUE</font></i>。</p><p>最后，在Vulkan程序运行的过程中，交换链很有可能会变得不再有效或者不再是性能最优的，比如窗口缩放等操作都会造成这种问题。因此，我们可能需要经常从头构建一个新的交换链。因此在一个新交换链的构建信息中指定一个旧交换链可以有助于减少资源的重新分配，提高性能，还能保证在新交换链创建后，旧交换链的资源能够被正确管理和释放，避免资源泄漏。交换链的更新是一个比较复杂的主题，我们将在后面介绍。在这里我们仅简单地将最后一个成员<i><font color="Orange">oldSwapchain</font></i>设置为<i><font color="Red">VK_NULL_HANDLE</font></i>。</p><p>终于，我们完成了<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html"><code>VkSwapchainCreateInfoKHR</code></a>结构体的填写！</p><hr><h2 id="创建交换链">创建交换链</h2><p>接下来我们终于可以创建交换链对象了。在类内新增一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSwapchainKHR.html"><code>VkSwapchainKHR</code></a>成员，构建过程我们已经非常熟悉：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateSwapchainKHR</span>(device, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;swapChain) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create swap chain!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，在后续章节涉及到渲染的时候我们还需要在代码中使用交换链中的图像，因此我们将这些图像也保存为类内成员<i><font color="Orange">std::vector<VkImage>swapChainImages</VkImage></font></i>，然后我们紧接着创建交换链之后来获取这些图像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkGetSwapchainImagesKHR</span>(device, swapChain, &amp;imageCount, <span class="hljs-literal">nullptr</span>);<br>swapChainImages.<span class="hljs-built_in">resize</span>(imageCount);<br><span class="hljs-built_in">vkGetSwapchainImagesKHR</span>(device, swapChain, &amp;imageCount, swapChainImages.<span class="hljs-built_in">data</span>());<br></code></pre></td></tr></table></figure><p>另外注意，在交换链销毁的时候这些交换链中的图像会被自动销毁，因此我们并不需要手动销毁它们。</p><p>我们在后续章节还会用到这些图像的图像格式以及图像尺寸，因此在类内再新增两个成员<i><font color="Orange">VkFormatswapChainImageFormat</font></i>以及<i><font color="Orange">VkExtent2DswapChainExtent</font></i>分别保存这两者，并且在设置<i><font color="Orange">VkSwapchainCreateInfoKHR</font></i>的相应形参的时候顺便保存这两个成员就可以了。</p><p>大功告成！可喜可贺~</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/">上一篇：窗口表面</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/11/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/">下一篇：图像视图</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>窗口表面</title>
    <link href="/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/"/>
    <url>/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述">概述</h2><p>因为Vulkan本身是平台无关的，所以它并不会直接和不同的窗口系统打交道，而是要通过所谓的WSI(WindowSystemIntegration)拓展来达到和窗口系统交互的目的。这一节我们将讨论该拓展提供的表面对象<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html"><code>VkSurfaceKHR</code></a>，该对象用于提供展示渲染结果所需的窗口表面。该对象将由我们使用的窗口系统GLFW负责创建。</p><p>值得一提的是，WSI拓展其实是一个Instance层面的拓展而非设备层面。之所以将这个Instance层面的拓展延后到本节来讲而不是在<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">创建Instance</a>章节讲是因为表面和接下来要讲的有关展示图像的内容部分关系紧密，所以将这些内容放在一起会更加自然。</p><p>另外，表面对象一定要在选择物理设备之前创建，因为表面其实会影响物理设备的选择。不过并非所有的应用程序都需要这样一个表面对象，因为有的程序只需要离屏渲染即可。对于这种应用程序，可以为它们创建一个不可见的窗口。</p><p>创建窗口表面分为三步：</p><ul><li>创建并保存<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html"><code>VkSurfaceKHR</code></a>对象</li><li>查询支持将图像显示到该表面的物理设备</li><li>构建该设备展示显示图像所需的显示队列</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Window_surface">Windowsurface</a>章节。</p><hr><h2 id="创建表面">创建表面</h2><p>在应用程序类内添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html"><code>VkSurfaceKHR</code></a>成员<i><font color="Orange">surface</font></i>用于保存表面对象。</p><p>创建一个表面对象很简单，首先我们需要启用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_surface.html"><code>VK_KHR_surface</code></a>拓展。幸运的是这个拓展已经包含在<a href="https://www.glfw.org/docs/3.3/group__vulkan.html#ga99ad342d82f4a3421e2864978cb6d1d6"><code>glfwGetRequiredInstanceExtensions</code></a>所返回的拓展中了，我们无需额外添加。接下来只需调用<a href="https://www.glfw.org/docs/3.3/group__vulkan.html#ga1a24536bec3f80b08ead18e28e6ae965"><code>glfwCreateWindowSurface</code></a>函数，GLFW就会帮我们处理好一切平台相关的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createSurface</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwCreateWindowSurface</span>(instance, window, <span class="hljs-literal">nullptr</span>, &amp;surface) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create window surface!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过虽然glfw负责创建该表面对象，销毁它仍然使用的是Vulkan的API：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkDestroySurfaceKHR</span>(instance, surface, <span class="hljs-literal">nullptr</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="查询支持设备">查询支持设备</h2><p>Vulkan本身是支持WSI的，但这并不意味着所有的显卡都可以支持这个拓展。为了保证选取的物理设备支持该拓展，我们需要拓展<i><font color="Green">isDeviceSuitable</font></i>函数以保证选择的物理设备支持将图像显示到创建的表面上。由于显示图像其实是一个和队列有关的特性，因此我们其实需要的是选择一个具有支持显示对象到指定表面功能的队列家族的物理设备。</p><p>因此，我们首先拓展一下<i><font color="Orange">QueueFamilyIndices</font></i>结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">QueueFamilyIndices</span> &#123;<br>    std::optional&lt;<span class="hljs-type">uint32_t</span>&gt; graphicsFamily;<br>    std::optional&lt;<span class="hljs-type">uint32_t</span>&gt; presentFamily;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isComplete</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> graphicsFamily.<span class="hljs-built_in">has_value</span>() &amp;&amp; presentFamily.<span class="hljs-built_in">has_value</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意，支持显示图像的队列家族和支持图像功能的的队列家族未必相同，虽然它们大概率一致，但保险起见我们还是使用两个队列家族分别存储。</p><p>接下来我们需要修改<i><font color="Green">findQueueFamilies</font></i>函数来寻找<i><font color="Orange">presentFamily</font></i>。为了寻找这样一个队列家族，我们使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceSupportKHR.html"><code>vkGetPhysicalDeviceSurfaceSupportKHR</code></a>函数。现在<i><font color="Green">findQueueFamilies</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QueueFamilyIndices <span class="hljs-title">findQueueFamilies</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices;<br><br>    <span class="hljs-type">uint32_t</span> queueFamilyCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkQueueFamilyProperties&gt; <span class="hljs-title">queueFamilies</span><span class="hljs-params">(queueFamilyCount)</span></span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, queueFamilies.<span class="hljs-built_in">data</span>());<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; queueFamily : queueFamilies) &#123;<br>        <span class="hljs-keyword">if</span> (queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) &#123;<br>            indices.graphicsFamily = i;<br>        &#125;<br><br>        VkBool32 presentSupport = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">vkGetPhysicalDeviceSurfaceSupportKHR</span>(device, i, surface, &amp;presentSupport);<br><br>        <span class="hljs-keyword">if</span> (presentSupport) &#123;<br>            indices.presentFamily = i;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (indices.<span class="hljs-built_in">isComplete</span>()) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        i++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> indices;<br>    &#125;<br></code></pre></td></tr></table></figure><p><i><font color="Green">isDeviceSuitable</font></i>函数的代码并不需要改动，因为它通过调用<i><font color="Orange">QueueFamilyIndices</font></i>结构体的成员函数<i><font color="Green">isComplete</font></i>来检查物理设备是否满足要求，而<font color="Green">isComplete</font>已经更新了并包含了目前一切需要检查的信息。</p><hr><h2 id="构建展示队列">构建展示队列</h2><p>接下来如同图形队列一样，设备对应的显示队列也应该保存在类内一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkQueue.html"><code>VkQueue</code></a>类型的成员<i><font color="Orange">presentQueue</font></i>中。</p><p>现在我们的逻辑设备已经有两个需要的队列了（如果它们不是同一个的话），因此在逻辑设备的创建信息<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateInfo.html"><code>VkDeviceCreateInfo</code></a>中我们需要两个对应的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html"><code>VkDeviceQueueCreateInfo</code></a>。因此我们需要更新<i><font color="Green">createLogicalDevice</font></i>函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createLogicalDevice</span><span class="hljs-params">()</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(physicalDevice);<br><br>    std::vector&lt;VkDeviceQueueCreateInfo&gt; queueCreateInfos;<br>    std::set&lt;<span class="hljs-type">uint32_t</span>&gt; uniqueQueueFamilies = &#123;indices.graphicsFamily.<span class="hljs-built_in">value</span>(), indices.presentFamily.<span class="hljs-built_in">value</span>()&#125;;<br><br>    <span class="hljs-type">float</span> queuePriority = <span class="hljs-number">1.0f</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> queueFamily : uniqueQueueFamilies) &#123;<br>        VkDeviceQueueCreateInfo queueCreateInfo&#123;&#125;;<br>        queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;<br>        queueCreateInfo.queueFamilyIndex = queueFamily;<br>        queueCreateInfo.queueCount = <span class="hljs-number">1</span>;<br>        queueCreateInfo.pQueuePriorities = &amp;queuePriority;<br>        queueCreateInfos.<span class="hljs-built_in">push_back</span>(queueCreateInfo);<br>    &#125;<br><br>    VkPhysicalDeviceFeatures deviceFeatures&#123;&#125;;<br><br>    VkDeviceCreateInfo createInfo&#123;&#125;;<br>    createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;<br><br>    createInfo.queueCreateInfoCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(queueCreateInfos.<span class="hljs-built_in">size</span>());<br>    createInfo.pQueueCreateInfos = queueCreateInfos.<span class="hljs-built_in">data</span>();<br><br>    createInfo.pEnabledFeatures = &amp;deviceFeatures;<br><br>    createInfo.enabledExtensionCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>        createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateDevice</span>(physicalDevice, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;device) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create logical device!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">vkGetDeviceQueue</span>(device, indices.graphicsFamily.<span class="hljs-built_in">value</span>(), <span class="hljs-number">0</span>, &amp;graphicsQueue);<br>    <span class="hljs-built_in">vkGetDeviceQueue</span>(device, indices.presentFamily.<span class="hljs-built_in">value</span>(), <span class="hljs-number">0</span>, &amp;presentQueue);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个函数的最后，如同对图形队列所做的那样，我们调用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue.html"><code>vkGetDeviceQueue</code></a>来获得该逻辑设备对应的显示队列并保存到<i><font color="Orange">presentQueue</font></i>成员中。</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/">上一篇：逻辑设备和队列</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E4%BA%A4%E6%8D%A2%E9%93%BE/">下一篇：交换链</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>逻辑设备和队列</title>
    <link href="/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>如果说Instance是Vulkan库的接口和抽象，那么逻辑设备就是物理设备的接口和抽象。可以认为逻辑设备是对物理设备功能的一个“定制化”视图，允许开发者选择所需的功能集。构建与物理设备关联的逻辑设备可以分为三步：</p><ul><li>从选定物理设备的队列家族中分配所需数目的队列供逻辑设备使用</li><li>指定逻辑设备所需要的物理设备特性和功能拓展等</li><li>创建逻辑设备</li></ul><p>接下来我们将创建一个<i><font color="Green">voidcreateLogicalDevice()</font></i>函数用于构建逻辑设备，并添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDevice.html"><code>VkDevice</code></a>成员<i><font color="Orange">device</font></i>来存储创建的逻辑设备。</p><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Logical_device_and_queues">Logicaldevice and queues</a>章节</p><hr><h2 id="指定队列">指定队列</h2><p>指定逻辑设备需要使用的队列很简单，我们只需要创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html"><code>VkDeviceQueueCreateInfo</code></a>并填写相应信息即可。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDeviceQueueCreateInfo</span> &#123;</span><br>    VkStructureType             sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                 pNext;<br>    VkDeviceQueueCreateFlags    flags;<br>    <span class="hljs-type">uint32_t</span>                    queueFamilyIndex;<span class="hljs-comment">//队列家族索引，上一章在QueueFamilyIndices结构体中已经存储好了</span><br>    <span class="hljs-type">uint32_t</span>                    queueCount;      <span class="hljs-comment">//需要从该队列家族分配的队列数</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span>*                pQueuePriorities;<span class="hljs-comment">//队列优先级</span><br>&#125; VkDeviceQueueCreateInfo;<br></code></pre></td></tr></table></figure><p>其中<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlags.html"><code>VkDeviceQueueCreateFlags</code></a>是<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlagBits.html"><code>VkDeviceQueueCreateFlagBits</code></a>的位组合，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlagBits.html"><code>VkDeviceQueueCreateFlagBits</code></a>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDeviceQueueCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_VERSION_1_1</span><br>    VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//受保护的队列，用于处理敏感数据或需要额外安全性的操作</span><br>&#125; VkDeviceQueueCreateFlagBits;<br></code></pre></td></tr></table></figure><p>另外，队列优先级是一个0.0到1.0之间的数，规定了队列中的命令被执行的顺序，优先级大的优先执行和访问资源。注意，即使只有一个队列也应该指定优先级。</p><p>在这里我们只需要一个队列就可以了，事实上，大多数的时候我们也不需要分配多个队列，因为Vulkan允许在多线程上创建命令然后在主线程上一次性提交所有命令到一个队列。填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html"><code>VkDeviceQueueCreateInfo</code></a>过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(physicalDevice);<br><br>VkDeviceQueueCreateInfo queueCreateInfo&#123;&#125;;<br>queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;<br>queueCreateInfo.queueFamilyIndex = indices.graphicsFamily.<span class="hljs-built_in">value</span>();<br>queueCreateInfo.queueCount = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">float</span> queuePriority = <span class="hljs-number">1.0f</span>;<br>queueCreateInfo.pQueuePriorities = &amp;queuePriority;<br></code></pre></td></tr></table></figure><hr><h2 id="指定物理设备特性">指定物理设备特性</h2><p>物理设备特性通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures.html"><code>vkGetPhysicalDeviceFeatures</code></a>得到。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkGetPhysicalDeviceFeatures</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkPhysicalDevice                            physicalDevice,</span><br><span class="hljs-params">    VkPhysicalDeviceFeatures*                   pFeatures)</span>;<br></code></pre></td></tr></table></figure><p>我们暂时还不需要指定任何特性，所以只需在<i><font color="Green">createLogicalDevice</font></i>函数中把<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html"><code>VkPhysicalDeviceFeatures</code></a>结构体留空即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkPhysicalDeviceFeatures deviceFeatures&#123;&#125;;<br></code></pre></td></tr></table></figure><p>一如我们之前一直做的那样，创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDevice.html"><code>VkDevice</code></a>同样需要我们填写相应的信息结构体<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateInfo.html"><code>VkDeviceCreateInfo</code></a>。该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDeviceCreateInfo</span> &#123;</span><br>    VkStructureType                    sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                        pNext;<br>    VkDeviceCreateFlags                flags;<br>    <span class="hljs-type">uint32_t</span>                           queueCreateInfoCount;<br>    <span class="hljs-type">const</span> VkDeviceQueueCreateInfo*     pQueueCreateInfos;<br>    <span class="hljs-comment">// enabledLayerCount is deprecated and should not be used</span><br>    <span class="hljs-type">uint32_t</span>                           enabledLayerCount;<br>    <span class="hljs-comment">// ppEnabledLayerNames is deprecated and should not be used</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*                 ppEnabledLayerNames;<br>    <span class="hljs-type">uint32_t</span>                           enabledExtensionCount;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*                 ppEnabledExtensionNames;<br>    <span class="hljs-type">const</span> VkPhysicalDeviceFeatures*    pEnabledFeatures;<br>&#125; VkDeviceCreateInfo;<br></code></pre></td></tr></table></figure><p>可以看到为了填充该结构体，我们还需要指定逻辑设备需要的拓展以及层。在<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">验证层</a>章节已经提到，如今Vulkan已经不再使用devicespecific layers了，instance specificlayer适用于一切的Vulkan调用。然而，为了与旧代码兼容，显示地指定设备层仍然是一个好的选择。另外，当前我们对于设备所需要的拓展尚且没有什么要求，因此填充信息代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkDeviceCreateInfo createInfo&#123;&#125;;<br>createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;<br><br>createInfo.pQueueCreateInfos = &amp;queueCreateInfo;<br>createInfo.queueCreateInfoCount = <span class="hljs-number">1</span>;<br><br>createInfo.pEnabledFeatures = &amp;deviceFeatures;<br><br>createInfo.enabledExtensionCount = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>    createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>    createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="创建逻辑设备">创建逻辑设备</h2><p>一切就绪，我们可以构建逻辑设备对象了，构建过程一如我们之前构建对象时一直做的那样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateDevice</span>(physicalDevice, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;device) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create logical device!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑设备就此构建完成，但我们还有一些工作需要做。由于之后我们可能需要在代码中使用逻辑设备对应的队列对象，但目前在应用程序类中并没有保存这个对象，所以我们需要添加一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkQueue.html"><code>VkQueue</code></a>类型的成员<i><font color="Orange">graphicsQueue</font></i>来保存这个对象。可以使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue.html"><code>vkGetDeviceQueue</code></a>函数得到赋予该逻辑设备的队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vkGetDeviceQueue</span>(device, indices.graphicsFamily.<span class="hljs-built_in">value</span>(), <span class="hljs-number">0</span>, &amp;graphicsQueue);<br><span class="hljs-comment">//0代表获取的队列在队列家族中的索引。由于我们只需要一个队列，所以该值为0。</span><br></code></pre></td></tr></table></figure><p>大功告成！设备层面的建立以及完成了，接下来的章节我们将处理和图像处理及展示有关的初始化流程。</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97%E5%AE%B6%E6%97%8F/">上一篇：物理设备和队列家族</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/10/CG_api/vulkan/vulkan_tutorial/%E7%AA%97%E5%8F%A3%E8%A1%A8%E9%9D%A2/">下一篇：窗口表面</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>物理设备和队列家族</title>
    <link href="/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97%E5%AE%B6%E6%97%8F/"/>
    <url>/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97%E5%AE%B6%E6%97%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>在创建好了Instance之后，我们需要选择一个合适的物理设备（显卡）来执行实际的操作。实际上我们可以选择多张显卡同时工作，不过简单起见本文只选择一张显卡进行操作。选择合适的显卡主要分为两步：</p><ul><li>决定应用程序需要显卡具有的功能和属性。</li><li>从所有显卡中选择合适的那个作为物理设备。</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Physical_devices_and_queue_families">Physicaldevices and queue families</a>章节。</p><hr><h2 id="显卡要求">显卡要求</h2><p>显卡在Vulkan中的对应句柄对象为<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html"><code>VkPhysicalDevice</code></a>，我们可以创建一个<i><font color="Green">boolisDeviceSuitable(VkPhysicalDevicedevice)</font></i>函数来决定一张显卡是否满足我们的需求。目前我们只需要显卡支持图形队列家族（Graphicsqueuefamilies），也就是能够接受图形有关命令的队列家族，于是对于一个给定的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html"><code>VkPhysicalDevice</code></a>，我们可以创建一个<i><font color="Green">QueueFamilyIndicesfindQueueFamilies(VkPhysicalDevicedevice)</font></i>函数来检查它是否支持该队列家族。其中，我们定义结构体<i><font color="Orange">QueueFamilyIndices</font></i>如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">QueueFamilyIndices</span> &#123;<br>    std::optional&lt;<span class="hljs-type">uint32_t</span>&gt; graphicsFamily;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isComplete</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> graphicsFamily.<span class="hljs-built_in">has_value</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>为c++17定义的一个模板类，它有一个成员函数<i><font color="Green">constexprbool has_value() const noexcept</font></i>，该函数在赋予了<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>包裹的对象值后返回true，否则返回false。如此设计是因为有时在考虑应用程序需要的队列家族的时候，有些队列家族是可选的，也就是说显卡有该家族的话更好，没有的话也不应该直接终止程序，而是选择别的替代品，因此我们可以通过<a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>包裹对象是否存储了一个找到的值来做出决策。另外，该结构体目前只包含一个成员，随着应用程序的深入和复杂化，也会有更多的队列家族需求，也就会有更多的成员添加到这个结构体中来。</p><p>接下来看一下<i><font color="Green">findQueueFamilies</font></i>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QueueFamilyIndices <span class="hljs-title">findQueueFamilies</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices;<br><br>    <span class="hljs-type">uint32_t</span> queueFamilyCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkQueueFamilyProperties&gt; <span class="hljs-title">queueFamilies</span><span class="hljs-params">(queueFamilyCount)</span></span>;<br>    <span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, queueFamilies.<span class="hljs-built_in">data</span>());<br>    <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; queueFamily : queueFamilies) &#123;<br>        <span class="hljs-keyword">if</span> (queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) &#123;<br>            indices.graphicsFamily = i;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (indices.<span class="hljs-built_in">isComplete</span>()) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        i++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> indices;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数的代码是直观易懂的，这里不做过多解释了。</p><p>于是，接下来我们就可以在<i><font color="Green">isDeviceSuitable</font></i>函数中使用这个函数来判断一个物理设备是否符合要求（当前来讲就是是否具有图形队列家族）。当然，随着应用程序的复杂化，<i><font color="Green">isDeviceSuitable</font></i>函数还会逐渐地拓展：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>&#123;<br>    QueueFamilyIndices indices = <span class="hljs-built_in">findQueueFamilies</span>(device);<br><br>    <span class="hljs-keyword">return</span> indices.graphicsFamily.<span class="hljs-built_in">has_value</span>();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="选择显卡">选择显卡</h2><p>在决定好对于设备的要求之后，是时候开始挑选符合要求的显卡了！首先我们当然要枚举出Instance所具有的所有物理设备，并且在类内创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html"><code>VkPhysicalDevice</code></a>成员<i><font color="Orange">physicalDevice</font></i>来存储满足需求的显卡对象（将这个成员初始化为<i><font color="Orange">VK_NULL_HANDLE</font></i>。我们创建一个<i><font color="Green">voidpickPhysicalDevice()</font></i>成员函数来挑选需要的显卡：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pickPhysicalDevice</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">uint32_t</span> deviceCount = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">vkEnumeratePhysicalDevices</span>(instance, &amp;deviceCount, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span> (deviceCount == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to find GPUs with Vulkan support!&quot;</span>);<br>&#125;<br>    <span class="hljs-function">std::vector&lt;VkPhysicalDevice&gt; <span class="hljs-title">devices</span><span class="hljs-params">(deviceCount)</span></span>;<br><span class="hljs-built_in">vkEnumeratePhysicalDevices</span>(instance, &amp;deviceCount, devices.<span class="hljs-built_in">data</span>());<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来对于每一个显卡，检查它是否满足需求，简单起见，我们这里采取的策略是一旦找到了一张满足要求的显卡，就直接使用它。当然你可以自定义更加复杂的选取策略以寻找最合适的那张显卡。测试显卡是否满足要求只需使用上文创建的<i><font color="Green">isDeviceSuitable</font></i>函数即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//接pickPhysicalDevice函数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; device : devices) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isDeviceSuitable</span>(device)) &#123;<br>        physicalDevice = device;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (physicalDevice == VK_NULL_HANDLE) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to find a suitable GPU!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，由于Instance被销毁时，对应的物理设备会被自动销毁，所以我们不需要在<i><font color="Green">cleanup</font></i>函数中显示销毁它。</p><p>大功告成！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">上一篇：验证层</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/">下一篇：逻辑设备和队列</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>验证层</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p>VulkanAPI本身几乎不自带任何错误检测功能，不过这并不意味着我们不能添加相应的错误检测功能。Vulkan的验证层（validationlayer）就是为此而生。验证层是可选的组件，它们会挂钩到 Vulkan函数调用中，以执行额外的操作，包括：</p><ul><li>检查参数类型以避免错误调用</li><li>跟踪对象的创建和销毁以防止内存泄漏</li><li>检查线程安全性</li><li>把调用信息以及其参数输出到标准输出</li><li>跟踪调用以便性能优化和复现</li></ul><p>Vulkan中有两种验证层：instance layer和devicelayer。最初的想法是instance layer用于检查全局的Vulkan调用，而devicelayer用于检查特定GPU相关的调用。不过现在devicelayer已经逐渐被废弃了，也就是说现在可以将instancelayer用于检查任何Vulkan调用。当然，如果是为了和旧代码兼容，仍然可以使用devicelayer。</p><p>验证层的使用主要分为以下三步：</p><ul><li>启用验证层</li><li>设置回调函数</li><li>创建debug messenger以使用回调函数控制输出验证层产生的信息</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Validation_layers#page_Message-callback">Validationlayers</a>章节</p><hr><h2 id="启用验证层">启用验证层</h2><p>我们需要启用的是Vulkan中几乎包含了所有有用验证功能的层，它的名称为<i><font color="Orange">VK_LAYER_KHRONOS_validation</font></i>。在启用之前，如同拓展一样，我们也需要检查层的可用性，检查的方式和拓展如出一辙。首先我们需要列举出硬件支持的所有层：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkValidationLayerSupport</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> layerCount;<br>    <span class="hljs-built_in">vkEnumerateInstanceLayerProperties</span>(&amp;layerCount, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">std::vector&lt;VkLayerProperties&gt; <span class="hljs-title">availableLayers</span><span class="hljs-params">(layerCount)</span></span>;<br>    <span class="hljs-built_in">vkEnumerateInstanceLayerProperties</span>(&amp;layerCount, availableLayers.<span class="hljs-built_in">data</span>());<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们需要的是<i><font color="Orange">VK_LAYER_KHRONOS_validation</font></i>，它由名称对应的字符串给出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; validationLayers = &#123;<br>    <span class="hljs-string">&quot;VK_LAYER_KHRONOS_validation&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>于是我们需要检查这个层是否可用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//接上述checkValidationLayerSupport函数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span>* layerName : validationLayers) &#123;<br>    <span class="hljs-type">bool</span> layerFound = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; layerProperties : availableLayers) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(layerName, layerProperties.layerName) == <span class="hljs-number">0</span>) &#123;<br>            layerFound = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!layerFound) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>检查完毕后，我们还需要决定什么时候启用这个验证层。由于验证层输出的调试信息应该只能被开发应用程序的程序员看见，因此调试模式下我们理应启用该验证层，而发布模式下我们当然应该关闭该验证层功能。这可以通过宏来做到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> NDEBUG</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> enableValidationLayers = <span class="hljs-literal">false</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> enableValidationLayers = <span class="hljs-literal">true</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>另外，<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">上一篇</a>中我们没有填上<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>结构体中的层信息，现在就可以填上我们选取的验证层信息了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>    createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>    createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//发布模式不需要启用验证层，因此结构体中层信息也不需要填写</span><br>    createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="设置回调函数">设置回调函数</h2><p>默认情况下验证层会将调试信息输出到标准输出。但是更多时候我们希望自己控制输出信息的种类以及详细程度等。因此我们需要设置一个回调函数来指定信息输出的方式。</p><p>为了设置回调函数，我们需要一个新的拓展：<i><font color="Orange">VK_EXT_debug_utils</font></i>，因此我们可以创建一个<i><font color="Green">getRequiredExtensions</font></i>函数来统一处理所有需要的拓展：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; <span class="hljs-title">getRequiredExtensions</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> glfwExtensionCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>** glfwExtensions;<br>    glfwExtensions = <span class="hljs-built_in">glfwGetRequiredInstanceExtensions</span>(&amp;glfwExtensionCount);<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; <span class="hljs-title">extensions</span><span class="hljs-params">(glfwExtensions, glfwExtensions + glfwExtensionCount)</span></span>;<br><br>    <span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>        extensions.<span class="hljs-built_in">push_back</span>(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);<br>        <span class="hljs-comment">//VK_EXT_DEBUG_UTILS_EXTENSION_NAME是字符串&quot;VK_EXT_debug_utils&quot;等价的宏，使用宏可以避免拼写错误问题</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> extensions;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到的拓展用于Instance的创建：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> extensions = <span class="hljs-built_in">getRequiredExtensions</span>();<br>createInfo.enabledExtensionCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(extensions.<span class="hljs-built_in">size</span>());<br>createInfo.ppEnabledExtensionNames = extensions.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>在启用了回调函数所需要的拓展之后，就可以创建回调函数本身了。Vulkan通过函数指针<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/PFN_vkDebugUtilsMessengerCallbackEXT.html"><code>PFN_vkDebugUtilsMessengerCallbackEXT</code></a>指明了一个回调函数所应该具有的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">VkBool32</span> <span class="hljs-params">(VKAPI_PTR *PFN_vkDebugUtilsMessengerCallbackEXT)</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDebugUtilsMessageSeverityFlagBitsEXT           messageSeverity,</span><br><span class="hljs-params">    VkDebugUtilsMessageTypeFlagsEXT                  messageTypes,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkDebugUtilsMessengerCallbackDataEXT*      pCallbackData,</span><br><span class="hljs-params">    <span class="hljs-type">void</span>*                                            pUserData)</span>;<br></code></pre></td></tr></table></figure><p>第一个成员通过[<code>VkDebugUtilsMessageSeverityFlagBitsEXT</code><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessageSeverityFlagBitsEXT.html">id4</a>的位掩码指定输出信息的严重性，该枚举定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDebugUtilsMessageSeverityFlagBitsEXT</span> &#123;</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = <span class="hljs-number">0x00000001</span>,<span class="hljs-comment">//所有诊断信息</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = <span class="hljs-number">0x00000010</span>, <span class="hljs-comment">//信息性消息，如资源细节</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = <span class="hljs-number">0x00000100</span>,<span class="hljs-comment">//警告信息</span><br>    VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = <span class="hljs-number">0x00001000</span>,  <span class="hljs-comment">//错误信息</span><br>&#125; VkDebugUtilsMessageSeverityFlagBitsEXT;<br></code></pre></td></tr></table></figure><p>第二个成员通过<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessageTypeFlagBitsEXT.html"><code>VkDebugUtilsMessageTypeFlagsBitsEXT</code></a>的位掩码指定输出信息的种类，该枚举定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkDebugUtilsMessageTypeFlagBitsEXT</span> &#123;</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = <span class="hljs-number">0x00000001</span>,    <span class="hljs-comment">//与使用规范或性能无关的一般事件消息</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = <span class="hljs-number">0x00000002</span>, <span class="hljs-comment">//未遵循Vulkan使用规则</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = <span class="hljs-number">0x00000004</span>,<span class="hljs-comment">//性能浪费</span><br>  <span class="hljs-comment">// Provided by VK_EXT_device_address_binding_report</span><br>    VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT = <span class="hljs-number">0x00000008</span>,<span class="hljs-comment">//地址绑定信息</span><br>&#125; VkDebugUtilsMessageTypeFlagBitsEXT;<br></code></pre></td></tr></table></figure><p>第三个成员指向一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCallbackDataEXT.html"><code>VkDebugUtilsMessengerCallbackDataEXT</code></a>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkDebugUtilsMessengerCallbackDataEXT</span> &#123;</span><br>    VkStructureType                              sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                  pNext;<br>    VkDebugUtilsMessengerCallbackDataFlagsEXT    flags; <span class="hljs-comment">//目前只有0</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                                  pMessageIdName;  <span class="hljs-comment">//消息相关名称标识符</span><br>    <span class="hljs-type">int32_t</span>                                      messageIdNumber; <span class="hljs-comment">//该名称对应ID</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                                  pMessage;  <span class="hljs-comment">//具体调试信息</span><br>    <span class="hljs-type">uint32_t</span>                                     queueLabelCount; <span class="hljs-comment">//队列标签数</span><br>    <span class="hljs-type">const</span> VkDebugUtilsLabelEXT*                  pQueueLabels;    <span class="hljs-comment">//队列标签</span><br>    <span class="hljs-type">uint32_t</span>                                     cmdBufLabelCount;<span class="hljs-comment">//命令缓冲标签数</span><br>    <span class="hljs-type">const</span> VkDebugUtilsLabelEXT*                  pCmdBufLabels;  <span class="hljs-comment">//命令缓冲标签</span><br>    <span class="hljs-type">uint32_t</span>                                     objectCount;  <span class="hljs-comment">//消息相关对象数</span><br>    <span class="hljs-type">const</span> VkDebugUtilsObjectNameInfoEXT*         pObjects;  <span class="hljs-comment">//消息相关对象</span><br>&#125; VkDebugUtilsMessengerCallbackDataEXT;<br></code></pre></td></tr></table></figure><p>该成员包含了回调函数输出信息的具体方式和细节。</p><p>最后一个成员指定用户自己提供的额外信息，一般为nullptr。</p><p>回调函数返回一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBool32.html"><code>VkBool32</code></a>类型的值，如果它返回<i><font color="Red">VK_TRUE</font></i>，则意味着产生验证层信息的函数应该被终止，这一般只用于验证调试层是否生效，因此我们一般返回<i><font color="Red">VK_FALSE</font></i>。</p><p>于是，我们可以创建一个自己的回调函数（注意要把它设置为静态函数）。<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Validation_layers#page_Message-callback">验证层</a>章节给出的一个简单的例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> VKAPI_ATTR VkBool32 VKAPI_CALL <span class="hljs-title">debugCallback</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,</span></span><br><span class="hljs-params"><span class="hljs-function">    VkDebugUtilsMessageTypeFlagsEXT messageType,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">void</span>* pUserData)</span> </span>&#123;<br><br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;validation layer: &quot;</span> &lt;&lt; pCallbackData-&gt;pMessage &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> VK_FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VKAPI_CALL.html"><code>VKAPI_CALL</code></a>和<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VKAPI_ATTR.html"><code>VKAPI_ATTR</code></a>宏用于指定和编译器有关的调用方式，前者指定MSVC-style的编译器调用方式，后者指定GCC/Clang-style的编译器调用方式。</p><hr><h2 id="创建debug-messenger">创建Debug Messenger</h2><p>设置好回调函数的形式后，现在我们需要告知Vulkan我们设置了一个回调函数。这可以通过创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerEXT.html"><code>VkDebugUtilsMessengerEXT</code></a>句柄对象来实现。</p><p>创建该对象同样需要填写相应的<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>信息，我们可以创建一个<i><font color="Green">voidsetupDebugMessenger()</font></i>函数来处理该对象的构建。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Provided by VK_EXT_debug_utils</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VkDebugUtilsMessengerCreateInfoEXT</span> &#123;<br>    VkStructureType                         sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                             pNext;<br>    VkDebugUtilsMessengerCreateFlagsEXT     flags;    <span class="hljs-comment">//目前只有0</span><br>    VkDebugUtilsMessageSeverityFlagsEXT     messageSeverity;<br>    VkDebugUtilsMessageTypeFlagsEXT         messageType;<br>    PFN_vkDebugUtilsMessengerCallbackEXT    pfnUserCallback;<br>    <span class="hljs-type">void</span>*                                   pUserData;<br>&#125; VkDebugUtilsMessengerCreateInfoEXT;<br></code></pre></td></tr></table></figure><p>容易注意到后四个成员中倒数第二个成员就是我们需要指定的回调函数，其它三个成员是我们需要传递给该回调函数的实参。</p><p>于是<i><font color="Green">voidsetupDebugMessenger()</font></i>函数可以如下编写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setupDebugMessenger</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!enableValidationLayers) <span class="hljs-keyword">return</span>;<br><br>    VkDebugUtilsMessengerCreateInfoEXT createInfo&#123;&#125;;<br>    <br>    createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;<br>    createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |   VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;<br>    createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;<br>    createInfo.pfnUserCallback = debugCallback;<br>    createInfo.pUserData = <span class="hljs-literal">nullptr</span>;<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来只需要创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerEXT.html"><code>VkDebugUtilsMessengerEXT</code></a>对象即可。但是到这里还有一个小问题，那就是创建对象的函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>是一个拓展函数，它不是自动加载的，而是需要我们手动使用[<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetInstanceProcAddr.html"><code>vkGetInstanceProcAddr</code></a>去寻找它的地址后才能使用。因此我们可以创建一个（全局的）工具函数VkResultCreateDebugUtilsMessengerEXT(VkInstance instance, constVkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, constVkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT*pDebugMessenger)函数来加载<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetInstanceProcAddr.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>进行加载。于是我们可以创建一个（全局的）<i><font color="Green">VkResultCreateDebugUtilsMessengerEXT(VkInstance instance, constVkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, constVkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT*pDebugMessenger)</font></i>函数加载<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>并在加载成功后使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>创建DebugMessenger对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VkResult <span class="hljs-title">CreateDebugUtilsMessengerEXT</span><span class="hljs-params">(VkInstance instance, <span class="hljs-type">const</span> VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, <span class="hljs-type">const</span> VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pDebugMessenger)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> func = (PFN_vkCreateDebugUtilsMessengerEXT) <span class="hljs-built_in">vkGetInstanceProcAddr</span>(instance, <span class="hljs-string">&quot;vkCreateDebugUtilsMessengerEXT&quot;</span>);<br>    <span class="hljs-keyword">if</span> (func != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(instance, pCreateInfo, pAllocator, pDebugMessenger);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> VK_ERROR_EXTENSION_NOT_PRESENT;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，只需要在<i><font color="Green">setupDebugMessenger</font></i>函数末尾使用该函数来创建句柄对象即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//接setupDebugMessenger函数</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">CreateDebugUtilsMessengerEXT</span>(instance, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;debugMessenger) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to set up debug messenger!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>另外注意，销毁<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerEXT.html"><code>VkDebugUtilsMessengerEXT</code></a>对象的函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyDebugUtilsMessengerEXT.html"><code>vkDestroyDebugUtilsMessengerEXT</code></a>也是一个拓展函数，同样需要我们手动加载，我们也写一个工具函数来完成加载该函数和销毁的工作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyDebugUtilsMessengerEXT</span><span class="hljs-params">(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, <span class="hljs-type">const</span> VkAllocationCallbacks* pAllocator)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> func = (PFN_vkDestroyDebugUtilsMessengerEXT) <span class="hljs-built_in">vkGetInstanceProcAddr</span>(instance, <span class="hljs-string">&quot;vkDestroyDebugUtilsMessengerEXT&quot;</span>);<br>    <span class="hljs-keyword">if</span> (func != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-built_in">func</span>(instance, debugMessenger, pAllocator);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后只需在应用程序类的<i><font color="Green">cleanup()</font></i>函数中调用该加载函数即可。</p><hr><h2 id="instance创建和销毁函数内部的调试">Instance创建和销毁函数内部的调试</h2><p>大功告成了吗？其实还没有。注意到<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html"><code>vkCreateDebugUtilsMessengerEXT</code></a>函数需要创建的Instance作为参数，这也就意味着Instance的创建函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html"><code>vkCreateInstance</code></a>和销毁函数<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyInstance.html"><code>vkDestroyInstance</code></a>是在DebugMessenger的作用范围之外的，它们的调试信息无法被显示出来。</p><p>解决办法是将<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>信息传递给<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>结构体的pNext成员指针。具体而言，我们可以创建一个<i><font color="Green">voidpopulateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT&amp;createInfo)</font></i>函数来抽象出填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html"><code>VkDebugUtilsMessengerCreateInfoEXT</code></a>的代码以便在<i><font color="Green">createInstance</font></i>函数和<i><font color="Green">setupDebugMessenger</font></i>函数中复用，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++|">void populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT&amp; createInfo) &#123;<br>    createInfo = &#123;&#125;;<br>    <br>    createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;<br>    createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;<br>    createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;<br>    createInfo.pfnUserCallback = debugCallback;<br>&#125;<br></code></pre></td></tr></table></figure><p><i><font color="Green">setupDebugMessenger</font></i>函数现在改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setupDebugMessenger</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!enableValidationLayers) <span class="hljs-keyword">return</span>;<br><br>    VkDebugUtilsMessengerCreateInfoEXT createInfo;<br>    <span class="hljs-built_in">populateDebugMessengerCreateInfo</span>(createInfo);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CreateDebugUtilsMessengerEXT</span>(instance, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;debugMessenger) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to set up debug messenger!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><i><font color="Green">createInstance</font></i>函数添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br><br>    VkInstanceCreateInfo createInfo&#123;&#125;;<br>    createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;<br>    createInfo.pApplicationInfo = &amp;appInfo;<br><br>    ...<br><br>    VkDebugUtilsMessengerCreateInfoEXT debugCreateInfo&#123;&#125;;<br>    <span class="hljs-keyword">if</span> (enableValidationLayers) &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(validationLayers.<span class="hljs-built_in">size</span>());<br>        createInfo.ppEnabledLayerNames = validationLayers.<span class="hljs-built_in">data</span>();<br><br>        <span class="hljs-built_in">populateDebugMessengerCreateInfo</span>(debugCreateInfo);<br>        createInfo.pNext = (VkDebugUtilsMessengerCreateInfoEXT*) &amp;debugCreateInfo;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br><br>        createInfo.pNext = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateInstance</span>(&amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;instance) != VK_SUCCESS) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create instance!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以实现在Instance的构造和销毁函数中也能输出调试信息。现在终于是大功告成了！</p><hr><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">上一篇：创建Instance</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/09/CG_api/vulkan/vulkan_tutorial/%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/">下一篇：物理设备和队列家族</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>创建Instance</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概要">概要</h2><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>是沟通应用程序和vulkan库的桥梁，它将你的应用程序的信息提供给图形驱动。创建一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>主要分为三步：</p><ul><li>检查instance所需的拓展是否可用</li><li>填写包含了创建instance所需信息的结构体</li><li>将该结构体传递给<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html"><code>vkCreateInstance</code></a>函数创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>实例</li></ul><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Instance">Instance</a>章节。</p><hr><h2 id="检查拓展">检查拓展</h2><p>使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html"><code>vkEnumerateInstanceExtensionProperties</code></a>函数分两步检查拓展：</p><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html"><code>vkEnumerateInstanceExtensionProperties</code></a>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br>VkResult <span class="hljs-title function_">vkEnumerateInstanceExtensionProperties</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                                 pLayerName,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>*                                   pPropertyCount,</span><br><span class="hljs-params">    VkExtensionProperties*                      pProperties)</span>;<br></code></pre></td></tr></table></figure><p>需要解释的是该函数第一个参数，该参数指定层名，如果为nullptr则则查询全局可用的扩展属性，否则查询指定层提供的额外拓展属性。</p><p>具体使用上，一般分两步进行，也就是先查询拓展个数再查询具体拓展，许多vulkan查询操作都分为这两步进行（假设这里不需要具体层名）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> extensionCount = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="hljs-literal">nullptr</span>, &amp;extensionCount, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-function">std::vector&lt;VkExtensionProperties&gt; <span class="hljs-title">extensions</span><span class="hljs-params">(extensionCount)</span></span>;<br><span class="hljs-built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="hljs-literal">nullptr</span>, &amp;extensionCount, extensions.<span class="hljs-built_in">data</span>());<span class="hljs-comment">// T* std::vector&lt;T,Allocator&gt;::data()返回指向vector底部数组元素的指针</span><br></code></pre></td></tr></table></figure><hr><h2 id="填写创建信息">填写创建信息</h2><p>为了创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>实例，需要填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>。Vulkan中很多创建实例的函数都需要一个createInfo结构体作为参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkInstanceCreateInfo</span> &#123;</span><br>    VkStructureType             sType;                  <span class="hljs-comment">//类型</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                 pNext;     <span class="hljs-comment">//拓展结构体，此教程均为nullptr</span><br>    VkInstanceCreateFlags       flags;  <br>    <span class="hljs-type">const</span> VkApplicationInfo*    pApplicationInfo;<br>    <span class="hljs-type">uint32_t</span>                    enabledLayerCount;    <span class="hljs-comment">//层数</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*          ppEnabledLayerNames;  <span class="hljs-comment">//层名</span><br>    <span class="hljs-type">uint32_t</span>                    enabledExtensionCount;  <span class="hljs-comment">//拓展数</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>*          ppEnabledExtensionNames;<span class="hljs-comment">//拓展名</span><br>&#125; VkInstanceCreateInfo;<br></code></pre></td></tr></table></figure><p>第三个成员代表一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateFlagBits.html"><code>VkInstanceCreateFlagBits</code></a>的位掩码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkInstanceCreateFlagBits</span> &#123;</span><br>  <span class="hljs-comment">// Provided by VK_KHR_portability_enumeration</span><br>    VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR = <span class="hljs-number">0x00000001</span>,<br>&#125; VkInstanceCreateFlagBits;<br></code></pre></td></tr></table></figure><p>其中只有一个标志位<i><font color="Red">VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR</font></i>，当设置这个标志时，表示应用程序希望能够在不同的设备和平台上更好地支持Vulkan的可移植性扩展。这对于那些希望在多种硬件和操作系统上运行的应用程序尤其重要。</p><p>第四个成员是一个指向<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkApplicationInfo.html"><code>VkApplicationInfo</code></a>结构体的指针，该结构体代表一个可选的应用程序信息，提供该信息可能有助于驱动优化应用程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkApplicationInfo</span> &#123;</span><br>    VkStructureType    sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*        pNext;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*        pApplicationName;<br>    <span class="hljs-type">uint32_t</span>           applicationVersion;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*        pEngineName;<br>    <span class="hljs-type">uint32_t</span>           engineVersion;<br>    <span class="hljs-type">uint32_t</span>           apiVersion;<br>&#125; VkApplicationInfo;<br></code></pre></td></tr></table></figure><p>该结构体每个成员都很好理解，<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Instance">Instance</a>章节中的使用范例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkApplicationInfo appInfo&#123;&#125;;<br>VkApplicationInfo appInfo&#123;&#125;;<br>appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;<br>appInfo.pApplicationName = <span class="hljs-string">&quot;Hello Triangle&quot;</span>;<br>appInfo.applicationVersion = <span class="hljs-built_in">VK_MAKE_VERSION</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>appInfo.pEngineName = <span class="hljs-string">&quot;No Engine&quot;</span>;<br>appInfo.engineVersion = <span class="hljs-built_in">VK_MAKE_VERSION</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>appInfo.apiVersion = VK_API_VERSION_1_0;<br></code></pre></td></tr></table></figure><p>解释完所有成员代表的意思之后，正式开始填写<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">VkInstanceCreateInfo createInfo&#123;&#125;;<br>createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;<br>createInfo.pApplicationInfo = &amp;appInfo;<br><br><span class="hljs-type">uint32_t</span> glfwExtensionCount = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>** glfwExtensions;<br><br><span class="hljs-comment">//获取glfw窗口系统所需的拓展，可以在获取前先使用步骤1检查以下拓展是否可用</span><br>glfwExtensions = <span class="hljs-built_in">glfwGetRequiredInstanceExtensions</span>(&amp;glfwExtensionCount);<br><br>createInfo.enabledExtensionCount = glfwExtensionCount;<br>createInfo.ppEnabledExtensionNames = glfwExtensions;<br><br><span class="hljs-comment">//这部分会在之后的设置验证层章节中填写</span><br>createInfo.enabledLayerCount = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>注意这里并没有填写层数和层名，这部分会在下一章<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">验证层</a>中进行填写</p><hr><h2 id="创建vkinstance实例">创建VkInstance实例</h2><p>最后，一切就绪，可以使用<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html"><code>VkCreateInstance</code></a>创建<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkInstance.html"><code>VkInstance</code></a>实例了，由于Vulkan中大多数创建实例的函数都会返回一个<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkResult.html"><code>VkResult</code></a>，于是我们一般通过下述方式创建实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">vkCreateInstance</span>(&amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;instance) != VK_SUCCESS) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;failed to create instance!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>很多Vulkan中的create函数都会具有一个可以传递用户自定义分配器的参数，在VulkanTutorial教程中该参数始终设为nullptr。</p><p>大功告成！我们可以将第二、三步的代码放到一个成员函数<i><font color="Green">voidcreateInstance()</font></i>中</p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/">上一篇：绘制基本流程梳理</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E9%AA%8C%E8%AF%81%E5%B1%82/">下一篇：验证层</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>绘制基本流程梳理</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="写在前面">写在前面</h3><p>本文对应Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Overview">Overview</a>章节</p><hr><h2 id="初始化及绘制的基本流程">初始化及绘制的基本流程</h2><p>下面按步骤给出绘制一个三角形所需的基本流程，这也构成了一个vulkan渲染程序最基础的框架</p><ul><li><p>创建一个用以描述你所创建的应用以及所需使用的API拓展的VkInstance。</p></li><li><p>查询硬件属性以挑选合适的物理设备VkPhysicalDevice。</p></li><li><p>从物理设备抽象出对应的逻辑设备VkDevice，并且创建用于接受提交命令的VkQueue。</p></li><li><p>创建用于显示渲染结果的窗口，以及一个处理跨平台窗口兼容性的的抽象层VkSurfaceKHR，然后创建用于提供渲染和展示画面的VkSwapchainKHR。</p></li><li><p>创建交换链中真正用于渲染和展示的VkImage,并且把这些图片包裹进用于指示图片的具体使用部分的VkImageView中。</p></li><li><p>创建用于指示渲染目标的类型用法等信息的VkRenderPass</p></li><li><p>在指定好渲染目标以及相应信息后，创建对应的载体VkFramebuffer，将创建好的VkImage用作它的颜色、深度或模板缓冲。</p></li><li><p>建立好包含整个渲染流程各个阶段信息的渲染管线对象VkPipeline。</p></li><li><p>准备好渲染所需的一切目标和信息后，从VkCommandPool分配出VkCommandBuffer，用于录制渲染流程中需要执行的命令。</p></li><li><p>开始主渲染循环，循环流程主要为从交换链获取图像，然后将录制好的命令提交给VkQueue执行，执行完毕后将图像归还交换链并展示渲染结果。</p><p>接下来的三角形绘制章节会详细解释每个步骤的具体流程和执行方式。</p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%BA%8F%E8%A8%80/">上一篇：序言</a></p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BAInstance/">下一篇：创建Instance</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>序言</title>
    <link href="/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%BA%8F%E8%A8%80/"/>
    <url>/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E5%BA%8F%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="写在前面的话">写在前面的话</h2><p>刚学完<a href="https://vulkan-tutorial.com/Introduction">vulkantutorial</a>教程不久，感觉自己对其中的很多细节理解还不是很透彻，同时也不能很好地理清vulkan复杂的初始化流程，于是准备再学一遍教程，并且记录下自己的理解和梳理思路，希望能对vulkan的工作机制有更深入的理解。</p><h2 id="主要内容概要">主要内容概要</h2><p>本系列文章主要以梳理概括vulkan搭建的渲染流程为主，不多涉及对于图形硬件底层或者api工作原理的深入理解（苯萌新尚未进化至如此境界~~</p><p>--<a href="https://zpc-dsg.github.io/2024/11/08/CG_api/vulkan/vulkan_tutorial/%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/">下一篇：绘制基本流程梳理</a></p>]]></content>
    
    
    <categories>
      
      <category>CG_api</category>
      
      <category>vulkan</category>
      
      <category>vulkan_tutorial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 847:访问所有节点的最短路径</title>
    <link href="/2024/09/19/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/Leetcode-847-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2024/09/19/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/Leetcode-847-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述">题目描述</h2><h3 id="题干">题干</h3><p>存在一个由 <code>n</code> 个节点组成的无向连通图，图中的节点按从<code>0</code> 到 <code>n - 1</code> 编号。</p><p>给你一个数组 <code>graph</code>表示这个图。其中，<code>graph[i]</code> 是一个列表，由所有与节点<code>i</code> 直接相连的节点组成。</p><p>返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。</p><h3 id="条件限制">条件限制</h3><ul><li><code>n == graph.length</code></li><li><code>1 &lt;= n &lt;= 12</code></li><li><code>0 &lt;= graph[i].length &lt; n</code></li><li><code>graph[i]</code> 不包含 <code>i</code></li><li>如果 <code>graph[a]</code> 包含 <code>b</code> ，那么<code>graph[b]</code> 也包含 <code>a</code></li><li>输入的图总是连通图</li></ul><h3 id="示例">示例</h3><figure><img src="/2024/09/19/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/Leetcode-847-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/example.png" alt="示例"><figcaption aria-hidden="true">示例</figcaption></figure><p><strong>输入</strong>：graph = [[1, 2, 3], [0], [0], [0]]</p><p><strong>输出</strong>：4</p><p><strong>解释</strong>：一种可能路径为[1, 0, 2, 0, 3]</p><hr><h2 id="错误解题思路">错误解题思路</h2><h3 id="思路">思路</h3><p>定义f[s][i]为位掩码为s且最后到达的节点为i时所走过的最短路径（如果在前述条件下不能遍历位掩码中的节点则记为INT_MAX，并且下面认为INT_MAX+1=INT_MAX)，简单地认为状态转移方程为：<span class="math display">\[f[s][i]\ =\mathop{min}\limits_{x\in graph[i]}(f[s\ \land\(1&lt;&lt;i)][x])\ +\ 1\]</span></p><h3 id="错误原因">错误原因</h3><p>事实上，位掩码为s且最后到达的节点为i时所走过的最短路径未必由除去i之后的位掩码下最后到达i的相邻节点x的最短路径转移而来，原因很简单，如果<span class="math inline">\(f[s\ \land\(1&lt;&lt;i)][x]\)</span>并非INT_MAX，那么这么转移是没有问题的，<u><mark><strong>但是，如果<span class="math inline">\(f[s\ \land\(1&lt;&lt;i)][x]\)</span>是INT_MAX呢？这是不是就意味着f[s][i]同样无法遍历得到了呢？当然不是</strong>。</mark></u>考虑上面示例，例如当位掩码为0111（即选择了0,1,2这三个节点），最后到达的节点为0时，如果按照上面错误的转移方程，我们有<span class="math display">\[f[0111][0]\ =\mathop{min}\{f[0110][1],\ f][0110][2]\}\ +\ 1\]</span>但是当位掩码仅为0110，也就是说要仅经过1,2两个节点的情况下遍历这两个节点都是不可能的，上面min的结果应该为INT_MAX，也就是说这么转移得到的f[0111][0]为INT_MAX，但是显然1-0-2-0为一条满足要求的路径，因此f[0111][0]最多也是3，因此这样的状态转移是不全面的。</p><hr><h2 id="正确解答">正确解答</h2><h3 id="思路一floyd最短路状压dp">思路一（Floyd最短路+状压dp）</h3><p>思路一延续前文错误思路的想法，只不过将状态转移方程改为 <span class="math display">\[f[s][i]\ =\mathop{min}\limits_{x\in \{0,1,\cdots,n-1\}}(f[s\ \land\(1&lt;&lt;i)][x])\ +\ dist(x,i)\]</span>其中dist(x,i)是节点x与i之间的最短距离，这个距离可以使用Floyd最短路径算法预计算出来。这样就不会出现漏掉一些状态转移方式的问题。</p><h4 id="floyd最短路径算法">Floyd最短路径算法</h4><p>算法原理以及描述这里不再赘述，读者可以在<a href="https://oi-wiki.org/graph/shortest-path/#floyd-%E7%AE%97%E6%B3%95">这里</a>找到关于该算法的具体描述和原理说明</p><p>Floyd算法的核心代码不过三层循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>  <span class="hljs-keyword">for</span> (x = <span class="hljs-number">1</span>; x &lt;= n; x++) &#123;<br>    <span class="hljs-keyword">for</span> (y = <span class="hljs-number">1</span>; y &lt;= n; y++) &#123;<br>      dist[k][x][y] = <span class="hljs-built_in">min</span>(dist[k - <span class="hljs-number">1</span>][x][y], dist[k - <span class="hljs-number">1</span>][x][k] + dist[k - <span class="hljs-number">1</span>][k][y]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中dist[k][x][y]表示只允许经过前k个节点的情况下由x到y的最短路径长度。由于外层状态k仅仅与k-1有关，所以实现的时候其实可以压缩掉一维：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>  <span class="hljs-keyword">for</span> (x = <span class="hljs-number">1</span>; x &lt;= n; x++) &#123;<br>    <span class="hljs-keyword">for</span> (y = <span class="hljs-number">1</span>; y &lt;= n; y++) &#123;<br>      dist[x][y] = <span class="hljs-built_in">min</span>(dist[x][y], dist[x][k] + dist[k][y]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中dist[x][y]直接定义为由x到y的最短路径长度。</p><h4 id="整体实现">整体实现</h4><p>首先预处理出任意两个节点之间的最短路径，然后使用上述正确状态转移方程求解，c++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestPathLength</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector <span class="hljs-title">dist</span><span class="hljs-params">(n, vector&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">1e9</span>))</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : graph[i]) &#123;<br>                dist[i][j] = dist[j][i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) dist[i][i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 预处理：floyd 求最短路</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                    dist[i][j] = <span class="hljs-built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//状压dp实现</span><br>        <span class="hljs-function">vector <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; n, vector&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">1e9</span>))</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) f[<span class="hljs-number">1</span> &lt;&lt; i][i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; (<span class="hljs-number">1</span> &lt;&lt; n); ++s) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (s &gt;&gt; i &amp; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                        <span class="hljs-keyword">if</span> ((s &gt;&gt; j &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>                            f[s | (<span class="hljs-number">1</span> &lt;&lt; j)][j] = <span class="hljs-built_in">min</span>(f[s | (<span class="hljs-number">1</span> &lt;&lt; j)][j], f[s][i] + dist[i][j]);<span class="hljs-comment">//转移方程形式上和前文略有差别，但本质上是一样的，这种写法会更方便</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//返回最终值</span><br>        <span class="hljs-keyword">return</span> *ranges::<span class="hljs-built_in">min_element</span>(f.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">begin</span>(),f.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">end</span>());<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="思路二bfs状压dp">思路二（BFS+状压dp）</h3><p>由于苯人还没有系统练习过BFS+队列存储的题目，这里暂时贴上leetcode上的<a href="https://leetcode.cn/problems/shortest-path-visiting-all-nodes/solutions/918634/gtalgorithm-tu-jie-fa-ba-hardbian-cheng-v5knb/">解答</a>，并且简述一下自己的一些理解，详细的思路说明留待之后补充~</p><h4 id="代码">代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestPathLength</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">// 1.初始化队列及标记数组，存入起点</span><br>        queue&lt; tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; q; <span class="hljs-comment">// 三个属性分别为 idx, mask, dist</span><br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">vis</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-number">1</span> &lt;&lt; n)); <span class="hljs-comment">// 节点编号及当前状态</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            q.<span class="hljs-built_in">push</span>(&#123;i, <span class="hljs-number">1</span> &lt;&lt; i, <span class="hljs-number">0</span>&#125;); <span class="hljs-comment">// 存入起点，起始距离0，标记</span><br>            vis[i][<span class="hljs-number">1</span> &lt;&lt; i] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 开始搜索</span><br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> [cur, mask, dist] = q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 弹出队头元素</span><br>            q.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-comment">// 找到答案，返回结果</span><br>            <span class="hljs-keyword">if</span>(mask == (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> dist;<br><br>            <span class="hljs-comment">// 扩展</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : graph[cur]) &#123;<br>                <span class="hljs-type">int</span> nextmask = mask | (<span class="hljs-number">1</span> &lt;&lt; x);<br>                <span class="hljs-keyword">if</span>(!vis[x][nextmask]) &#123;<br>                    q.<span class="hljs-built_in">push</span>(&#123;x, nextmask, dist + <span class="hljs-number">1</span>&#125;);<br>                    vis[x][nextmask] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="个人理解">个人理解</h4><p>q中每个tuple的三个元素存储的是当前位掩码mask，遍历mask中所有节点并最后到达的节点idx，以及满足前述两个条件的最短路径长度dist，vis[idx][mask]记录在当前位掩码为mask的状态下，最后到达节点idx的路径是否已经经过计算了，事实上，在下面的while循环过程中，我们可以保证只要vis[idx][mask]经过了一次计算（也就是设置为true了），这次计算算得的路径就是相应的最短路径，因此后续无需再次计算该状态下的最短路径。首先初始状态下，我们将所有仅含1个节点的状态(i,1&lt;&lt;i,0)入队，并且更改vis[i][1&lt;&lt;i]为true，然后开始正式搜索。观察while循环中的代码可以非常直观地得出一个重要的结论，就是每次循环入队的tuple元素的dist分量是单调递增的，因此在循环内部注释拓展部分，只有在vis[idx][mask]还没有计算得到的时候才将相应元素入队，如果它已经计算过了（也就是vis[idx][mask]已经设置为true了），那么根据前文所述单调递增的性质，第一次计算之后的计算得到的dist只会比第一次计算得到的更大，因此这种情况下相应的tuple不能入队。最终随着搜索的进行，当第一次发现搜索已经遍历了所有的节点之后，我们就可以立即返回相应的dist了，这还是源于dist在每层循环单调递增的特性，因为这意味着第一次遍历之后的遍历所对应tuple中的dist元素肯定至少大于等于第一次的dist，所以第一次的dist就是我们寻找的最短距离。另外，由于题目保证该图是连通的，也就是说一定可以求出这样的最短距离，所以其实最后的return0是用不上的，但必须加上这句代码以确保所有分支情况都有数返回（不然会报错）。</p><h2 id="补充">补充</h2><p>对于不熟悉状压dp及其写法的读者，可以参考OI Wiki中的<a href="https://oi-wiki.org/dp/state/">简介</a>，基础写法可以参考灵茶山艾府大神的几篇<a href="https://leetcode.cn/problems/find-the-minimum-cost-array-permutation/solutions/2775272/zhuang-ya-dpcong-ji-yi-hua-sou-suo-dao-d-s9t5/">题解</a>。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>状态压缩dp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
