<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/icon/mikuicon.jpg"><link rel="icon" href="/images/icon/mikuicon.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="ZPC-dsg"><meta name="keywords" content=""><meta name="description" content="前言 这几天终于完成了对Vulkan官方示例集中的Compute_nbody示例源码的阅读。该示例旨在利用计算着色器模拟一个简易的粒子效果。在阅读的过程中自己也厘清了不少之前比较模糊的概念，大佬们的文章无疑对我助益良多，文末会放上相应文章的链接。本文就将根据我自己的理解，浅浅分析一下这个示例的操作流程，后续我还会尝试实现该效果的OGL以及d3d11,d3d12版本。  效果 首先上视频，看"><meta property="og:type" content="article"><meta property="og:title" content="Compute_nbody"><meta property="og:url" content="http://example.com/2025/01/24/CG_api/vulkan/vulkan_samples/compute_nbody/index.html"><meta property="og:site_name" content="ZPC の Blog"><meta property="og:description" content="前言 这几天终于完成了对Vulkan官方示例集中的Compute_nbody示例源码的阅读。该示例旨在利用计算着色器模拟一个简易的粒子效果。在阅读的过程中自己也厘清了不少之前比较模糊的概念，大佬们的文章无疑对我助益良多，文末会放上相应文章的链接。本文就将根据我自己的理解，浅浅分析一下这个示例的操作流程，后续我还会尝试实现该效果的OGL以及d3d11,d3d12版本。  效果 首先上视频，看"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/images/textbg/CG_api/vk_sample_nbody.jpg"><meta property="article:published_time" content="2025-01-24T14:23:37.000Z"><meta property="article:modified_time" content="2025-01-27T01:09:52.511Z"><meta property="article:author" content="ZPC-dsg"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/images/textbg/CG_api/vk_sample_nbody.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>Compute_nbody - ZPC の Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:"measurement_id:G-X8N3TZCB57",tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 7.3.0"><script src="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.css"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>ZPC の Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/images/textbg/CG_api/vk_sample_nbody.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Compute_nbody"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> ZPC-dsg </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-01-24 22:23" pubdate>2025年1月24日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 12k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 104 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">Compute_nbody</h1><div class="markdown-body"><h2 id="前言">前言</h2><p>这几天终于完成了对Vulkan官方示例集中的Compute_nbody示例源码的阅读。该示例旨在利用计算着色器模拟一个简易的粒子效果。在阅读的过程中自己也厘清了不少之前比较模糊的概念，大佬们的文章无疑对我助益良多，文末会放上相应文章的链接。本文就将根据我自己的理解，浅浅分析一下这个示例的操作流程，后续我还会尝试实现该效果的OGL以及d3d11,d3d12版本。</p><hr><h2 id="效果">效果</h2><p>首先上视频，看看这个粒子效果~</p><div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom:20px"></div><script>!function(){var e=new DPlayer({container:document.getElementById("dplayer2"),loop:"yes",screenshot:"yes",video:{url:"/2025/01/24/CG_api/vulkan/vulkan_samples/compute_nbody/compute_nBody.mp4"},danmaku:{api:"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]),window.dplayers.push(e)}()</script><hr><h2 id="流程概述">流程概述</h2><p>实现该粒子效果的流程主要分为四步：</p><ul><li>渲染前准备计算和渲染所需的资源</li><li>使用两个compute pass计算在新的一帧中粒子的位置与速度</li><li>使用一个graphics pass在屏幕上显示粒子效果</li><li>更新效果相关着色器常量</li></ul><p>接下来我们将一步步跟随源码来探究这四步流程之中的细节，尤其是其中较为复杂繁琐的同步设置。本示例对应源码文件为<strong>compute_nbody.cpp</strong>。</p><hr><h2 id="准备阶段">准备阶段</h2><p>准备工作流程由<i><font color="green">bool ComputeNBody::prepare(const vkb::ApplicationOptions &amp;options)</font></i>函数给出，该函数将在渲染循环开始之前运行，准备好渲染循环需要的图形和计算资源。函数源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ComputeNBody::prepare</span><span class="hljs-params">(<span class="hljs-type">const</span> vkb::ApplicationOptions &amp;options)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (!ApiVulkanSample::<span class="hljs-built_in">prepare</span>(options))<br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	graphics.queue_family_index = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_family_index</span>(VK_QUEUE_GRAPHICS_BIT);<br>	compute.queue_family_index  = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_family_index</span>(VK_QUEUE_COMPUTE_BIT);<br><br>	<span class="hljs-comment">// Not all implementations support a work group size of 256, so we need to check with the device limits</span><br>	work_group_size = std::<span class="hljs-built_in">min</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(<span class="hljs-number">256</span>), <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_properties</span>().limits.maxComputeWorkGroupSize[<span class="hljs-number">0</span>]);<br>	<span class="hljs-comment">// Same for shared data size for passing data between shader invocations</span><br>	shared_data_size = std::<span class="hljs-built_in">min</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(<span class="hljs-number">1024</span>), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_properties</span>().limits.maxComputeSharedMemorySize / <span class="hljs-built_in">sizeof</span>(glm::vec4)));<br><br>	<span class="hljs-built_in">load_assets</span>();<br>	<span class="hljs-built_in">setup_descriptor_pool</span>();<br>	<span class="hljs-built_in">prepare_graphics</span>();<br>	<span class="hljs-built_in">prepare_compute</span>();<br>	<span class="hljs-built_in">build_command_buffers</span>();<br>	prepared = <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数开头首先调用<i><font color="green">ApiVulkanSample::prepare</font></i>。<strong>ComputeNBody</strong>类是继承自<strong>ApiVulkanSample</strong>类的，这里先调用基类的<i><font color="green">prepare</font></i>函数来准备好继承自该类的示例公用的图形管线所需的大部分资源，比如说帧缓冲、颜色深度附件、用于同步显示等渲染流程的信号量等。该函数不涉及到主要逻辑，我们只将其源码放在下面，后续用到相关资源时再提及：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ApiVulkanSample::prepare</span><span class="hljs-params">(<span class="hljs-type">const</span> vkb::ApplicationOptions &amp;options)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (!VulkanSample::<span class="hljs-built_in">prepare</span>(options))<br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	depth_format = vkb::<span class="hljs-built_in">get_suitable_depth_format</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_handle</span>());<br><br>	<span class="hljs-comment">// Create synchronization objects</span><br>	VkSemaphoreCreateInfo semaphore_create_info = vkb::initializers::<span class="hljs-built_in">semaphore_create_info</span>();<br>	<span class="hljs-comment">// Create a semaphore used to synchronize image presentation</span><br>	<span class="hljs-comment">// Ensures that the current swapchain render target has completed presentation and has been released by the presentation engine, ready for rendering</span><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateSemaphore</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;semaphore_create_info, <span class="hljs-literal">nullptr</span>, &amp;semaphores.acquired_image_ready));<br>	<span class="hljs-comment">// Create a semaphore used to synchronize command submission</span><br>	<span class="hljs-comment">// Ensures that the image is not presented until all commands have been sumbitted and executed</span><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateSemaphore</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;semaphore_create_info, <span class="hljs-literal">nullptr</span>, &amp;semaphores.render_complete));<br><br>	<span class="hljs-comment">// Set up submit info structure</span><br>	<span class="hljs-comment">// Semaphores will stay the same during application lifetime</span><br>	<span class="hljs-comment">// Command buffer submission info is set by each example</span><br>	submit_info                   = vkb::initializers::<span class="hljs-built_in">submit_info</span>();<br>	submit_info.pWaitDstStageMask = &amp;submit_pipeline_stages;<br><br>	<span class="hljs-keyword">if</span> (window-&gt;<span class="hljs-built_in">get_window_mode</span>() != vkb::Window::Mode::Headless)<br>	&#123;<br>		submit_info.waitSemaphoreCount   = <span class="hljs-number">1</span>;<br>		submit_info.pWaitSemaphores      = &amp;semaphores.acquired_image_ready;<br>		submit_info.signalSemaphoreCount = <span class="hljs-number">1</span>;<br>		submit_info.pSignalSemaphores    = &amp;semaphores.render_complete;<br>	&#125;<br><br>	queue = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_suitable_graphics_queue</span>().<span class="hljs-built_in">get_handle</span>();<br><br>	<span class="hljs-built_in">create_swapchain_buffers</span>();<br>	<span class="hljs-built_in">create_command_pool</span>();<br>	<span class="hljs-built_in">create_command_buffers</span>();<br>	<span class="hljs-built_in">create_synchronization_primitives</span>();<br>	<span class="hljs-built_in">setup_depth_stencil</span>();<br>	<span class="hljs-built_in">setup_render_pass</span>();<br>	<span class="hljs-built_in">create_pipeline_cache</span>();<br>	<span class="hljs-built_in">setup_framebuffer</span>();<br><br>	width  = <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_surface_extent</span>().width;<br>	height = <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_surface_extent</span>().height;<br><br>	<span class="hljs-built_in">prepare_gui</span>();<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来的两行用于查询并设置图形和计算命令各自提交队列的索引。这里用到的两个结构体<i><font color="Orange">graphics</font></i>和<i><font color="Orange">compute</font></i>分别存储了图形和计算阶段需要的各种资源，下面是它们的定义，后续关于图形和计算的操作都是基于这两个结构体内容进行的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span><br>&#123;<br>	std::unique_ptr&lt;vkb::core::BufferC&gt; uniform_buffer;               <span class="hljs-comment">// Contains scene matrices</span><br>	VkDescriptorSetLayout               descriptor_set_layout;        <span class="hljs-comment">// Particle system rendering shader binding layout</span><br>	VkDescriptorSet                     descriptor_set;               <span class="hljs-comment">// Particle system rendering shader bindings</span><br>	VkPipelineLayout                    pipeline_layout;              <span class="hljs-comment">// Layout of the graphics pipeline</span><br>	VkPipeline                          pipeline;                     <span class="hljs-comment">// Particle rendering pipeline</span><br>	VkSemaphore                         semaphore;                    <span class="hljs-comment">// Execution dependency between compute &amp; graphic submission</span><br>	<span class="hljs-type">uint32_t</span>                            queue_family_index;<br>	<span class="hljs-keyword">struct</span><br>	&#123;<br>		glm::mat4 projection;<br>		glm::mat4 view;<br>		glm::vec2 screenDim;<br>	&#125; ubo;<br>&#125; graphics;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">struct</span><br>&#123;<br>	std::unique_ptr&lt;vkb::core::BufferC&gt; storage_buffer;               <span class="hljs-comment">// (Shader) storage buffer object containing the particles</span><br>	std::unique_ptr&lt;vkb::core::BufferC&gt; uniform_buffer;               <span class="hljs-comment">// Uniform buffer object containing particle system parameters</span><br>	VkQueue                             queue;                        <span class="hljs-comment">// Separate queue for compute commands (queue family may differ from the one used for graphics)</span><br>	VkCommandPool                       command_pool;                 <span class="hljs-comment">// Use a separate command pool (queue family may differ from the one used for graphics)</span><br>	VkCommandBuffer                     command_buffer;               <span class="hljs-comment">// Command buffer storing the dispatch commands and barriers</span><br>	VkSemaphore                         semaphore;                    <span class="hljs-comment">// Execution dependency between compute &amp; graphic submission</span><br>	VkDescriptorSetLayout               descriptor_set_layout;        <span class="hljs-comment">// Compute shader binding layout</span><br>	VkDescriptorSet                     descriptor_set;               <span class="hljs-comment">// Compute shader bindings</span><br>	VkPipelineLayout                    pipeline_layout;              <span class="hljs-comment">// Layout of the compute pipeline</span><br>	VkPipeline                          pipeline_calculate;           <span class="hljs-comment">// Compute pipeline for N-Body velocity calculation (1st pass)</span><br>	VkPipeline                          pipeline_integrate;           <span class="hljs-comment">// Compute pipeline for euler integration (2nd pass)</span><br>	VkPipeline                          blur;<br>	VkPipelineLayout                    pipeline_layout_blur;<br>	VkDescriptorSetLayout               descriptor_set_layout_blur;<br>	VkDescriptorSet                     descriptor_set_blur;<br>	<span class="hljs-type">uint32_t</span>                            queue_family_index;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ComputeUBO</span><br>	&#123;                              <span class="hljs-comment">// Compute shader uniform block object</span><br>		<span class="hljs-type">float</span>   delta_time;        <span class="hljs-comment">//		Frame delta time</span><br>		<span class="hljs-type">int32_t</span> particle_count;<br>	&#125; ubo;<br>&#125; compute;<br></code></pre></td></tr></table></figure><p>接下来同样需要查询的是硬件所允许的计算工作组大小<i><font color="Orange">work_group_size</font></i>以及一个工作组内共享数据区域的大小<i><font color="Orange">shared_data_size</font></i>（以<strong>glm::vec4</strong>大小为单位）。注意，由于本程序只需要划分一维工作组，所以只需要查询一维工作组大小即可。通过添加打印语句可以发现在我的设备上这两个查询值分别为<strong>1024</strong>和<strong>3072</strong>《所以最后这两个变量值分别为<strong>256</strong>和<strong>1024</strong>。</p><p>下面函数通过调用一组工具函数完成整个准备阶段，我们分别来看每一个函数都做了什么：</p><h3 id="加载纹理资源">加载纹理资源</h3><p>接下来函数将加载粒子的颜色纹理和渐变纹理，这通过<i><font color="Green">void load_assets()</font></i>函数完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::load_assets</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	textures.particle = <span class="hljs-built_in">load_texture</span>(<span class="hljs-string">&quot;textures/particle_rgba.ktx&quot;</span>, vkb::sg::Image::Color);<br>	textures.gradient = <span class="hljs-built_in">load_texture</span>(<span class="hljs-string">&quot;textures/particle_gradient_rgba.ktx&quot;</span>, vkb::sg::Image::Color);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数调用了基类中的<i><font color="Green">load_texture</font></i>函数来进行图片的加载，这里不会介绍该工具函数的具体逻辑，后续在分析官方示例集架构的技术细节的时候可能会单独分析以下这些实现细节，现在暂且按下不表~</p><p><code>.ktx</code> 文件是一种用于存储纹理数据的文件格式，全称为 <strong>Khronos Texture</strong>。它由 Khronos Group 定义，主要用于 OpenGL 和 Vulkan 等图形 API 中，以便高效地加载和使用纹理。</p><p>本来想着使用Khronos Group提供的KTX Tools来加载一下这两张图片看看，结果一用发现KTX Tools竟然只支持加载ktx2文件（有被无语到。。。然后又试了试其它线上的KTX文件加载工具，竟然都不能把这个示例中用到的文件转换成png或其它可直接浏览的图像格式（什么鬼。。。然后我就想着要么手动写一个OpenGL程序用来解析并显示KTX文件，但在我稍微浏览了一下<i><font color="Orange">load_texture</font></i>函数对KTX文件的加载实现之后果断放弃了（别问，问就是太长不愿看。正当束手无策之际，我不经意间发现Vulkan官方示例集的代码仓库中竟然就有一个<strong>texture_loading</strong>示例！简直救了老命，稍微梳理了一下这个示例的实现后，我将示例中用到的纹理分别修改为<strong>particle_rgba.ktx</strong>和<strong>particle_gradient_rgba.ktx</strong>，然后终于显示出了这两张图片的庐山真面目。。。如下图：</p><figure><img src="/2025/01/24/CG_api/vulkan/vulkan_samples/compute_nbody/color.png" srcset="/img/loading.gif" lazyload alt="particle_rgba"><figcaption aria-hidden="true">particle_rgba</figcaption></figure><figure><img src="/2025/01/24/CG_api/vulkan/vulkan_samples/compute_nbody/gradient.png" srcset="/img/loading.gif" lazyload alt="particle_gradient_rgba"><figcaption aria-hidden="true">particle_gradient_rgba</figcaption></figure><p>好了，闲话少说，让我们继续探索源码~</p><hr><h3 id="构建描述符池">构建描述符池</h3><p>在纹理加载完毕后，紧接着<i><font color="Green">prepare</font></i>函数开始构建描述符池。描述符池对象本身位于基类中，是所有示例所公用的。<i><font color="Green">void setup_descriptor_pool()</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::setup_descriptor_pool</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//要注意，pool_sizes描述的是描述符的数量，而不是描述符集的数量</span><br>	std::vector&lt;VkDescriptorPoolSize&gt; pool_sizes =<br>	    &#123;<br>	        vkb::initializers::<span class="hljs-built_in">descriptor_pool_size</span>(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">2</span>),<br>	        vkb::initializers::<span class="hljs-built_in">descriptor_pool_size</span>(VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, <span class="hljs-number">1</span>),<br>	        vkb::initializers::<span class="hljs-built_in">descriptor_pool_size</span>(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="hljs-number">2</span>)&#125;;<br><br>	VkDescriptorPoolCreateInfo descriptor_pool_create_info =<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_pool_create_info</span>(<br>	        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(pool_sizes.<span class="hljs-built_in">size</span>()),<br>	        pool_sizes.<span class="hljs-built_in">data</span>(),<br>	        <span class="hljs-number">2</span>);<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorPool</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_pool_create_info, <span class="hljs-literal">nullptr</span>, &amp;descriptor_pool));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，该示例需要分配两个Uniform buffer，一个Storage buffer和两个组合图像采样器，其中两个Uniform buffer分别对应于<i><font color="Orange">graphics</font></i>和<i><font color="Orange">compute</font></i>结构体中的两个ubo对象，Storage buffer用于储存计算着色器的输出结果并用于图形管线顶点着色器的输入，两个组合图像采样器分别用于片段着色器采样上文加载的两张图片。</p><hr><h3 id="准备图形资源">准备图形资源</h3><p>接下来开始准备图形管线需要的资源，<i><font color="Orange">void prepare_graphics()</font></i>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::prepare_graphics</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">prepare_storage_buffers</span>();<br>	<span class="hljs-built_in">prepare_uniform_buffers</span>();<br>	<span class="hljs-built_in">setup_descriptor_set_layout</span>();<br>	<span class="hljs-built_in">prepare_pipelines</span>();<br>	<span class="hljs-built_in">setup_descriptor_set</span>();<br><br>	<span class="hljs-comment">// Semaphore for compute &amp; graphics sync</span><br>	VkSemaphoreCreateInfo semaphore_create_info = vkb::initializers::<span class="hljs-built_in">semaphore_create_info</span>();<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateSemaphore</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;semaphore_create_info, <span class="hljs-literal">nullptr</span>, &amp;graphics.semaphore));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，该函数流程分为如下几步：</p><ul><li>准备Storage buffer</li><li>准备图形的Uniform buffer</li><li>设置好图形管线的描述符布局</li><li>构建图形渲染管线</li><li>设置好图形所用描述符资源</li><li>构建用于图形—计算同步的信号量</li></ul><p>我们分别来看这些操作：</p><h4 id="准备storage-buffer">准备Storage buffer</h4><p>先上<i><font color="Orange">prepare_storage_buffer</font></i>函数代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::prepare_storage_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>	std::vector&lt;glm::vec3&gt; attractors = &#123;<br>		glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">2.5f</span>, <span class="hljs-number">1.5f</span>, <span class="hljs-number">0.0f</span>),<br>		glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">-2.5f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">0.0f</span>),<br>	&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>	std::vector&lt;glm::vec3&gt; attractors = &#123;<br>	    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">5.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>),<br>	    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">-5.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>),<br>	    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">5.0f</span>),<br>	    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-5.0f</span>),<br>	    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">4.0f</span>, <span class="hljs-number">0.0f</span>),<br>	    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">-8.0f</span>, <span class="hljs-number">0.0f</span>),<br>	&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>	num_particles = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attractors.<span class="hljs-built_in">size</span>()) * PARTICLES_PER_ATTRACTOR;<br><br>	<span class="hljs-comment">// Initial particle positions</span><br>	<span class="hljs-function">std::vector&lt;Particle&gt; <span class="hljs-title">particle_buffer</span><span class="hljs-params">(num_particles)</span></span>;<br><br>	<span class="hljs-function">std::default_random_engine      <span class="hljs-title">rnd_engine</span><span class="hljs-params">(lock_simulation_speed ? <span class="hljs-number">0</span> : <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-type">unsigned</span>&gt;(time(<span class="hljs-literal">nullptr</span>)))</span></span>;<br>	<span class="hljs-function">std::normal_distribution&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">rnd_distribution</span><span class="hljs-params">(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>)</span></span>;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attractors.<span class="hljs-built_in">size</span>()); i++)<br>	&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> j = <span class="hljs-number">0</span>; j &lt; PARTICLES_PER_ATTRACTOR; j++)<br>		&#123;<br>			Particle &amp;particle = particle_buffer[i * PARTICLES_PER_ATTRACTOR + j];<br><br>			<span class="hljs-comment">// First particle in group as heavy center of gravity</span><br>			<span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)<br>			&#123;<br>				particle.pos = glm::<span class="hljs-built_in">vec4</span>(attractors[i] * <span class="hljs-number">1.5f</span>, <span class="hljs-number">90000.0f</span>);<br>				particle.vel = glm::<span class="hljs-built_in">vec4</span>(glm::<span class="hljs-built_in">vec4</span>(<span class="hljs-number">0.0f</span>));<br>			&#125;<br>			<span class="hljs-keyword">else</span><br>			&#123;<br>				<span class="hljs-comment">// Position</span><br>				glm::vec3 <span class="hljs-built_in">position</span>(attractors[i] + glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-built_in">rnd_distribution</span>(rnd_engine), <span class="hljs-built_in">rnd_distribution</span>(rnd_engine), <span class="hljs-built_in">rnd_distribution</span>(rnd_engine)) * <span class="hljs-number">0.75f</span>);<br>				<span class="hljs-type">float</span>     len = glm::<span class="hljs-built_in">length</span>(glm::<span class="hljs-built_in">normalize</span>(position - attractors[i]));<br>				position.y *= <span class="hljs-number">2.0f</span> - (len * len);<br><br>				<span class="hljs-comment">// Velocity</span><br>				glm::vec3 angular  = glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.5f</span>, <span class="hljs-number">1.5f</span>, <span class="hljs-number">0.5f</span>) * (((i % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>) ? <span class="hljs-number">1.0f</span> : <span class="hljs-number">-1.0f</span>);<br>				glm::vec3 velocity = glm::<span class="hljs-built_in">cross</span>((position - attractors[i]), angular) + glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-built_in">rnd_distribution</span>(rnd_engine), <span class="hljs-built_in">rnd_distribution</span>(rnd_engine), <span class="hljs-built_in">rnd_distribution</span>(rnd_engine) * <span class="hljs-number">0.025f</span>);<br><br>				<span class="hljs-type">float</span> mass   = (<span class="hljs-built_in">rnd_distribution</span>(rnd_engine) * <span class="hljs-number">0.5f</span> + <span class="hljs-number">0.5f</span>) * <span class="hljs-number">75.0f</span>;<br>				particle.pos = glm::<span class="hljs-built_in">vec4</span>(position, mass);<br>				particle.vel = glm::<span class="hljs-built_in">vec4</span>(velocity, <span class="hljs-number">0.0f</span>);<br>			&#125;<br><br>			<span class="hljs-comment">// Color gradient offset</span><br>			particle.vel.w = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(i) * <span class="hljs-number">1.0f</span> / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attractors.<span class="hljs-built_in">size</span>());<br>		&#125;<br>	&#125;<br><br>	compute.ubo.particle_count = num_particles;<br><br>	VkDeviceSize storage_buffer_size = particle_buffer.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(Particle);<br><br>	<span class="hljs-comment">// Staging</span><br>	<span class="hljs-comment">// SSBO won&#x27;t be changed on the host after upload so copy to device local memory</span><br>	vkb::core::BufferC staging_buffer = vkb::core::BufferC::<span class="hljs-built_in">create_staging_buffer</span>(<span class="hljs-built_in">get_device</span>(), particle_buffer);<br><br>	compute.storage_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(),<br>	                                                              storage_buffer_size,<br>	                                                              VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT,<br>	                                                              VMA_MEMORY_USAGE_GPU_ONLY);<br><br>	<span class="hljs-comment">// Copy from staging buffer to storage buffer</span><br>	VkCommandBuffer copy_command = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">create_command_buffer</span>(VK_COMMAND_BUFFER_LEVEL_PRIMARY, <span class="hljs-literal">true</span>);<br>	VkBufferCopy    copy_region  = &#123;&#125;;<br>	copy_region.size             = storage_buffer_size;<br>	<span class="hljs-built_in">vkCmdCopyBuffer</span>(copy_command, staging_buffer.<span class="hljs-built_in">get_handle</span>(), compute.storage_buffer-&gt;<span class="hljs-built_in">get_handle</span>(), <span class="hljs-number">1</span>, &amp;copy_region);<br>	<span class="hljs-comment">// Execute a transfer to the compute queue, if necessary</span><br>	<span class="hljs-keyword">if</span> (graphics.queue_family_index != compute.queue_family_index)<br>	&#123;<br>		VkBufferMemoryBarrier buffer_barrier =<br>		    &#123;<br>		        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,<br>		        <span class="hljs-literal">nullptr</span>,<br>		        VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,<br>		        <span class="hljs-number">0</span>,<br>		        graphics.queue_family_index,<br>		        compute.queue_family_index,<br>		        compute.storage_buffer-&gt;<span class="hljs-built_in">get_handle</span>(),<br>		        <span class="hljs-number">0</span>,<br>		        compute.storage_buffer-&gt;<span class="hljs-built_in">get_size</span>()&#125;;<br><br>		<span class="hljs-built_in">vkCmdPipelineBarrier</span>(<br>		    copy_command,<br>		    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,<br>		    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,<br>		    <span class="hljs-number">0</span>,<br>		    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>		    <span class="hljs-number">1</span>, &amp;buffer_barrier,<br>		    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>	&#125;<br><br>	<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">flush_command_buffer</span>(copy_command, queue, <span class="hljs-literal">true</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最开始的一大段逻辑用于在CPU端初始化Storage buffer一开始会存储的数据，也就是粒子的初始位置和速度，暂时存储在<i><font color="Orange">particle_buffer</font></i>对象中。位置和速度具体值的计算我并没有细看，也不会详细解释，因为这部分只会影响到最后粒子系统的视觉效果，和本示例的逻辑框架本身没什么联系，有兴趣的读者当然也可以自行定义这些量来达到不一样的效果。这里唯一需要注意的点是为了更好的存储效率和空间利用率，粒子的位置向量实际上存储为一个4维的向量，它的w坐标用于存储粒子的质量，这个质量会影响粒子的运动表现（可以参阅后文的着色器代码）。另外，速度向量同样为一个四维向量，w坐标此时用于存储这个粒子的颜色在颜色梯度图中的偏移，这会影响粒子颜色的采样结果，最终获得上文视频中那样五彩斑斓的效果（同样参阅后文着色器代码）。</p><p>然后，该函数顺带手就将<i><font color="Orange">compute</font></i>结构体中的粒子数量给设定好了。虽然这理应由之后准备计算阶段资源的函数设定，不过既然Storage buffer由<i><font color="Orange">prepare_storage_buffer</font></i>函数准备，那么在这里就设定好这个数量显然更方便。</p><p>接下来就是常规的构建Storage buffer流程了，也就是先构建一个临时缓冲区，将CPU端数据先上传至临时缓冲区中，然后创建一个仅供GPU使用的Storage buffer，将临时缓冲区中的数据复制到Storage buffer中去。当然，在Vulkan中缓冲区的复制操作需要启动一个命令缓冲来录制相应复制命令并提交执行。这部分不需要过多解释了，有不清楚这一部分细节的读者可以参考<a target="_blank" rel="noopener" href="https://vulkan-tutorial.com/"><code>Vulkan Tutorial</code></a>中的对应教程或者<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/28/CG_api/vulkan/vulkan_tutorial/%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/"><code>我的博客</code></a>中对该教程这部分内容的翻译和分析。</p><p>最后，该函数判断图形队列和计算队列的队列家族是否是同一个，如果是同一个，就不需要对Storage buffer进行繁琐的归属权转移工作了（因为Storage buffer在创建时的共享模式是设定为<i><font color="Red">VK_SHARING_MODE_EXCLUSIVE</font></i>的，这意味着当不同的队列使用它的时候它的队列归属权需要转移给将要使用它的队列），不过显然大多数情况下这两个队列是处在不同的队列家族的（至少在我的电脑上是这样），那么归属权就要发生转移。关于队列归属权的转移，<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#synchronization-queue-transfers"><code>Vulkan官方文档7.7.4节</code></a>给出了十分清晰且全面的解释（不过这里想吐槽一下的是我的电脑每次打开官方文档页面都会卡死然后崩掉，不知道是电脑的原因还是官方页面的问题。。。如果有和我有同样问题的小伙伴建议直接下载pdf文档离线阅读~），概括地说该操作需要注意的点大致就是一个归属权的转移操作包括两部分：原队列的释放操作和目标队列的获取操作，而且这两个操作必须要配对进行。队列归属权的转移会发生在源阶段的所有指定写操作变得available和内存对等待阶段指定的操作变得visible这两个时间节点之间。关于available和visible以及更多关于Vulkan中同步有关的内容，<a target="_blank" rel="noopener" href="https://themaister.net/blog/2019/08/14/yet-another-blog-explaining-vulkan-synchronization/"><code>这篇文章</code></a>提供了一个非常清晰易懂且详实的说明，十分具有参考价值！（虽然我不清楚文章中说<strong>VkBufferMemoryBarrier</strong>是个废物应该作何理解，至少在这个官方示例中内存屏障一直使用的这个。。。另外之后我可能也会考虑翻译一下这一篇文章吧，对初学者而言还是十分友好的）另外需要注意的是，在上文代码的释放归属权操作中目标阶段的<strong>access mask</strong>被设置为了0，即不需要指定任何在目标阶段可能需要访问资源的操作，这是合理的，因为毕竟我们并不需要在原队列上继续对该资源有什么操作，归属权已经转移了（事实上根据官方文档所述，目标阶段的<strong>access mask</strong>也可以取非零值，只不过实际上没有任何作用。另外，同理可知在目标队列获取归属权的时候也无需设置源阶段的<strong>access mask</strong>，因为源阶段并没有对资源执行任何写操作，资源是从别的地方转移来的）。</p><p>终于，Storaage buffer准备就绪！</p><hr><h4 id="准备uniform-buffer">准备Uniform buffer</h4><p>接下来程序开始准备图形和计算所需的Uniform buffer。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::prepare_uniform_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// Compute shader uniform buffer block</span><br>	compute.uniform_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(),<br>	                                                              <span class="hljs-built_in">sizeof</span>(compute.ubo),<br>	                                                              VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,<br>	                                                              VMA_MEMORY_USAGE_CPU_TO_GPU);<br><br>	<span class="hljs-comment">// Vertex shader uniform buffer block</span><br>	graphics.uniform_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(),<br>	                                                               <span class="hljs-built_in">sizeof</span>(graphics.ubo),<br>	                                                               VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,<br>	                                                               VMA_MEMORY_USAGE_CPU_TO_GPU);<br>	<span class="hljs-comment">//上面的buffer创建均使用VMA(Vulkan Memory allocator)来分配内存</span><br><br>	<span class="hljs-built_in">update_compute_uniform_buffers</span>(<span class="hljs-number">1.0f</span>);<br>	<span class="hljs-built_in">update_graphics_uniform_buffers</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码就十分简单易懂了，无非就是创建好图形和计算各自的Uniform buffer，然后赋予这两个缓冲区初始时的数据。完整起见<i><font color="Green">update_compute_uniform_buffer</font></i>和<i><font color="Green">update_graphics_uniform_buffer</font></i>的代码也放在下面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::update_compute_uniform_buffers</span><span class="hljs-params">(<span class="hljs-type">float</span> delta_time)</span></span><br><span class="hljs-function"></span>&#123;<br>	compute.ubo.delta_time = paused ? <span class="hljs-number">0.0f</span> : delta_time;<br>	compute.uniform_buffer-&gt;<span class="hljs-built_in">convert_and_update</span>(compute.ubo);<span class="hljs-comment">//简单地将新的ubo数据逐字节复制到uniform buffer中</span><br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::update_graphics_uniform_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	graphics.ubo.projection = camera.matrices.perspective;<br>	graphics.ubo.view       = camera.matrices.view;<br>	graphics.ubo.screenDim  = glm::<span class="hljs-built_in">vec2</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(height));<br>	graphics.uniform_buffer-&gt;<span class="hljs-built_in">convert_and_update</span>(graphics.ubo);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里<i><font color="Orange">convert_and_update</font></i>是类外的一个函数，负责将更新后的数据复制到缓冲区中，我们在这里不会过多探讨这些工具函数的细节，只需要大致知道它是做什么的就行了，后续如果有时间的话我会令开一个系列的文章来研究官方示例集的程序架构有关细节。</p><hr><h4 id="设置描述符集布局">设置描述符集布局</h4><p>接下来函数开始设置图形管线所需的描述符集布局。我们已经知道图形管线需要两个图形采样器和一个Uniform buffer，所以描述符集布局的设置也是十分易于理解的。相应的<i><font color="Green">setup_descriptor_set_layout</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::setup_descriptor_set_layout</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::vector&lt;VkDescriptorSetLayoutBinding&gt; set_layout_bindings;<br>	set_layout_bindings = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT, <span class="hljs-number">0</span>),<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT, <span class="hljs-number">1</span>),<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_SHADER_STAGE_VERTEX_BIT, <span class="hljs-number">2</span>),<br>	&#125;;<br><br>	VkDescriptorSetLayoutCreateInfo descriptor_layout =<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_create_info</span>(<br>	        set_layout_bindings.<span class="hljs-built_in">data</span>(),<br>	        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(set_layout_bindings.<span class="hljs-built_in">size</span>()));<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorSetLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_layout, <span class="hljs-literal">nullptr</span>, &amp;graphics.descriptor_set_layout));<br><br>	VkPipelineLayoutCreateInfo pipeline_layout_create_info =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_layout_create_info</span>(<br>	        &amp;graphics.descriptor_set_layout,<br>	        <span class="hljs-number">1</span>);<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreatePipelineLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;pipeline_layout_create_info, <span class="hljs-literal">nullptr</span>, &amp;graphics.pipeline_layout));<br>&#125;<br></code></pre></td></tr></table></figure><p>在创建好描述符集布局之后顺带手也将管线布局给设置好了。这个示例的图形管线布局只需要指定描述符集布局而不需要指定Push constant，所以只需要将先前创建好的描述符集布局喂给管线布局就好了。</p><hr><h4 id="创建图形管线">创建图形管线</h4><p>然后就是图形管线的创建部分代码了。这段代码确实很长，但是所有管线阶段的设置都十分常规，在这里我不会做过多的解释，只会着重分析一下图形管线着色器阶段所用的顶点和片段着色器的代码。如果对这部分不了解的同学也不用慌，可以参考我<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/12/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%AE%80%E4%BB%8B/"><code>之前关于渲染管线的部分文章</code></a>，对管线构建过程有十分详细的说明。</p><p>代码同样放在下面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::prepare_pipelines</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	VkPipelineInputAssemblyStateCreateInfo input_assembly_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_input_assembly_state_create_info</span>(<br>	        VK_PRIMITIVE_TOPOLOGY_POINT_LIST,<br>	        <span class="hljs-number">0</span>,<br>	        VK_FALSE);<br><br>	VkPipelineRasterizationStateCreateInfo rasterization_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_rasterization_state_create_info</span>(<br>	        VK_POLYGON_MODE_FILL,<br>	        VK_CULL_MODE_NONE,<br>	        VK_FRONT_FACE_COUNTER_CLOCKWISE,<br>	        <span class="hljs-number">0</span>);<br><br>	VkPipelineColorBlendAttachmentState blend_attachment_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_color_blend_attachment_state</span>(<br>	        <span class="hljs-number">0xf</span>,<br>	        VK_FALSE);<br><br>	VkPipelineColorBlendStateCreateInfo color_blend_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_color_blend_state_create_info</span>(<br>	        <span class="hljs-number">1</span>,<br>	        &amp;blend_attachment_state);<br><br>	VkPipelineDepthStencilStateCreateInfo depth_stencil_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_depth_stencil_state_create_info</span>(<br>	        VK_FALSE,<br>	        VK_FALSE,<br>	        VK_COMPARE_OP_ALWAYS);<br><br>	VkPipelineViewportStateCreateInfo viewport_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_viewport_state_create_info</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><br>	VkPipelineMultisampleStateCreateInfo multisample_state =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_multisample_state_create_info</span>(<br>	        VK_SAMPLE_COUNT_1_BIT,<br>	        <span class="hljs-number">0</span>);<br><br>	std::vector&lt;VkDynamicState&gt; dynamic_state_enables = &#123;<br>	    VK_DYNAMIC_STATE_VIEWPORT,<br>	    VK_DYNAMIC_STATE_SCISSOR&#125;;<br>	VkPipelineDynamicStateCreateInfo dynamicState =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_dynamic_state_create_info</span>(<br>	        dynamic_state_enables.<span class="hljs-built_in">data</span>(),<br>	        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(dynamic_state_enables.<span class="hljs-built_in">size</span>()),<br>	        <span class="hljs-number">0</span>);<br><br>	<span class="hljs-comment">// Rendering pipeline</span><br>	<span class="hljs-comment">// Load shaders</span><br>	std::array&lt;VkPipelineShaderStageCreateInfo, 2&gt; shader_stages;<br><br>	shader_stages[<span class="hljs-number">0</span>] = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;compute_nbody&quot;</span>, <span class="hljs-string">&quot;particle.vert&quot;</span>, VK_SHADER_STAGE_VERTEX_BIT);<br>	shader_stages[<span class="hljs-number">1</span>] = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;compute_nbody&quot;</span>, <span class="hljs-string">&quot;particle.frag&quot;</span>, VK_SHADER_STAGE_FRAGMENT_BIT);<br><br>	<span class="hljs-comment">// Vertex bindings and attributes</span><br>	<span class="hljs-type">const</span> std::vector&lt;VkVertexInputBindingDescription&gt; vertex_input_bindings = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_binding_description</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Particle), VK_VERTEX_INPUT_RATE_VERTEX),<br>	&#125;;<br>	<span class="hljs-type">const</span> std::vector&lt;VkVertexInputAttributeDescription&gt; vertex_input_attributes = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, VK_FORMAT_R32G32B32A32_SFLOAT, <span class="hljs-built_in">offsetof</span>(Particle, pos)),<br>	    vkb::initializers::<span class="hljs-built_in">vertex_input_attribute_description</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, VK_FORMAT_R32G32B32A32_SFLOAT, <span class="hljs-built_in">offsetof</span>(Particle, vel))&#125;;<br>	VkPipelineVertexInputStateCreateInfo vertex_input_state = vkb::initializers::<span class="hljs-built_in">pipeline_vertex_input_state_create_info</span>();<br>	vertex_input_state.vertexBindingDescriptionCount        = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertex_input_bindings.<span class="hljs-built_in">size</span>());<br>	vertex_input_state.pVertexBindingDescriptions           = vertex_input_bindings.<span class="hljs-built_in">data</span>();<br>	vertex_input_state.vertexAttributeDescriptionCount      = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(vertex_input_attributes.<span class="hljs-built_in">size</span>());<br>	vertex_input_state.pVertexAttributeDescriptions         = vertex_input_attributes.<span class="hljs-built_in">data</span>();<br><br>	VkGraphicsPipelineCreateInfo pipeline_create_info =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_create_info</span>(<br>	        graphics.pipeline_layout,<br>	        render_pass,<br>	        <span class="hljs-number">0</span>);<br><br>	pipeline_create_info.pVertexInputState   = &amp;vertex_input_state;<br>	pipeline_create_info.pInputAssemblyState = &amp;input_assembly_state;<br>	pipeline_create_info.pRasterizationState = &amp;rasterization_state;<br>	pipeline_create_info.pColorBlendState    = &amp;color_blend_state;<br>	pipeline_create_info.pMultisampleState   = &amp;multisample_state;<br>	pipeline_create_info.pViewportState      = &amp;viewport_state;<br>	pipeline_create_info.pDepthStencilState  = &amp;depth_stencil_state;<br>	pipeline_create_info.pDynamicState       = &amp;dynamicState;<br>	pipeline_create_info.stageCount          = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(shader_stages.<span class="hljs-built_in">size</span>());<br>	pipeline_create_info.pStages             = shader_stages.<span class="hljs-built_in">data</span>();<br>	pipeline_create_info.renderPass          = render_pass;<br><br>	<span class="hljs-comment">// Additive blending</span><br>	blend_attachment_state.colorWriteMask      = <span class="hljs-number">0xF</span>;<br>	blend_attachment_state.blendEnable         = VK_TRUE;<br>	blend_attachment_state.colorBlendOp        = VK_BLEND_OP_ADD;<br>	blend_attachment_state.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;<br>	blend_attachment_state.dstColorBlendFactor = VK_BLEND_FACTOR_ONE;<br>	blend_attachment_state.alphaBlendOp        = VK_BLEND_OP_ADD;<br>	blend_attachment_state.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;<br>	blend_attachment_state.dstAlphaBlendFactor = VK_BLEND_FACTOR_DST_ALPHA;<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateGraphicsPipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;graphics.pipeline));<br>	<span class="hljs-comment">//pipeline cache参考另一个sample,文档为 https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/performance/pipeline_cache</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么下面我们来看一下顶点着色器和片段着色器的代码。事实上官方示例给的着色器文件glsl和hlsl版本的都有，不过出于glsl还是和Vulkan更适配的原因，这里仅给出glsl着色器代码，有兴趣的读者完全可以自行翻阅示例源文件~</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> inPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> inVel;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">float</span> outGradientPos;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">uniform</span> UBO <br>&#123;<br>	<span class="hljs-type">mat4</span> projection;<br>	<span class="hljs-type">mat4</span> modelview;<br>	<span class="hljs-type">vec2</span> screendim;<br>&#125; ubo;<br><br><span class="hljs-keyword">out</span> gl_PerVertex<br>&#123;<br>	<span class="hljs-type">vec4</span> <span class="hljs-built_in">gl_Position</span>;<br>	<span class="hljs-type">float</span> <span class="hljs-built_in">gl_PointSize</span>;<br>&#125;;<br><br><span class="hljs-type">void</span> main () <br>&#123;<br>	<span class="hljs-keyword">const</span> <span class="hljs-type">float</span> spriteSize = <span class="hljs-number">0.005</span> * inPos.w; <span class="hljs-comment">// Point size influenced by mass (stored in inPos.w);</span><br><br>	<span class="hljs-type">vec4</span> eyePos = ubo.modelview * <span class="hljs-type">vec4</span>(inPos.x, inPos.y, inPos.z, <span class="hljs-number">1.0</span>); <br>	<span class="hljs-type">vec4</span> projectedCorner = ubo.projection * <span class="hljs-type">vec4</span>(<span class="hljs-number">0.5</span> * spriteSize, <span class="hljs-number">0.5</span> * spriteSize, eyePos.z, eyePos.w);<br>	<span class="hljs-built_in">gl_PointSize</span> = <span class="hljs-built_in">clamp</span>(ubo.screendim.x * projectedCorner.x / projectedCorner.w, <span class="hljs-number">1.0</span>, <span class="hljs-number">128.0</span>);<br>	<br>	<span class="hljs-built_in">gl_Position</span> = ubo.projection * eyePos;<br><br>	outGradientPos = inVel.w;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> samplerColorMap;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> samplerGradientRamp;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">float</span> inGradientPos;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outFragColor;<br><br><span class="hljs-type">void</span> main () <br>&#123;<br>	<span class="hljs-type">vec3</span> color = <span class="hljs-built_in">texture</span>(samplerGradientRamp, <span class="hljs-type">vec2</span>(inGradientPos, <span class="hljs-number">0.0</span>)).rgb;<br>	outFragColor.rgb = <span class="hljs-built_in">texture</span>(samplerColorMap, <span class="hljs-built_in">gl_PointCoord</span>).rgb * color;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先对于顶点着色器，它会根据每个粒子的质量决定粒子在屏幕上绘制点的大小。由于我们之前是将粒子的质量存储在位置向量的第四个分量中，所以只需取位置向量的w分量即可获得质量大小。</p><p>之后代码通过一些逻辑来真正计算点的大小。需要注意的是，在对点的观察空间大小进行了投射变换之后，然后再进行透视除法，其实就相当于求出了在NDC空间中点的相对大小，也就是点大小与屏幕宽度的比值。而<i><font color="Orange">gl_PointSize</font></i>描述的是屏幕空间中点所占像素数量，因此我们还需要对点的相对大小乘以一个屏幕宽度（从上文对图形Uniform buffer的设置代码可知这个宽度通过<i><font color="Orange">screendim.x</font></i>给出。）。最后，顶点着色器将粒子在梯度图中的颜色坐标（这存储在速度向量的第四个分量中）传递给片段着色器供其使用。</p><p>片段着色器的代码是十分简单易懂的，就是两次采样纹理获得粒子的最终颜色。首先通过顶点着色器传递而来的梯度图坐标采样得到粒子的颜色（从上文的图像可以看出梯度图虽说是二维的，但是y方向的颜色值始终是相同的，所以采样的时候可以忽略y坐标），然后再乘以由另一个纹理给出的粒子亮度（观察上文图片知第二次采样的纹理其实是一个灰度图，只用于控制粒子不同位置的亮度，这样可以细化粒子的视觉表现）。这里一开始我对于内置变量<i><font color="Orange">gl_PointCoord</font></i>并不熟，后来查阅了相关文档（以及在GPT的鼎力支持下~）大概弄懂了它所表示的含义，简述如下：</p><p><code>gl_PointCoord代表点精灵的纹理坐标，这只有在渲染点精灵的上下文中才可以使用。点精灵（Point Sprite） 是一种在计算机图形学中用于渲染点的技术，通常用于表示粒子效果、星星、光点等。点精灵通过使用纹理来增强视觉效果， 使得单个点不仅仅是一个简单的像素，而是一个具有纹理和其他视觉属性的对象。点精灵通常被视为一个正方形或矩形， 渲染时会在屏幕上显示为一个四边形。这个四边形的大小由 gl_PointSize 控制。在渲染点精灵时，OpenGL 会将点精灵的 每个片段（fragment）映射到纹理的坐标系中。假设点精灵的大小为 size，在屏幕上的中心位置为 (centerX, centerY)， gl_PointCoord 的计算可以理解为： x 坐标：gl_PointCoord.x = (fragmentX - (centerX - size/2)) / size y 坐标：gl_PointCoord.y = (fragmentY - (centerY - size/2)) / size</code></p><p>这样就厘清了渲染阶段使用的着色器代码！</p><hr><h4 id="绑定描述符资源">绑定描述符资源</h4><p>创建好渲染管线后，现在我们可以将实际使用的描述符资源绑定起来供后续渲染流程使用了。<i><font color="Orange">setup_descriptor_set</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::setup_descriptor_set</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	VkDescriptorSetAllocateInfo alloc_info =<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_allocate_info</span>(<br>	        descriptor_pool,<br>	        &amp;graphics.descriptor_set_layout,<br>	        <span class="hljs-number">1</span>);<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;alloc_info, &amp;graphics.descriptor_set));<br><br>	VkDescriptorBufferInfo            buffer_descriptor         = <span class="hljs-built_in">create_descriptor</span>(*graphics.uniform_buffer);<br>	VkDescriptorImageInfo             particle_image_descriptor = <span class="hljs-built_in">create_descriptor</span>(textures.particle);<br>	VkDescriptorImageInfo             gradient_image_descriptor = <span class="hljs-built_in">create_descriptor</span>(textures.gradient);<br>	std::vector&lt;VkWriteDescriptorSet&gt; write_descriptor_sets;<br>	write_descriptor_sets = &#123;<br>	    vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(graphics.descriptor_set, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="hljs-number">0</span>, &amp;particle_image_descriptor),<br>	    vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(graphics.descriptor_set, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, <span class="hljs-number">1</span>, &amp;gradient_image_descriptor),<br>	    vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(graphics.descriptor_set, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">2</span>, &amp;buffer_descriptor),<br>	&#125;;<br>	<span class="hljs-built_in">vkUpdateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(write_descriptor_sets.<span class="hljs-built_in">size</span>()), write_descriptor_sets.<span class="hljs-built_in">data</span>(), <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码将三个描述符资源绑定在一个描述符集上（不过这三个资源具有各自不同的着色器绑定点），然后设置好它们各自的更新方式。这部分内容在<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/12/06/CG_api/vulkan/vulkan_tutorial/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B1%A0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86/"><code>我之前的文章</code></a>中也有详细的说明，这里不再赘述，有需要的读者请移步~</p><hr><h4 id="创建同步信号量">创建同步信号量</h4><p>图形准备阶段的最后，程序将用于图形—计算同步的信号量创建好。这个信号量将用于保证计算着色器开始对Storage buffer进行操作的时候图形管线已经完成了对其中内容的读取，不然图形管线有可能会读取到正在被计算着色器写入的内容，引发未定义的行为。</p><p>好了，现在图形阶段的准备工作总算是告一段落了，然而坏消息是这仍然不是终点。。。接下来让我们稍事休息，调匀呼吸，然后继续开始计算阶段所需的资源准备的探索吧（强颜欢笑</p><hr><h3 id="准备计算资源">准备计算资源</h3><p>人狠话不多，先上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::prepare_compute</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// Get compute queue</span><br>	<span class="hljs-built_in">vkGetDeviceQueue</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), compute.queue_family_index, <span class="hljs-number">0</span>, &amp;compute.queue);<br><br>	<span class="hljs-comment">// Create compute pipeline</span><br>	<span class="hljs-comment">// Compute pipelines are created separate from graphics pipelines even if they use the same queue (family index)</span><br><br>	std::vector&lt;VkDescriptorSetLayoutBinding&gt; set_layout_bindings = &#123;<br>	    <span class="hljs-comment">// Binding 0 : Particle position storage buffer</span><br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(<br>	        VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,<br>	        VK_SHADER_STAGE_COMPUTE_BIT,<br>	        <span class="hljs-number">0</span>),<br>	    <span class="hljs-comment">// Binding 1 : Uniform buffer</span><br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_binding</span>(<br>	        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,<br>	        VK_SHADER_STAGE_COMPUTE_BIT,<br>	        <span class="hljs-number">1</span>),<br>	&#125;;<br><br>	VkDescriptorSetLayoutCreateInfo descriptor_layout =<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_layout_create_info</span>(<br>	        set_layout_bindings.<span class="hljs-built_in">data</span>(),<br>	        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(set_layout_bindings.<span class="hljs-built_in">size</span>()));<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorSetLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_layout, <span class="hljs-literal">nullptr</span>, &amp;compute.descriptor_set_layout));<br><br>	VkPipelineLayoutCreateInfo pipeline_layout_create_info =<br>	    vkb::initializers::<span class="hljs-built_in">pipeline_layout_create_info</span>(<br>	        &amp;compute.descriptor_set_layout,<br>	        <span class="hljs-number">1</span>);<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreatePipelineLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;pipeline_layout_create_info, <span class="hljs-literal">nullptr</span>, &amp;compute.pipeline_layout));<br><br>	VkDescriptorSetAllocateInfo alloc_info =<br>	    vkb::initializers::<span class="hljs-built_in">descriptor_set_allocate_info</span>(<br>	        descriptor_pool,<br>	        &amp;compute.descriptor_set_layout,<br>	        <span class="hljs-number">1</span>);<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;alloc_info, &amp;compute.descriptor_set));<br><br>	VkDescriptorBufferInfo            storage_buffer_descriptor = <span class="hljs-built_in">create_descriptor</span>(*compute.storage_buffer);<br>	VkDescriptorBufferInfo            uniform_buffer_descriptor = <span class="hljs-built_in">create_descriptor</span>(*compute.uniform_buffer);<br>	std::vector&lt;VkWriteDescriptorSet&gt; compute_write_descriptor_sets =<br>	    &#123;<br>	        <span class="hljs-comment">// Binding 0 : Particle position storage buffer</span><br>	        vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(<br>	            compute.descriptor_set,<br>	            VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,<br>	            <span class="hljs-number">0</span>,<br>	            &amp;storage_buffer_descriptor),<br>	        <span class="hljs-comment">// Binding 1 : Uniform buffer</span><br>	        vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(<br>	            compute.descriptor_set,<br>	            VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,<br>	            <span class="hljs-number">1</span>,<br>	            &amp;uniform_buffer_descriptor)&#125;;<br><br>	<span class="hljs-built_in">vkUpdateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(compute_write_descriptor_sets.<span class="hljs-built_in">size</span>()), compute_write_descriptor_sets.<span class="hljs-built_in">data</span>(), <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>	<span class="hljs-comment">// Create pipelines</span><br>	VkComputePipelineCreateInfo compute_pipeline_create_info = vkb::initializers::<span class="hljs-built_in">compute_pipeline_create_info</span>(compute.pipeline_layout, <span class="hljs-number">0</span>);<br><br>	<span class="hljs-comment">// 1st pass - Particle movement calculations，更新速度</span><br>	compute_pipeline_create_info.stage = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;compute_nbody&quot;</span>, <span class="hljs-string">&quot;particle_calculate.comp&quot;</span>, VK_SHADER_STAGE_COMPUTE_BIT);<br><br>	<span class="hljs-comment">// Set some shader parameters via specialization constants</span><br>	<span class="hljs-comment">//专用常量的sample文档可以参考 https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/performance/specialization_constants</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SpecializationData</span><br>	&#123;<br>		<span class="hljs-type">uint32_t</span> workgroup_size;<br>		<span class="hljs-type">uint32_t</span> shared_data_size;<br>		<span class="hljs-type">float</span>    gravity;<br>		<span class="hljs-type">float</span>    power;<br>		<span class="hljs-type">float</span>    soften;<br>	&#125; specialization_data;<br><br>	std::vector&lt;VkSpecializationMapEntry&gt; specialization_map_entries;<br>	specialization_map_entries.<span class="hljs-built_in">push_back</span>(vkb::initializers::<span class="hljs-built_in">specialization_map_entry</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">offsetof</span>(SpecializationData, workgroup_size), <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>)));<br>	specialization_map_entries.<span class="hljs-built_in">push_back</span>(vkb::initializers::<span class="hljs-built_in">specialization_map_entry</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">offsetof</span>(SpecializationData, shared_data_size), <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>)));<br>	specialization_map_entries.<span class="hljs-built_in">push_back</span>(vkb::initializers::<span class="hljs-built_in">specialization_map_entry</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">offsetof</span>(SpecializationData, gravity), <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br>	specialization_map_entries.<span class="hljs-built_in">push_back</span>(vkb::initializers::<span class="hljs-built_in">specialization_map_entry</span>(<span class="hljs-number">3</span>, <span class="hljs-built_in">offsetof</span>(SpecializationData, power), <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br>	specialization_map_entries.<span class="hljs-built_in">push_back</span>(vkb::initializers::<span class="hljs-built_in">specialization_map_entry</span>(<span class="hljs-number">4</span>, <span class="hljs-built_in">offsetof</span>(SpecializationData, soften), <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br><br>	specialization_data.workgroup_size   = work_group_size;<br>	specialization_data.shared_data_size = shared_data_size;<br>	specialization_data.gravity          = <span class="hljs-number">0.002f</span>;<br>	specialization_data.power            = <span class="hljs-number">0.75f</span>;<br>	specialization_data.soften           = <span class="hljs-number">0.05f</span>;<br><br>	VkSpecializationInfo specialization_info =<br>	    vkb::initializers::<span class="hljs-built_in">specialization_info</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(specialization_map_entries.<span class="hljs-built_in">size</span>()), specialization_map_entries.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">sizeof</span>(specialization_data), &amp;specialization_data);<br>	compute_pipeline_create_info.stage.pSpecializationInfo = &amp;specialization_info;<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateComputePipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;compute_pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;compute.pipeline_calculate));<br><br>	<span class="hljs-comment">// 2nd pass - Particle integration，更新位置</span><br>	compute_pipeline_create_info.stage = <span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;compute_nbody&quot;</span>, <span class="hljs-string">&quot;particle_integrate.comp&quot;</span>, VK_SHADER_STAGE_COMPUTE_BIT);<br><br>	specialization_map_entries.<span class="hljs-built_in">clear</span>();<br>	specialization_map_entries.<span class="hljs-built_in">push_back</span>(vkb::initializers::<span class="hljs-built_in">specialization_map_entry</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>)));<br>	specialization_info =<br>	    vkb::initializers::<span class="hljs-built_in">specialization_info</span>(<span class="hljs-number">1</span>, specialization_map_entries.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">sizeof</span>(work_group_size), &amp;work_group_size);<br><br>	compute_pipeline_create_info.stage.pSpecializationInfo = &amp;specialization_info;<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateComputePipelines</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline_cache, <span class="hljs-number">1</span>, &amp;compute_pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;compute.pipeline_integrate));<br><br>	<span class="hljs-comment">// Separate command pool as queue family for compute may be different than graphics</span><br>	VkCommandPoolCreateInfo command_pool_create_info = &#123;&#125;;<br>	command_pool_create_info.sType                   = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;<br>	command_pool_create_info.queueFamilyIndex        = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_family_index</span>(VK_QUEUE_COMPUTE_BIT);<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateCommandPool</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;command_pool_create_info, <span class="hljs-literal">nullptr</span>, &amp;compute.command_pool));<br><br>	<span class="hljs-comment">// Create a command buffer for compute operations</span><br>	VkCommandBufferAllocateInfo command_buffer_allocate_info =<br>	    vkb::initializers::<span class="hljs-built_in">command_buffer_allocate_info</span>(<br>	        compute.command_pool,<br>	        VK_COMMAND_BUFFER_LEVEL_PRIMARY,<br>	        <span class="hljs-number">1</span>);<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateCommandBuffers</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;command_buffer_allocate_info, &amp;compute.command_buffer));<br><br>	<span class="hljs-comment">// Semaphore for compute &amp; graphics sync</span><br>	VkSemaphoreCreateInfo semaphore_create_info = vkb::initializers::<span class="hljs-built_in">semaphore_create_info</span>();<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateSemaphore</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;semaphore_create_info, <span class="hljs-literal">nullptr</span>, &amp;compute.semaphore));<br><br>	<span class="hljs-comment">// Signal the semaphore</span><br>	VkSubmitInfo submit_info         = &#123;VK_STRUCTURE_TYPE_SUBMIT_INFO&#125;;<br>	submit_info.signalSemaphoreCount = <span class="hljs-number">1</span>;<br>	submit_info.pSignalSemaphores    = &amp;compute.semaphore;<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkQueueSubmit</span>(queue, <span class="hljs-number">1</span>, &amp;submit_info, VK_NULL_HANDLE));<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkQueueWaitIdle</span>(queue));<br><br>	<span class="hljs-comment">// Build a single command buffer containing the compute dispatch commands</span><br>	<span class="hljs-built_in">build_compute_command_buffer</span>();<br><br>	<span class="hljs-comment">// If necessary, acquire and immediately release the storage buffer, so that the initial acquire</span><br>	<span class="hljs-comment">// from the graphics command buffers are matched up properly.</span><br><br>	<span class="hljs-keyword">if</span> (graphics.queue_family_index != compute.queue_family_index)<br>	&#123;<br>		VkCommandBuffer transfer_command;<br><br>		<span class="hljs-comment">// Create a transient command buffer for setting up the initial buffer transfer state</span><br>		VkCommandBufferAllocateInfo command_buffer_allocate_info =<br>		    vkb::initializers::<span class="hljs-built_in">command_buffer_allocate_info</span>(<br>		        compute.command_pool,<br>		        VK_COMMAND_BUFFER_LEVEL_PRIMARY,<br>		        <span class="hljs-number">1</span>);<br><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateCommandBuffers</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;command_buffer_allocate_info, &amp;transfer_command));<br><br>		VkCommandBufferBeginInfo command_buffer_info&#123;&#125;;<br>		command_buffer_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBeginCommandBuffer</span>(transfer_command, &amp;command_buffer_info));<br><br>		VkBufferMemoryBarrier acquire_buffer_barrier =<br>		    &#123;<br>		        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,<br>		        <span class="hljs-literal">nullptr</span>,<br>		        <span class="hljs-number">0</span>,<br>		        VK_ACCESS_SHADER_WRITE_BIT,<br>		        graphics.queue_family_index,<br>		        compute.queue_family_index,<br>		        compute.storage_buffer-&gt;<span class="hljs-built_in">get_handle</span>(),<br>		        <span class="hljs-number">0</span>,<br>		        compute.storage_buffer-&gt;<span class="hljs-built_in">get_size</span>()&#125;;<br>		<span class="hljs-built_in">vkCmdPipelineBarrier</span>(<br>		    transfer_command,<br>		    VK_PIPELINE_STAGE_TRANSFER_BIT,<br>		    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,<br>		    <span class="hljs-number">0</span>,<br>		    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>		    <span class="hljs-number">1</span>, &amp;acquire_buffer_barrier,<br>		    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br><br>		VkBufferMemoryBarrier release_buffer_barrier =<br>		    &#123;<br>		        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,<br>		        <span class="hljs-literal">nullptr</span>,<br>		        VK_ACCESS_SHADER_WRITE_BIT,<br>		        <span class="hljs-number">0</span>,<br>		        compute.queue_family_index,<br>		        graphics.queue_family_index,<br>		        compute.storage_buffer-&gt;<span class="hljs-built_in">get_handle</span>(),<br>		        <span class="hljs-number">0</span>,<br>		        compute.storage_buffer-&gt;<span class="hljs-built_in">get_size</span>()&#125;;<br>		<span class="hljs-built_in">vkCmdPipelineBarrier</span>(<br>		    transfer_command,<br>		    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,<br>		    VK_PIPELINE_STAGE_TRANSFER_BIT,<br>		    <span class="hljs-number">0</span>,<br>		    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>		    <span class="hljs-number">1</span>, &amp;release_buffer_barrier,<br>		    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br><br>		<span class="hljs-comment">// Copied from Device::flush_command_buffer, which we can&#x27;t use because it would be</span><br>		<span class="hljs-comment">// working with the wrong command pool</span><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkEndCommandBuffer</span>(transfer_command));<br><br>		<span class="hljs-comment">// Submit compute commands</span><br>		VkSubmitInfo submit_info&#123;&#125;;<br>		submit_info.sType              = VK_STRUCTURE_TYPE_SUBMIT_INFO;<br>		submit_info.commandBufferCount = <span class="hljs-number">1</span>;<br>		submit_info.pCommandBuffers    = &amp;transfer_command;<br><br>		<span class="hljs-comment">// Create fence to ensure that the command buffer has finished executing</span><br>		VkFenceCreateInfo fence_info&#123;&#125;;<br>		fence_info.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;<br>		fence_info.flags = VK_FLAGS_NONE;<br><br>		VkFence fence;<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateFence</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;fence_info, <span class="hljs-literal">nullptr</span>, &amp;fence));<br>		<span class="hljs-comment">// Submit to the *compute* queue</span><br>		VkResult result = <span class="hljs-built_in">vkQueueSubmit</span>(compute.queue, <span class="hljs-number">1</span>, &amp;submit_info, fence);<br>		<span class="hljs-comment">// Wait for the fence to signal that command buffer has finished executing</span><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkWaitForFences</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-number">1</span>, &amp;fence, VK_TRUE, DEFAULT_FENCE_TIMEOUT));<br>		<span class="hljs-built_in">vkDestroyFence</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), fence, <span class="hljs-literal">nullptr</span>);<br><br>		<span class="hljs-built_in">vkFreeCommandBuffers</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), compute.command_pool, <span class="hljs-number">1</span>, &amp;transfer_command);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看着是不是很唬人？没错它实际上也很唬人。。。不过慢慢拆解后，它的逻辑还是十分清晰的，且听我徐徐道来~</p><p>在对这段代码进行了细致的梳理后，我认为该函数所做的工作可以分为几个步骤：</p><ul><li>创建描述符集布局和计算管线布局</li><li>创建描述符集并绑定</li><li>创建计算管线</li><li>创建计算阶段命令提交所需的命令池并分配相应的命令缓冲</li><li>创建用于计算—图形同步的信号量</li><li>录制计算阶段命令</li><li>处理第一帧的Storage buffer归属权转移</li></ul><p>是不是也挺复杂的？接下来我们就一步步来探究吧。</p><h4 id="创建布局">创建布局</h4><p>首先要明确的是，计算着色器需要绑定两个资源，一个Storage buffer，一个Uniform buffer。在明确了这一点之后，创建相应的布局就是常规操作了。</p><hr><h4 id="创建描述符集并绑定">创建描述符集并绑定</h4><p>同样，程序从描述符池分配一个描述符集给计算阶段，该描述符集会引用相应的Storage buffer和Uniform buffer资源。这部分同样是常规的代码，不再赘述。</p><hr><h4 id="创建计算管线">创建计算管线</h4><p>由于本程序使用了两个compute pass来完成对粒子位置和速度的计算，所以需要相应地创建两个计算管线对象。计算管线的创建过程比图形管线要简单不少。在本程序中只需指定管线需要的着色器和布局就可以了。第一阶段的ji算管线对象使用的计算着色器代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br>struct Particle<br>&#123;<br>	<span class="hljs-type">vec4</span> pos;<br>	<span class="hljs-type">vec4</span> vel;<br>&#125;;<br><br><span class="hljs-comment">// Binding 0 : Position storage buffer</span><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">std140</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">buffer</span> Pos <br>&#123;<br>   Particle particles[ ];<br>&#125;;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">uniform</span> UBO <br>&#123;<br>	<span class="hljs-type">float</span> deltaT;<br>	<span class="hljs-type">int</span> particleCount;<br>&#125; ubo;<br><br><span class="hljs-keyword">layout</span> (constant_id = <span class="hljs-number">1</span>) <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> SHARED_DATA_SIZE = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">layout</span> (constant_id = <span class="hljs-number">2</span>) <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> GRAVITY = <span class="hljs-number">0.002</span>;<br><span class="hljs-keyword">layout</span> (constant_id = <span class="hljs-number">3</span>) <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> POWER = <span class="hljs-number">0.75</span>;<br><span class="hljs-keyword">layout</span> (constant_id = <span class="hljs-number">4</span>) <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> SOFTEN = <span class="hljs-number">0.05</span>;<br><br><span class="hljs-keyword">layout</span> (local_size_x_id = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span>;<br><br><span class="hljs-comment">// Share data between computer shader invocations to speed up caluclations</span><br><span class="hljs-keyword">shared</span> <span class="hljs-type">vec4</span> sharedData[SHARED_DATA_SIZE];<br><br><span class="hljs-meta">#define TIME_FACTOR 0.05</span><br><br><span class="hljs-type">void</span> main() <br>&#123;<br>	<span class="hljs-comment">// Current SSBO index</span><br>	<span class="hljs-type">uint</span> <span class="hljs-keyword">index</span> = <span class="hljs-built_in">gl_GlobalInvocationID</span>.x;<br>	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &gt;= ubo.particleCount) <br>		<span class="hljs-keyword">return</span>;	<br><br>	<span class="hljs-type">vec4</span> position = particles[<span class="hljs-keyword">index</span>].pos;<br>	<span class="hljs-type">vec4</span> velocity = particles[<span class="hljs-keyword">index</span>].vel;<br>	<span class="hljs-type">vec4</span> acceleration = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>);<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ubo.particleCount; i += SHARED_DATA_SIZE)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (i + <span class="hljs-built_in">gl_LocalInvocationID</span>.x &lt; ubo.particleCount)<br>		&#123;<br>			sharedData[<span class="hljs-built_in">gl_LocalInvocationID</span>.x] = particles[i + <span class="hljs-built_in">gl_LocalInvocationID</span>.x].pos;<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			sharedData[<span class="hljs-built_in">gl_LocalInvocationID</span>.x] = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>);<br>		&#125;<br><br>		<span class="hljs-built_in">barrier</span>();<span class="hljs-comment">//对工作组中的线程进行同步</span><br><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">gl_WorkGroupSize</span>.x; j++)<br>		&#123;<br>			<span class="hljs-type">vec4</span> other = sharedData[j];<br>			<span class="hljs-type">vec3</span> len = other.xyz - position.xyz;<br>			acceleration.xyz += GRAVITY * len * other.w / <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">dot</span>(len, len) + SOFTEN, POWER);<br>		&#125;<br><br>		<span class="hljs-built_in">barrier</span>();<br>	&#125;<br><br>	particles[<span class="hljs-keyword">index</span>].vel.xyz += ubo.deltaT * TIME_FACTOR * acceleration.xyz;<br><br>	<span class="hljs-comment">// Gradient texture position</span><br>	particles[<span class="hljs-keyword">index</span>].vel.w += <span class="hljs-number">0.1</span> * TIME_FACTOR * ubo.deltaT;<br>	<span class="hljs-keyword">if</span> (particles[<span class="hljs-keyword">index</span>].vel.w &gt; <span class="hljs-number">1.0</span>)<br>		particles[<span class="hljs-keyword">index</span>].vel.w -= <span class="hljs-number">1.0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>先来分析主函数的逻辑。首先根据<code>index &gt;= ubo.particleCount</code>这行代码可以得知该计算着色器应该是每个调用处理一个粒子的计算。然后在每一个调用单元中，首先提取出Storage buffer中存储的粒子位置和速度。为了更新粒子的速度，首先需要计算粒子当前的加速度。这里着色器使用了一个for循环来枚举出所有对粒子状态产生影响的其它粒子，并且将其存储在工作组的共享空间中，每个调用负责填写对应<i><font color="Orange">gl_LocalInvocationID</font></i>索引处的共享数据。然后，各调用需要等待所有调用均完成了一个循环内的数据填写，此时<i><font color="Orange">sharedData</font></i>内的数据已经填写完整，接下来每个调用使用所有填写好的共享数据信息开始计算各自处理的粒子的加速度，这样就模拟了多个粒子之间复杂的相互作用关系。同样，在每次调用你计算完各自的加速度增量之后也需要等待所有的调用计算完毕才能执行下一轮循环，不然共享数据可能还没有被某个调用读取完毕就已经被另一个调用写入了。</p><p>在执行完循环后，每个调用处理的粒子的加速度已经计算完毕，接下来只需使用加速度乘以时间计算该粒子速度的变化量即可（当然这里还乘了一个时间因子以添加对粒子运动速度的控制）。不过前文提到过，速度的第四个分量会存储粒子在梯度图中的坐标，这里同样需要更新。程序采用的更新方式为让粒子颜色按时间沿着梯度图均匀变化，从而让粒子的颜色随时间变化而周期性改变。</p><p>这样粒子速度更新的逻辑就已经厘清了。不过在此之外还需要看一看着色器所使用的变量。这里对我而言比较陌生的部分首先是constant_id那部分对应的变量声明。经查阅资料知这其实是在指定Vulkan中的一种特殊的着色器变量——<strong>专有常量（Specialization constant)</strong>。关于专有常量，我也还没有十分细致的了解，只是大体知道这种常量一般用于指定在着色器中不太需要变化的量，相比于Uniform变量而言着色器在编译的时候可以对专有常量进行一定的优化，相比于着色器文件内定义的常量而言专有常量可以传递给许多不同的着色器文件。不过幸运的是官方示例集中实际上也有专门的用于展示专有常量作用的示例<strong>specialization_constants</strong>，我会在之后去阅读相关的源码以加深理解~</p><p>另外还有一个不太了解的点就是输入处的代码<code>layout (local_size_x_id = 0) in;</code>，经简单的搜索了解到local_size_x_id=0实际上代表local_size_x取specialization constants中指定的第一个常量（事实上专有常量的id编号是从0开始的，但是代码中并没有列举第0号常量，这个常量实际上就用于指定工作组调用的第一个维度大小了，从后文在CPU端对专有常量的设定也可以看出来事实上是设置了5个专有常量的，并且第一个指定的是工作组调用维度的大小），更多解释可见 https://zhuanlan.zhihu.com/p/468404001。</p><p>最后还有一个需要提及的点，就是在glsl中是允许将constant variable指定为数组大小的，但是在hlsl中这种用法是不允许的（这在本示例对应的hlsl文件中有提及）。</p><p>好的，现在让我们把注意力拉回到示例源码上~在设定好管线的计算着色器后，紧接着程序就开始设定着色器用到的专有常量了。同样，这部分代码其实大概来看也是能理解意思的，不过我打算将更清晰的理解推迟到之后阅读示例<strong>specialization_constants</strong>源码的时候，所以这里只看个大概就行（摸了。。。</p><p>另外，从<code>compute_pipeline_create_info.stage.pSpecializationInfo = &amp;specialization_info;</code>一行代码也可以看出专有常量其实也是Pipeline stage指定的一部分。经查阅可知确实如此：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_VERSION_1_0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkPipelineShaderStageCreateInfo</span> &#123;</span><br>    VkStructureType                     sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                         pNext;<br>    VkPipelineShaderStageCreateFlags    flags;<br>    VkShaderStageFlagBits               stage;<br>    VkShaderModule                      module;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*                         pName;<br>    <span class="hljs-type">const</span> VkSpecializationInfo*         pSpecializationInfo;<br>&#125; VkPipelineShaderStageCreateInfo;<br></code></pre></td></tr></table></figure><p>这样第一阶段的管线就构建完毕了，接下来赶到战场的是第二阶段的管线构建。同样先来查看一下管线使用的着色器源码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450</span><br><br>struct Particle<br>&#123;<br>	<span class="hljs-type">vec4</span> pos;<br>	<span class="hljs-type">vec4</span> vel;<br>&#125;;<br><br><span class="hljs-comment">// Binding 0 : Position storage buffer</span><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">std140</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">buffer</span> Pos <br>&#123;<br>   Particle particles[ ];<br>&#125;;<br><br><span class="hljs-keyword">layout</span> (local_size_x_id = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span>;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">uniform</span> UBO <br>&#123;<br>	<span class="hljs-type">float</span> deltaT;<br>	<span class="hljs-type">int</span> particleCount;<br>&#125; ubo;<br><br><span class="hljs-meta">#define TIME_FACTOR 0.05</span><br><br><span class="hljs-type">void</span> main() <br>&#123;<br>	<span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-type">int</span>(<span class="hljs-built_in">gl_GlobalInvocationID</span>);<br>	<span class="hljs-type">vec4</span> position = particles[<span class="hljs-keyword">index</span>].pos;<br>	<span class="hljs-type">vec4</span> velocity = particles[<span class="hljs-keyword">index</span>].vel;<br>	position += ubo.deltaT * TIME_FACTOR * velocity;<br>	particles[<span class="hljs-keyword">index</span>].pos = position;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个着色器负责更新粒子的位置。更新逻辑同样是一个调用处理一个粒子的更新，然后位置计算的逻辑也就是简单的速度乘时间得到位置变化量，然后更新即可。</p><p>这个着色器同样需要一个专有常量来指定工作组调用第一个维度的大小，所以在示例程序中同样需要设定Pipeline stage需要的专有常量信息，只不过这时候就只需要这一个专有常量了。</p><p>这样两个compute pass的管线均已构建完毕！</p><hr><h4 id="创建命令缓冲">创建命令缓冲</h4><p>图形命令提交使用的命令缓冲是由基类提供的命令池分配的，但基类的命令池只适用于分配提交图形命令的命令缓冲，想要提交计算命令还需要在示例类中自行创建计算命令池并分配计算命令缓冲，这就是<i><font color="Orange">compute</font></i>结构体中<i><font color="Orange">command_pool</font></i>和<i><font color="Orange">commmand_buffer</font></i>成员的作用。在明确了这一点之后，命令池的创建和命令缓冲的分配就是常规操作了，不熟悉的读者可以参考我之前翻译的Vulkan Tutorial中对命令缓冲部分的<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2"><code>教程</code></a>。</p><hr><h4 id="创建同步信号量-1">创建同步信号量</h4><p>接下来需要创建用于计算—图形同步的信号量，因为图形的顶点输入阶段需要等待计算着色器工作完毕才能读入Storage buffer中的数据。但是这里的巧妙之处在于，程序在创建信号量之后创建了一个没有录制任何命令但附带有该信号量的提交信息，然后立刻提交该空命令列表。刚开始我也是看的一脸懵，不过后续我发现信号量只有在提交的命令全部完成后才能被点亮，似乎没有其它（至少更便捷的）点亮手段，所以这段代码的唯一作用肯定就是在创建好该信号量之后立刻点亮它。那么现在问题就是为什么要这么做呢？根据我的分析，这应该是因为渲染第一帧画面的时候，渲染管线的顶点输入使用的是Storage buffer中已经在渲染前设定好的初始值，而不会像之后的所有帧那样依赖于计算着色器对Storage buffer的更新结果。因此第一帧渲染时，图形管线应该直接输入Storage buffer中的数据而无需使用该信号量在顶点输入阶段等待计算着色器运行完毕，所以这里将信号量的初始状态设置为点亮以取消计算着色器运行对顶点输入阶段的阻塞效果。</p><hr><h4 id="录制计算命令">录制计算命令</h4><p>接下来程序使用<i><font color="Green">build_compute_command_buffer</font></i>函数来录制计算命令。该函数源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::build_compute_command_buffer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	VkCommandBufferBeginInfo command_buffer_begin_info = vkb::initializers::<span class="hljs-built_in">command_buffer_begin_info</span>();<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBeginCommandBuffer</span>(compute.command_buffer, &amp;command_buffer_begin_info));<br><br>	<span class="hljs-comment">// Acquire</span><br>	<span class="hljs-keyword">if</span> (graphics.queue_family_index != compute.queue_family_index)<br>	&#123;<br>		VkBufferMemoryBarrier buffer_barrier =<br>		    &#123;<br>		        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,<br>		        <span class="hljs-literal">nullptr</span>,<br>		        <span class="hljs-number">0</span>,<br>		        VK_ACCESS_SHADER_WRITE_BIT,<br>		        graphics.queue_family_index,<br>		        compute.queue_family_index,<br>		        compute.storage_buffer-&gt;<span class="hljs-built_in">get_handle</span>(),<br>		        <span class="hljs-number">0</span>,<br>		        compute.storage_buffer-&gt;<span class="hljs-built_in">get_size</span>()&#125;;<br><br>		<span class="hljs-built_in">vkCmdPipelineBarrier</span>(<br>		    compute.command_buffer,<br>		    VK_PIPELINE_STAGE_TRANSFER_BIT,<br>		    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,<br>		    <span class="hljs-number">0</span>,<br>		    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>		    <span class="hljs-number">1</span>, &amp;buffer_barrier,<br>		    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>	&#125;<br><br>	<span class="hljs-comment">// First pass: Calculate particle movement</span><br>	<span class="hljs-comment">// -------------------------------------------------------------------------------------------------------</span><br>	<span class="hljs-built_in">vkCmdBindPipeline</span>(compute.command_buffer, VK_PIPELINE_BIND_POINT_COMPUTE, compute.pipeline_calculate);<br>	<span class="hljs-built_in">vkCmdBindDescriptorSets</span>(compute.command_buffer, VK_PIPELINE_BIND_POINT_COMPUTE, compute.pipeline_layout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;compute.descriptor_set, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>	<span class="hljs-built_in">vkCmdDispatch</span>(compute.command_buffer, num_particles / work_group_size, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><br>	<span class="hljs-comment">// Add memory barrier to ensure that the computer shader has finished writing to the buffer</span><br>	VkBufferMemoryBarrier memory_barrier = vkb::initializers::<span class="hljs-built_in">buffer_memory_barrier</span>();<br>	memory_barrier.buffer                = compute.storage_buffer-&gt;<span class="hljs-built_in">get_handle</span>();<br>	memory_barrier.size                  = compute.storage_buffer-&gt;<span class="hljs-built_in">get_size</span>();<br>	memory_barrier.srcAccessMask         = VK_ACCESS_SHADER_WRITE_BIT;<br>	memory_barrier.dstAccessMask         = VK_ACCESS_SHADER_READ_BIT;<br>	memory_barrier.srcQueueFamilyIndex   = VK_QUEUE_FAMILY_IGNORED;<br>	memory_barrier.dstQueueFamilyIndex   = VK_QUEUE_FAMILY_IGNORED;<br><br>	<span class="hljs-built_in">vkCmdPipelineBarrier</span>(<br>	    compute.command_buffer,<br>	    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,<br>	    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,<br>	    VK_FLAGS_NONE,<br>	    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>	    <span class="hljs-number">1</span>, &amp;memory_barrier,<br>	    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br><br>	<span class="hljs-comment">// Second pass: Integrate particles</span><br>	<span class="hljs-comment">// -------------------------------------------------------------------------------------------------------</span><br>	<span class="hljs-built_in">vkCmdBindPipeline</span>(compute.command_buffer, VK_PIPELINE_BIND_POINT_COMPUTE, compute.pipeline_integrate);<br>	<span class="hljs-built_in">vkCmdDispatch</span>(compute.command_buffer, num_particles / work_group_size, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><br>	<span class="hljs-comment">// Release</span><br>	<span class="hljs-keyword">if</span> (graphics.queue_family_index != compute.queue_family_index)<br>	&#123;<br>		VkBufferMemoryBarrier buffer_barrier =<br>		    &#123;<br>		        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,<br>		        <span class="hljs-literal">nullptr</span>,<br>		        VK_ACCESS_SHADER_WRITE_BIT,<br>		        <span class="hljs-number">0</span>,<br>		        compute.queue_family_index,<br>		        graphics.queue_family_index,<br>		        compute.storage_buffer-&gt;<span class="hljs-built_in">get_handle</span>(),<br>		        <span class="hljs-number">0</span>,<br>		        compute.storage_buffer-&gt;<span class="hljs-built_in">get_size</span>()&#125;;<br><br>		<span class="hljs-built_in">vkCmdPipelineBarrier</span>(<br>		    compute.command_buffer,<br>		    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,<br>		    VK_PIPELINE_STAGE_TRANSFER_BIT,<br>		    <span class="hljs-number">0</span>,<br>		    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>		    <span class="hljs-number">1</span>, &amp;buffer_barrier,<br>		    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>	&#125;<br><br>	<span class="hljs-built_in">vkEndCommandBuffer</span>(compute.command_buffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>也不短（没完没了了。。。还是让我们耐下性子继续分析吧~</p><p>首先，要录制命令当然需要先启动之前分配好的计算命令缓冲。然后，计算队列需要获取Storage buffer的归属权，因为在准备图形资源的时候图形队列是释放了Storage buffer的归属权，但计算队列还没有执行相应的获取操作。在得到Storage buffer归属权之后，紧接着就可以录制执行第一个compute pass的命令了，这只需要绑定相应的计算管线，绑定管线需要的描述符集，最后将计算工作打包成多个工作组即可。</p><p>在完成了第一个计算任务之后，我们需要显示地同步两个pass以保证它们运行的先后顺序，这同样是通过Buffer Memory Barrier来实现的（只不过此时该内存屏障用来保证执行顺序的先后关系而不是用来转移内存归属权）。在此之后就可以安心地录制执行第二个pass的命令了。</p><p>在录制完所有的管线执行命令之后，最后计算队列还需要释放对Storage buffer的所有权，因为在计算完毕后Storage buffer将供图形管线使用。</p><hr><h4 id="处理第一帧storage-buffer归属权转移">处理第一帧Storage buffer归属权转移</h4><p>终于来到了准备计算资源的最后一部分，也是当初困扰我最久的一部分，就是<i><font color="Green">build_compute_command_buffer</font></i>函数下面的那一大段。经过仔细的分析之后我认为这段代码的目的同样在于处理第一帧渲染的特殊情形。在后文录制图形命令部分我们实际上可以看到图形部分录制的第一个命令会是图形队列对Storage buffer归属权的获取，这是因为在除了第一帧之外的所有帧中，图形的顶点输入阶段会等待计算阶段执行完毕，而计算阶段在更新完Storage buffer后会释放对它的所有权，此时图形队列一定需要一个匹配的获取所有权的操作。但是问题在于第一帧，在第一帧渲染的时候，图形管线有关命令的执行不会等待计算阶段的运行，但图形队列从计算队列获取所有权一定需要和计算队列向图形队列释放所有权相匹配，但第一帧跳过了计算队列的所有操作，那也就是说计算命令缓冲中开头的计算队列获取所有权和结尾的计算队列释放所有权都被跳过了，这并不是我们希望看到的。因此在准备计算资源代码的最后程序从计算命令池（因为是计算队列的获取和释放操作，当然需要从计算命令池中分配）中分配一个临时的计算缓冲用来处理上述匹配操作，并且设置一个栅栏(Fence)来保证在图形队列获取到Storage buffer前匹配操作已经完成。</p><p>计算阶段的准备工作终于大功告成！接下来开始准备图形命令的录制吧！</p><hr><h3 id="录制图形命令">录制图形命令</h3><p>准备阶段的最后一步是把绘制有关的命令录制好。<i><font color="Green">build_command_buffers</font></i>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::build_command_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	VkCommandBufferBeginInfo command_buffer_begin_info = vkb::initializers::<span class="hljs-built_in">command_buffer_begin_info</span>();<br><br>	VkClearValue clear_values[<span class="hljs-number">2</span>];<br>	clear_values[<span class="hljs-number">0</span>].color        = &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;&#125;;<br>	clear_values[<span class="hljs-number">1</span>].depthStencil = &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0</span>&#125;;<br><br>	VkRenderPassBeginInfo render_pass_begin_info    = vkb::initializers::<span class="hljs-built_in">render_pass_begin_info</span>();<br>	render_pass_begin_info.renderPass               = render_pass;<br>	render_pass_begin_info.renderArea.offset.x      = <span class="hljs-number">0</span>;<br>	render_pass_begin_info.renderArea.offset.y      = <span class="hljs-number">0</span>;<br>	render_pass_begin_info.renderArea.extent.width  = width;<br>	render_pass_begin_info.renderArea.extent.height = height;<br>	render_pass_begin_info.clearValueCount          = <span class="hljs-number">2</span>;<br>	render_pass_begin_info.pClearValues             = clear_values;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; draw_cmd_buffers.<span class="hljs-built_in">size</span>(); ++i)<br>	&#123;<br>		<span class="hljs-comment">// Set target frame buffer</span><br>		render_pass_begin_info.framebuffer = framebuffers[i];<br><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBeginCommandBuffer</span>(draw_cmd_buffers[i], &amp;command_buffer_begin_info));<br><br>		<span class="hljs-comment">// Acquire</span><br>		<span class="hljs-keyword">if</span> (graphics.queue_family_index != compute.queue_family_index)<br>		&#123;<br>			VkBufferMemoryBarrier buffer_barrier =<br>			    &#123;<br>			        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,<br>			        <span class="hljs-literal">nullptr</span>,<br>			        <span class="hljs-number">0</span>,<br>			        VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,<br>			        compute.queue_family_index,<br>			        graphics.queue_family_index,<br>			        compute.storage_buffer-&gt;<span class="hljs-built_in">get_handle</span>(),<br>			        <span class="hljs-number">0</span>,<br>			        compute.storage_buffer-&gt;<span class="hljs-built_in">get_size</span>()&#125;;<br><br>			<span class="hljs-built_in">vkCmdPipelineBarrier</span>(<br>			    draw_cmd_buffers[i],<br>			    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,<br>			    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,<br>			    <span class="hljs-number">0</span>,<br>			    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>			    <span class="hljs-number">1</span>, &amp;buffer_barrier,<br>			    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>		&#125;<br><br>		<span class="hljs-comment">// Draw the particle system using the update vertex buffer</span><br>		<span class="hljs-built_in">vkCmdBeginRenderPass</span>(draw_cmd_buffers[i], &amp;render_pass_begin_info, VK_SUBPASS_CONTENTS_INLINE);<span class="hljs-comment">//VK_SUBPASS_CONTENTS_INLINE代表子通道命令录制在初级命令缓冲中</span><br>		VkViewport viewport = vkb::initializers::<span class="hljs-built_in">viewport</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(width), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(height), <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br>		<span class="hljs-built_in">vkCmdSetViewport</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;viewport);<br>		VkRect2D scissor = vkb::initializers::<span class="hljs-built_in">rect2D</span>(width, height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>		<span class="hljs-built_in">vkCmdSetScissor</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;scissor);<br>		<span class="hljs-built_in">vkCmdBindPipeline</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphics.pipeline);<br>		<span class="hljs-built_in">vkCmdBindDescriptorSets</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphics.pipeline_layout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;graphics.descriptor_set, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>		VkDeviceSize offsets[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>		<span class="hljs-built_in">vkCmdBindVertexBuffers</span>(draw_cmd_buffers[i], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, compute.storage_buffer-&gt;<span class="hljs-built_in">get</span>(), offsets);<br>		<span class="hljs-built_in">vkCmdDraw</span>(draw_cmd_buffers[i], num_particles, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>		<span class="hljs-built_in">draw_ui</span>(draw_cmd_buffers[i]);<br>		<span class="hljs-built_in">vkCmdEndRenderPass</span>(draw_cmd_buffers[i]);<br><br>		<span class="hljs-comment">// Release barrier</span><br>		<span class="hljs-keyword">if</span> (graphics.queue_family_index != compute.queue_family_index)<br>		&#123;<br>			VkBufferMemoryBarrier buffer_barrier =<br>			    &#123;<br>			        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,<br>			        <span class="hljs-literal">nullptr</span>,<br>			        VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,<br>			        <span class="hljs-number">0</span>,<br>			        graphics.queue_family_index,<br>			        compute.queue_family_index,<br>			        compute.storage_buffer-&gt;<span class="hljs-built_in">get_handle</span>(),<br>			        <span class="hljs-number">0</span>,<br>			        compute.storage_buffer-&gt;<span class="hljs-built_in">get_size</span>()&#125;;<br><br>			<span class="hljs-built_in">vkCmdPipelineBarrier</span>(<br>			    draw_cmd_buffers[i],<br>			    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,<br>			    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,<br>			    <span class="hljs-number">0</span>,<br>			    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>,<br>			    <span class="hljs-number">1</span>, &amp;buffer_barrier,<br>			    <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>		&#125;<br><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkEndCommandBuffer</span>(draw_cmd_buffers[i]));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>录制的流程也和<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2"><code>我之前的文章</code></a>中对Vulkan Tutorial相应教程的翻译并没有多少区别，大致的流程就是先开始命令缓冲的录制，然后开启渲染通道，之后将视口和裁剪区域设置好，绑定渲染管线，绑定管线用到的描述符资源，绑定顶点缓冲 ，然后开启绘制，绘制结束后结束渲染通道并结束命令录制。不过这里也有几个需要关注一下的点：首先是注意到渲染命令的录制针对每一个帧缓冲都要进行一次，并且每个帧缓冲需要录制的命令是相同的，所以在函数中我们可以看到程序使用了一个循环来录制这些命令。另外注意到所有的命令是录制到<i><font color="Orange">draw_cmd_buffers</font></i>上，这组命令缓冲本身不是示例类内的成员，它们是基类已经准备好的成员，供子类的图形命令绘制调用，它们的数量和帧缓冲的数量是一致的，同样这里用到的帧缓冲<i><font color="Orange">framebuffers</font></i>也是基类创建好的资源。然后就是上文提到过图形录制的第一步需要让图形队列获取Storage buffer的所有权，所以在开启渲染通道之前需要首先使用一个内存屏障来完成图形队列归属权的获取操作。最后在真正的绘制部分我们会发现其实程序录制了两个绘制命令，其中第一个是对粒子系统的绘制，第二个实际上是对程序UI界面的绘制（没错，就是那个<i><font color="Green">draw_ui</font></i>函数），Vulkan官方示例集采用<a target="_blank" rel="noopener" href="https://github.com/ocornut/imgui"><code>imgui</code></a>作为窗口系统，后续在探索该示例集框架的时候我们再来详细分析这个函数以及相关绘制调用的逻辑，这里只要知道它的大致作用就行了。最后，在命令录制的最后，图形队列已经不再需要使用Storage buffer了，此时应该将Storage buffer交给计算对列处理，因此最后图形队列需要释放对Storage buffer的所有权，这也和计算命令最开始的计算队列获取所有权是对应的。</p><hr><h3 id="准备阶段的收尾">准备阶段的收尾</h3><p>终于将<i><font color="Green">prepare</font></i>函数中的主逻辑给分析完了，在该函数的最后，程序将私有变量<i><font color="Orange">prepared</font></i>设置为true，代表准备工作已经结束了，可以开始主渲染循环了。Ok，事不宜迟，那现在就让我们开始主渲染循环逻辑的分析吧！</p><hr><h2 id="主渲染循环">主渲染循环</h2><p>程序的主渲染循环的主要逻辑是通过循环调用示例类的<i><font color="Green">render</font></i>函数实现的。我们就着重关注这个函数的逻辑。下面先上函数代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::render</span><span class="hljs-params">(<span class="hljs-type">float</span> delta_time)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (!prepared)<br>	&#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-built_in">draw</span>();<br>	<span class="hljs-built_in">update_compute_uniform_buffers</span>(delta_time);<br>	<span class="hljs-keyword">if</span> (camera.updated)<br>	&#123;<br>		<span class="hljs-built_in">update_graphics_uniform_buffers</span>();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的逻辑的相对比较简单，主要可以分为两个部分：</p><ul><li>绘制粒子效果</li><li>更新使用的Uniform buffer资源</li></ul><p>下面同样我们来一步步分析这些步骤：</p><h3 id="绘制粒子效果">绘制粒子效果</h3><p>粒子效果的绘制过程已经被封装到了<i><font color="Green">draw</font></i>函数中了。下面是<i><font color="Green">draw</font></i>函数的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComputeNBody::draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	ApiVulkanSample::<span class="hljs-built_in">prepare_frame</span>();<br><br>	VkPipelineStageFlags graphics_wait_stage_masks[]  = &#123;VK_PIPELINE_STAGE_VERTEX_INPUT_BIT, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&#125;;<br>	VkSemaphore          graphics_wait_semaphores[]   = &#123;compute.semaphore, semaphores.acquired_image_ready&#125;;<br>	VkSemaphore          graphics_signal_semaphores[] = &#123;graphics.semaphore, semaphores.render_complete&#125;;<br><br>	<span class="hljs-comment">// Submit graphics commands</span><br>	submit_info.commandBufferCount   = <span class="hljs-number">1</span>;<br>	submit_info.pCommandBuffers      = &amp;draw_cmd_buffers[current_buffer];<br>	submit_info.waitSemaphoreCount   = <span class="hljs-number">2</span>;<br>	submit_info.pWaitSemaphores      = graphics_wait_semaphores;<br>	submit_info.pWaitDstStageMask    = graphics_wait_stage_masks;<br>	submit_info.signalSemaphoreCount = <span class="hljs-number">2</span>;<br>	submit_info.pSignalSemaphores    = graphics_signal_semaphores;<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkQueueSubmit</span>(queue, <span class="hljs-number">1</span>, &amp;submit_info, VK_NULL_HANDLE));<br><br>	ApiVulkanSample::<span class="hljs-built_in">submit_frame</span>();<br><br>	<span class="hljs-comment">// Wait for rendering finished</span><br>	VkPipelineStageFlags wait_stage_mask = VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT;<br><br>	<span class="hljs-comment">// Submit compute commands</span><br>	VkSubmitInfo compute_submit_info         = vkb::initializers::<span class="hljs-built_in">submit_info</span>();<br>	compute_submit_info.commandBufferCount   = <span class="hljs-number">1</span>;<br>	compute_submit_info.pCommandBuffers      = &amp;compute.command_buffer;<br>	compute_submit_info.waitSemaphoreCount   = <span class="hljs-number">1</span>;<br>	compute_submit_info.pWaitSemaphores      = &amp;graphics.semaphore;<br>	compute_submit_info.pWaitDstStageMask    = &amp;wait_stage_mask;<br>	compute_submit_info.signalSemaphoreCount = <span class="hljs-number">1</span>;<br>	compute_submit_info.pSignalSemaphores    = &amp;compute.semaphore;<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkQueueSubmit</span>(compute.queue, <span class="hljs-number">1</span>, &amp;compute_submit_info, VK_NULL_HANDLE));<br>&#125;<br></code></pre></td></tr></table></figure><p>首先程序会调用基类的<i><font color="Green">prepare_frame</font></i>函数来进行真正的绘制前的准备工作，包括处理窗口大小的变化，获取需要绘制到的下一张图像等，这里我们放上这个函数的代码，但是同样不会进行过多的分析，因为这部分函数并不属于这个示例的主逻辑，只需要知道它的大致功能就行了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ApiVulkanSample::prepare_frame</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">has_swapchain</span>())<br>	&#123;<br>		<span class="hljs-built_in">handle_surface_changes</span>();<br>		<span class="hljs-comment">// Acquire the next image from the swap chain</span><br>		VkResult result = <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_swapchain</span>().<span class="hljs-built_in">acquire_next_image</span>(current_buffer, semaphores.acquired_image_ready, VK_NULL_HANDLE);<br>		<span class="hljs-comment">// Recreate the swapchain if it&#x27;s no longer compatible with the surface (OUT_OF_DATE)</span><br>		<span class="hljs-keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR)<br>		&#123;<br>			<span class="hljs-built_in">resize</span>(width, height);<br>		&#125;<br>		<span class="hljs-comment">// VK_SUBOPTIMAL_KHR means that acquire was successful and semaphore is signaled but image is suboptimal</span><br>		<span class="hljs-comment">// allow rendering frame to suboptimal swapchain as otherwise we would have to manually unsignal semaphore and acquire image again</span><br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != VK_SUBOPTIMAL_KHR)<br>		&#123;<br>			<span class="hljs-built_in">VK_CHECK</span>(result);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在准备好渲染所需的帧资源之后，现在就可以进行渲染命令提交信息的填写了。这里需要厘清的是提交信息中信号量的设置。这里可以看到程序设置了两个等待的信号量，分别是<i><font color="Orange">compute.semaphore</font></i>和<i><font color="Orange">semaphores.acquired_image_ready</font></i>，这两个信号会分别在<i><font color="Red">VK_PIPELINE_STAGE_VERTEX_INPUT_BIT</font></i>和<i><font color="Red">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</font></i>阶段上等待，第一个信号量是示例准备阶段创建的用于进行计算—图形阶段同步的信号量，它会在顶点数据输入阶段等待计算命令的完成以将它点亮，点亮之后才能从Storage buffer读取顶点数据；第二个信号量是基类创建的成员，在上文的<i><font color="Green">prepare_frame</font></i>函数中我们也看到了它的作用是通知后续阶段用于本次绘制的图像已经准备好了，片段着色器可以向这张图像输出颜色了。如果有读者对这个过程不是很清楚的话可以参考<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/"><code>我的这篇文章</code></a>。总之，该信号量大体的工作方式就是会在获取到图像之后被点亮，然后片段着色器输出阶段会等待这个信号量被点亮，然后才能执行下一步的输出。</p><p>同时也可以发现提交信息中还设置了两个在渲染命令执行完毕后会点亮的信号量：<i><font color="Orange">graphics.semaphore</font></i>用于进行图形—计算同步，计算着色器想要进行Storage buffer的更新，必须等待图形命令完成对Storage buffer的使用；另一个信号量<i><font color="Orange">semaphores.render_complete</font></i>同样是基类的成员，它用于进行渲染和屏幕显示之间的同步，这部分同步代码在下方的<i><font color="Green">submit_frame</font></i>中给出，我们还是给出这个函数的代码但不会做具体的分析，因为这部分的逻辑在<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/16/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/"><code>我之前的文章</code></a>中也有系统的梳理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ApiVulkanSample::submit_frame</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">has_swapchain</span>())<br>	&#123;<br>		<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;queue = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_by_present</span>(<span class="hljs-number">0</span>);<br><br>		VkSwapchainKHR sc = <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_swapchain</span>().<span class="hljs-built_in">get_handle</span>();<br><br>		VkPresentInfoKHR present_info = &#123;&#125;;<br>		present_info.sType            = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;<br>		present_info.pNext            = <span class="hljs-literal">NULL</span>;<br>		present_info.swapchainCount   = <span class="hljs-number">1</span>;<br>		present_info.pSwapchains      = &amp;sc;<br>		present_info.pImageIndices    = &amp;current_buffer;<br><br>		VkDisplayPresentInfoKHR disp_present_info&#123;&#125;;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">is_extension_supported</span>(VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME) &amp;&amp;<br>		    window-&gt;<span class="hljs-built_in">get_display_present_info</span>(&amp;disp_present_info, width, height))<br>		&#123;<br>			<span class="hljs-comment">// Add display present info if supported and wanted</span><br>			present_info.pNext = &amp;disp_present_info;<br>		&#125;<br><br>		<span class="hljs-comment">// Check if a wait semaphore has been specified to wait for before presenting the image</span><br>		<span class="hljs-keyword">if</span> (semaphores.render_complete != VK_NULL_HANDLE)<br>		&#123;<br>			present_info.pWaitSemaphores    = &amp;semaphores.render_complete;<br>			present_info.waitSemaphoreCount = <span class="hljs-number">1</span>;<br>		&#125;<br><br>		VkResult present_result = queue.<span class="hljs-built_in">present</span>(present_info);<br><br>		<span class="hljs-keyword">if</span> (!((present_result == VK_SUCCESS) || (present_result == VK_SUBOPTIMAL_KHR)))<br>		&#123;<br>			<span class="hljs-keyword">if</span> (present_result == VK_ERROR_OUT_OF_DATE_KHR)<br>			&#123;<br>				<span class="hljs-comment">// Swap chain is no longer compatible with the surface and needs to be recreated</span><br>				<span class="hljs-built_in">resize</span>(width, height);<br>				<span class="hljs-keyword">return</span>;<br>			&#125;<br>			<span class="hljs-keyword">else</span><br>			&#123;<br>				<span class="hljs-built_in">VK_CHECK</span>(present_result);<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// DO NOT USE</span><br>	<span class="hljs-comment">// vkDeviceWaitIdle and vkQueueWaitIdle are extremely expensive functions, and are used here purely for demonstrating the vulkan API</span><br>	<span class="hljs-comment">// without having to concern ourselves with proper syncronization. These functions should NEVER be used inside the render loop like this (every frame).</span><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_queue_by_present</span>(<span class="hljs-number">0</span>).<span class="hljs-built_in">wait_idle</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就完成了图形命令提交信息的指定，接下来只需一键提交即可（bushi。提交之后，我们就需要来继续处理计算命令的提交了。从代码中可以看到计算阶段会等待之前在图形阶段完成时点亮的信号量<i><font color="Orange">graphics.semaphore</font></i>，然后在完成了自己的工作之后会负责点亮<i><font color="Orange">compute.semaphore</font></i>以通知下一帧的顶点输入阶段已经可以输入更新好的数据了。最后提交命令，大功告成！</p><hr><h3 id="更新uniform-buffer">更新Uniform buffer</h3><p>当然，每一帧中着色器会用到的Uniform变量也是会变的，所以当然应该要在每一个循环的最后更新下一帧会用到的变量。每一帧所耗费的时间都有可能会变化，所以计算阶段使用的Uniform buffer中的<i><font color="Orange">delta_time</font></i>一定需要更新。另外注意到<i><font color="Orange">graphics</font></i>中的<i><font color="Orange">ubo</font></i>结构体中包含的三个成员中<i><font color="Orange">screenDim</font></i>成员只要窗口大小不发生变化就不会发生改变，而另外两个成员均依赖于当前摄像机的状态，所以如果摄像机没有发生改变，则这两个变量也无需更新。</p><p>本示例的分析终于结束了！撒花！！！</p><hr></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/CG-api/" class="category-chain-item">CG_api</a> <span>></span> <a href="/categories/CG-api/vulkan/" class="category-chain-item">vulkan</a> <span>></span> <a href="/categories/CG-api/vulkan/vulkan-samples/" class="category-chain-item">vulkan_samples</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>Compute_nbody</div><div>http://example.com/2025/01/24/CG_api/vulkan/vulkan_samples/compute_nbody/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>ZPC-dsg</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年1月24日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2025/01/24/articles/algo_techniques/%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB1/" title="文章汇总"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">文章汇总</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/12/27/CG_api/vulkan/vulkan_tutorial/%E5%90%8E%E8%AE%B0/" title="后记"><span class="hidden-mobile">后记</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>