<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/icon/mikuicon.jpg"><link rel="icon" href="/images/icon/mikuicon.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="ZPC-dsg"><meta name="keywords" content=""><meta name="description" content="前言 从这篇起，我将开始Vulkan官方示例集中光线追踪部分的学习。官方示例集中提供了五个示例供Vulkan光追的学习，本文将重点分析第一个最为简单的示例。 如果有读者对光线追踪的原理不是很了解，可以参考games101中关于光追的部分，可以说是解释得十分清晰详细了。另外，大名鼎鼎的ray tracing in one weekend也是学习光追实现的好材料。本文非必要将不会涉及太多光追的原理"><meta property="og:type" content="article"><meta property="og:title" content="Ray tracing basic"><meta property="og:url" content="http://example.com/2025/02/27/CG_api/vulkan/vulkan_samples/ray_tracing_basic/index.html"><meta property="og:site_name" content="ZPC の Blog"><meta property="og:description" content="前言 从这篇起，我将开始Vulkan官方示例集中光线追踪部分的学习。官方示例集中提供了五个示例供Vulkan光追的学习，本文将重点分析第一个最为简单的示例。 如果有读者对光线追踪的原理不是很了解，可以参考games101中关于光追的部分，可以说是解释得十分清晰详细了。另外，大名鼎鼎的ray tracing in one weekend也是学习光追实现的好材料。本文非必要将不会涉及太多光追的原理"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/images/textbg/CG_api/vk_sample_rtbasic.jpg"><meta property="article:published_time" content="2025-02-27T12:54:46.000Z"><meta property="article:modified_time" content="2025-03-01T10:55:19.324Z"><meta property="article:author" content="ZPC-dsg"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/images/textbg/CG_api/vk_sample_rtbasic.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>Ray tracing basic - ZPC の Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:"measurement_id:G-X8N3TZCB57",tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>ZPC の Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/images/textbg/CG_api/vk_sample_rtbasic.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Ray tracing basic"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> ZPC-dsg </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-02-27 20:54" pubdate>2025年2月27日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 10k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 87 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">Ray tracing basic</h1><div class="markdown-body"><h2 id="前言">前言</h2><p>从这篇起，我将开始Vulkan官方示例集中光线追踪部分的学习。官方示例集中提供了五个示例供Vulkan光追的学习，本文将重点分析第一个最为简单的示例。</p><p>如果有读者对光线追踪的原理不是很了解，可以参考<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1X7411F744?spm_id_from=333.788.videopod.episodes&amp;vd_source=96b763f75b621baa119e5118b6164aee&amp;p=13"><code>games101</code></a>中关于光追的部分，可以说是解释得十分清晰详细了。另外，大名鼎鼎的<a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html"><code>ray tracing in one weekend</code></a>也是学习光追实现的好材料。本文非必要将不会涉及太多光追的原理，而是着重于Vulkan中光追的实现。关于Vulkan中的光追如何实现以及相关API使用的具体规范，可以参考<a target="_blank" rel="noopener" href="https://docs.vulkan.org/guide/latest/extensions/ray_tracing.html"><code>官方文档</code></a>或者<a target="_blank" rel="noopener" href="https://www.khronos.org/blog/ray-tracing-in-vulkan"><code>Khronos Group发表的文章</code></a>。</p><p>那下面就让我们推开Vulkan光追的大门一探究竟吧~</p><hr><h2 id="效果">效果</h2><p><strong>ray_tracing_basic</strong>示例仅绘制了一个再普通不过的三角形，和直接使用光栅化绘制出的三角形并无二致，这里放上程序运行的结果：</p><figure><img src="/2025/02/27/CG_api/vulkan/vulkan_samples/ray_tracing_basic/triangle.png" srcset="/img/loading.gif" lazyload alt="光追三角形"><figcaption aria-hidden="true">光追三角形</figcaption></figure><hr><h2 id="特性拓展">特性拓展</h2><p>首先还是来看一下使用基本的光线追踪需要开启的拓展：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++">RaytracingBasic::<span class="hljs-built_in">RaytracingBasic</span>()<br>&#123;<br>	title = <span class="hljs-string">&quot;Hardware accelerated ray tracing&quot;</span>;<br><br>	<span class="hljs-comment">// SPIRV 1.4 requires Vulkan 1.1</span><br>	<span class="hljs-built_in">set_api_version</span>(VK_API_VERSION_1_1);<br><br>	<span class="hljs-comment">// Ray tracing related extensions required by this sample</span><br>	<span class="hljs-built_in">add_device_extension</span>(VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME);<br>	<span class="hljs-built_in">add_device_extension</span>(VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME);<br><br>	<span class="hljs-comment">// Required by VK_KHR_acceleration_structure</span><br>	<span class="hljs-built_in">add_device_extension</span>(VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME);<br>	<span class="hljs-built_in">add_device_extension</span>(VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME);<br>	<span class="hljs-built_in">add_device_extension</span>(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME);<br><br>	<span class="hljs-comment">// Required for VK_KHR_ray_tracing_pipeline</span><br>	<span class="hljs-built_in">add_device_extension</span>(VK_KHR_SPIRV_1_4_EXTENSION_NAME);<br><br>	<span class="hljs-comment">// Required by VK_KHR_spirv_1_4</span><br>	<span class="hljs-built_in">add_device_extension</span>(VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME);<br>&#125;<br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::request_gpu_features</span><span class="hljs-params">(vkb::PhysicalDevice &amp;gpu)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// Enable extension features required by this sample</span><br>	<span class="hljs-comment">// These are passed to device creation via a pNext structure chain</span><br>	<span class="hljs-built_in">REQUEST_REQUIRED_FEATURE</span>(gpu,<br>	                         VkPhysicalDeviceBufferDeviceAddressFeatures,<br>	                         VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,<br>	                         bufferDeviceAddress);<br><br>	<span class="hljs-built_in">REQUEST_REQUIRED_FEATURE</span>(gpu,<br>	                         VkPhysicalDeviceRayTracingPipelineFeaturesKHR,<br>	                         VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,<br>	                         rayTracingPipeline);<br><br>	<span class="hljs-built_in">REQUEST_REQUIRED_FEATURE</span>(gpu,<br>	                         VkPhysicalDeviceAccelerationStructureFeaturesKHR,<br>	                         VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,<br>	                         accelerationStructure);<br>&#125;<br></code></pre></td></tr></table></figure><p>本例中需要和光线追踪管线、加速结构构建以及缓冲区设备地址有关的拓展特性。（是必须的，所以没有像之前的mdi那个示例一样使用几个布尔成员记录特性是否支持，不支持就使用fallback。）</p><hr><h2 id="准备阶段">准备阶段</h2><p>准备函数<i><font color="Green">prepare</font></i>的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">RaytracingBasic::prepare</span><span class="hljs-params">(<span class="hljs-type">const</span> vkb::ApplicationOptions &amp;options)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (!ApiVulkanSample::<span class="hljs-built_in">prepare</span>(options))<br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// This sample copies the ray traced output to the swap chain image, so we need to enable the required image usage flags</span><br>	<span class="hljs-type">const</span> std::set&lt;VkImageUsageFlagBits&gt; image_usage_flags = &#123;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_TRANSFER_DST_BIT&#125;;<br>	<span class="hljs-built_in">update_swapchain_image_usage_flags</span>(image_usage_flags);<br><br>	<span class="hljs-comment">// This sample renders the UI overlay on top of the ray tracing output, so we need to disable color attachment clears</span><br>	<span class="hljs-built_in">update_render_pass_flags</span>(RenderPassCreateFlags::ColorAttachmentLoad);<br><br>	<span class="hljs-comment">// Get the ray tracing pipeline properties, which we&#x27;ll need later on in the sample</span><br>	ray_tracing_pipeline_properties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR;<br>	VkPhysicalDeviceProperties2 device_properties&#123;&#125;;<br>	device_properties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;<br>	device_properties.pNext = &amp;ray_tracing_pipeline_properties;<br>	<span class="hljs-built_in">vkGetPhysicalDeviceProperties2</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_handle</span>(), &amp;device_properties);<br><br>	<span class="hljs-comment">// Get the acceleration structure features, which we&#x27;ll need later on in the sample</span><br>	acceleration_structure_features.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR;<br>	VkPhysicalDeviceFeatures2 device_features&#123;&#125;;<br>	device_features.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;<br>	device_features.pNext = &amp;acceleration_structure_features;<br>	<span class="hljs-built_in">vkGetPhysicalDeviceFeatures2</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_gpu</span>().<span class="hljs-built_in">get_handle</span>(), &amp;device_features);<br><br>	camera.type = vkb::CameraType::LookAt;<br>	camera.<span class="hljs-built_in">set_perspective</span>(<span class="hljs-number">60.0f</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(width) / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(height), <span class="hljs-number">0.1f</span>, <span class="hljs-number">512.0f</span>);<br>	camera.<span class="hljs-built_in">set_rotation</span>(glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>));<br>	camera.<span class="hljs-built_in">set_translation</span>(glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-2.5f</span>));<br><br>	<span class="hljs-built_in">create_storage_image</span>();<br>	<span class="hljs-built_in">create_scene</span>();<br>	<span class="hljs-built_in">create_uniform_buffer</span>();<br>	<span class="hljs-built_in">create_ray_tracing_pipeline</span>();<br>	<span class="hljs-built_in">create_shader_binding_tables</span>();<br>	<span class="hljs-built_in">create_descriptor_sets</span>();<br>	<span class="hljs-built_in">build_command_buffers</span>();<br>	prepared = <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，交换链实际上是由应用程序类的基类构建好的，这就意味着事实上应用程序最初拥有的交换链是通用交换链，交换链图像仅可作为渲染目标使用（也就是枚举<i><font color="Red">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</font></i>对应的用途），但如果想要使用Vulkan光线追踪，一般是需要先将光线追踪生成的图像渲染到一张<strong>Storage image</strong>上，然后再将<strong>Storage image</strong>上的图像数据copy到交换链图像上去显示。因此，准备阶段开头首先需要更新交换链图像，将其同时设置为可以作为数据传输目标的图像（<i><font color="Red">VK_IMAGE_USAGE_TRANSFER_DST_BIT</font></i>），然后重建交换链以及相关资源。<i><font color="Green">update_swapchain_image_usage_flags</font></i>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ApiVulkanSample::update_swapchain_image_usage_flags</span><span class="hljs-params">(std::set&lt;VkImageUsageFlagBits&gt; image_usage_flags)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">update_swapchain</span>(image_usage_flags);<br>	<span class="hljs-built_in">create_swapchain_buffers</span>();<br>	<span class="hljs-built_in">setup_framebuffer</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个基类中的函数，这里不会具体分析它的代码逻辑，只需要知道它的功能就是负责根据新的渲染图像使用用途更新交换链，然后获取新的交换链图像句柄，并创建相应的图像视图保存在一个<code>SwapchainBuffer</code>结构体向量中，并且更新交换链图像相应的帧缓冲。</p><p>接下来，函数的注释行解释了为什么要更新渲染通道。这是因为基类创建的渲染通道默认是在执行通道之前会清除掉缓冲图像中的内容的，但是在本实例中我们需要在渲染通道开启之前将光追得到的图像复制到交换链图像上去，这就意味着渲染通道开始时我们不能清除已有的内容（不然光追就白做了。。。），而是要在光追得到的图像结果的基础上绘制UI界面。更新渲染通道代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ApiVulkanSample::update_render_pass_flags</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">vkDestroyRenderPass</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), render_pass, <span class="hljs-literal">nullptr</span>);<br><br>	VkAttachmentLoadOp  color_attachment_load_op      = VK_ATTACHMENT_LOAD_OP_CLEAR;<br>	VkAttachmentStoreOp color_attachment_store_op     = VK_ATTACHMENT_STORE_OP_STORE;<br>	VkImageLayout       color_attachment_image_layout = VK_IMAGE_LAYOUT_UNDEFINED;<br><br>	<span class="hljs-comment">// Samples can keep the color attachment contents, e.g. if they have previously written to the swap chain images</span><br>	<span class="hljs-keyword">if</span> (flags &amp; RenderPassCreateFlags::ColorAttachmentLoad)<br>	&#123;<br>		color_attachment_load_op      = VK_ATTACHMENT_LOAD_OP_LOAD;<br>		color_attachment_image_layout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;<br>	&#125;<br><br>	std::array&lt;VkAttachmentDescription, 2&gt; attachments = &#123;&#125;;<br>	<span class="hljs-comment">// Color attachment</span><br>	attachments[<span class="hljs-number">0</span>].format         = <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_format</span>();<br>	attachments[<span class="hljs-number">0</span>].samples        = VK_SAMPLE_COUNT_1_BIT;<br>	attachments[<span class="hljs-number">0</span>].loadOp         = color_attachment_load_op;<br>	attachments[<span class="hljs-number">0</span>].storeOp        = color_attachment_store_op;<br>	attachments[<span class="hljs-number">0</span>].stencilLoadOp  = VK_ATTACHMENT_LOAD_OP_DONT_CARE;<br>	attachments[<span class="hljs-number">0</span>].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>	attachments[<span class="hljs-number">0</span>].initialLayout  = color_attachment_image_layout;<br>	attachments[<span class="hljs-number">0</span>].finalLayout    = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;<br>	<span class="hljs-comment">// Depth attachment</span><br>	attachments[<span class="hljs-number">1</span>].format         = depth_format;<br>	attachments[<span class="hljs-number">1</span>].samples        = VK_SAMPLE_COUNT_1_BIT;<br>	attachments[<span class="hljs-number">1</span>].loadOp         = VK_ATTACHMENT_LOAD_OP_CLEAR;<br>	attachments[<span class="hljs-number">1</span>].storeOp        = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>	attachments[<span class="hljs-number">1</span>].stencilLoadOp  = VK_ATTACHMENT_LOAD_OP_CLEAR;<br>	attachments[<span class="hljs-number">1</span>].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;<br>	attachments[<span class="hljs-number">1</span>].initialLayout  = VK_IMAGE_LAYOUT_UNDEFINED;<br>	attachments[<span class="hljs-number">1</span>].finalLayout    = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;<br><br>	VkAttachmentReference color_reference = &#123;&#125;;<br>	color_reference.attachment            = <span class="hljs-number">0</span>;<br>	color_reference.layout                = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;<br><br>	VkAttachmentReference depth_reference = &#123;&#125;;<br>	depth_reference.attachment            = <span class="hljs-number">1</span>;<br>	depth_reference.layout                = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;<br><br>	VkSubpassDescription subpass_description    = &#123;&#125;;<br>	subpass_description.pipelineBindPoint       = VK_PIPELINE_BIND_POINT_GRAPHICS;<br>	subpass_description.colorAttachmentCount    = <span class="hljs-number">1</span>;<br>	subpass_description.pColorAttachments       = &amp;color_reference;<br>	subpass_description.pDepthStencilAttachment = &amp;depth_reference;<br>	subpass_description.inputAttachmentCount    = <span class="hljs-number">0</span>;<br>	subpass_description.pInputAttachments       = <span class="hljs-literal">nullptr</span>;<br>	subpass_description.preserveAttachmentCount = <span class="hljs-number">0</span>;<br>	subpass_description.pPreserveAttachments    = <span class="hljs-literal">nullptr</span>;<br>	subpass_description.pResolveAttachments     = <span class="hljs-literal">nullptr</span>;<br><br>	<span class="hljs-comment">// Subpass dependencies for layout transitions</span><br>	std::array&lt;VkSubpassDependency, 2&gt; dependencies&#123;&#125;;<br><br>	dependencies[<span class="hljs-number">0</span>].srcSubpass      = VK_SUBPASS_EXTERNAL;<br>	dependencies[<span class="hljs-number">0</span>].dstSubpass      = <span class="hljs-number">0</span>;<br>	dependencies[<span class="hljs-number">0</span>].srcStageMask    = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;<br>	dependencies[<span class="hljs-number">0</span>].dstStageMask    = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT;<br>	dependencies[<span class="hljs-number">0</span>].srcAccessMask   = VK_ACCESS_NONE_KHR;<br>	dependencies[<span class="hljs-number">0</span>].dstAccessMask   = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;<br>	dependencies[<span class="hljs-number">0</span>].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;<br><br>	dependencies[<span class="hljs-number">1</span>].srcSubpass      = <span class="hljs-number">0</span>;<br>	dependencies[<span class="hljs-number">1</span>].dstSubpass      = VK_SUBPASS_EXTERNAL;<br>	dependencies[<span class="hljs-number">1</span>].srcStageMask    = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT;<br>	dependencies[<span class="hljs-number">1</span>].dstStageMask    = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;<br>	dependencies[<span class="hljs-number">1</span>].srcAccessMask   = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;<br>	dependencies[<span class="hljs-number">1</span>].dstAccessMask   = VK_ACCESS_MEMORY_READ_BIT;<br>	dependencies[<span class="hljs-number">1</span>].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;<br><br>	VkRenderPassCreateInfo render_pass_create_info = &#123;&#125;;<br>	render_pass_create_info.sType                  = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;<br>	render_pass_create_info.attachmentCount        = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(attachments.<span class="hljs-built_in">size</span>());<br>	render_pass_create_info.pAttachments           = attachments.<span class="hljs-built_in">data</span>();<br>	render_pass_create_info.subpassCount           = <span class="hljs-number">1</span>;<br>	render_pass_create_info.pSubpasses             = &amp;subpass_description;<br>	render_pass_create_info.dependencyCount        = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(dependencies.<span class="hljs-built_in">size</span>());<br>	render_pass_create_info.pDependencies          = dependencies.<span class="hljs-built_in">data</span>();<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateRenderPass</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;render_pass_create_info, <span class="hljs-literal">nullptr</span>, &amp;render_pass));<br>&#125;<br></code></pre></td></tr></table></figure><p>这也是一个基类的函数，其中渲染通道的创建逻辑十分常规，在<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/15/CG_api/vulkan/vulkan_tutorial/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/"><code>我之前的文章</code></a>中已经详细地梳理过这部分内容，这里不再赘述。</p><p>接下来代码获取了光追管线和加速结构的硬件特性，这在之后创建管线和加速结构的时候会用到，到那部分内容的时候我们再讲。</p><p>在设置好摄像机类型和参数后，下面就来逐一分析一连串函数调用中各自的逻辑吧：</p><h3 id="create_storage_image">create_storage_image</h3><p>先上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Set up a storage image that the ray generation shader will be writing to</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::create_storage_image</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	storage_image.width  = width;<br>	storage_image.height = height;<br><br>	VkImageCreateInfo image = vkb::initializers::<span class="hljs-built_in">image_create_info</span>();<br>	image.imageType         = VK_IMAGE_TYPE_2D;<br>	image.format            = VK_FORMAT_B8G8R8A8_UNORM;<br>	image.extent.width      = storage_image.width;<br>	image.extent.height     = storage_image.height;<br>	image.extent.depth      = <span class="hljs-number">1</span>;<br>	image.mipLevels         = <span class="hljs-number">1</span>;<br>	image.arrayLayers       = <span class="hljs-number">1</span>;<br>	image.samples           = VK_SAMPLE_COUNT_1_BIT;<br>	image.tiling            = VK_IMAGE_TILING_OPTIMAL;<br>	image.usage             = VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_STORAGE_BIT;<br>	image.initialLayout     = VK_IMAGE_LAYOUT_UNDEFINED;<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateImage</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;image, <span class="hljs-literal">nullptr</span>, &amp;storage_image.image));<br><br>	VkMemoryRequirements memory_requirements;<br>	<span class="hljs-built_in">vkGetImageMemoryRequirements</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), storage_image.image, &amp;memory_requirements);<br>	VkMemoryAllocateInfo memory_allocate_info = vkb::initializers::<span class="hljs-built_in">memory_allocate_info</span>();<br>	memory_allocate_info.allocationSize       = memory_requirements.size;<br>	memory_allocate_info.memoryTypeIndex      = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_memory_type</span>(memory_requirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateMemory</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;memory_allocate_info, <span class="hljs-literal">nullptr</span>, &amp;storage_image.memory));<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBindImageMemory</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), storage_image.image, storage_image.memory, <span class="hljs-number">0</span>));<br><br>	VkImageViewCreateInfo color_image_view           = vkb::initializers::<span class="hljs-built_in">image_view_create_info</span>();<br>	color_image_view.viewType                        = VK_IMAGE_VIEW_TYPE_2D;<br>	color_image_view.format                          = VK_FORMAT_B8G8R8A8_UNORM;<br>	color_image_view.subresourceRange                = &#123;&#125;;<br>	color_image_view.subresourceRange.aspectMask     = VK_IMAGE_ASPECT_COLOR_BIT;<br>	color_image_view.subresourceRange.baseMipLevel   = <span class="hljs-number">0</span>;<br>	color_image_view.subresourceRange.levelCount     = <span class="hljs-number">1</span>;<br>	color_image_view.subresourceRange.baseArrayLayer = <span class="hljs-number">0</span>;<br>	color_image_view.subresourceRange.layerCount     = <span class="hljs-number">1</span>;<br>	color_image_view.image                           = storage_image.image;<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateImageView</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;color_image_view, <span class="hljs-literal">nullptr</span>, &amp;storage_image.view));<br><br>	VkCommandBuffer command_buffer = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">create_command_buffer</span>(VK_COMMAND_BUFFER_LEVEL_PRIMARY, <span class="hljs-literal">true</span>);<br>	vkb::<span class="hljs-built_in">image_layout_transition</span>(command_buffer,<br>	                             storage_image.image,<br>	                             VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,<br>	                             VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,<br>	                             &#123;&#125;,<br>	                             &#123;&#125;,<br>	                             VK_IMAGE_LAYOUT_UNDEFINED,<br>	                             VK_IMAGE_LAYOUT_GENERAL,<br>	                             &#123;VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<br>	<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">flush_command_buffer</span>(command_buffer, queue);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用就是创建一张用于存储光追渲染结果的Storage buffer。其中应用程序类是自定义了一个<code>StorageImage</code>的结构体来存储相关的所有资源以及图像参数等信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StorageImage</span><br>&#123;<br>	VkDeviceMemory memory;<br>	VkImage        image = VK_NULL_HANDLE;<br>	VkImageView    view;<br>	VkFormat       format;<br>	<span class="hljs-type">uint32_t</span>       width;<br>	<span class="hljs-type">uint32_t</span>       height;<br>&#125; storage_image;<br></code></pre></td></tr></table></figure><p>具体的创建逻辑无需细说，在<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/12/12/CG_api/vulkan/vulkan_tutorial/%E5%9B%BE%E5%83%8F/"><code>我之前的文章</code></a>中也有十分详细的介绍。这里需要注意的是在填写图像创建信息的时候图像的用途应该填写为<i><font color="Red">VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_STORAGE_BIT</font></i>，因为在作为Storage image存储光追结果之余，它还需要作为数据传输源将图像数据复制到缓冲区图像中去。在函数的最后，为了能够使用该图像作为光追结果的写入目标，我们还需要提前转换图像布局。注意这里我们应该将其布局转换为<i><font color="Red">VK_IMAGE_LAYOUT_GENERAL</font></i>，因为光追着色器通常会对图像进行频繁的复杂读写操作，<i><font color="Red">VK_IMAGE_LAYOUT_GENERAL</font></i>是唯一适配这种复杂读写模式的布局。</p><h3 id="create_scene">create_scene</h3><p>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::create_scene</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">create_bottom_level_acceleration_structure</span>();<br>	<span class="hljs-built_in">create_top_level_acceleration_structure</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这个函数是调用了两个工具函数来完成的，这两个函数分别构建好了场景的底层加速结构和顶层加速结构。在构建光追加速结构的时候我们通常需要构建这两种结构，其中底层加速结构用于存储场景中实际的几何体信息，包括三角形或AABB信息；顶层结构体则存储对底层结构体的引用，并且管理底层加速结构的实例化。不过不管是构建哪种加速结构，基本的构建思路是一样的;</p><ul><li>首先根据加速结构的类型、几何体的类型数量等信息填写<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildGeometryInfoKHR.html"><code>VkAccelerationStructureBuildGeometryInfoKHR</code></a>信息结构体，此时填写这个结构体并不是为了创建加速结构，而是为了查询需要创建的加速结构的大小。</li><li>使用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureBuildSizesKHR.html"><code>vkGetAccelerationStructureBuildSizesKHR</code></a>得到需要构建的加速结构的大小以及构建过程中需要的<strong>scratch buffer</strong>的大小（大小信息存储在<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildSizesInfoKHR.html"><code>VkAccelerationStructureBuildSizesInfoKHR</code></a>中）。</li><li>分配足够大小的缓冲区用于存储将要创建的加速结构以及构建过程会用到的<strong>scratch buffer</strong>。</li><li>调用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateAccelerationStructureKHR.html"><code>vkCreateAccelerationStructureKHR</code></a>在缓冲区内的指定位置创建加速结构对象。</li><li>调用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildAccelerationStructuresKHR.html"><code>vkCmdBuildAccelerationStructuresKHR</code></a>来在GPU中真正构建加速结构。</li></ul><p>我们下面来分别详细分析这两个加速结构的构建过程：</p><h4 id="create_bottom_level_acceleration_structure">create_bottom_level_acceleration_structure</h4><p>函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Create the bottom level acceleration structure that contains the scene&#x27;s geometry (triangles)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::create_bottom_level_acceleration_structure</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// Setup vertices and indices for a single triangle</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vertex</span><br>	&#123;<br>		<span class="hljs-type">float</span> pos[<span class="hljs-number">3</span>];<br>	&#125;;<br>	std::vector&lt;Vertex&gt; vertices = &#123;<br>	    &#123;&#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>	    &#123;&#123;<span class="hljs-number">-1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;,<br>	    &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">-1.0f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;&#125;;<br>	std::vector&lt;<span class="hljs-type">uint32_t</span>&gt; indices = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><br>	<span class="hljs-keyword">auto</span> vertex_buffer_size = vertices.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(Vertex);<br>	<span class="hljs-keyword">auto</span> index_buffer_size  = indices.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>);<br><br>	<span class="hljs-comment">// Create buffers for the bottom level geometry</span><br>	<span class="hljs-comment">// For the sake of simplicity we won&#x27;t stage the vertex data to the GPU memory</span><br><br>	<span class="hljs-comment">// Note that the buffer usage flags for buffers consumed by the bottom level acceleration structure require special flags</span><br>	<span class="hljs-type">const</span> VkBufferUsageFlags buffer_usage_flags = VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;<br><br>	vertex_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), vertex_buffer_size, buffer_usage_flags, VMA_MEMORY_USAGE_CPU_TO_GPU);<br>	vertex_buffer-&gt;<span class="hljs-built_in">update</span>(vertices.<span class="hljs-built_in">data</span>(), vertex_buffer_size);<br><br>	index_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), index_buffer_size, buffer_usage_flags, VMA_MEMORY_USAGE_CPU_TO_GPU);<br>	index_buffer-&gt;<span class="hljs-built_in">update</span>(indices.<span class="hljs-built_in">data</span>(), index_buffer_size);<br><br>	<span class="hljs-comment">// Setup a single transformation matrix that can be used to transform the whole geometry for a single bottom level acceleration structure</span><br>	VkTransformMatrixKHR transform_matrix = &#123;<br>	    <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>	    <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>	    <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;;<br>	std::unique_ptr&lt;vkb::core::BufferC&gt; transform_matrix_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), <span class="hljs-built_in">sizeof</span>(transform_matrix), buffer_usage_flags, VMA_MEMORY_USAGE_CPU_TO_GPU);<br>	transform_matrix_buffer-&gt;<span class="hljs-built_in">update</span>(&amp;transform_matrix, <span class="hljs-built_in">sizeof</span>(transform_matrix));<br><br>	VkDeviceOrHostAddressConstKHR vertex_data_device_address&#123;&#125;;<br>	VkDeviceOrHostAddressConstKHR index_data_device_address&#123;&#125;;<br>	VkDeviceOrHostAddressConstKHR transform_matrix_device_address&#123;&#125;;<br><br>	vertex_data_device_address.deviceAddress      = <span class="hljs-built_in">get_buffer_device_address</span>(vertex_buffer-&gt;<span class="hljs-built_in">get_handle</span>());<br>	index_data_device_address.deviceAddress       = <span class="hljs-built_in">get_buffer_device_address</span>(index_buffer-&gt;<span class="hljs-built_in">get_handle</span>());<br>	transform_matrix_device_address.deviceAddress = <span class="hljs-built_in">get_buffer_device_address</span>(transform_matrix_buffer-&gt;<span class="hljs-built_in">get_handle</span>());<br><br>	<span class="hljs-comment">// The bottom level acceleration structure contains one set of triangles as the input geometry</span><br>	VkAccelerationStructureGeometryKHR acceleration_structure_geometry&#123;&#125;;<br>	acceleration_structure_geometry.sType                            = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR;<br>	acceleration_structure_geometry.geometryType                     = VK_GEOMETRY_TYPE_TRIANGLES_KHR;<br>	acceleration_structure_geometry.flags                            = VK_GEOMETRY_OPAQUE_BIT_KHR;<br>	acceleration_structure_geometry.geometry.triangles.sType         = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR;<br>	acceleration_structure_geometry.geometry.triangles.vertexFormat  = VK_FORMAT_R32G32B32_SFLOAT;<br>	acceleration_structure_geometry.geometry.triangles.vertexData    = vertex_data_device_address;<br>	acceleration_structure_geometry.geometry.triangles.maxVertex     = <span class="hljs-number">3</span>;<br>	acceleration_structure_geometry.geometry.triangles.vertexStride  = <span class="hljs-built_in">sizeof</span>(Vertex);<br>	acceleration_structure_geometry.geometry.triangles.indexType     = VK_INDEX_TYPE_UINT32;<br>	acceleration_structure_geometry.geometry.triangles.indexData     = index_data_device_address;<br>	acceleration_structure_geometry.geometry.triangles.transformData = transform_matrix_device_address;<br><br>	<span class="hljs-comment">// Get the size requirements for buffers involved in the acceleration structure build process</span><br>	VkAccelerationStructureBuildGeometryInfoKHR acceleration_structure_build_geometry_info&#123;&#125;;<br>	acceleration_structure_build_geometry_info.sType         = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR;<br>	acceleration_structure_build_geometry_info.type          = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;<br>	acceleration_structure_build_geometry_info.flags         = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR;<br>	acceleration_structure_build_geometry_info.geometryCount = <span class="hljs-number">1</span>;<br>	acceleration_structure_build_geometry_info.pGeometries   = &amp;acceleration_structure_geometry;<br><br>	<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> primitive_count = <span class="hljs-number">1</span>;<br><br>	VkAccelerationStructureBuildSizesInfoKHR acceleration_structure_build_sizes_info&#123;&#125;;<br>	acceleration_structure_build_sizes_info.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR;<br>	<span class="hljs-built_in">vkGetAccelerationStructureBuildSizesKHR</span>(<br>	    <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(),<br>	    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,<br>	    &amp;acceleration_structure_build_geometry_info,<br>	    &amp;primitive_count,<br>	    &amp;acceleration_structure_build_sizes_info);<br><br>	<span class="hljs-comment">// Create a buffer to hold the acceleration structure</span><br>	bottom_level_acceleration_structure.buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<br>	    <span class="hljs-built_in">get_device</span>(),<br>	    acceleration_structure_build_sizes_info.accelerationStructureSize,<br>	    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,<br>	    VMA_MEMORY_USAGE_GPU_ONLY);<br><br>	<span class="hljs-comment">// Create the acceleration structure</span><br>	VkAccelerationStructureCreateInfoKHR acceleration_structure_create_info&#123;&#125;;<br>	acceleration_structure_create_info.sType  = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR;<br>	acceleration_structure_create_info.buffer = bottom_level_acceleration_structure.buffer-&gt;<span class="hljs-built_in">get_handle</span>();<br>	acceleration_structure_create_info.size   = acceleration_structure_build_sizes_info.accelerationStructureSize;<br>	acceleration_structure_create_info.type   = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;<br>	<span class="hljs-built_in">vkCreateAccelerationStructureKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;acceleration_structure_create_info, <span class="hljs-literal">nullptr</span>, &amp;bottom_level_acceleration_structure.handle);<br><br>	<span class="hljs-comment">// The actual build process starts here</span><br><br>	<span class="hljs-comment">// Create a scratch buffer as a temporary storage for the acceleration structure build</span><br>	ScratchBuffer scratch_buffer = <span class="hljs-built_in">create_scratch_buffer</span>(acceleration_structure_build_sizes_info.buildScratchSize);<br><br>	VkAccelerationStructureBuildGeometryInfoKHR acceleration_build_geometry_info&#123;&#125;;<br>	acceleration_build_geometry_info.sType                     = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR;<br>	acceleration_build_geometry_info.type                      = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;<br>	acceleration_build_geometry_info.flags                     = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR;<br>	acceleration_build_geometry_info.mode                      = VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR;<br>	acceleration_build_geometry_info.dstAccelerationStructure  = bottom_level_acceleration_structure.handle;<br>	acceleration_build_geometry_info.geometryCount             = <span class="hljs-number">1</span>;<br>	acceleration_build_geometry_info.pGeometries               = &amp;acceleration_structure_geometry;<br>	acceleration_build_geometry_info.scratchData.deviceAddress = scratch_buffer.device_address;<br><br>	VkAccelerationStructureBuildRangeInfoKHR acceleration_structure_build_range_info;<br>	acceleration_structure_build_range_info.primitiveCount                                           = <span class="hljs-number">1</span>;<br>	acceleration_structure_build_range_info.primitiveOffset                                          = <span class="hljs-number">0</span>;<br>	acceleration_structure_build_range_info.firstVertex                                              = <span class="hljs-number">0</span>;<br>	acceleration_structure_build_range_info.transformOffset                                          = <span class="hljs-number">0</span>;<br>	std::vector&lt;VkAccelerationStructureBuildRangeInfoKHR *&gt; acceleration_build_structure_range_infos = &#123;&amp;acceleration_structure_build_range_info&#125;;<br><br>	<span class="hljs-comment">// Build the acceleration structure on the device via a one-time command buffer submission</span><br>	<span class="hljs-comment">// Some implementations may support acceleration structure building on the host (VkPhysicalDeviceAccelerationStructureFeaturesKHR-&gt;accelerationStructureHostCommands), but we prefer device builds</span><br>	VkCommandBuffer command_buffer = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">create_command_buffer</span>(VK_COMMAND_BUFFER_LEVEL_PRIMARY, <span class="hljs-literal">true</span>);<br>	<span class="hljs-built_in">vkCmdBuildAccelerationStructuresKHR</span>(<br>	    command_buffer,<br>	    <span class="hljs-number">1</span>,<br>	    &amp;acceleration_build_geometry_info,<br>	    acceleration_build_structure_range_infos.<span class="hljs-built_in">data</span>());<br>	<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">flush_command_buffer</span>(command_buffer, queue);<br><br>	<span class="hljs-built_in">delete_scratch_buffer</span>(scratch_buffer);<br><br>	<span class="hljs-comment">// Get the bottom acceleration structure&#x27;s handle, which will be used during the top level acceleration build</span><br>	VkAccelerationStructureDeviceAddressInfoKHR acceleration_device_address_info&#123;&#125;;<br>	acceleration_device_address_info.sType                 = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR;<br>	acceleration_device_address_info.accelerationStructure = bottom_level_acceleration_structure.handle;<br>	bottom_level_acceleration_structure.device_address =<br>	    <span class="hljs-built_in">vkGetAccelerationStructureDeviceAddressKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;acceleration_device_address_info);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们选择的构建几何体是三角形。按照上文构建加速结构的大体流程，我们首先需要填写<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildGeometryInfoKHR.html"><code>VkAccelerationStructureBuildGeometryInfoKHR</code></a>信息结构体，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkAccelerationStructureBuildGeometryInfoKHR</span> &#123;</span><br>    VkStructureType                                     sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                         pNext;<br>    VkAccelerationStructureTypeKHR                      type;<br>    VkBuildAccelerationStructureFlagsKHR                flags;<br>    VkBuildAccelerationStructureModeKHR                 mode;<br>    VkAccelerationStructureKHR                          srcAccelerationStructure;<br>    VkAccelerationStructureKHR                          dstAccelerationStructure;<br>    <span class="hljs-type">uint32_t</span>                                            geometryCount;<br>    <span class="hljs-type">const</span> VkAccelerationStructureGeometryKHR*           pGeometries;<br>    <span class="hljs-type">const</span> VkAccelerationStructureGeometryKHR* <span class="hljs-type">const</span>*    ppGeometries;<br>    VkDeviceOrHostAddressKHR                            scratchData;<br>&#125; VkAccelerationStructureBuildGeometryInfoKHR;<br></code></pre></td></tr></table></figure><p>填写这个结构体当前的目的是为了得到加速结构和scratch buffer的大小信息，因此我们无需填写所有成员。在代码中，首先指定创建的加速结构是底层加速结构（<i><font color="Red">VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR</font></i>），然后指定标志位为<i><font color="Red">VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR</font></i>用于指示硬件优化构建加速结构过程的性能。本示例中的加速结构仅包含一个三角形，所以几何数设置为1，几何体信息设置为前文填写好的<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureGeometryKHR.html"><code>VkAccelerationStructureGeometryKHR</code></a>，下面来看这个结构体的填写过程。首先还是放上它的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkAccelerationStructureGeometryKHR</span> &#123;</span><br>    VkStructureType                           sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                               pNext;<br>    VkGeometryTypeKHR                         geometryType;<br>    VkAccelerationStructureGeometryDataKHR    geometry;<br>    VkGeometryFlagsKHR                        flags;<br>&#125; VkAccelerationStructureGeometryKHR;<br></code></pre></td></tr></table></figure><p>首先设置好几何体类型，我们希望的类型是三角形（<i><font color="Red">VK_GEOMETRY_TYPE_TRIANGLES_KHR</font></i>），可能的几何体类型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VkGeometryTypeKHR</span> &#123;</span><br>    VK_GEOMETRY_TYPE_TRIANGLES_KHR = <span class="hljs-number">0</span>,<br>    VK_GEOMETRY_TYPE_AABBS_KHR = <span class="hljs-number">1</span>,<br>    VK_GEOMETRY_TYPE_INSTANCES_KHR = <span class="hljs-number">2</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_ray_tracing_linear_swept_spheres</span><br>    VK_GEOMETRY_TYPE_SPHERES_NV = <span class="hljs-number">1000429004</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_ray_tracing_linear_swept_spheres</span><br>    VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV = <span class="hljs-number">1000429005</span>,<br>  <span class="hljs-comment">// Provided by VK_NV_ray_tracing</span><br>    VK_GEOMETRY_TYPE_TRIANGLES_NV = VK_GEOMETRY_TYPE_TRIANGLES_KHR,<br>  <span class="hljs-comment">// Provided by VK_NV_ray_tracing</span><br>    VK_GEOMETRY_TYPE_AABBS_NV = VK_GEOMETRY_TYPE_AABBS_KHR,<br>&#125; VkGeometryTypeKHR;<br></code></pre></td></tr></table></figure><p>然后指定标志位为<i><font color="Red">VK_GEOMETRY_OPAQUE_BIT_KHR</font></i>，官方解释为这么设置就意味着该几何体即使与光线相交也不会触发任何<strong>any-hit shader</strong>的调用（<strong>any-hit shader</strong>常用于进行alpha测试有关的操作）。接下来就需要指定真正的几何体数据信息了，这是通过<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureGeometryDataKHR.html"><code>VkAccelerationStructureGeometryDataKHR</code></a>来指定的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">VkAccelerationStructureGeometryDataKHR</span> &#123;</span><br>    VkAccelerationStructureGeometryTrianglesDataKHR    triangles;<br>    VkAccelerationStructureGeometryAabbsDataKHR        aabbs;<br>    VkAccelerationStructureGeometryInstancesDataKHR    instances;<br>&#125; VkAccelerationStructureGeometryDataKHR;<br></code></pre></td></tr></table></figure><p>由于我们的几何体是三角形，所以这里只需填写<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureGeometryTrianglesDataKHR.html"><code>VkAccelerationStructureGeometryTrianglesDataKHR</code></a>结构体即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkAccelerationStructureGeometryTrianglesDataKHR</span> &#123;</span><br>    VkStructureType                  sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                      pNext;<br>    VkFormat                         vertexFormat;<br>    VkDeviceOrHostAddressConstKHR    vertexData;<br>    VkDeviceSize                     vertexStride;<br>    <span class="hljs-type">uint32_t</span>                         maxVertex;<br>    VkIndexType                      indexType;<br>    VkDeviceOrHostAddressConstKHR    indexData;<br>    VkDeviceOrHostAddressConstKHR    transformData;<br>&#125; VkAccelerationStructureGeometryTrianglesDataKHR;<br></code></pre></td></tr></table></figure><p>首先是指定顶点格式，顶点信息中只包含一个三维的位置向量，所以格式指定为<i><font color="Red">VK_FORMAT_R32G32B32_SFLOAT</font></i>。然后指定顶点数据缓冲所在的设备地址，这可以在创建好缓冲区之后通过<code>vkGetBufferDeviceAddressKHR</code>得到，在之前的mdi示例分析中已经有十分详细的介绍了，不过需要注意的是在创建这个顶点缓冲区时需要额外指定用途为<i><font color="Red">VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR</font></i>（包括索引和变换缓冲区也是）。<i><font color="Orange">maxVertex</font></i>官方文档中指定的是顶点缓冲中存储的顶点数减1，那按理来讲代码中应该填写为2才对，为什么这里填的是3呢？我试了下把这个地方改为2，结果仍然是正确的，那只能理解为这个值指定为比最大定点数减1要更大的数对结果都是没有影响的了（瞎猜的，还望大佬指点）。接下来的<i><font color="Orange">vertexStride</font></i>用于指定顶点之间的字节数，也就是一个顶点数据的大小。然后还需要指定相应的索引数据，包括索引类型以及索引缓冲的设备地址。最后还可以额外指定一个变换信息，用于对指定的几何体顶点位置进行一个调整，示例代码选择将这部分设置为单位矩阵，也就是无需调整（这里的变换矩阵同样需要上传到缓冲区中，然后通过设备地址访问）。</p><p>然后就可以查询加速结构以及scratch buffer所需大小了。<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureBuildSizesKHR.html"><code>vkGetAccelerationStructureBuildSizesKHR</code></a>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkGetAccelerationStructureBuildSizesKHR</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDevice                                    device,</span><br><span class="hljs-params">    VkAccelerationStructureBuildTypeKHR         buildType,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*                             pMaxPrimitiveCounts,</span><br><span class="hljs-params">    VkAccelerationStructureBuildSizesInfoKHR*   pSizeInfo)</span>;<br></code></pre></td></tr></table></figure><p>该函数调用会填写好<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildSizesInfoKHR.html"><code>VkAccelerationStructureBuildSizesInfoKHR</code></a>中的大小信息。接下来我们就可以根据这个大小信息创建加速结构缓冲区和scratch buffer了。在创建加速结构缓冲区时唯一需要注意的是缓冲区的用途被设置为<i><font color="Red">VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</font></i>。然后就可以创建加速结构对象了，这只需要指定加速结构的类型、存储缓冲区以及其大小，然后调用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateAccelerationStructureKHR.html"><code>vkCreateAccelerationStructureKHR</code></a>即可。scratch buffer则是通过应用程序类中的一个工具函数<i><font color="Green">create_scratch_buffer</font></i>来创建的，该函数定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Create buffer and allocate memory for a temporary scratch buffer</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">ScratchBuffer <span class="hljs-title">RaytracingBasic::create_scratch_buffer</span><span class="hljs-params">(VkDeviceSize size)</span></span><br><span class="hljs-function"></span>&#123;<br>	ScratchBuffer scratch_buffer&#123;&#125;;<br><br>	VkBufferCreateInfo buffer_create_info = &#123;&#125;;<br>	buffer_create_info.sType              = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;<br>	buffer_create_info.size               = size;<br>	buffer_create_info.usage              = VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateBuffer</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;buffer_create_info, <span class="hljs-literal">nullptr</span>, &amp;scratch_buffer.handle));<br><br>	VkMemoryRequirements memory_requirements = &#123;&#125;;<br>	<span class="hljs-built_in">vkGetBufferMemoryRequirements</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), scratch_buffer.handle, &amp;memory_requirements);<br><br>	VkMemoryAllocateFlagsInfo memory_allocate_flags_info = &#123;&#125;;<br>	memory_allocate_flags_info.sType                     = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;<br>	memory_allocate_flags_info.flags                     = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR;<br><br>	VkMemoryAllocateInfo memory_allocate_info = &#123;&#125;;<br>	memory_allocate_info.sType                = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;<br>	memory_allocate_info.pNext                = &amp;memory_allocate_flags_info;<br>	memory_allocate_info.allocationSize       = memory_requirements.size;<br>	memory_allocate_info.memoryTypeIndex      = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_memory_type</span>(memory_requirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateMemory</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;memory_allocate_info, <span class="hljs-literal">nullptr</span>, &amp;scratch_buffer.memory));<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBindBufferMemory</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), scratch_buffer.handle, scratch_buffer.memory, <span class="hljs-number">0</span>));<br><br>	VkBufferDeviceAddressInfoKHR buffer_device_address_info&#123;&#125;;<br>	buffer_device_address_info.sType  = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;<br>	buffer_device_address_info.buffer = scratch_buffer.handle;<br>	scratch_buffer.device_address     = <span class="hljs-built_in">vkGetBufferDeviceAddressKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;buffer_device_address_info);<br><br>	<span class="hljs-keyword">return</span> scratch_buffer;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数返回一个<code>ScratchBuffer</code>结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ScratchBuffer</span><br>&#123;<br>	<span class="hljs-type">uint64_t</span>       device_address;<br>	VkBuffer       handle;<br>	VkDeviceMemory memory;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该结构体简单地包含了缓冲区句柄、内存以及设备地址。</p><p><i><font color="Green">create_scratch_buffer</font></i>本身的缓冲区创建逻辑和一般的缓冲区创建逻辑并无二致，都是创建缓冲区对象，然后查询内存要求并且为该缓冲区对象分配合适的内存并绑定。这部分在<a target="_blank" rel="noopener" href="https://zpc-dsg.github.io/2024/11/27/CG_api/vulkan/vulkan_tutorial/%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2/"><code>我之前的文章</code></a>中已经有详细的描述了，这里不再赘述。</p><p>在创建好这两个对象之后，终于是可以真正地构建加速结构了。为此需要调用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildAccelerationStructuresKHR.html"><code>vkCmdBuildAccelerationStructuresKHR</code></a>，该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdBuildAccelerationStructuresKHR</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    infoCount,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkAccelerationStructureBuildGeometryInfoKHR* pInfos,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkAccelerationStructureBuildRangeInfoKHR* <span class="hljs-type">const</span>* ppBuildRangeInfos)</span>;<br></code></pre></td></tr></table></figure><p>首先指定需要构建多少个加速结构，这里我们当然只需要构建一个。然后需要填入<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildGeometryInfoKHR.html"><code>VkAccelerationStructureBuildGeometryInfoKHR</code></a>参数，还记得代码之前为了获取加速结构和scratch buffer的大小已经填写过这个结构体了吗？当时填写的信息是不完整的，这里我们还需要再填写一遍完整的结构体信息。代码额外指定了要对这个加速结构执行的操作（<i><font color="Red">VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR</font></i>，也就是构建操作）、前文创建好的加速结构的句柄以及构建加速结构所需的scratch buffer设备地址。最后一个参数是一个指向一个<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildRangeInfoKHR.html"><code>VkAccelerationStructureBuildRangeInfoKHR</code></a>结构体的指针的指针，<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildRangeInfoKHR.html"><code>VkAccelerationStructureBuildRangeInfoKHR</code></a>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkAccelerationStructureBuildRangeInfoKHR</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>    primitiveCount;<br>    <span class="hljs-type">uint32_t</span>    primitiveOffset;<br>    <span class="hljs-type">uint32_t</span>    firstVertex;<br>    <span class="hljs-type">uint32_t</span>    transformOffset;<br>&#125; VkAccelerationStructureBuildRangeInfoKHR;<br></code></pre></td></tr></table></figure><p>四个成员分别指定几何体数量、几何体数据在内存中的偏移（按字节）、第一个顶点对应的索引以及变换数据在内存中的偏移（按字节），这里我们绘制一个几何体，并且不需要任何偏移。</p><p>最后，只需启用一个command buffer提交构建命令即可。scratch buffer在完成加速结构的构建后就没有用了，所以代码在构建完毕后将其销毁。函数在结尾处还将构建好的底层加速结构的设备地址保存起来了，在之后构建顶层加速结构的时候会用到底层加速结构的设备地址。</p><h4 id="create_top_level_acceleration_structure">create_top_level_acceleration_structure</h4><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Create the top level acceleration structure containing geometry instances of the bottom level acceleration structure(s)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::create_top_level_acceleration_structure</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	VkTransformMatrixKHR transform_matrix = &#123;<br>	    <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>	    <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>	    <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>&#125;;<br><br>	VkAccelerationStructureInstanceKHR acceleration_structure_instance&#123;&#125;;<br>	acceleration_structure_instance.transform                              = transform_matrix;<br>	acceleration_structure_instance.instanceCustomIndex                    = <span class="hljs-number">0</span>;<br>	acceleration_structure_instance.mask                                   = <span class="hljs-number">0xFF</span>;<br>	acceleration_structure_instance.instanceShaderBindingTableRecordOffset = <span class="hljs-number">0</span>;<br>	acceleration_structure_instance.flags                                  = VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR;<br>	acceleration_structure_instance.accelerationStructureReference         = bottom_level_acceleration_structure.device_address;<br><br>	std::unique_ptr&lt;vkb::core::BufferC&gt; instances_buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(),<br>	                                                                                            <span class="hljs-built_in">sizeof</span>(VkAccelerationStructureInstanceKHR),<br>	                                                                                            VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,<br>	                                                                                            VMA_MEMORY_USAGE_CPU_TO_GPU);<br>	instances_buffer-&gt;<span class="hljs-built_in">update</span>(&amp;acceleration_structure_instance, <span class="hljs-built_in">sizeof</span>(VkAccelerationStructureInstanceKHR));<br><br>	VkDeviceOrHostAddressConstKHR instance_data_device_address&#123;&#125;;<br>	instance_data_device_address.deviceAddress = <span class="hljs-built_in">get_buffer_device_address</span>(instances_buffer-&gt;<span class="hljs-built_in">get_handle</span>());<br><br>	<span class="hljs-comment">// The top level acceleration structure contains (bottom level) instance as the input geometry</span><br>	VkAccelerationStructureGeometryKHR acceleration_structure_geometry&#123;&#125;;<br>	acceleration_structure_geometry.sType                              = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR;<br>	acceleration_structure_geometry.geometryType                       = VK_GEOMETRY_TYPE_INSTANCES_KHR;<br>	acceleration_structure_geometry.flags                              = VK_GEOMETRY_OPAQUE_BIT_KHR;<br>	acceleration_structure_geometry.geometry.instances.sType           = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR;<br>	acceleration_structure_geometry.geometry.instances.arrayOfPointers = VK_FALSE;<br>	acceleration_structure_geometry.geometry.instances.data            = instance_data_device_address;<br><br>	<span class="hljs-comment">// Get the size requirements for buffers involved in the acceleration structure build process</span><br>	VkAccelerationStructureBuildGeometryInfoKHR acceleration_structure_build_geometry_info&#123;&#125;;<br>	acceleration_structure_build_geometry_info.sType         = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR;<br>	acceleration_structure_build_geometry_info.type          = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR;<br>	acceleration_structure_build_geometry_info.flags         = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR;<br>	acceleration_structure_build_geometry_info.geometryCount = <span class="hljs-number">1</span>;<br>	acceleration_structure_build_geometry_info.pGeometries   = &amp;acceleration_structure_geometry;<br><br>	<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> primitive_count = <span class="hljs-number">1</span>;<br><br>	VkAccelerationStructureBuildSizesInfoKHR acceleration_structure_build_sizes_info&#123;&#125;;<br>	acceleration_structure_build_sizes_info.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR;<br>	<span class="hljs-built_in">vkGetAccelerationStructureBuildSizesKHR</span>(<br>	    <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,<br>	    &amp;acceleration_structure_build_geometry_info,<br>	    &amp;primitive_count,<br>	    &amp;acceleration_structure_build_sizes_info);<br><br>	<span class="hljs-comment">// Create a buffer to hold the acceleration structure</span><br>	top_level_acceleration_structure.buffer = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<br>	    <span class="hljs-built_in">get_device</span>(),<br>	    acceleration_structure_build_sizes_info.accelerationStructureSize,<br>	    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,<br>	    VMA_MEMORY_USAGE_GPU_ONLY);<br><br>	<span class="hljs-comment">// Create the acceleration structure</span><br>	VkAccelerationStructureCreateInfoKHR acceleration_structure_create_info&#123;&#125;;<br>	acceleration_structure_create_info.sType  = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR;<br>	acceleration_structure_create_info.buffer = top_level_acceleration_structure.buffer-&gt;<span class="hljs-built_in">get_handle</span>();<br>	acceleration_structure_create_info.size   = acceleration_structure_build_sizes_info.accelerationStructureSize;<br>	acceleration_structure_create_info.type   = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR;<br>	<span class="hljs-built_in">vkCreateAccelerationStructureKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;acceleration_structure_create_info, <span class="hljs-literal">nullptr</span>, &amp;top_level_acceleration_structure.handle);<br><br>	<span class="hljs-comment">// The actual build process starts here</span><br><br>	<span class="hljs-comment">// Create a scratch buffer as a temporary storage for the acceleration structure build</span><br>	ScratchBuffer scratch_buffer = <span class="hljs-built_in">create_scratch_buffer</span>(acceleration_structure_build_sizes_info.buildScratchSize);<br><br>	VkAccelerationStructureBuildGeometryInfoKHR acceleration_build_geometry_info&#123;&#125;;<br>	acceleration_build_geometry_info.sType                     = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR;<br>	acceleration_build_geometry_info.type                      = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR;<br>	acceleration_build_geometry_info.flags                     = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR;<br>	acceleration_build_geometry_info.mode                      = VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR;<br>	acceleration_build_geometry_info.dstAccelerationStructure  = top_level_acceleration_structure.handle;<br>	acceleration_build_geometry_info.geometryCount             = <span class="hljs-number">1</span>;<br>	acceleration_build_geometry_info.pGeometries               = &amp;acceleration_structure_geometry;<br>	acceleration_build_geometry_info.scratchData.deviceAddress = scratch_buffer.device_address;<br><br>	VkAccelerationStructureBuildRangeInfoKHR acceleration_structure_build_range_info;<br>	acceleration_structure_build_range_info.primitiveCount                                           = <span class="hljs-number">1</span>;<br>	acceleration_structure_build_range_info.primitiveOffset                                          = <span class="hljs-number">0</span>;<br>	acceleration_structure_build_range_info.firstVertex                                              = <span class="hljs-number">0</span>;<br>	acceleration_structure_build_range_info.transformOffset                                          = <span class="hljs-number">0</span>;<br>	std::vector&lt;VkAccelerationStructureBuildRangeInfoKHR *&gt; acceleration_build_structure_range_infos = &#123;&amp;acceleration_structure_build_range_info&#125;;<br><br>	<span class="hljs-comment">// Build the acceleration structure on the device via a one-time command buffer submission</span><br>	<span class="hljs-comment">// Some implementations may support acceleration structure building on the host (VkPhysicalDeviceAccelerationStructureFeaturesKHR-&gt;accelerationStructureHostCommands), but we prefer device builds</span><br>	VkCommandBuffer command_buffer = <span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">create_command_buffer</span>(VK_COMMAND_BUFFER_LEVEL_PRIMARY, <span class="hljs-literal">true</span>);<br>	<span class="hljs-built_in">vkCmdBuildAccelerationStructuresKHR</span>(<br>	    command_buffer,<br>	    <span class="hljs-number">1</span>,<br>	    &amp;acceleration_build_geometry_info,<br>	    acceleration_build_structure_range_infos.<span class="hljs-built_in">data</span>());<br>	<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">flush_command_buffer</span>(command_buffer, queue);<br><br>	<span class="hljs-built_in">delete_scratch_buffer</span>(scratch_buffer);<br><br>	<span class="hljs-comment">// Get the top acceleration structure&#x27;s handle, which will be used to setup it&#x27;s descriptor</span><br>	VkAccelerationStructureDeviceAddressInfoKHR acceleration_device_address_info&#123;&#125;;<br>	acceleration_device_address_info.sType                 = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR;<br>	acceleration_device_address_info.accelerationStructure = top_level_acceleration_structure.handle;<br>	top_level_acceleration_structure.device_address =<br>	    <span class="hljs-built_in">vkGetAccelerationStructureDeviceAddressKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;acceleration_device_address_info);<br>&#125;<br></code></pre></td></tr></table></figure><p>创建顶层加速结构的过程和底层加速结构大同小异，不过在创建细节上二者还是有一些出入。首先注意到顶层加速结构指定的几何体类型为<i><font color="Red">VK_GEOMETRY_TYPE_INSTANCES_KHR</font></i>，因此在填写顶层加速结构的<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureGeometryKHR.html"><code>VkAccelerationStructureGeometryKHR</code></a>的时候就需要填写<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureGeometryInstancesDataKHR.html"><code>VkAccelerationStructureGeometryInstancesDataKHR</code></a>信息结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkAccelerationStructureGeometryInstancesDataKHR</span> &#123;</span><br>    VkStructureType                  sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                      pNext;<br>    VkBool32                         arrayOfPointers;<br>    VkDeviceOrHostAddressConstKHR    data;<br>&#125; VkAccelerationStructureGeometryInstancesDataKHR;<br></code></pre></td></tr></table></figure><p>其中<i><font color="Orange">arrayOfPointers</font></i>代表最后一个<i><font color="Orange">data</font></i>成员是一个指向<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureInstanceKHR.html"><code>VkAccelerationStructureInstanceKHR</code></a>结构体的指针数组的地址还是一个单纯的<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureInstanceKHR.html"><code>VkAccelerationStructureInstanceKHR</code></a>结构体数组的地址。这里代码填写了<i><font color="Red">VK_FALSE</font></i>，也就是说为了填写<i><font color="Orange">data</font></i>，还需要填写一个<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureInstanceKHR.html"><code>VkAccelerationStructureInstanceKHR</code></a>结构体并且获取它的设备地址。<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureInstanceKHR.html"><code>VkAccelerationStructureInstanceKHR</code></a>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkAccelerationStructureInstanceKHR</span> &#123;</span><br>    VkTransformMatrixKHR          transform;<br>    <span class="hljs-type">uint32_t</span>                      instanceCustomIndex:<span class="hljs-number">24</span>;<br>    <span class="hljs-type">uint32_t</span>                      mask:<span class="hljs-number">8</span>;<br>    <span class="hljs-type">uint32_t</span>                      instanceShaderBindingTableRecordOffset:<span class="hljs-number">24</span>;<br>    VkGeometryInstanceFlagsKHR    flags:<span class="hljs-number">8</span>;<br>    <span class="hljs-type">uint64_t</span>                      accelerationStructureReference;<br>&#125; VkAccelerationStructureInstanceKHR;<br></code></pre></td></tr></table></figure><p>对于每个实例，还可以填写额外的变换，代码中仍然将其填写为单位矩阵表示不做变换。接下来的<i><font color="Orange">instanceCustomIndex</font></i>是一个用户指定的可以在光追着色器中通过<code>InstanceCustomIndexKHR</code>内置变量获取的索引值，本示例事实上并未用到该索引，设置为0。接下来的<i><font color="Orange">mask</font></i>会与着色器中的<code>Cull mask</code>一同决定该实例是否可以被光线击中（只要<strong>Cull mask &amp; instance.mask != 0就可以），这里直接保持默认值</strong>。<i><font color="Orange">instanceShaderBindingTableRecordOffset</font></i>指定该示例使用的<strong>hit shader</strong>（包括<strong>any hit shader</strong>和<strong>closest hit shader</strong>）在<strong>SBT</strong>中的偏移，示例仅绘制一个实例，指定为不偏移就可以了。接下来代码将标志位设置为<i><font color="Red">VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR</font></i>，表明在光追过程中禁用面剔除。最后指定好该实例指向的底层加速结构的地址，就完成了该结构体的填写。然后需要做的就是将该结构体数据上传到一个buffer中并且将该buffer的设备地址交给<i><font color="Orange">acceleration_structure_geometry</font></i>即可。</p><p>接下来的步骤和构建底层结构时如出一辙。同样获取该顶层加速结构以及构建所需的scratch buffer大小，然后构建存储顶层加速结构的缓冲区以及顶层加速结构句柄，并且构建好scratch buffer。之后再填写一遍完整的<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildGeometryInfoKHR.html"><code>VkAccelerationStructureBuildGeometryInfoKHR</code></a>信息，配合<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildRangeInfoKHR.html"><code>VkAccelerationStructureBuildRangeInfoKHR</code></a>信息传入<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildAccelerationStructuresKHR.html"><code>vkCmdBuildAccelerationStructuresKHR</code></a>构建好顶层加速结构。最后销毁scratch buffer并且获取顶层加速结构的设备地址并保存即可。</p><h3 id="create_uniform_buffer">create_uniform_buffer</h3><p>代码很简单，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Create the uniform buffer used to pass matrices to the ray tracing ray generation shader</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::create_uniform_buffer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	ubo = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(),<br>	                                           <span class="hljs-built_in">sizeof</span>(uniform_data),<br>	                                           VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,<br>	                                           VMA_MEMORY_USAGE_CPU_TO_GPU);<br>	ubo-&gt;<span class="hljs-built_in">convert_and_update</span>(uniform_data);<br><br>	<span class="hljs-built_in">update_uniform_buffers</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>就是更新uniform buffer，其中该示例用到的uniform buffer所需数据结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UniformData</span><br>&#123;<br>	glm::mat4 view_inverse;<br>	glm::mat4 proj_inverse;<br>&#125; uniform_data;<br>std::unique_ptr&lt;vkb::core::BufferC&gt; ubo;<br></code></pre></td></tr></table></figure><h3 id="create_ray_tracing_pipeline">create_ray_tracing_pipeline</h3><p>放上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Create our ray tracing pipeline</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::create_ray_tracing_pipeline</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// Slot for binding top level acceleration structures to the ray generation shader</span><br>	VkDescriptorSetLayoutBinding acceleration_structure_layout_binding&#123;&#125;;<br>	acceleration_structure_layout_binding.binding         = <span class="hljs-number">0</span>;<br>	acceleration_structure_layout_binding.descriptorType  = VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR;<br>	acceleration_structure_layout_binding.descriptorCount = <span class="hljs-number">1</span>;<br>	acceleration_structure_layout_binding.stageFlags      = VK_SHADER_STAGE_RAYGEN_BIT_KHR;<br><br>	VkDescriptorSetLayoutBinding result_image_layout_binding&#123;&#125;;<br>	result_image_layout_binding.binding         = <span class="hljs-number">1</span>;<br>	result_image_layout_binding.descriptorType  = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;<br>	result_image_layout_binding.descriptorCount = <span class="hljs-number">1</span>;<br>	result_image_layout_binding.stageFlags      = VK_SHADER_STAGE_RAYGEN_BIT_KHR;<br><br>	VkDescriptorSetLayoutBinding uniform_buffer_binding&#123;&#125;;<br>	uniform_buffer_binding.binding         = <span class="hljs-number">2</span>;<br>	uniform_buffer_binding.descriptorType  = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;<br>	uniform_buffer_binding.descriptorCount = <span class="hljs-number">1</span>;<br>	uniform_buffer_binding.stageFlags      = VK_SHADER_STAGE_RAYGEN_BIT_KHR;<br><br>	std::vector&lt;VkDescriptorSetLayoutBinding&gt; bindings = &#123;<br>	    acceleration_structure_layout_binding,<br>	    result_image_layout_binding,<br>	    uniform_buffer_binding&#125;;<br><br>	VkDescriptorSetLayoutCreateInfo layout_info&#123;&#125;;<br>	layout_info.sType        = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;<br>	layout_info.bindingCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(bindings.<span class="hljs-built_in">size</span>());<br>	layout_info.pBindings    = bindings.<span class="hljs-built_in">data</span>();<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorSetLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;layout_info, <span class="hljs-literal">nullptr</span>, &amp;descriptor_set_layout));<br><br>	VkPipelineLayoutCreateInfo pipeline_layout_create_info&#123;&#125;;<br>	pipeline_layout_create_info.sType          = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;<br>	pipeline_layout_create_info.setLayoutCount = <span class="hljs-number">1</span>;<br>	pipeline_layout_create_info.pSetLayouts    = &amp;descriptor_set_layout;<br><br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreatePipelineLayout</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;pipeline_layout_create_info, <span class="hljs-literal">nullptr</span>, &amp;pipeline_layout));<br><br>	<span class="hljs-comment">// Ray tracing shaders require SPIR-V 1.4, so we need to set the appropriate target environment for the glslang compiler</span><br>	vkb::GLSLCompiler::<span class="hljs-built_in">set_target_environment</span>(glslang::EShTargetSpv, glslang::EShTargetSpv_1_4);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	    Setup ray tracing shader groups</span><br><span class="hljs-comment">	    Each shader group points at the corresponding shader in the pipeline</span><br><span class="hljs-comment">	*/</span><br>	std::vector&lt;VkPipelineShaderStageCreateInfo&gt; shader_stages;<br><br>	<span class="hljs-comment">// Ray generation group</span><br>	&#123;<br>		shader_stages.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;ray_tracing_basic&quot;</span>, <span class="hljs-string">&quot;raygen.rgen&quot;</span>, VK_SHADER_STAGE_RAYGEN_BIT_KHR));<br>		VkRayTracingShaderGroupCreateInfoKHR raygen_group_ci&#123;&#125;;<br>		raygen_group_ci.sType              = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR;<br>		raygen_group_ci.type               = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR;<br>		raygen_group_ci.generalShader      = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(shader_stages.<span class="hljs-built_in">size</span>()) - <span class="hljs-number">1</span>;<br>		raygen_group_ci.closestHitShader   = VK_SHADER_UNUSED_KHR;<br>		raygen_group_ci.anyHitShader       = VK_SHADER_UNUSED_KHR;<br>		raygen_group_ci.intersectionShader = VK_SHADER_UNUSED_KHR;<br>		shader_groups.<span class="hljs-built_in">push_back</span>(raygen_group_ci);<br>	&#125;<br><br>	<span class="hljs-comment">// Ray miss group</span><br>	&#123;<br>		shader_stages.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;ray_tracing_basic&quot;</span>, <span class="hljs-string">&quot;miss.rmiss&quot;</span>, VK_SHADER_STAGE_MISS_BIT_KHR));<br>		VkRayTracingShaderGroupCreateInfoKHR miss_group_ci&#123;&#125;;<br>		miss_group_ci.sType              = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR;<br>		miss_group_ci.type               = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR;<br>		miss_group_ci.generalShader      = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(shader_stages.<span class="hljs-built_in">size</span>()) - <span class="hljs-number">1</span>;<br>		miss_group_ci.closestHitShader   = VK_SHADER_UNUSED_KHR;<br>		miss_group_ci.anyHitShader       = VK_SHADER_UNUSED_KHR;<br>		miss_group_ci.intersectionShader = VK_SHADER_UNUSED_KHR;<br>		shader_groups.<span class="hljs-built_in">push_back</span>(miss_group_ci);<br>	&#125;<br><br>	<span class="hljs-comment">// Ray closest hit group</span><br>	&#123;<br>		shader_stages.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">load_shader</span>(<span class="hljs-string">&quot;ray_tracing_basic&quot;</span>, <span class="hljs-string">&quot;closesthit.rchit&quot;</span>, VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR));<br>		VkRayTracingShaderGroupCreateInfoKHR closes_hit_group_ci&#123;&#125;;<br>		closes_hit_group_ci.sType              = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR;<br>		closes_hit_group_ci.type               = VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR;<br>		closes_hit_group_ci.generalShader      = VK_SHADER_UNUSED_KHR;<br>		closes_hit_group_ci.closestHitShader   = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(shader_stages.<span class="hljs-built_in">size</span>()) - <span class="hljs-number">1</span>;<br>		closes_hit_group_ci.anyHitShader       = VK_SHADER_UNUSED_KHR;<br>		closes_hit_group_ci.intersectionShader = VK_SHADER_UNUSED_KHR;<br>		shader_groups.<span class="hljs-built_in">push_back</span>(closes_hit_group_ci);<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	    Create the ray tracing pipeline</span><br><span class="hljs-comment">	*/</span><br>	VkRayTracingPipelineCreateInfoKHR raytracing_pipeline_create_info&#123;&#125;;<br>	raytracing_pipeline_create_info.sType                        = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR;<br>	raytracing_pipeline_create_info.stageCount                   = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(shader_stages.<span class="hljs-built_in">size</span>());<br>	raytracing_pipeline_create_info.pStages                      = shader_stages.<span class="hljs-built_in">data</span>();<br>	raytracing_pipeline_create_info.groupCount                   = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(shader_groups.<span class="hljs-built_in">size</span>());<br>	raytracing_pipeline_create_info.pGroups                      = shader_groups.<span class="hljs-built_in">data</span>();<br>	raytracing_pipeline_create_info.maxPipelineRayRecursionDepth = <span class="hljs-number">1</span>;<br>	raytracing_pipeline_create_info.layout                       = pipeline_layout;<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateRayTracingPipelinesKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), VK_NULL_HANDLE, VK_NULL_HANDLE, <span class="hljs-number">1</span>, &amp;raytracing_pipeline_create_info, <span class="hljs-literal">nullptr</span>, &amp;pipeline));<br>&#125;<br></code></pre></td></tr></table></figure><p>构建一个光追管线除了要绑定所需的描述符之外，最重要的就是设置好<strong>SBT（Shader binding table）</strong>了。<a target="_blank" rel="noopener" href="https://docs.vulkan.org/guide/latest/extensions/ray_tracing.html"><code>Vulkan官方文档中的一张图</code></a>对Vulkan光追使用到的着色器以及它们之间的流程关系做了一个形象的刻画：</p><figure><img src="/2025/02/27/CG_api/vulkan/vulkan_samples/ray_tracing_basic/shaders.png" srcset="/img/loading.gif" lazyload alt="光追着色器"><figcaption aria-hidden="true">光追着色器</figcaption></figure><p>大致解释如下：</p><ul><li><strong>Ray generation shader</strong>代表着光追流程的起点，调用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdTraceRaysKHR.html"><code>vkCmdTraceRaysKHR</code></a>会启动一系列的该着色器调用，而该着色器负责在代码中使用<code>traceRayEXT</code>构造并发射追踪光线。</li><li><strong>Closest hit shader</strong>在最近的一个被光线击中的几何体上调用，主要用于进行一些光照计算以及继续迭代地追踪光线。</li><li><strong>Miss shader</strong>在光线没击中几何体时调用，它的一个十分常见的用途是采样环境贴图。</li><li><strong>Intersection shader</strong>用于指定用户自定义的光线相交逻辑。如果没有指定该着色器，光线与物体相交默认逻辑为判断光线和三角形是否相交。</li><li><strong>Any hit shader</strong>在光线的所有相交处都会被调用，一般用于过滤交点和用于alpha测试。</li></ul><p>对这些基本概念有了一个大致的了解后，下面回到示例代码，看看具体的代码是如何编写的。</p><p>首先指定光追管线所需的所有描述符，包括了加速结构（注意它的描述符类型要指定为<i><font color="Red">VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</font></i>)、存储光追结果的Storage image以及uniform buffer。指定这些描述符集布局以及创建相应的管线布局都是常规操作，读者可自行阅读。接下来重点来看<strong>SBT</strong>的构建。</p><p>构建SBT，需要填写管线用到的着色器阶段以及相应的shader group。而指定shader group又需要填写<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRayTracingShaderGroupCreateInfoKHR.html"><code>VkRayTracingShaderGroupCreateInfoKHR</code></a>信息结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_ray_tracing_pipeline</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkRayTracingShaderGroupCreateInfoKHR</span> &#123;</span><br>    VkStructureType                   sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                       pNext;<br>    VkRayTracingShaderGroupTypeKHR    type;<br>    <span class="hljs-type">uint32_t</span>                          generalShader;<br>    <span class="hljs-type">uint32_t</span>                          closestHitShader;<br>    <span class="hljs-type">uint32_t</span>                          anyHitShader;<br>    <span class="hljs-type">uint32_t</span>                          intersectionShader;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                       pShaderGroupCaptureReplayHandle;<br>&#125; VkRayTracingShaderGroupCreateInfoKHR;<br></code></pre></td></tr></table></figure><p>其中<i><font color="Orange">type</font></i>指定这个着色器组的类型，可能的取值有<i><font color="Red">VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR</font></i>（通用着色器组，通常用于RGS和MS）、<i><font color="Red">VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR</font></i>（三角形几何体命中着色器组，通常用于CHS和AHS）、<i><font color="Red">VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR</font></i>（过程几何体命中着色器组，通常用于IS、CHS和AHS），接下来的四个成员分别指定成员名对应的着色器在<code>VkPipelineShaderStageCreateInfo</code>数组中的索引（第一个指定的是RGS和MS），如果不使用某种着色器则把相应成员设置为<i><font color="Red">VK_SHADER_UNUSED_KHR</font></i>。最后一个成员指定捕获重放，这个我们暂且不关心。</p><p>解释清楚这个结构体之后代码的填写就十分简单易懂了。在填写完SBT信息之后，就可以填写最终用于创建光追管线的<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkRayTracingPipelineCreateInfoKHR.html"><code>VkRayTracingPipelineCreateInfoKHR</code></a>信息结构体了，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_ray_tracing_pipeline</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkRayTracingPipelineCreateInfoKHR</span> &#123;</span><br>    VkStructureType                                      sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                                          pNext;<br>    VkPipelineCreateFlags                                flags;<br>    <span class="hljs-type">uint32_t</span>                                             stageCount;<br>    <span class="hljs-type">const</span> VkPipelineShaderStageCreateInfo*               pStages;<br>    <span class="hljs-type">uint32_t</span>                                             groupCount;<br>    <span class="hljs-type">const</span> VkRayTracingShaderGroupCreateInfoKHR*          pGroups;<br>    <span class="hljs-type">uint32_t</span>                                             maxPipelineRayRecursionDepth;<br>    <span class="hljs-type">const</span> VkPipelineLibraryCreateInfoKHR*                pLibraryInfo;<br>    <span class="hljs-type">const</span> VkRayTracingPipelineInterfaceCreateInfoKHR*    pLibraryInterface;<br>    <span class="hljs-type">const</span> VkPipelineDynamicStateCreateInfo*              pDynamicState;<br>    VkPipelineLayout                                     layout;<br>    VkPipeline                                           basePipelineHandle;<br>    <span class="hljs-type">int32_t</span>                                              basePipelineIndex;<br>&#125; VkRayTracingPipelineCreateInfoKHR;<br></code></pre></td></tr></table></figure><p>本示例比较简单，只需要指定该结构体中的部分和着色器以及管线布局有关的成员就行了，这些成员的含义是显而易见的，其它未填写的成员在之后深入了解Vulkan光追的时候再做进一步的分析。另外，代码还指定了<i><font color="Orange">maxPipelineRayRecursionDepth</font></i>，这个成员指定光追中光线的最大弹射次数。由于示例仅仅渲染一个三角形，设置为1就足够了。</p><p>最后调用<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRayTracingPipelinesKHR.html"><code>vkCreateRayTracingPipelinesKHR</code></a>即可创建光追管线对象。</p><p>在梳理完光追管线的创建流程之后，下面我们来分析一下本示例使用到的光追着色器代码。</p><p>首先是RGS：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 460</span><br><span class="hljs-meta">#extension GL_EXT_ray_tracing : enable</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>, set = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> accelerationStructureEXT topLevelAS;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>, set = <span class="hljs-number">0</span>, <span class="hljs-keyword">rgba8</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">image2D</span> image;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">2</span>, set = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> CameraProperties <br>&#123;<br>	<span class="hljs-type">mat4</span> viewInverse;<br>	<span class="hljs-type">mat4</span> projInverse;<br>&#125; cam;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) rayPayloadEXT <span class="hljs-type">vec3</span> hitValue;<br><br><span class="hljs-type">void</span> main() <br>&#123;<br>	<span class="hljs-keyword">const</span> <span class="hljs-type">vec2</span> pixelCenter = <span class="hljs-type">vec2</span>(gl_LaunchIDEXT.xy) + <span class="hljs-type">vec2</span>(<span class="hljs-number">0.5</span>);<br>	<span class="hljs-keyword">const</span> <span class="hljs-type">vec2</span> inUV = pixelCenter/<span class="hljs-type">vec2</span>(gl_LaunchSizeEXT.xy);<br>	<span class="hljs-type">vec2</span> d = inUV * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>;<br><br>	<span class="hljs-type">vec4</span> origin = cam.viewInverse * <span class="hljs-type">vec4</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>	<span class="hljs-type">vec4</span> target = cam.projInverse * <span class="hljs-type">vec4</span>(d.x, d.y, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) ;<br>	<span class="hljs-type">vec4</span> direction = cam.viewInverse*<span class="hljs-type">vec4</span>(<span class="hljs-built_in">normalize</span>(target.xyz), <span class="hljs-number">0</span>) ;<br><br>	<span class="hljs-type">float</span> tmin = <span class="hljs-number">0.001</span>;<br>	<span class="hljs-type">float</span> tmax = <span class="hljs-number">10000.0</span>;<br><br>    hitValue = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>);<br><br>    traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, <span class="hljs-number">0xff</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, origin.xyz, tmin, direction.xyz, tmax, <span class="hljs-number">0</span>);<br><br>	<span class="hljs-built_in">imageStore</span>(image, <span class="hljs-type">ivec2</span>(gl_LaunchIDEXT.xy), <span class="hljs-type">vec4</span>(hitValue, <span class="hljs-number">0.0</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到为了使用光追相关的变量和API，首先需要开启<code>GL_EXT_ray_tracing</code>拓展。然后注意加速结构描述符在着色器内的指定方式（<strong>uniform accelerationStructureEXT</strong>）。Storage image的布局中指定的<strong>rgba8</strong>是<strong>图像格式限定符</strong>，指定该图像格式为RGBA四个通道，每个通道各8位，这个格式需要和Storage image在程序中指定的格式相对应，合理指定图像格式可以优化硬件性能。还要注意<strong>rayPayloadEXT</strong>这个关键字，它用于指定<strong>光线载荷</strong>，所谓光线载荷，也就是可以在RGS、MS、CHS、AHS之间传递的数据，数据类型可以是任何有效类型，并且也可以指定多个光线载荷。代码中指定的荷载就是光线与物体相交点的颜色。</p><p>接下来来看main函数。发射一条光线当然需要确定光线的起点和方向。在本示例main函数中这是通过当前屏幕像素的方向来确定的。可以看到<i><font color="Orange">pixelCenter</font></i>就是当前像素的中心在屏幕空间的坐标（<strong>gl_launchIDEXT</strong>代表当前光线的编号，也就是第几条发射的光线），然后<i><font color="Orange">inUV</font></i>代表的就是像素的纹理坐标，将它变换到<strong>[-1,1]</strong>范围内就成了像素在NDC中的横纵坐标（也就是变量<i><font color="Orange">d</font></i>）。</p><p>然后为了得到从原点出发，指向当前像素的光线，我们需要首先将原点（摄像机所在位置）和像素中心点都变换到世界坐标中去，这就是通过对摄像机位置（代码中简单地设置为(0,0,0)）乘以视角矩阵的逆矩阵以及对NDC空间中的像素中心点顺次乘以投影矩阵和视角矩阵的逆矩阵实现的。这样光线的方向就确定了。</p><p>最后实际上还需要设置光线的最小和最大相交检测距离（在这两个距离之外即使与物体有交点也不会触发命中着色器调用）。在设置好所有这些参数之后，就可以调用<code>traceRayEXT</code>来开始光线追踪了。该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">traceRayEXT(<br>    accelerationStructure, <span class="hljs-comment">// 顶层加速结构</span><br>    rayFlags,             <span class="hljs-comment">// 光线标志</span><br>    cullMask,             <span class="hljs-comment">// 遮罩</span><br>    sbtRecordOffset,      <span class="hljs-comment">// SBT 记录偏移</span><br>    sbtRecordStride,      <span class="hljs-comment">// SBT 记录步长</span><br>    missIndex,            <span class="hljs-comment">// Miss Shader 索引</span><br>    rayOrigin,            <span class="hljs-comment">// 光线起点</span><br>    rayTmin,              <span class="hljs-comment">// 光线最小距离</span><br>    rayDirection,         <span class="hljs-comment">// 光线方向</span><br>    rayTmax,              <span class="hljs-comment">// 光线最大距离</span><br>    payloadLocation       <span class="hljs-comment">// 光线载荷索引</span><br>);<br></code></pre></td></tr></table></figure><p>示例代码中指定光线标志为<i><font color="Red">gl_RayFlagsOpaqueEXT</font></i>，代表忽略AHS，由于程序中并未指定AHS，所以这么设置标志并不影响。另外，代码将SBT步长设为0，意思是让硬件自行判断。如果 SBT 中的记录大小相同，并且不需要自定义步长，可以将 <code>sbtRecordStride</code> 设置为 0，让 Vulkan 自动处理步长。</p><p>最后，如果该发出的光线完成了追踪过程，hitValue中存储着最终的颜色值，只需要将这个颜色值写入Storage image对应的像素即可。</p><p>好的，接下来让我们继续分析CHS的代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 460</span><br><span class="hljs-meta">#extension GL_EXT_ray_tracing : enable</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) rayPayloadInEXT <span class="hljs-type">vec3</span> hitValue;<br>hitAttributeEXT <span class="hljs-type">vec3</span> attribs;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-type">vec3</span> barycentricCoords = <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>f - attribs.x - attribs.y, attribs.x, attribs.y);<br>  hitValue = barycentricCoords;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个着色器就是用来决定光线追踪最终得到的颜色的。因为这个颜色值需要通过hitValue传递，所以这里也需要声明并使用hitValue。另外，关键字<code>hitAttributeEXT</code>是一个在IS、CHS、AHS中传递的量，当光线与几何体相交时，可以通过这个量来传递额外的几何信息。事实上，这个数据在IS中可以读写，但在CHS、AHS中只能读取。如果说用户没有定义自己的IS，那么这个数据实际上存储的是光线和三角形交点在三角形中的<strong>重心坐标（barycentric coordinate）</strong>（更多有关GLSL_EXT_ray_tracing的拓展特性、关键字、API等，可以参考<a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_ray_tracing.txt"><code>这个页面</code></a>）。在示例代码中就是这种情况：首先通过该数据获取交点在三角形中的重心坐标，然后将交点颜色值通过该重心坐标值进行设置。接下来是我个人对于颜色值的理解，未必准确：回忆之前在定义三角形顶点数据的时候，顺序是右侧顶点——左侧顶点——上方顶点，那么这三点的重心坐标应该分别为(1,0,0)，(0,1,0)，(0,0,1)，推测重心坐标所指定的两个值应该是后两个顶点的坐标值，如果是这样的话那么三个顶点的颜色值顺次为(1,0,0)，(0,1,0)，(0,0,1)，也就是分别为红色，绿色，蓝色，和前文程序运行结果完全一致！</p><p>最后来看MS的代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 460</span><br><span class="hljs-meta">#extension GL_EXT_ray_tracing : enable</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) rayPayloadInEXT <span class="hljs-type">vec3</span> hitValue;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    hitValue = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个逻辑就更简单了：如果没有交点，就将颜色值指定为(0,0,0.2)，这就是为什么运行结果三角形之外的背景呈深蓝色的原因。</p><p>另外，示例还提供了hlsl代码，我们也可以看看hlsl的API写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//RGS</span><br><br>RaytracingAccelerationStructure rs : <span class="hljs-keyword">register</span>(t0);<br>RWTexture2D&lt;float4&gt; image : <span class="hljs-keyword">register</span>(u1);<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CameraProperties</span></span><br><span class="hljs-class">&#123;</span><br>    float4x4 viewInverse;<br>    float4x4 projInverse;<br>&#125;;<br>cbuffer camera : <span class="hljs-keyword">register</span>(b2)<br>&#123;<br>    CameraProperties camera;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Payload</span></span><br><span class="hljs-class">&#123;</span><br>    [[vk::location(<span class="hljs-number">0</span>)]] float3 hitValue;<br>&#125;;<br><br>[shader(<span class="hljs-string">&quot;raygeneration&quot;</span>)]<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    uint3 LaunchID = DispatchRaysIndex();<br>    uint3 LaunchSize = DispatchRaysDimensions();<br><br>    <span class="hljs-type">const</span> float2 pixelCenter = float2(LaunchID.xy) + float2(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>);<br>    <span class="hljs-type">const</span> float2 inUV = pixelCenter / float2(LaunchSize.xy);<br>    float2 d = inUV * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>;<br>    float4 target = mul(camera.projInverse, float4(d.x, d.y, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br><br>    RayDesc rayDesc;<br>    rayDesc.Origin = mul(camera.viewInverse, float4(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)).xyz;<br>    rayDesc.Direction = mul(camera.viewInverse, float4(normalize(target.xyz), <span class="hljs-number">0</span>)).xyz;<br>    rayDesc.TMin = <span class="hljs-number">0.001</span>;<br>    rayDesc.TMax = <span class="hljs-number">10000.0</span>;<br><br>    Payload payload;<br>    TraceRay(rs, RAY_FLAG_FORCE_OPAQUE, <span class="hljs-number">0xff</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, rayDesc, payload);<br><br>    image[int2(LaunchID.xy)] = float4(payload.hitValue, <span class="hljs-number">0.0</span>);<br>&#125;<br><br><span class="hljs-comment">//CHS</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Attributes</span></span><br><span class="hljs-class">&#123;</span><br>    float2 bary;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Payload</span></span><br><span class="hljs-class">&#123;</span><br>    [[vk::location(<span class="hljs-number">0</span>)]] float3 hitValue;<br>&#125;;<br><br>[shader(<span class="hljs-string">&quot;closesthit&quot;</span>)]<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(inout Payload p, in Attributes attribs)</span><br>&#123;<br>    <span class="hljs-type">const</span> float3 barycentricCoords = float3(<span class="hljs-number">1.0f</span> - attribs.bary.x - attribs.bary.y, attribs.bary.x, attribs.bary.y);<br>    p.hitValue = barycentricCoords;<br>&#125;<br><br><span class="hljs-comment">//MS</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Payload</span></span><br><span class="hljs-class">&#123;</span><br>    [[vk::location(<span class="hljs-number">0</span>)]] float3 hitValue;<br>&#125;;<br><br>[shader(<span class="hljs-string">&quot;miss&quot;</span>)]<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(inout Payload p)</span><br>&#123;<br>    p.hitValue = float3(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>只是有一些语法层面上的不同，读者可以自行比较分析。</p><h3 id="create_shader_binding_tables">create_shader_binding_tables</h3><p>接下来需要创建真正的SBT对象了，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Create the Shader Binding Tables that connects the ray tracing pipelines&#x27; programs and the  top-level acceleration structure</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    SBT Layout used in this sample:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        /-----------\</span><br><span class="hljs-comment">        | raygen    |</span><br><span class="hljs-comment">        |-----------|</span><br><span class="hljs-comment">        | miss      |</span><br><span class="hljs-comment">        |-----------|</span><br><span class="hljs-comment">        | hit       |</span><br><span class="hljs-comment">        \-----------/</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::create_shader_binding_tables</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>           handle_size            = ray_tracing_pipeline_properties.shaderGroupHandleSize;<br>	<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>           handle_size_aligned    = <span class="hljs-built_in">aligned_size</span>(ray_tracing_pipeline_properties.shaderGroupHandleSize, ray_tracing_pipeline_properties.shaderGroupHandleAlignment);<br>	<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>           handle_alignment       = ray_tracing_pipeline_properties.shaderGroupHandleAlignment;<br>	<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>           group_count            = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(shader_groups.<span class="hljs-built_in">size</span>());<br>	<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>           sbt_size               = group_count * handle_size_aligned;<br>	<span class="hljs-type">const</span> VkBufferUsageFlags sbt_buffer_usage_flags = VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR | VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;<br>	<span class="hljs-type">const</span> VmaMemoryUsage     sbt_memory_usage       = VMA_MEMORY_USAGE_CPU_TO_GPU;<br><br>	<span class="hljs-comment">// Raygen</span><br>	<span class="hljs-comment">// Create binding table buffers for each shader type</span><br>	raygen_shader_binding_table = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), handle_size, sbt_buffer_usage_flags, sbt_memory_usage, <span class="hljs-number">0</span>);<br>	miss_shader_binding_table   = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), handle_size, sbt_buffer_usage_flags, sbt_memory_usage, <span class="hljs-number">0</span>);<br>	hit_shader_binding_table    = std::<span class="hljs-built_in">make_unique</span>&lt;vkb::core::BufferC&gt;(<span class="hljs-built_in">get_device</span>(), handle_size, sbt_buffer_usage_flags, sbt_memory_usage, <span class="hljs-number">0</span>);<br><br>	<span class="hljs-comment">// Copy the pipeline&#x27;s shader handles into a host buffer</span><br>	<span class="hljs-function">std::vector&lt;<span class="hljs-type">uint8_t</span>&gt; <span class="hljs-title">shader_handle_storage</span><span class="hljs-params">(sbt_size)</span></span>;<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkGetRayTracingShaderGroupHandlesKHR</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), pipeline, <span class="hljs-number">0</span>, group_count, sbt_size, shader_handle_storage.<span class="hljs-built_in">data</span>()));<br><br>	<span class="hljs-comment">// Copy the shader handles from the host buffer to the binding tables</span><br>	<span class="hljs-type">uint8_t</span> *data = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span> *&gt;(raygen_shader_binding_table-&gt;<span class="hljs-built_in">map</span>());<br>	<span class="hljs-built_in">memcpy</span>(data, shader_handle_storage.<span class="hljs-built_in">data</span>(), handle_size);<br>	data = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span> *&gt;(miss_shader_binding_table-&gt;<span class="hljs-built_in">map</span>());<br>	<span class="hljs-built_in">memcpy</span>(data, shader_handle_storage.<span class="hljs-built_in">data</span>() + handle_size_aligned, handle_size);<br>	data = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span> *&gt;(hit_shader_binding_table-&gt;<span class="hljs-built_in">map</span>());<br>	<span class="hljs-built_in">memcpy</span>(data, shader_handle_storage.<span class="hljs-built_in">data</span>() + handle_size_aligned * <span class="hljs-number">2</span>, handle_size);<br>	raygen_shader_binding_table-&gt;<span class="hljs-built_in">unmap</span>();<br>	miss_shader_binding_table-&gt;<span class="hljs-built_in">unmap</span>();<br>	hit_shader_binding_table-&gt;<span class="hljs-built_in">unmap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>所谓的SBT，其实也是一块缓冲区内存，其中连续地保存了所有光追管线绑定的某种特定的shader group的handle。为了能将这些shader group的handle保存到缓冲区中，需要先从管线通过<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingShaderGroupHandlesNV.html"><code>vkGetRayTracingShaderGroupHandlesKHR</code></a>获取这些handle到CPU中，再上传到GPU中。该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_ray_tracing_pipeline</span><br>VkResult <span class="hljs-title function_">vkGetRayTracingShaderGroupHandlesKHR</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkDevice                                    device,</span><br><span class="hljs-params">    VkPipeline                                  pipeline,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    firstGroup,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    groupCount,</span><br><span class="hljs-params">    <span class="hljs-type">size_t</span>                                      dataSize,</span><br><span class="hljs-params">    <span class="hljs-type">void</span>*                                       pData)</span>;<br></code></pre></td></tr></table></figure><p>可以看见，我们需要指定光追管线、首个想要获取句柄的绑定的shader group索引、获取的shader group总数、用于存储handle的内存大小以及相应的CPU内存区域。代码通过在之前获取并保存的<i><font color="Orange">ray_tracing_pipeline_properties</font></i>来获取shader group的句柄大小以及对齐要求，这样就可以计算出对齐之后的句柄大小，从而计算出所有句柄的大小之和（每个句柄是一样大，并且一样对齐的），计算对齐大小函数<i><font color="Green">aligned_size</font></i>也十分易于理解（其实就是将内存大小向上补齐为对齐大小的倍数）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">aligned_size</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> value, <span class="hljs-type">uint32_t</span> alignment)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> (value + alignment - <span class="hljs-number">1</span>) &amp; ~(alignment - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们就可以通过<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingShaderGroupHandlesNV.html"><code>vkGetRayTracingShaderGroupHandlesKHR</code></a><a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingShaderGroupHandlesNV.html"><code>vkGetRayTracingShaderGroupHandlesKHR</code></a>将所有的句柄先保存在一个8字节无符号整数的向量中，然后再将向量中某shader group句柄对应偏移处的数据复制到用于存储该句柄的缓冲区中。按照创建光追管线时指定的shader group顺序，向量中句柄数据顺序应该为RGS——MS——CHS。</p><h3 id="create_descriptor_sets">create_descriptor_sets</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Create the descriptor sets used for the ray tracing dispatch</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::create_descriptor_sets</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::vector&lt;VkDescriptorPoolSize&gt; pool_sizes = &#123;<br>	    &#123;VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR, <span class="hljs-number">1</span>&#125;,<br>	    &#123;VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, <span class="hljs-number">1</span>&#125;,<br>	    &#123;VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">1</span>&#125;&#125;;<br>	VkDescriptorPoolCreateInfo descriptor_pool_create_info = vkb::initializers::<span class="hljs-built_in">descriptor_pool_create_info</span>(pool_sizes, <span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkCreateDescriptorPool</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_pool_create_info, <span class="hljs-literal">nullptr</span>, &amp;descriptor_pool));<br><br>	VkDescriptorSetAllocateInfo descriptor_set_allocate_info = vkb::initializers::<span class="hljs-built_in">descriptor_set_allocate_info</span>(descriptor_pool, &amp;descriptor_set_layout, <span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkAllocateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), &amp;descriptor_set_allocate_info, &amp;descriptor_set));<br><br>	<span class="hljs-comment">// Setup the descriptor for binding our top level acceleration structure to the ray tracing shaders</span><br>	VkWriteDescriptorSetAccelerationStructureKHR descriptor_acceleration_structure_info&#123;&#125;;<br>	descriptor_acceleration_structure_info.sType                      = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR;<br>	descriptor_acceleration_structure_info.accelerationStructureCount = <span class="hljs-number">1</span>;<br>	descriptor_acceleration_structure_info.pAccelerationStructures    = &amp;top_level_acceleration_structure.handle;<br><br>	VkWriteDescriptorSet acceleration_structure_write&#123;&#125;;<br>	acceleration_structure_write.sType           = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;<br>	acceleration_structure_write.dstSet          = descriptor_set;<br>	acceleration_structure_write.dstBinding      = <span class="hljs-number">0</span>;<br>	acceleration_structure_write.descriptorCount = <span class="hljs-number">1</span>;<br>	acceleration_structure_write.descriptorType  = VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR;<br>	<span class="hljs-comment">// The acceleration structure descriptor has to be chained via pNext</span><br>	acceleration_structure_write.pNext = &amp;descriptor_acceleration_structure_info;<br><br>	VkDescriptorImageInfo image_descriptor&#123;&#125;;<br>	image_descriptor.imageView   = storage_image.view;<br>	image_descriptor.imageLayout = VK_IMAGE_LAYOUT_GENERAL;<br><br>	VkDescriptorBufferInfo buffer_descriptor = <span class="hljs-built_in">create_descriptor</span>(*ubo);<br><br>	VkWriteDescriptorSet result_image_write   = vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_set, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, <span class="hljs-number">1</span>, &amp;image_descriptor);<br>	VkWriteDescriptorSet uniform_buffer_write = vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_set, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, <span class="hljs-number">2</span>, &amp;buffer_descriptor);<br><br>	std::vector&lt;VkWriteDescriptorSet&gt; write_descriptor_sets = &#123;<br>	    acceleration_structure_write,<br>	    result_image_write,<br>	    uniform_buffer_write&#125;;<br>	<span class="hljs-built_in">vkUpdateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(write_descriptor_sets.<span class="hljs-built_in">size</span>()), write_descriptor_sets.<span class="hljs-built_in">data</span>(), <span class="hljs-number">0</span>, VK_NULL_HANDLE);<br>&#125;<br></code></pre></td></tr></table></figure><p>整个流程十分常规，无需多言。不过这里还是需要注意一下加速结构描述符的绑定：在指定加速结构的<code>VkWriteDescriptorSet</code>的时候，除了指定绑定点、绑定描述符集、描述符类型、绑定数目等常规信息之外，真正绑定的加速结构资源需要通过<i><font color="Orange">pNext</font></i>成员指向一个<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetAccelerationStructureKHR.html"><code>VkWriteDescriptorSetAccelerationStructureKHR</code></a>结构体来指定（就像缓冲区和图像资源分别会通过<code>VkDescriptorBufferInfo</code>和<code>VkDescriptorImageInfo</code>指定一样），其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_acceleration_structure</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkWriteDescriptorSetAccelerationStructureKHR</span> &#123;</span><br>    VkStructureType                      sType;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>*                          pNext;<br>    <span class="hljs-type">uint32_t</span>                             accelerationStructureCount;<br>    <span class="hljs-type">const</span> VkAccelerationStructureKHR*    pAccelerationStructures;<br>&#125; VkWriteDescriptorSetAccelerationStructureKHR;<br></code></pre></td></tr></table></figure><p>注意绑定到管线上的是顶层加速结构的句柄就可以了。</p><h3 id="build_command_buffers">build_command_buffers</h3><p>上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Command buffer generation</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::build_command_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (width != storage_image.width || height != storage_image.height)<br>	&#123;<br>		<span class="hljs-comment">// If the view port size has changed, we need to recreate the storage image</span><br>		<span class="hljs-built_in">vkDestroyImageView</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), storage_image.view, <span class="hljs-literal">nullptr</span>);<br>		<span class="hljs-built_in">vkDestroyImage</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), storage_image.image, <span class="hljs-literal">nullptr</span>);<br>		<span class="hljs-built_in">vkFreeMemory</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), storage_image.memory, <span class="hljs-literal">nullptr</span>);<br>		<span class="hljs-built_in">create_storage_image</span>();<br>		<span class="hljs-comment">// The descriptor also needs to be updated to reference the new image</span><br>		VkDescriptorImageInfo image_descriptor&#123;&#125;;<br>		image_descriptor.imageView              = storage_image.view;<br>		image_descriptor.imageLayout            = VK_IMAGE_LAYOUT_GENERAL;<br>		VkWriteDescriptorSet result_image_write = vkb::initializers::<span class="hljs-built_in">write_descriptor_set</span>(descriptor_set, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, <span class="hljs-number">1</span>, &amp;image_descriptor);<br>		<span class="hljs-built_in">vkUpdateDescriptorSets</span>(<span class="hljs-built_in">get_device</span>().<span class="hljs-built_in">get_handle</span>(), <span class="hljs-number">1</span>, &amp;result_image_write, <span class="hljs-number">0</span>, VK_NULL_HANDLE);<br>	&#125;<br><br>	VkCommandBufferBeginInfo command_buffer_begin_info = vkb::initializers::<span class="hljs-built_in">command_buffer_begin_info</span>();<br><br>	VkImageSubresourceRange subresource_range = &#123;VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; draw_cmd_buffers.<span class="hljs-built_in">size</span>(); ++i)<br>	&#123;<br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkBeginCommandBuffer</span>(draw_cmd_buffers[i], &amp;command_buffer_begin_info));<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		    Setup the strided device address regions pointing at the shader identifiers in the shader binding table</span><br><span class="hljs-comment">		*/</span><br><br>		<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> handle_size_aligned = <span class="hljs-built_in">aligned_size</span>(ray_tracing_pipeline_properties.shaderGroupHandleSize, ray_tracing_pipeline_properties.shaderGroupHandleAlignment);<br><br>		VkStridedDeviceAddressRegionKHR raygen_shader_sbt_entry&#123;&#125;;<br>		raygen_shader_sbt_entry.deviceAddress = <span class="hljs-built_in">get_buffer_device_address</span>(raygen_shader_binding_table-&gt;<span class="hljs-built_in">get_handle</span>());<br>		raygen_shader_sbt_entry.stride        = handle_size_aligned;<br>		raygen_shader_sbt_entry.size          = handle_size_aligned;<br><br>		VkStridedDeviceAddressRegionKHR miss_shader_sbt_entry&#123;&#125;;<br>		miss_shader_sbt_entry.deviceAddress = <span class="hljs-built_in">get_buffer_device_address</span>(miss_shader_binding_table-&gt;<span class="hljs-built_in">get_handle</span>());<br>		miss_shader_sbt_entry.stride        = handle_size_aligned;<br>		miss_shader_sbt_entry.size          = handle_size_aligned;<br><br>		VkStridedDeviceAddressRegionKHR hit_shader_sbt_entry&#123;&#125;;<br>		hit_shader_sbt_entry.deviceAddress = <span class="hljs-built_in">get_buffer_device_address</span>(hit_shader_binding_table-&gt;<span class="hljs-built_in">get_handle</span>());<br>		hit_shader_sbt_entry.stride        = handle_size_aligned;<br>		hit_shader_sbt_entry.size          = handle_size_aligned;<br><br>		VkStridedDeviceAddressRegionKHR callable_shader_sbt_entry&#123;&#125;;<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		    Dispatch the ray tracing commands</span><br><span class="hljs-comment">		*/</span><br>		<span class="hljs-built_in">vkCmdBindPipeline</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, pipeline);<br>		<span class="hljs-built_in">vkCmdBindDescriptorSets</span>(draw_cmd_buffers[i], VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, pipeline_layout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;descriptor_set, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>		<span class="hljs-built_in">vkCmdTraceRaysKHR</span>(<br>		    draw_cmd_buffers[i],<br>		    &amp;raygen_shader_sbt_entry,<br>		    &amp;miss_shader_sbt_entry,<br>		    &amp;hit_shader_sbt_entry,<br>		    &amp;callable_shader_sbt_entry,<br>		    width,<br>		    height,<br>		    <span class="hljs-number">1</span>);<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		    Copy ray tracing output to swap chain image</span><br><span class="hljs-comment">		*/</span><br><br>		<span class="hljs-comment">// Prepare current swap chain image as transfer destination</span><br>		vkb::<span class="hljs-built_in">image_layout_transition</span>(draw_cmd_buffers[i],<br>		                             <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_swapchain</span>().<span class="hljs-built_in">get_images</span>()[i],<br>		                             VK_IMAGE_LAYOUT_UNDEFINED,<br>		                             VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);<br><br>		<span class="hljs-comment">// Prepare ray tracing output image as transfer source</span><br>		vkb::<span class="hljs-built_in">image_layout_transition</span>(draw_cmd_buffers[i],<br>		                             storage_image.image,<br>		                             VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,<br>		                             VK_PIPELINE_STAGE_TRANSFER_BIT,<br>		                             &#123;&#125;,<br>		                             VK_ACCESS_TRANSFER_READ_BIT,<br>		                             VK_IMAGE_LAYOUT_GENERAL,<br>		                             VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,<br>		                             subresource_range);<br><br>		VkImageCopy copy_region&#123;&#125;;<br>		copy_region.srcSubresource = &#123;VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>		copy_region.srcOffset      = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>		copy_region.dstSubresource = &#123;VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>		copy_region.dstOffset      = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>		copy_region.extent         = &#123;width, height, <span class="hljs-number">1</span>&#125;;<br>		<span class="hljs-built_in">vkCmdCopyImage</span>(draw_cmd_buffers[i], storage_image.image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,<br>		               <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_swapchain</span>().<span class="hljs-built_in">get_images</span>()[i], VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, <span class="hljs-number">1</span>, &amp;copy_region);<br><br>		<span class="hljs-comment">// Transition swap chain image back for presentation</span><br>		vkb::<span class="hljs-built_in">image_layout_transition</span>(draw_cmd_buffers[i],<br>		                             <span class="hljs-built_in">get_render_context</span>().<span class="hljs-built_in">get_swapchain</span>().<span class="hljs-built_in">get_images</span>()[i],<br>		                             VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,<br>		                             VK_IMAGE_LAYOUT_PRESENT_SRC_KHR);<br><br>		<span class="hljs-comment">// Transition ray tracing output image back to general layout</span><br>		vkb::<span class="hljs-built_in">image_layout_transition</span>(draw_cmd_buffers[i],<br>		                             storage_image.image,<br>		                             VK_PIPELINE_STAGE_TRANSFER_BIT,<br>		                             VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,<br>		                             VK_ACCESS_TRANSFER_READ_BIT,<br>		                             &#123;&#125;,<br>		                             VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,<br>		                             VK_IMAGE_LAYOUT_GENERAL,<br>		                             subresource_range);<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		    Start a new render pass to draw the UI overlay on top of the ray traced image</span><br><span class="hljs-comment">		*/</span><br>		VkClearValue clear_values[<span class="hljs-number">2</span>];<br>		clear_values[<span class="hljs-number">0</span>].color        = &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.033f</span>, <span class="hljs-number">0.0f</span>&#125;&#125;;<br>		clear_values[<span class="hljs-number">1</span>].depthStencil = &#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0</span>&#125;;<br><br>		VkRenderPassBeginInfo render_pass_begin_info    = vkb::initializers::<span class="hljs-built_in">render_pass_begin_info</span>();<br>		render_pass_begin_info.renderPass               = render_pass;<br>		render_pass_begin_info.framebuffer              = framebuffers[i];<br>		render_pass_begin_info.renderArea.extent.width  = width;<br>		render_pass_begin_info.renderArea.extent.height = height;<br>		render_pass_begin_info.clearValueCount          = <span class="hljs-number">2</span>;<br>		render_pass_begin_info.pClearValues             = clear_values;<br><br>		<span class="hljs-built_in">vkCmdBeginRenderPass</span>(draw_cmd_buffers[i], &amp;render_pass_begin_info, VK_SUBPASS_CONTENTS_INLINE);<br>		<span class="hljs-built_in">draw_ui</span>(draw_cmd_buffers[i]);<br>		<span class="hljs-built_in">vkCmdEndRenderPass</span>(draw_cmd_buffers[i]);<br><br>		<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkEndCommandBuffer</span>(draw_cmd_buffers[i]));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数用于构建提交给GPU执行的命令缓冲。事实上本示例需要录制的命令可以分为三部分：处理屏幕大小变化、开启光追、绘制UI界面。</p><p>首先判断当前屏幕大小有无变化，若发生了变化，则需要重建Storage image（相应的描述符也需要更新），这部分没什么需要多分析的。</p><p>然后开始准备开启光追。Vulkan中光追命令的开启是通过<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdTraceRaysKHR.html"><code>vkCmdTraceRaysKHR</code></a>完成的。该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_ray_tracing_pipeline</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkCmdTraceRaysKHR</span><span class="hljs-params">(</span><br><span class="hljs-params">    VkCommandBuffer                             commandBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkStridedDeviceAddressRegionKHR*      pRaygenShaderBindingTable,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkStridedDeviceAddressRegionKHR*      pMissShaderBindingTable,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkStridedDeviceAddressRegionKHR*      pHitShaderBindingTable,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> VkStridedDeviceAddressRegionKHR*      pCallableShaderBindingTable,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    width,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    height,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span>                                    depth)</span>;<br></code></pre></td></tr></table></figure><p>大多参数都可以靠名字猜出它的含义：<i><font color="Orange">pRaygenShaderBindingTable</font></i>指定的是RGS的SBT绑定条目，<i><font color="Orange">pMissShaderBindingTable</font></i>指定的是MS的SBT绑定条目，<i><font color="Orange">pHitShaderBindingTable</font></i>指定的是IS、CHS、AHS的SBT绑定条目，而<i><font color="Orange">pRaygenShaderBindingTable</font></i><i><font color="Orange">pCallableShaderBindingTable</font></i>指定的则是一些可以被其它着色器调用的着色器绑定条目（一般用于封装一些计算逻辑以便代码复用等）。最后的三个成员分别代表发射光线在各个维度的数量。</p><p>为了指定这些SBT条目参数，需要填写<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/latest/man/html/VkStridedDeviceAddressRegionKHR.html"><code>VkStridedDeviceAddressRegionKHR</code></a>结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Provided by VK_KHR_ray_tracing_pipeline</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VkStridedDeviceAddressRegionKHR</span> &#123;</span><br>    VkDeviceAddress    deviceAddress;<br>    VkDeviceSize       stride;<br>    VkDeviceSize       size;<br>&#125; VkStridedDeviceAddressRegionKHR;<br></code></pre></td></tr></table></figure><p>由于示例程序中每种（前三种）SBT条目各一个，因此size和stride均为该条目对应的shader group handle在缓冲区种的对齐大小。</p><p>最后，只需要在开启光追前绑定管线和描述符即可。</p><p>然后，由于光追结果是渲染到Storage image上的，我们需要将渲染数据复制到后台缓冲区中。在复制之前当然需要对后台缓冲区图像和Storage image的布局进行合适的转换（分别转换为传输目标和传输源），不过这里要注意，前后两次的图像布局转换实际上使用的是不同的工具函数，前一个使用的是一般的<i><font color="Green">image_layout_transition</font></i>，它可以根据传入的前后布局来推断前后管线阶段和操作，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">image_layout_transition</span><span class="hljs-params">(VkCommandBuffer command_buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                             VkImage         image,</span></span><br><span class="hljs-params"><span class="hljs-function">                             VkImageLayout   old_layout,</span></span><br><span class="hljs-params"><span class="hljs-function">                             VkImageLayout   new_layout)</span></span><br><span class="hljs-function"></span>&#123;<br>	VkImageSubresourceRange subresource_range = &#123;&#125;;<br>	subresource_range.aspectMask              = VK_IMAGE_ASPECT_COLOR_BIT;<br>	subresource_range.baseMipLevel            = <span class="hljs-number">0</span>;<br>	subresource_range.levelCount              = <span class="hljs-number">1</span>;<br>	subresource_range.baseArrayLayer          = <span class="hljs-number">0</span>;<br>	subresource_range.layerCount              = <span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">image_layout_transition</span>(command_buffer, image, old_layout, new_layout, subresource_range);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">image_layout_transition</span><span class="hljs-params">(VkCommandBuffer                command_buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                             VkImage                        image,</span></span><br><span class="hljs-params"><span class="hljs-function">                             VkImageLayout                  old_layout,</span></span><br><span class="hljs-params"><span class="hljs-function">                             VkImageLayout                  new_layout,</span></span><br><span class="hljs-params"><span class="hljs-function">                             VkImageSubresourceRange <span class="hljs-type">const</span> &amp;subresource_range)</span></span><br><span class="hljs-function"></span>&#123;<br>	VkPipelineStageFlags src_stage_mask  = <span class="hljs-built_in">getPipelineStageFlags</span>(old_layout);<br>	VkPipelineStageFlags dst_stage_mask  = <span class="hljs-built_in">getPipelineStageFlags</span>(new_layout);<br>	VkAccessFlags        src_access_mask = <span class="hljs-built_in">getAccessFlags</span>(old_layout);<br>	VkAccessFlags        dst_access_mask = <span class="hljs-built_in">getAccessFlags</span>(new_layout);<br><br>	<span class="hljs-built_in">image_layout_transition</span>(command_buffer, image, src_stage_mask, dst_stage_mask, src_access_mask, dst_access_mask, old_layout, new_layout, subresource_range);<br>&#125;<br><br><br><span class="hljs-function">VkPipelineStageFlags <span class="hljs-title">getPipelineStageFlags</span><span class="hljs-params">(VkImageLayout layout)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">switch</span> (layout)<br>	&#123;<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_UNDEFINED:<br>			<span class="hljs-keyword">return</span> VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_PREINITIALIZED:<br>			<span class="hljs-keyword">return</span> VK_PIPELINE_STAGE_HOST_BIT;<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL:<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL:<br>			<span class="hljs-keyword">return</span> VK_PIPELINE_STAGE_TRANSFER_BIT;<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL:<br>			<span class="hljs-keyword">return</span> VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL:<br>			<span class="hljs-keyword">return</span> VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT;<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR:<br>			<span class="hljs-keyword">return</span> VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL:<br>			<span class="hljs-keyword">return</span> VK_PIPELINE_STAGE_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_PRESENT_SRC_KHR:<br>			<span class="hljs-keyword">return</span> VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_GENERAL:<br>			<span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-string">&quot;Don&#x27;t know how to get a meaningful VkPipelineStageFlags for VK_IMAGE_LAYOUT_GENERAL! Don&#x27;t use it!&quot;</span>);<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">default</span>:<br>			<span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span>);<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>&#125;<br><br><br><span class="hljs-function">VkAccessFlags <span class="hljs-title">getAccessFlags</span><span class="hljs-params">(VkImageLayout layout)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">switch</span> (layout)<br>	&#123;<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_UNDEFINED:<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_PRESENT_SRC_KHR:<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_PREINITIALIZED:<br>			<span class="hljs-keyword">return</span> VK_ACCESS_HOST_WRITE_BIT;<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL:<br>			<span class="hljs-keyword">return</span> VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL:<br>			<span class="hljs-keyword">return</span> VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR:<br>			<span class="hljs-keyword">return</span> VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR;<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL:<br>			<span class="hljs-keyword">return</span> VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_INPUT_ATTACHMENT_READ_BIT;<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL:<br>			<span class="hljs-keyword">return</span> VK_ACCESS_TRANSFER_READ_BIT;<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL:<br>			<span class="hljs-keyword">return</span> VK_ACCESS_TRANSFER_WRITE_BIT;<br>		<span class="hljs-keyword">case</span> VK_IMAGE_LAYOUT_GENERAL:<br>			<span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-string">&quot;Don&#x27;t know how to get a meaningful VkAccessFlags for VK_IMAGE_LAYOUT_GENERAL! Don&#x27;t use it!&quot;</span>);<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">default</span>:<br>			<span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span>);<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是可以发现这个函数无法处理图像布局为<i><font color="Red">VK_IMAGE_LAYOUT_GENERAL</font></i>的情况，因为这种情况下图像可能用于各种用途，因此需要用户来指定相应的管线阶段和操作，这就是为什么在第二个布局转换的时候代码额外指定了管线阶段和操作（注意这里源阶段直接简单粗暴地指定为<i><font color="Red">VK_PIPELINE_STAGE_ALL_COMMANDS_BIT</font></i>）。</p><p>在完成了Storage image和后台缓冲区图像的布局转换后，就可以复制图像数据了。复制完成后，别忘了将后台缓冲区图像布局转换为显示最优，并且将Storage image布局转换回<i><font color="Red">VK_IMAGE_LAYOUT_GENERAL</font></i>供下一帧使用。</p><p>最后完成UI界面绘制命令的录制工作，就完成了整个命令录制。</p><p>准备阶段到此结束。</p><h2 id="绘制阶段">绘制阶段</h2><p>绘制阶段的代码十分简单，就是提交录制好的命令，然后更新UBO数据即可。直接放上代码，不再分析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::render</span><span class="hljs-params">(<span class="hljs-type">float</span> delta_time)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (!prepared)<br>	&#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-built_in">draw</span>();<br>	<span class="hljs-keyword">if</span> (camera.updated)<br>	&#123;<br>		<span class="hljs-built_in">update_uniform_buffers</span>();<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	ApiVulkanSample::<span class="hljs-built_in">prepare_frame</span>();<br>	submit_info.commandBufferCount = <span class="hljs-number">1</span>;<br>	submit_info.pCommandBuffers    = &amp;draw_cmd_buffers[current_buffer];<br>	<span class="hljs-built_in">VK_CHECK</span>(<span class="hljs-built_in">vkQueueSubmit</span>(queue, <span class="hljs-number">1</span>, &amp;submit_info, VK_NULL_HANDLE));<br>	ApiVulkanSample::<span class="hljs-built_in">submit_frame</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaytracingBasic::update_uniform_buffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	uniform_data.proj_inverse = glm::<span class="hljs-built_in">inverse</span>(camera.matrices.perspective);<br>	uniform_data.view_inverse = glm::<span class="hljs-built_in">inverse</span>(camera.matrices.view);<br>	ubo-&gt;<span class="hljs-built_in">convert_and_update</span>(uniform_data);<br>&#125;<br></code></pre></td></tr></table></figure><p>终于是完成了对于光追基础示例的分析！！（瘫了 **(=_=)**</p><hr></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/CG-api/" class="category-chain-item">CG_api</a> <span>></span> <a href="/categories/CG-api/vulkan/" class="category-chain-item">vulkan</a> <span>></span> <a href="/categories/CG-api/vulkan/vulkan-samples/" class="category-chain-item">vulkan_samples</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>Ray tracing basic</div><div>http://example.com/2025/02/27/CG_api/vulkan/vulkan_samples/ray_tracing_basic/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>ZPC-dsg</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年2月27日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2025/03/07/CG_api/d3d12/directX_samples/D3D12Multithreading/" title="D3D12 Multithreading"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">D3D12 Multithreading</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2025/02/23/CG_api/vulkan/vulkan_samples/multi_draw_indirect/" title="Multi draw indirect"><span class="hidden-mobile">Multi draw indirect</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>